
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Battlemat Next</title>
  <style>
    :root {
      color-scheme: dark;
      --bg: #0c0f14;
      --panel: #131722;
      --panel-2: #0f141c;
      --accent: #6fd3ff;
      --text: #e6ecf3;
      --muted: #97a2b3;
      --danger: #ff7a7a;
      --success: #63d18d;
      --grid: rgba(255,255,255,0.06);
      --room-outline: rgba(255,255,255,0.18);
    }

    * { box-sizing: border-box; }
    body {
      margin: 0;
      background: var(--bg);
      color: var(--text);
      font: 14px/1.4 ui-sans-serif, system-ui, -apple-system, Segoe UI, sans-serif;
    }

    #app {
      display: grid;
      grid-template-columns: 1fr 320px;
      min-height: 100vh;
    }

    #canvasWrap {
      position: relative;
      overflow: hidden;
      background: var(--bg);
    }

    canvas {
      display: block;
      width: 100%;
      height: 100%;
    }

    #toolbar {
      position: absolute;
      top: 12px;
      left: 12px;
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 8px 10px;
      background: rgba(15,20,28,0.85);
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: 8px;
      backdrop-filter: blur(8px);
      z-index: 10;
    }

    #toolbar select, #toolbar input, #toolbar button {
      background: #0f141c;
      color: var(--text);
      border: 1px solid rgba(255,255,255,0.12);
      border-radius: 6px;
      padding: 6px 8px;
      font-size: 13px;
    }

    #toolbar button {
      cursor: pointer;
    }

    #toolbar .toolBtn.active {
      border-color: var(--accent);
      box-shadow: 0 0 0 1px rgba(111,211,255,0.35) inset;
    }

    #toolbar .status {
      padding: 0 6px;
      font-size: 12px;
      color: var(--muted);
    }

    #sidebar {
      background: var(--panel);
      border-left: 1px solid rgba(255,255,255,0.08);
      padding: 12px;
      display: flex;
      flex-direction: column;
      gap: 12px;
    }
    section {
      background: var(--panel-2);
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: 10px;
      padding: 10px;
    }

    section h3 {
      margin: 0 0 8px 0;
      font-size: 13px;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: var(--muted);
    }

    .row {
      display: grid;
      grid-template-columns: 90px 1fr;
      gap: 6px;
      align-items: center;
      margin-bottom: 6px;
    }

    .row input, .row select, .row textarea {
      background: #0f141c;
      color: var(--text);
      border: 1px solid rgba(255,255,255,0.12);
      border-radius: 6px;
      padding: 6px 8px;
      font-size: 13px;
    }

    .row input[readonly] {
      opacity: 0.6;
    }

    #statusList {
      display: flex;
      flex-direction: column;
      gap: 6px;
      max-height: 240px;
      overflow: auto;
    }

    .statusItem {
      display: grid;
      grid-template-columns: 1fr auto;
      gap: 6px;
      align-items: center;
      padding: 6px 8px;
      border-radius: 8px;
      background: rgba(255,255,255,0.03);
      border: 1px solid rgba(255,255,255,0.06);
    }

    .statusItem .meta { color: var(--muted); font-size: 12px; }

    #inspectorEmpty {
      color: var(--muted);
      font-size: 13px;
    }

    .btnRow {
      display: flex;
      gap: 6px;
      margin-top: 6px;
    }

    .btnRow button {
      flex: 1;
      padding: 6px 8px;
      border-radius: 6px;
      border: 1px solid rgba(255,255,255,0.12);
      background: #0f141c;
      color: var(--text);
      cursor: pointer;
    }

    .warning {
      color: var(--danger);
      font-size: 12px;
    }
  </style>
</head>
<body>
  <div id="app">
    <div id="canvasWrap">
      <canvas id="map"></canvas>
      <div id="toolbar">
        <button id="toolSelect" class="toolBtn active">Select</button>
        <button id="toolRoom" class="toolBtn">Room</button>
        <button id="toolOpening" class="toolBtn">Opening</button>
        <button id="toolObject" class="toolBtn">Object</button>
        <button id="toolToken" class="toolBtn">Token</button>
        <button id="toolDelete" class="toolBtn">Delete</button>
        <label class="status">Opening</label>
        <select id="openingKind">
          <option value="door.wood">door.wood</option>
          <option value="door">door</option>
          <option value="window">window</option>
          <option value="threshold">threshold</option>
          <option value="portal">portal</option>
        </select>
        <button id="openingOrientH" class="toolBtn">H</button>
        <button id="openingOrientV" class="toolBtn">V</button>
        <label class="status">Object</label>
        <select id="objectKind">
          <option value="object">object</option>
          <option value="poi.view">poi.view</option>
          <option value="table.round">table.round</option>
          <option value="table.rect">table.rect</option>
          <option value="chair">chair</option>
          <option value="crate">crate</option>
          <option value="barrel">barrel</option>
          <option value="stairs">stairs</option>
          <option value="bed">bed</option>
        </select>
        <label class="status">Token</label>
        <select id="tokenKind">
          <option value="pc">pc</option>
          <option value="npc" selected>npc</option>
          <option value="monster">monster</option>
          <option value="creature">creature</option>
        </select>
        <select id="floorSelect"></select>
        <label class="status">Zoom</label>
        <input id="zoom" type="range" min="0.25" max="4" step="0.05" value="1" />
        <button id="btnSave">Save</button>
        <span id="saveStatus" class="status">DB: idle</span>
      </div>
    </div>

    <aside id="sidebar">
      <section>
        <h3>Status</h3>
        <div id="statusList"></div>
      </section>

      <section>
        <h3>Inspector</h3>
        <div id="inspectorEmpty">Select something to edit.</div>
        <div id="inspectorFields" hidden></div>
      </section>
    </aside>
  </div>
  <datalist id="floorKindList"></datalist>
  <datalist id="wallKindList"></datalist>
  <datalist id="openingKindList"></datalist>
  <datalist id="objectKindList"></datalist>
  <datalist id="tokenKindList"></datalist>

  <script>
    (() => {
      const canvas = document.getElementById('map');
      const ctx = canvas.getContext('2d');

      const toolButtons = {
        select: document.getElementById('toolSelect'),
        room: document.getElementById('toolRoom'),
        opening: document.getElementById('toolOpening'),
        object: document.getElementById('toolObject'),
        token: document.getElementById('toolToken'),
        delete: document.getElementById('toolDelete'),
      };

      const floorSelect = document.getElementById('floorSelect');
      const openingKindSelect = document.getElementById('openingKind');
      const openingOrientH = document.getElementById('openingOrientH');
      const openingOrientV = document.getElementById('openingOrientV');
      const objectKindSelect = document.getElementById('objectKind');
      const tokenKindSelect = document.getElementById('tokenKind');
      const zoomInput = document.getElementById('zoom');
      const saveButton = document.getElementById('btnSave');
      const saveStatus = document.getElementById('saveStatus');
      const statusList = document.getElementById('statusList');
      const inspectorEmpty = document.getElementById('inspectorEmpty');
      const inspectorFields = document.getElementById('inspectorFields');
      const floorKindList = document.getElementById('floorKindList');
      const wallKindList = document.getElementById('wallKindList');
      const openingKindList = document.getElementById('openingKindList');
      const objectKindList = document.getElementById('objectKindList');
      const tokenKindList = document.getElementById('tokenKindList');

      const GRID = { size: 32 };
      const VIEW = { camera: { col: 0, row: 0 }, zoom: 1, floorId: '' };
      const STATE = { battle: null, campaign: null, entities: [] };
      const EDITOR = {
        tool: 'select',
        selection: null,
        roomStart: null,
        dirty: false,
        drag: null,
        ignoreClick: false,
        openingKind: 'door.wood',
        openingOrientation: 'h',
        objectKind: 'object',
        tokenKind: 'npc'
      };

      const DEFAULT_FLOOR_KINDS = [
        'wood_oak', 'wood', 'stone', 'cobble', 'brick', 'brick_dark', 'gravel', 'fog'
      ];
      const DEFAULT_WALL_KINDS = [
        'brick', 'brick_dark', 'wood_dark', 'wood', 'stone', 'cobble', 'none'
      ];
      const DEFAULT_OPENING_KINDS = [
        'door.wood', 'door', 'window', 'threshold', 'portal'
      ];
      const DEFAULT_OBJECT_KINDS = [
        'object', 'poi.view', 'table.rect', 'table.round', 'table.sqr', 'table.hot', 'table.cold', 'table.prep',
        'chair', 'bed', 'bed.double', 'bath', 'chest', 'hearth', 'cooking.hearth', 'stairs',
        'crate', 'barrel', 'keg'
      ];
      const DEFAULT_TOKEN_KINDS = ['pc', 'npc', 'monster', 'creature'];

      const OPENING_STYLE = {
        door: { len: 1.5, thick: 0.25, color: '#9a6b3a' },
        window: { len: 1.2, thick: 0.2, color: '#7aaad6' },
        threshold: { len: 1.4, thick: 0.12, color: '#6f7884' },
        portal: { len: 1.3, thick: 0.22, color: '#6fd3ff' }
      };

      const FLOOR_COLORS = {
        fog: '#0e1117',
        wood: '#2a1f17',
        wood_oak: '#3a2b1e',
        cobble: '#45474a',
        stone: '#3f3f3f',
        default: '#1a1f2a'
      };

      const WALL_COLORS = {
        brick: '#3d2b23',
        brick_dark: '#2c1e19',
        wood_dark: '#2b231a',
        none: 'transparent',
        default: '#2d2f33'
      };

      const TEXTURE_FILES = {
        wood_oak: '/assets/sprites/wood_oak.png',
        wood_elm: '/assets/sprites/wood_elm.png',
        wood_dark: '/assets/sprites/wood_dark.png',
        stone: '/assets/sprites/stone.png',
        stone_cobble: '/assets/sprites/stone_cobble.png',
        brick_gray: '/assets/sprites/brick_gray.png',
        brick_red: '/assets/sprites/brick_red.png',
        brick_dark: '/assets/sprites/brick_dark.png',
        crosskeys: '/images/the_cross_keys_floor.jpg'
      };

      const TEXTURE_SCALES = {
        wall: {
          wood_oak: 0.5,
          wood_elm: 0.5,
          wood_dark: 0.5,
          stone: 0.5,
          stone_cobble: 0.1,
          brick_gray: 0.15,
          brick_red: 0.15,
          brick_dark: 0.15,
        },
        floor: {
          wood_oak: 0.5,
          wood_elm: 0.5,
          wood_dark: 0.5,
          stone: 0.25,
          stone_cobble: 0.15,
          brick_gray: 0.15,
          brick_red: 0.15,
          brick_dark: 0.15,
          crosskeys: 1.0
        }
      };

      const TEXTURE_ALIASES = {
        wall: {
          brick: 'brick_gray',
          wood: 'wood_oak',
          cobble: 'stone_cobble',
          stone: 'stone',
          gravel: 'stone_cobble'
        },
        floor: {
          wood: 'wood_oak',
          stone: 'stone',
          cobble: 'stone_cobble',
          gravel: 'stone_cobble',
          brick: 'brick_gray'
        }
      };

      const SPRITE_MAP = {
        'poi.view': '/assets/sprites/cross_keys.png',
        'chair': '/assets/sprites/chair.png',
        'table.round': '/assets/sprites/table_round.png',
        'table.rect': '/assets/sprites/table_rectangle.png',
        'table.sqr': '/assets/sprites/table_square.png',
        'table.hot': '/assets/sprites/table_hot.png',
        'table.cold': '/assets/sprites/table_cold.png',
        'table.prep': '/assets/sprites/table_prep.png',
        'table.plate': '/assets/sprites/table_plate.png',
        'bed': '/assets/sprites/bed.png',
        'bed.double': '/assets/sprites/bed_double.png',
        'bath': '/assets/sprites/bath.png',
        'chest': '/assets/sprites/chest_closed.png',
        'hearth': '/assets/sprites/hearth.png',
        'cooking.hearth': '/assets/sprites/cooking_hearth.png',
        'stairs': '/assets/sprites/stairs.png',
        'stairs.up': '/assets/sprites/stairs_up.png',
        'stairs.down': '/assets/sprites/stairs_down.png',
        'crate': '/assets/sprites/crate.png',
        'barrel': '/assets/sprites/barrel.png',
        'keg': '/assets/sprites/keg.png'
      };

      function colStep() { return 1.5 * GRID.size; }
      function rowStep() { return Math.sqrt(3) * GRID.size; }

      function hexToWorld(col, row) {
        const x = col * colStep();
        const y = -(row * rowStep() + (col & 1) * (rowStep() / 2));
        return { x, y };
      }

      function worldToScreen(p) {
        const cam = hexToWorld(VIEW.camera.col, VIEW.camera.row);
        const w = canvas.width / devicePixelRatio;
        const h = canvas.height / devicePixelRatio;
        return {
          x: w / 2 + (p.x - cam.x) * VIEW.zoom,
          y: h / 2 + (p.y - cam.y) * VIEW.zoom,
        };
      }

      function screenToWorld(x, y) {
        const cam = hexToWorld(VIEW.camera.col, VIEW.camera.row);
        const w = canvas.width / devicePixelRatio;
        const h = canvas.height / devicePixelRatio;
        const wx = (x - w / 2) / VIEW.zoom + cam.x;
        const wy = (y - h / 2) / VIEW.zoom + cam.y;
        return { x: wx, y: wy };
      }

      function axialToCube(q, r) {
        return { x: q, z: r, y: -q - r };
      }

      function cubeRound(c) {
        let rx = Math.round(c.x);
        let ry = Math.round(c.y);
        let rz = Math.round(c.z);
        const dx = Math.abs(rx - c.x);
        const dy = Math.abs(ry - c.y);
        const dz = Math.abs(rz - c.z);
        if (dx > dy && dx > dz) rx = -ry - rz;
        else if (dy > dz) ry = -rx - rz;
        else rz = -rx - ry;
        return { x: rx, y: ry, z: rz };
      }

      function worldToHex(p) {
        const size = GRID.size || 1;
        const qf = (2 / 3) * (p.x / size);
        const rf = ((-p.y) / size) / Math.sqrt(3) - (qf / 2);
        const col = Math.round(qf);
        const rowf = rf + (col - (col & 1)) / 2;
        const row = Math.round(rowf);
        return { col, row };
      }

      function roundQuarter(v) {
        return Math.round(v * 4) / 4;
      }

      function formatStep(v) {
        const s = roundQuarter(v).toFixed(2);
        return s.replace(/\.00$/, '').replace(/(\.\d)0$/, '$1');
      }

      function openingHexFromWorld(p) {
        const size = GRID.size || 1;
        const qf = (2 / 3) * (p.x / size);
        const rf = ((-p.y) / size) / Math.sqrt(3) - (qf / 2);
        const col = Math.round(qf);
        const rowf = rf + (col - (col & 1)) / 2;
        const row = roundQuarter(rowf);
        return { col, row };
      }

      function openingHexLabelFromCoords(col, row) {
        if (!Number.isFinite(col) || !Number.isFinite(row)) return null;
        const rowNum = row + 1;
        return indexToLetters(col) + formatStep(rowNum);
      }

      function indexToLetters(idx) {
        let n = idx;
        let out = '';
        while (n >= 0) {
          out = String.fromCharCode(65 + (n % 26)) + out;
          n = Math.floor(n / 26) - 1;
        }
        return out;
      }

      function lettersToIndex(letters) {
        let n = 0;
        for (let i = 0; i < letters.length; i++) {
          n = n * 26 + (letters.charCodeAt(i) - 64);
        }
        return n - 1;
      }

      function toHexLabel(col, row) {
        return indexToLetters(col) + String(row + 1);
      }

      function parseHexLabel(label) {
        if (!label) return null;
        const m = String(label).trim().toUpperCase().match(/^([A-Z]+)(-?\d+(?:\.\d+)?)$/);
        if (!m) return null;
        const col = lettersToIndex(m[1]);
        const row = parseFloat(m[2]) - 1;
        return { col, row };
      }

      function getQueryParams() {
        return new URLSearchParams(window.location.search || '');
      }

      function getAuthHeaders() {
        const qp = getQueryParams();
        const token = (qp.get('token') || qp.get('auth') || qp.get('bearer') || '').trim();
        if (!token) return {};
        return { Authorization: 'Bearer ' + token };
      }

      function setTool(tool) {
        EDITOR.tool = tool;
        Object.entries(toolButtons).forEach(([key, btn]) => {
          if (!btn) return;
          btn.classList.toggle('active', key === tool);
        });
        EDITOR.roomStart = null;
      }

      function normalizeState(state) {
        if (!state || typeof state !== 'object') return { floors: [] };
        if (!Array.isArray(state.floors)) {
          const floorId = state.view && state.view.floorId ? String(state.view.floorId) : 'ground';
          state.floors = [{
            id: floorId,
            name: floorId,
            rooms: Array.isArray(state.rooms) ? state.rooms : [],
            openings: Array.isArray(state.openings) ? state.openings : [],
            objects: Array.isArray(state.objects) ? state.objects : []
          }];
        }
        for (const floor of state.floors) {
          if (!floor || typeof floor !== 'object') continue;
          floor.id = String(floor.id || 'floor');
          if (!Array.isArray(floor.rooms)) floor.rooms = [];
          if (!Array.isArray(floor.openings)) floor.openings = [];
          if (!Array.isArray(floor.objects)) floor.objects = [];
          for (const obj of floor.objects) {
            if (obj && obj.floorId == null) obj.floorId = floor.id;
          }
        }
        return state;
      }

      function extractScene(raw) {
        if (!raw || typeof raw !== 'object') return { scene: { floors: [] }, wrapper: null, recordId: '' };
        if (raw.records && typeof raw.records === 'object') {
          const activeId = raw.active && raw.active.recordId ? String(raw.active.recordId) : '';
          let recordId = activeId;
          let scene = recordId && raw.records[recordId] ? raw.records[recordId] : null;
          if (!scene) {
            const keys = Object.keys(raw.records);
            if (keys.length) {
              recordId = keys[0];
              scene = raw.records[recordId];
            }
          }
          if (!scene || typeof scene !== 'object') return { scene: { floors: [] }, wrapper: raw, recordId: recordId || '' };
          return { scene, wrapper: raw, recordId: recordId || '' };
        }
        return { scene: raw, wrapper: null, recordId: '' };
      }

      function applyViewFromState(scene) {
        const view = scene && scene.view ? scene.view : {};
        const floorId = view.floorId || view.floor_id || view.floor || null;
        if (floorId) VIEW.floorId = String(floorId);
        const camHex = view.camera_hex || view.cameraHex || null;
        if (camHex) {
          const p = parseHexLabel(camHex);
          if (p) {
            VIEW.camera.col = p.col;
            VIEW.camera.row = p.row;
          }
        }
      }

      function resolveBattleId() {
        const qp = getQueryParams();
        return qp.get('battle_id') || qp.get('battleId') || qp.get('id');
      }

      async function loadBattle() {
        const battleId = resolveBattleId();
        if (!battleId) throw new Error('Missing battle_id');

        const isLocal = ['localhost', '127.0.0.1'].includes(window.location.hostname);
        const qp = getQueryParams();
        const devStateUrl = isLocal ? (qp.get('dev_state') || qp.get('state_url') || '') : '';
        if (devStateUrl) {
          const res = await fetch(devStateUrl, { cache: 'no-store' });
          if (!res.ok) throw new Error('Dev state load failed');
          const raw = await res.json();
          const extracted = extractScene(raw);
          STATE.wrapper = extracted.wrapper;
          STATE.recordId = extracted.recordId;
          STATE.battle = normalizeState(extracted.scene);
          applyViewFromState(STATE.battle);
          return;
        }

        const res = await fetch(`/api/battles/${encodeURIComponent(battleId)}`, {
          headers: { 'accept': 'application/json', ...getAuthHeaders() }
        });
        if (!res.ok) throw new Error('Battle load failed');
        const data = await res.json();
        const raw = data && data.state_json ? JSON.parse(data.state_json) : data;
        const extracted = extractScene(raw);
        STATE.wrapper = extracted.wrapper;
        STATE.recordId = extracted.recordId;
        STATE.battle = normalizeState(extracted.scene);
        applyViewFromState(STATE.battle);
        STATE.battle._battle_id = data.battle_id || battleId;
        STATE.battle._campaign_id = data.campaign_id || data.campaignId || null;
      }

      function getCampaignId() {
        return STATE.battle && (STATE.battle._campaign_id || STATE.battle.campaign_id || STATE.battle.campaignId) || null;
      }

      async function loadCampaign() {
        const cid = getCampaignId();
        if (!cid) return;
        const res = await fetch(`/api/campaigns/${encodeURIComponent(cid)}`, {
          headers: { 'accept': 'application/json', ...getAuthHeaders() }
        });
        if (!res.ok) return;
        const data = await res.json();
        let meta = data.meta_json || data.metaJson || null;
        if (typeof meta === 'string') {
          try { meta = JSON.parse(meta); } catch { meta = null; }
        }
        STATE.campaign = meta || {};
        STATE.entities = (STATE.campaign.world && Array.isArray(STATE.campaign.world.entities))
          ? STATE.campaign.world.entities
          : [];
      }

      function resolvePoiId() {
        const campaign = STATE.campaign || {};
        const index = campaign.poi_index || (campaign.world && campaign.world.poi_index) || null;
        const bid = STATE.battle && STATE.battle._battle_id;
        if (!index || !bid) return '';
        for (const [poi, battleId] of Object.entries(index)) {
          if (String(battleId) === String(bid)) return String(poi);
        }
        return '';
      }

      function buildTokens() {
        const poiId = resolvePoiId();
        const entities = Array.isArray(STATE.entities) ? STATE.entities : [];
        return entities
          .filter(e => e && (!e.poi_id || e.poi_id === poiId))
          .map(e => {
            const loc = e.location || e.position || {};
            const hex = e.hex || loc.hex || '';
            const floorId = e.floorId || loc.floorId || loc.floor_id || e.floor_id || '';
            return {
              id: String(e.id || e.character_id || ''),
              name: e.name || e.label || e.title || e.id,
              hex,
              floorId,
              kind: e.kind || 'pc',
              hp: e.hp || (e.stats && e.stats.hp) || null,
              init: e.init || (e.stats && e.stats.init) || null,
              side: e.side || (e.kind === 'npc' ? 'NPC' : 'PC'),
              __entity: e
            };
          });
      }
      function renderStatus() {
        statusList.innerHTML = '';
        const tokens = buildTokens();
        for (const t of tokens) {
          const div = document.createElement('div');
          div.className = 'statusItem';
          div.innerHTML = `<div><strong>${t.name || t.id}</strong><div class="meta">${t.floorId || ''}</div></div><div class="meta">${t.hp != null ? t.hp : '-'} / ${t.init != null ? t.init : '-'}</div>`;
          statusList.appendChild(div);
        }
      }

      function setFloorOptions() {
        floorSelect.innerHTML = '';
        const floors = STATE.battle ? STATE.battle.floors : [];
        floors.forEach(f => {
          const opt = document.createElement('option');
          opt.value = f.id;
          opt.textContent = f.name || f.id;
          floorSelect.appendChild(opt);
        });
        if (!VIEW.floorId && floors[0]) VIEW.floorId = floors[0].id;
        floorSelect.value = VIEW.floorId;
      }

      function pickFloor() {
        const floors = STATE.battle ? STATE.battle.floors : [];
        return floors.find(f => f.id === VIEW.floorId) || floors[0];
      }

      function autoCenterCamera() {
        if (!STATE.battle) return;
        const view = STATE.battle.view || {};
        if (view.camera_hex || view.cameraHex) return;
        const floor = pickFloor();
        if (!floor) return;
        let target = null;
        if (Array.isArray(floor.rooms) && floor.rooms.length) {
          const corners = Array.isArray(floor.rooms[0].corners) ? floor.rooms[0].corners : [];
          const pts = corners.map(parseHexLabel).filter(Boolean);
          if (pts.length) {
            const avg = pts.reduce((acc, p) => ({ col: acc.col + p.col, row: acc.row + p.row }), { col: 0, row: 0 });
            target = { col: avg.col / pts.length, row: avg.row / pts.length };
          }
        }
        if (!target && Array.isArray(floor.objects) && floor.objects.length) {
          target = parseHexLabel(floor.objects[0].hex);
        }
        if (!target) {
          const tokens = buildTokens();
          if (tokens.length) target = parseHexLabel(tokens[0].hex);
        }
        if (target) {
          VIEW.camera.col = Math.round(target.col);
          VIEW.camera.row = Math.round(target.row);
        }
      }

      function roomWallKind(room) {
        const wall = room && room.wall && typeof room.wall === 'object' ? room.wall : null;
        const kind = wall && wall.kind != null ? String(wall.kind) : '';
        const type = wall && wall.type != null ? String(wall.type) : '';
        return (kind || type || 'brick').toLowerCase();
      }

      function roomHasWalls(room) {
        const thickness = Number(room && room.thickness != null ? room.thickness : 0);
        return thickness > 0 && roomWallKind(room) !== 'none';
      }

      function roomToWallBox(room) {
        const corners = Array.isArray(room && room.corners) ? room.corners : [];
        if (corners.length !== 4) return null;
        const tl = parseHexLabel(corners[0]);
        const tr = parseHexLabel(corners[1]);
        const br = parseHexLabel(corners[2]);
        const bl = parseHexLabel(corners[3]);
        if (!tl || !tr || !br || !bl) return null;

        const pTL = hexToWorld(tl.col, tl.row);
        const pTR = hexToWorld(tr.col, tr.row);
        const pBR = hexToWorld(br.col, br.row);
        const pBL = hexToWorld(bl.col, bl.row);

        const xL = (pTL.x + pBL.x) / 2;
        const xR = (pTR.x + pBR.x) / 2;
        const yTop = (pTL.y + pTR.y) / 2;
        const yBot = (pBL.y + pBR.y) / 2;

        const thicknessBase = Number(room && room.thickness != null ? room.thickness : 0);
        const t = roomHasWalls(room) ? thicknessBase : 0;
        const half = t / 2;

        // Treat corners as the wall centerline. Expand outward for wall band.
        const center = { x1: xL, y1: yTop, x2: xR, y2: yBot };
        const outer = { x1: xL - half, y1: yTop - half, x2: xR + half, y2: yBot + half };
        const inner = { x1: xL + half, y1: yTop + half, x2: xR - half, y2: yBot - half };

        return { xL, xR, yTop, yBot, thickness: t, center, outer, inner };
      }

      function roomFloorRectWorld(room, box) {
        if (!box) return null;
        const src = roomHasWalls(room) ? box.inner : box.center;
        return { x1: src.x1, y1: src.y1, x2: src.x2, y2: src.y2 };
      }

      function buildWallSegments(rooms) {
        const segs = [];
        for (const room of (Array.isArray(rooms) ? rooms : [])) {
          const box = roomToWallBox(room);
          if (!box) continue;
          segs.push({ orientation: 'h', y: box.yTop, x1: box.xL, x2: box.xR });
          segs.push({ orientation: 'h', y: box.yBot, x1: box.xL, x2: box.xR });
          segs.push({ orientation: 'v', x: box.xL, y1: box.yTop, y2: box.yBot });
          segs.push({ orientation: 'v', x: box.xR, y1: box.yTop, y2: box.yBot });
        }
        return segs;
      }

      function wallSegDistance2(seg, p) {
        if (!seg || !p) return Infinity;
        if (seg.orientation === 'h') {
          const dy = Math.abs(p.y - seg.y);
          let dx = 0;
          if (p.x < seg.x1) dx = seg.x1 - p.x;
          else if (p.x > seg.x2) dx = p.x - seg.x2;
          return dx * dx + dy * dy;
        }
        const dx = Math.abs(p.x - seg.x);
        let dy = 0;
        if (p.y < seg.y1) dy = seg.y1 - p.y;
        else if (p.y > seg.y2) dy = p.y - seg.y2;
        return dx * dx + dy * dy;
      }

      function projectToWall(seg, p) {
        if (!seg || !p) return null;
        if (seg.orientation === 'h') {
          const x = Math.min(seg.x2, Math.max(seg.x1, p.x));
          return { x, y: seg.y };
        }
        const y = Math.min(seg.y2, Math.max(seg.y1, p.y));
        return { x: seg.x, y };
      }

      function snapWorldToWall(worldPoint, floor, orientation) {
        const want = orientation === 'v' ? 'v' : 'h';
        const segs = buildWallSegments(floor ? floor.rooms : []);
        let best = null;
        let bestD2 = Infinity;
        for (const seg of segs) {
          if (!seg || seg.orientation !== want) continue;
          const d2 = wallSegDistance2(seg, worldPoint);
          if (d2 < bestD2) {
            bestD2 = d2;
            best = seg;
          }
        }
        if (!best) return worldPoint;
        return projectToWall(best, worldPoint) || worldPoint;
      }

      function roomRectScreen(room) {
        const box = roomToWallBox(room);
        if (!box) return null;
        const rect = roomFloorRectWorld(room, box);
        if (!rect) return null;
        const p1 = worldToScreen({ x: rect.x1, y: rect.y1 });
        const p2 = worldToScreen({ x: rect.x2, y: rect.y2 });
        return {
          x1: Math.min(p1.x, p2.x),
          y1: Math.min(p1.y, p2.y),
          x2: Math.max(p1.x, p2.x),
          y2: Math.max(p1.y, p2.y),
          box
        };
      }

      function drawRoom(room) {
        const rectInfo = roomRectScreen(room);
        if (!rectInfo) return;
        const { x1, y1, x2, y2, box } = rectInfo;

        const fk = room.floor && room.floor.kind ? String(room.floor.kind) : 'default';
        const floorColor = FLOOR_COLORS[fk] || FLOOR_COLORS.default;
        const wk = roomWallKind(room);
        const wallColor = WALL_COLORS[wk] || WALL_COLORS.default;

        // Fill wall band first (outer rect), then floor (inner rect) so walls aren't black.
        if (wk !== 'none' && box && box.thickness > 0) {
          const outer = box.outer || box.center;
          const o1 = worldToScreen({ x: outer.x1, y: outer.y1 });
          const o2 = worldToScreen({ x: outer.x2, y: outer.y2 });
          const ox1 = Math.min(o1.x, o2.x);
          const oy1 = Math.min(o1.y, o2.y);
          const ow = Math.abs(o2.x - o1.x);
          const oh = Math.abs(o2.y - o1.y);
          ctx.fillStyle = getFillStyle('wall', wk, wallColor);
          ctx.globalAlpha = 1;
          ctx.fillRect(ox1, oy1, ow, oh);
        }

        ctx.fillStyle = getFillStyle('floor', fk, floorColor);
        ctx.globalAlpha = 1;
        ctx.fillRect(x1, y1, x2 - x1, y2 - y1);

        // Subtle outline to keep edges crisp.
        if (wk !== 'none') {
          const outer = box ? (box.outer || box.center) : { x1, y1, x2, y2 };
          const o1 = worldToScreen({ x: outer.x1, y: outer.y1 });
          const o2 = worldToScreen({ x: outer.x2, y: outer.y2 });
          const ox1 = Math.min(o1.x, o2.x);
          const oy1 = Math.min(o1.y, o2.y);
          const ow = Math.abs(o2.x - o1.x);
          const oh = Math.abs(o2.y - o1.y);
          ctx.strokeStyle = 'rgba(0,0,0,0.35)';
          ctx.lineWidth = 1;
          ctx.strokeRect(ox1, oy1, ow, oh);
        }
      }

      function openingWorldCenter(opening, floor) {
        const p = parseHexLabel(opening.hex);
        if (!p) return null;
        const world = hexToWorld(p.col, p.row);
        const orient = opening && opening.orientation === 'v' ? 'v' : 'h';
        return snapWorldToWall(world, floor, orient);
      }

      function drawOpening(opening, floor) {
        const world = openingWorldCenter(opening, floor);
        if (!world) return;
        const center = worldToScreen(world);
        const orient = opening.orientation === 'v' ? 'v' : 'h';
        const kindRaw = String(opening.kind || '').toLowerCase();
        const kind =
          kindRaw.startsWith('window') ? 'window' :
          kindRaw.startsWith('portal') ? 'portal' :
          kindRaw.startsWith('threshold') ? 'threshold' : 'door';
        const style = OPENING_STYLE[kind] || OPENING_STYLE.door;
        const lenUnits = Number.isFinite(Number(opening.len ?? opening.length ?? opening.size))
          ? Number(opening.len ?? opening.length ?? opening.size)
          : style.len;
        const thickUnits = Number.isFinite(Number(opening.thick ?? opening.thickness))
          ? Number(opening.thick ?? opening.thickness)
          : style.thick;
        const len = GRID.size * lenUnits * VIEW.zoom;
        const thick = GRID.size * thickUnits * VIEW.zoom;
        const seamKind = opening.seam_kind || opening.seamKind || '';
        const seamColor = seamKind ? (FLOOR_COLORS[String(seamKind)] || FLOOR_COLORS.default) : null;
        const seamFill = seamKind ? getFillStyle('floor', String(seamKind), seamColor) : null;
        const seamLen = len * 1.15;
        const seamThick = thick * 1.6;
        ctx.save();
        ctx.translate(center.x, center.y);
        if (orient === 'v') ctx.rotate(Math.PI / 2);
        if (seamFill) {
          ctx.fillStyle = seamFill;
          ctx.fillRect(-seamLen / 2, -seamThick / 2, seamLen, seamThick);
        }
        ctx.fillStyle = style.color;
        ctx.fillRect(-len / 2, -thick / 2, len, thick);
        ctx.restore();
      }

      function objectWorldCenter(obj) {
        if (!obj) return null;
        const p = parseHexLabel(obj.hex);
        if (!p) return null;
        const base = hexToWorld(p.col, p.row);
        const ox = Number(obj.ox);
        const oy = Number(obj.oy);
        return {
          x: base.x + (Number.isFinite(ox) ? ox : 0) * GRID.size,
          y: base.y + (Number.isFinite(oy) ? oy : 0) * GRID.size,
        };
      }

      const spriteCache = new Map();
      function loadSprite(url) {
        if (!url) return null;
        if (spriteCache.has(url)) return spriteCache.get(url);
        const img = new Image();
        img.src = url;
        spriteCache.set(url, img);
        return img;
      }

      const PATTERN_CACHE = new Map();

      function resolveTextureDef(category, kind) {
        const cat = String(category || '').toLowerCase();
        const k0 = String(kind || '').toLowerCase();
        if (!cat || !k0) return null;
        if (k0 === 'fog' || k0 === 'none') return null;

        const aliases = TEXTURE_ALIASES[cat] || {};
        const key = (k0 in TEXTURE_FILES) ? k0 : (aliases[k0] || '');
        if (!key || !(key in TEXTURE_FILES)) return null;

        const scale = (TEXTURE_SCALES[cat] && Number.isFinite(Number(TEXTURE_SCALES[cat][key])))
          ? Number(TEXTURE_SCALES[cat][key])
          : 1;
        return { url: TEXTURE_FILES[key], scale };
      }

      function getTexturePattern(category, kind) {
        const def = resolveTextureDef(category, kind);
        if (!def) return null;
        const cached = PATTERN_CACHE.get(def.url);
        if (cached && cached.pattern) return { pattern: cached.pattern, scale: def.scale };

        const img = loadSprite(def.url);
        if (!img || !img.complete) {
          if (img && !img.__patternHooked) {
            img.__patternHooked = true;
            img.onload = () => {
              img.__patternHooked = false;
              PATTERN_CACHE.delete(def.url);
              render();
            };
          }
          return null;
        }

        const pattern = ctx.createPattern(img, 'repeat');
        if (!pattern) return null;
        PATTERN_CACHE.set(def.url, { pattern });
        return { pattern, scale: def.scale };
      }

      function applyPatternTransform(pattern, scale) {
        if (!pattern || typeof pattern.setTransform !== 'function') return;
        const cam = hexToWorld(VIEW.camera.col, VIEW.camera.row);
        const rect = canvas.getBoundingClientRect();
        const originX = rect.width / 2 - cam.x * VIEW.zoom;
        const originY = rect.height / 2 - cam.y * VIEW.zoom;
        const s = (Number(scale) || 1) * VIEW.zoom;
        const m = new DOMMatrix();
        m.a = s;
        m.d = s;
        m.e = originX;
        m.f = originY;
        pattern.setTransform(m);
      }

      function getFillStyle(category, kind, fallback) {
        const tex = getTexturePattern(category, kind);
        if (tex && tex.pattern) {
          applyPatternTransform(tex.pattern, tex.scale);
          return tex.pattern;
        }
        return fallback;
      }

      function drawObject(obj, zIndex) {
        const world = objectWorldCenter(obj);
        if (!world) return;
        const center = worldToScreen(world);
        const url = obj.sprite || obj.spriteFile || SPRITE_MAP[obj.kind];
        const scale = Number.isFinite(Number(obj.spriteScale)) ? Number(obj.spriteScale) : 1;
        const scaleX = Number.isFinite(Number(obj.spriteScaleX)) ? Number(obj.spriteScaleX) : scale;
        const scaleY = Number.isFinite(Number(obj.spriteScaleY)) ? Number(obj.spriteScaleY) : scale;
        const sizeW = GRID.size * 1.15 * scaleX * VIEW.zoom;
        const sizeH = GRID.size * 1.15 * scaleY * VIEW.zoom;
        const rotDeg = Number.isFinite(Number(obj.rotDeg)) ? Number(obj.rotDeg) : 0;
        const rot = rotDeg * Math.PI / 180;

        if (url) {
          const img = loadSprite(url);
          if (img && img.complete) {
            ctx.save();
            ctx.translate(center.x, center.y);
            if (rot) ctx.rotate(rot);
            ctx.drawImage(img, -sizeW / 2, -sizeH / 2, sizeW, sizeH);
            ctx.restore();
            return;
          }
        }

        ctx.save();
        ctx.translate(center.x, center.y);
        if (rot) ctx.rotate(rot);
        ctx.fillStyle = '#2b2f3a';
        ctx.fillRect(-sizeW / 2, -sizeH / 2, sizeW, sizeH);
        ctx.strokeStyle = '#4a5568';
        ctx.strokeRect(-sizeW / 2, -sizeH / 2, sizeW, sizeH);
        ctx.fillStyle = '#cfd6df';
        ctx.font = `${10 * VIEW.zoom}px sans-serif`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        const baseLabel = obj.name || obj.kind || 'obj';
        const displayZ = obj.z != null ? obj.z : (Number.isFinite(zIndex) ? zIndex : null);
        const label = displayZ != null ? `${baseLabel} (${displayZ})` : baseLabel;
        ctx.fillText(label, 0, 0);
        ctx.restore();
      }

      function drawToken(token) {
        const p = parseHexLabel(token.hex);
        if (!p) return;
        const center = worldToScreen(hexToWorld(p.col, p.row));
        const r = GRID.size * 0.35 * VIEW.zoom;
        ctx.fillStyle = token.side === 'NPC' ? '#c95c5c' : '#5ca9c9';
        ctx.beginPath();
        ctx.arc(center.x, center.y, r, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = '#0b0f14';
        ctx.font = `${11 * VIEW.zoom}px sans-serif`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        const label = token.name ? token.name[0].toUpperCase() : '?';
        ctx.fillText(label, center.x, center.y);
      }

      function numOr(value, fallback) {
        const n = Number(value);
        return Number.isFinite(n) ? n : fallback;
      }

      function sortByZ(list) {
        if (!Array.isArray(list)) return [];
        const order = new Map();
        list.forEach((item, idx) => order.set(item, idx));
        return list.slice().sort((a, b) => {
          const za = numOr(a && a.z, order.get(a));
          const zb = numOr(b && b.z, order.get(b));
          return za - zb;
        });
      }

      function render() {
        if (!STATE.battle) return;
        const dpr = window.devicePixelRatio || 1;
        const rect = canvas.getBoundingClientRect();
        canvas.width = rect.width * dpr;
        canvas.height = rect.height * dpr;
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        ctx.clearRect(0, 0, rect.width, rect.height);

        const floor = pickFloor();
        if (!floor) return;

        const rooms = sortByZ(floor.rooms || []);
        const openings = sortByZ(floor.openings || []);
        const objects = sortByZ(floor.objects || []);
        const tokens = buildTokens().filter(t => !t.floorId || t.floorId === floor.id);

        rooms.forEach(drawRoom);
        openings.forEach(o => drawOpening(o, floor));
        objects.forEach((obj, idx) => drawObject(obj, idx));
        tokens.forEach(drawToken);
      }

      function updateInspector() {
        const sel = EDITOR.selection;
        if (!sel) {
          inspectorEmpty.hidden = false;
          inspectorFields.hidden = true;
          inspectorFields.innerHTML = '';
          return;
        }

        inspectorEmpty.hidden = true;
        inspectorFields.hidden = false;
        inspectorFields.innerHTML = '';

        const addField = (label, value, key, opts = {}) => {
          const row = document.createElement('div');
          row.className = 'row';
          const lab = document.createElement('label');
          lab.textContent = label;
          const input = document.createElement('input');
          if (opts.type) input.type = opts.type;
          if (opts.step != null) input.step = String(opts.step);
          if (opts.list) input.setAttribute('list', opts.list);
          input.value = value == null ? '' : String(value);
          if (opts.readonly) input.readOnly = true;
          input.addEventListener('input', () => {
            applyFieldChange(key, input.value);
          });
          row.appendChild(lab);
          row.appendChild(input);
          inspectorFields.appendChild(row);
        };
        const addButtonRow = (buttons) => {
          const row = document.createElement('div');
          row.className = 'btnRow';
          buttons.forEach(({ label, onClick }) => {
            const btn = document.createElement('button');
            btn.textContent = label;
            btn.addEventListener('click', onClick);
            row.appendChild(btn);
          });
          inspectorFields.appendChild(row);
        };
        const bumpToken = (key, delta) => {
          const cur = Number(sel.item[key]);
          const next = Number.isFinite(cur) ? cur + delta : delta;
          applyFieldChange(key, String(next));
          updateInspector();
        };
        const setTokenSide = (side, kind) => {
          applyFieldChange('side', side);
          if (kind) applyFieldChange('kind', kind);
          updateInspector();
        };

        if (sel.type === 'room') {
          addField('Type', 'room', 'type', { readonly: true });
          addField('ID', sel.item.id, 'id', { readonly: true });
          addField('Name', sel.item.name || '', 'name');
          addField('Floor', sel.floorId, 'floorId');
          addField('Corner TL', sel.item.corners ? sel.item.corners[0] : '', 'cornerTL');
          addField('Corner BR', sel.item.corners ? sel.item.corners[2] : '', 'cornerBR');
          addField('Thickness', sel.item.thickness != null ? sel.item.thickness : '', 'thickness', { type: 'number', step: '1' });
          addField('Floor Kind', sel.item.floor && sel.item.floor.kind ? sel.item.floor.kind : '', 'floor.kind', { list: 'floorKindList' });
          addField('Wall Kind', sel.item.wall && sel.item.wall.kind ? sel.item.wall.kind : '', 'wall.kind', { list: 'wallKindList' });
          addButtonRow([
            { label: 'To Front', onClick: () => reorderSelection('front') },
            { label: 'To Back', onClick: () => reorderSelection('back') },
          ]);
        }

        if (sel.type === 'opening') {
          addField('Type', 'opening', 'type', { readonly: true });
          addField('ID', sel.item.id, 'id', { readonly: true });
          addField('Name', sel.item.name || '', 'name');
          addField('Kind', sel.item.kind || '', 'kind', { list: 'openingKindList' });
          addField('Hex', sel.item.hex || '', 'hex');
          addField('Floor', sel.floorId || '', 'floorId');
          addField('Orientation', sel.item.orientation || 'h', 'orientation');
          addField('Open %', sel.item.openPct != null ? sel.item.openPct : 0, 'openPct', { type: 'number', step: '0.05' });
          addField('Length', sel.item.len != null ? sel.item.len : '', 'len', { type: 'number', step: '0.05' });
          addField('Thickness', sel.item.thickness != null ? sel.item.thickness : '', 'thickness', { type: 'number', step: '0.05' });
          addField('Seam', sel.item.seam_kind || '', 'seam_kind');
          addButtonRow([
            { label: 'To Front', onClick: () => reorderSelection('front') },
            { label: 'To Back', onClick: () => reorderSelection('back') },
          ]);
        }

        if (sel.type === 'object') {
          addField('Type', 'object', 'type', { readonly: true });
          addField('ID', sel.item.id, 'id', { readonly: true });
          addField('Name', sel.item.name || '', 'name');
          addField('Kind', sel.item.kind || '', 'kind', { list: 'objectKindList' });
          addField('Hex', sel.item.hex || '', 'hex');
          addField('Floor', sel.item.floorId || '', 'floorId');
          addField('Sprite', sel.item.sprite || sel.item.spriteFile || '', 'sprite');
          addField('Scale', sel.item.spriteScale != null ? sel.item.spriteScale : '', 'spriteScale', { type: 'number', step: '0.05' });
          addField('Scale X', sel.item.spriteScaleX != null ? sel.item.spriteScaleX : '', 'spriteScaleX', { type: 'number', step: '0.05' });
          addField('Scale Y', sel.item.spriteScaleY != null ? sel.item.spriteScaleY : '', 'spriteScaleY', { type: 'number', step: '0.05' });
          addField('Rot Deg', sel.item.rotDeg != null ? sel.item.rotDeg : '', 'rotDeg', { type: 'number', step: '1' });
          addField('Offset X', sel.item.ox != null ? sel.item.ox : '', 'ox', { type: 'number', step: '0.05' });
          addField('Offset Y', sel.item.oy != null ? sel.item.oy : '', 'oy', { type: 'number', step: '0.05' });
          addButtonRow([
            { label: 'To Front', onClick: () => reorderSelection('front') },
            { label: 'To Back', onClick: () => reorderSelection('back') },
          ]);
        }

        if (sel.type === 'token') {
          addField('Type', 'token', 'type', { readonly: true });
          addField('ID', sel.item.id, 'id', { readonly: true });
          addField('Name', sel.item.name || '', 'name');
          addField('Kind', sel.item.kind || '', 'kind', { list: 'tokenKindList' });
          addField('Hex', sel.item.hex || '', 'hex');
          addField('Floor', sel.item.floorId || '', 'floorId');
          addField('POI', sel.item.poi_id || '', 'poi_id');
          addField('Side', sel.item.side || '', 'side');
          addField('HP', sel.item.hp != null ? sel.item.hp : '', 'hp', { type: 'number', step: '1' });
          addField('Init', sel.item.init != null ? sel.item.init : '', 'init', { type: 'number', step: '1' });
          addButtonRow([
            { label: 'HP -1', onClick: () => bumpToken('hp', -1) },
            { label: 'HP +1', onClick: () => bumpToken('hp', 1) },
            { label: 'Init -1', onClick: () => bumpToken('init', -1) },
            { label: 'Init +1', onClick: () => bumpToken('init', 1) },
          ]);
          addButtonRow([
            { label: 'Set PC', onClick: () => setTokenSide('PC', 'pc') },
            { label: 'Set NPC', onClick: () => setTokenSide('NPC', 'npc') },
          ]);
        }
      }
      function applyFieldChange(key, value) {
        const sel = EDITOR.selection;
        if (!sel) return;
        const item = sel.item;
        const num = (val, fallback = null) => {
          if (val == null || String(val).trim() === '') return fallback;
          const n = Number(val);
          return Number.isFinite(n) ? n : fallback;
        };

        if (sel.type === 'room') {
          if (key === 'name') item.name = value;
          if (key === 'floorId') moveRoomToFloor(item, value);
          if (key === 'cornerTL' || key === 'cornerBR') updateRoomCorners(item, key, value);
          if (key === 'thickness') item.thickness = num(value, 0);
          if (key === 'floor.kind') {
            item.floor = item.floor || {};
            item.floor.kind = value;
          }
          if (key === 'wall.kind') {
            item.wall = item.wall || {};
            item.wall.kind = value;
          }
        }

        if (sel.type === 'opening') {
          if (key === 'name') item.name = value;
          if (key === 'kind') item.kind = value;
          if (key === 'hex') item.hex = value;
          if (key === 'floorId') moveOpeningToFloor(item, value);
          if (key === 'orientation') item.orientation = value;
          if (key === 'openPct') item.openPct = Math.max(0, Math.min(1, num(value, 0)));
          if (key === 'len') {
            const n = num(value, null);
            if (n == null) delete item.len;
            else item.len = n;
          }
          if (key === 'thickness') {
            const n = num(value, null);
            if (n == null) delete item.thickness;
            else item.thickness = n;
          }
          if (key === 'seam_kind') item.seam_kind = value;
        }

        if (sel.type === 'object') {
          if (key === 'name') item.name = value;
          if (key === 'kind') item.kind = value;
          if (key === 'hex') item.hex = value;
          if (key === 'floorId') item.floorId = value;
          if (key === 'sprite') item.sprite = value;
          if (key === 'spriteScale') item.spriteScale = num(value, 1);
          if (key === 'spriteScaleX') item.spriteScaleX = num(value, null);
          if (key === 'spriteScaleY') item.spriteScaleY = num(value, null);
          if (key === 'rotDeg') item.rotDeg = num(value, 0);
          if (key === 'ox') item.ox = num(value, 0);
          if (key === 'oy') item.oy = num(value, 0);
        }

        if (sel.type === 'token') {
          if (key === 'name') item.name = value;
          if (key === 'kind') item.kind = value;
          if (key === 'hex') item.hex = value;
          if (key === 'floorId') item.floorId = value;
          if (key === 'poi_id') item.poi_id = value;
          if (key === 'side') item.side = value;
          if (key === 'hp') item.hp = num(value, null);
          if (key === 'init') item.init = num(value, null);
          syncEntityFromToken(item);
          queueEntitySave(item);
          renderStatus();
        }

        EDITOR.dirty = true;
        render();
      }

      function updateRoomCorners(room, key, value) {
        const corners = Array.isArray(room.corners) ? room.corners.slice() : [];
        if (corners.length < 4) return;
        if (key === 'cornerTL') corners[0] = value;
        if (key === 'cornerBR') corners[2] = value;
        room.corners = corners;
      }

      function moveRoomToFloor(room, floorId) {
        const floors = STATE.battle.floors;
        const source = floors.find(f => f.rooms.includes(room));
        const target = floors.find(f => f.id === floorId);
        if (!source || !target) return;
        source.rooms = source.rooms.filter(r => r !== room);
        target.rooms.push(room);
        EDITOR.selection.floorId = floorId;
      }

      function moveOpeningToFloor(opening, floorId) {
        const floors = STATE.battle.floors;
        const source = floors.find(f => f.openings && f.openings.includes(opening));
        const target = floors.find(f => f.id === floorId);
        if (!source || !target) return;
        source.openings = source.openings.filter(o => o !== opening);
        if (!Array.isArray(target.openings)) target.openings = [];
        target.openings.push(opening);
        EDITOR.selection.floorId = floorId;
      }

      function reorderSelection(direction) {
        const sel = EDITOR.selection;
        if (!sel || !STATE.battle) return;
        const floor = STATE.battle.floors.find(f => String(f.id) === String(sel.floorId));
        if (!floor) return;

        let list = null;
        if (sel.type === 'room') list = floor.rooms;
        if (sel.type === 'opening') list = floor.openings;
        if (sel.type === 'object') list = floor.objects;
        if (!Array.isArray(list)) return;

        const idx = list.indexOf(sel.item);
        if (idx === -1) return;
        list.splice(idx, 1);
        if (direction === 'front') list.push(sel.item);
        else list.unshift(sel.item);

        // Persist order via z so reloads keep the stack.
        const zVals = list.map((item, i) => numOr(item && item.z, i));
        const maxZ = Math.max(0, ...zVals);
        const minZ = Math.min(0, ...zVals);
        sel.item.z = direction === 'front' ? maxZ + 1 : minZ - 1;

        EDITOR.dirty = true;
        render();
      }

      function selectItem(type, item, floorId) {
        EDITOR.selection = { type, item, floorId };
        updateInspector();
      }

      function clearSelection() {
        EDITOR.selection = null;
        updateInspector();
      }

      function nearestItem(list, point, getPos, maxDist = 20) {
        let best = null;
        let bestD = Infinity;
        for (const item of list) {
          const pos = getPos(item);
          if (!pos) continue;
          const dx = pos.x - point.x;
          const dy = pos.y - point.y;
          const d = Math.sqrt(dx * dx + dy * dy);
          if (d < bestD && d <= maxDist) {
            bestD = d;
            best = item;
          }
        }
        return best;
      }

      function findSelectionAt(worldPoint) {
        const floor = pickFloor();
        if (!floor) return null;
        const screenPoint = worldToScreen(worldPoint);

        const tokens = buildTokens().filter(t => !t.floorId || t.floorId === floor.id);
        const token = nearestItem(tokens, screenPoint, t => {
          const pos = parseHexLabel(t.hex);
          return pos ? worldToScreen(hexToWorld(pos.col, pos.row)) : null;
        }, 18);
        if (token) return { type: 'token', item: token, floorId: floor.id };

        const objects = floor.objects || [];
        const object = nearestItem(objects, screenPoint, o => {
          const world = objectWorldCenter(o);
          return world ? worldToScreen(world) : null;
        }, 18);
        if (object) return { type: 'object', item: object, floorId: floor.id };

        const openings = floor.openings || [];
        const opening = nearestItem(openings, screenPoint, o => {
          const world = openingWorldCenter(o, floor);
          return world ? worldToScreen(world) : null;
        }, 14);
        if (opening) return { type: 'opening', item: opening, floorId: floor.id };

        for (const room of floor.rooms) {
          const rectInfo = roomRectScreen(room);
          if (!rectInfo) continue;
          if (screenPoint.x >= rectInfo.x1 && screenPoint.x <= rectInfo.x2 &&
              screenPoint.y >= rectInfo.y1 && screenPoint.y <= rectInfo.y2) {
            return { type: 'room', item: room, floorId: floor.id };
          }
        }

        return null;
      }

      function pointInPolygon(point, vs) {
        let inside = false;
        for (let i = 0, j = vs.length - 1; i < vs.length; j = i++) {
          const xi = vs[i].x, yi = vs[i].y;
          const xj = vs[j].x, yj = vs[j].y;
          const intersect = ((yi > point.y) !== (yj > point.y)) &&
            (point.x < (xj - xi) * (point.y - yi) / (yj - yi + 0.00001) + xi);
          if (intersect) inside = !inside;
        }
        return inside;
      }

      function handleCanvasClick(ev) {
        if (EDITOR.ignoreClick) {
          EDITOR.ignoreClick = false;
          return;
        }
        const rect = canvas.getBoundingClientRect();
        const x = ev.clientX - rect.left;
        const y = ev.clientY - rect.top;
        const world = screenToWorld(x, y);
        const hex = worldToHex(world);
        const hexLabel = toHexLabel(hex.col, hex.row);
        const floor = pickFloor();
        if (!floor) return;

        if (EDITOR.tool === 'select') {
          const sel = findSelectionAt(world);
          if (sel) selectItem(sel.type, sel.item, sel.floorId);
          else clearSelection();
          return;
        }

        if (EDITOR.tool === 'delete') {
          const sel = findSelectionAt(world);
          if (!sel) return;
          if (sel.type === 'room') floor.rooms = floor.rooms.filter(r => r !== sel.item);
          if (sel.type === 'opening') floor.openings = floor.openings.filter(o => o !== sel.item);
          if (sel.type === 'object') floor.objects = floor.objects.filter(o => o !== sel.item);
          clearSelection();
          EDITOR.dirty = true;
          render();
          return;
        }

        if (EDITOR.tool === 'room') {
          if (!EDITOR.roomStart) {
            EDITOR.roomStart = hex;
            return;
          }
          const start = EDITOR.roomStart;
          EDITOR.roomStart = null;
          const minCol = Math.min(start.col, hex.col);
          const maxCol = Math.max(start.col, hex.col);
          const minRow = Math.min(start.row, hex.row);
          const maxRow = Math.max(start.row, hex.row);
          const room = {
            id: 'room_' + Date.now().toString(36),
            corners: [
              toHexLabel(minCol, maxRow),
              toHexLabel(maxCol, maxRow),
              toHexLabel(maxCol, minRow),
              toHexLabel(minCol, minRow)
            ],
            thickness: 12,
            floor: { kind: 'wood_oak' },
            wall: { kind: 'brick' }
          };
          floor.rooms.push(room);
          selectItem('room', room, floor.id);
          EDITOR.dirty = true;
          render();
          return;
        }

        if (EDITOR.tool === 'opening') {
          const snapped = snapWorldToWall(world, floor, EDITOR.openingOrientation || 'h');
          const openHex = openingHexFromWorld(snapped);
          const openLabel = openingHexLabelFromCoords(openHex.col, openHex.row) || hexLabel;
          const opening = {
            id: 'opening_' + Date.now().toString(36),
            kind: EDITOR.openingKind || 'door.wood',
            hex: openLabel,
            orientation: EDITOR.openingOrientation || 'h',
            openPct: 0
          };
          floor.openings.push(opening);
          selectItem('opening', opening, floor.id);
          EDITOR.dirty = true;
          render();
          return;
        }

        if (EDITOR.tool === 'object') {
          const obj = {
            id: 'object_' + Date.now().toString(36),
            kind: EDITOR.objectKind || 'object',
            hex: hexLabel,
            floorId: floor.id
          };
          floor.objects.push(obj);
          selectItem('object', obj, floor.id);
          EDITOR.dirty = true;
          render();
          return;
        }

        if (EDITOR.tool === 'token') {
          const poiId = resolvePoiId();
          const entityId = `entity_${Date.now().toString(36)}_${Math.random().toString(36).slice(2, 6)}`;
          const tokenKind = (EDITOR.tokenKind || 'npc').toLowerCase();
          const tokenSide = tokenKind === 'pc' ? 'PC' : 'NPC';
          const entity = {
            id: entityId,
            name: 'Token',
            kind: tokenKind,
            poi_id: poiId || '',
            location: { hex: hexLabel, floorId: floor.id }
          };
          STATE.entities = Array.isArray(STATE.entities) ? STATE.entities : [];
          STATE.entities.push(entity);

          const token = {
            id: entityId,
            name: entity.name,
            kind: entity.kind,
            hex: entity.location.hex,
            floorId: entity.location.floorId,
            poi_id: entity.poi_id,
            side: entity.side || tokenSide,
            __entity: entity
          };
          selectItem('token', token, floor.id);
          syncEntityFromToken(token);
          queueEntitySave(token);
          renderStatus();
          EDITOR.dirty = true;
          render();
        }
      }

      function syncEntityFromToken(token) {
        const entity = token && token.__entity;
        if (!entity) return;
        entity.name = token.name;
        if (token.kind) entity.kind = token.kind;
        if (!entity.location || typeof entity.location !== 'object') entity.location = {};
        if (token.hex) entity.location.hex = token.hex;
        if (token.floorId) entity.location.floorId = token.floorId;
        if (token.poi_id) entity.poi_id = token.poi_id;
        if (token.side) entity.side = token.side;
        if (!entity.stats || typeof entity.stats !== 'object') entity.stats = {};
        if (token.hp != null) {
          entity.stats.hp = token.hp;
          entity.hp = token.hp;
        }
        if (token.init != null) {
          entity.stats.init = token.init;
          entity.init = token.init;
        }
      }

      function onDragMove(worldPoint) {
        const drag = EDITOR.drag;
        if (!drag) return;
        const hex = worldToHex(worldPoint);
        const hexLabel = toHexLabel(hex.col, hex.row);

        if (drag.type === 'token') {
          drag.item.hex = hexLabel;
          drag.item.floorId = VIEW.floorId || drag.floorId || drag.item.floorId;
          syncEntityFromToken(drag.item);
        } else if (drag.type === 'opening') {
          const orient = drag.item && drag.item.orientation === 'v' ? 'v' : 'h';
          const snapped = snapWorldToWall(worldPoint, pickFloor(), orient);
          const openHex = openingHexFromWorld(snapped);
          const openLabel = openingHexLabelFromCoords(openHex.col, openHex.row) || hexLabel;
          drag.item.hex = openLabel;
        } else if (drag.type === 'object') {
          const base = hexToWorld(hex.col, hex.row);
          const ox = (worldPoint.x - base.x) / GRID.size;
          const oy = (worldPoint.y - base.y) / GRID.size;
          drag.item.hex = hexLabel;
          drag.item.ox = Math.round(ox * 100) / 100;
          drag.item.oy = Math.round(oy * 100) / 100;
        }
        EDITOR.dirty = true;
        render();
      }

      function attachDragHandlers() {
        canvas.addEventListener('mousedown', (ev) => {
          if (EDITOR.tool !== 'select') return;
          const rect = canvas.getBoundingClientRect();
          const x = ev.clientX - rect.left;
          const y = ev.clientY - rect.top;
          const world = screenToWorld(x, y);
          const sel = findSelectionAt(world);
          if (!sel) return;
          if (sel.type === 'room') return;
          selectItem(sel.type, sel.item, sel.floorId);
          EDITOR.drag = sel;
          EDITOR.drag.didMove = false;
        });

        canvas.addEventListener('mousemove', (ev) => {
          if (!EDITOR.drag) return;
          EDITOR.drag.didMove = true;
          const rect = canvas.getBoundingClientRect();
          const x = ev.clientX - rect.left;
          const y = ev.clientY - rect.top;
          const world = screenToWorld(x, y);
          onDragMove(world);
        });

        window.addEventListener('mouseup', () => {
          if (!EDITOR.drag) return;
          const dragged = EDITOR.drag;
          EDITOR.drag = null;
          if (dragged.didMove) {
            EDITOR.ignoreClick = true;
            updateInspector();
            if (dragged.type === 'token') {
              syncEntityFromToken(dragged.item);
              queueEntitySave(dragged.item);
              renderStatus();
            }
          }
        });
      }

      async function saveState() {
        const battleId = resolveBattleId();
        if (!battleId || !STATE.battle) return;
        saveStatus.textContent = 'DB: saving...';
        try {
          let payloadState = STATE.battle;
          if (STATE.wrapper && STATE.recordId) {
            const wrapper = STATE.wrapper;
            if (!wrapper.records || typeof wrapper.records !== 'object') wrapper.records = {};
            wrapper.records[STATE.recordId] = STATE.battle;
            if (!wrapper.active || typeof wrapper.active !== 'object') wrapper.active = { recordId: STATE.recordId };
            if (!wrapper.active.recordId) wrapper.active.recordId = STATE.recordId;
            payloadState = wrapper;
          }
          const body = JSON.stringify({ state_json: payloadState });
          const res = await fetch(`/api/battles/${encodeURIComponent(battleId)}`, {
            method: 'PUT',
            headers: { 'content-type': 'application/json', 'accept': 'application/json', ...getAuthHeaders() },
            body
          });
          if (!res.ok) throw new Error('Save failed');
          saveStatus.textContent = 'DB: saved';
          EDITOR.dirty = false;
        } catch (e) {
          saveStatus.textContent = 'DB: error';
        }
      }

      let entitySaveTimer = null;
      function queueEntitySave(token) {
        if (!getCampaignId()) return;
        if (entitySaveTimer) clearTimeout(entitySaveTimer);
        entitySaveTimer = setTimeout(() => saveEntity(token), 400);
      }

      async function saveEntity(token) {
        const cid = getCampaignId();
        if (!cid) return;
        const stats = {};
        if (token.hp != null) stats.hp = token.hp;
        if (token.init != null) stats.init = token.init;
        const payload = {
          entity_id: token.id,
          patch: {
            name: token.name,
            kind: token.kind,
            side: token.side,
            poi_id: token.poi_id || resolvePoiId(),
            location: { hex: token.hex, floorId: token.floorId },
            ...(Object.keys(stats).length ? { stats } : {})
          },
          create_if_missing: true
        };
        try {
          await fetch(`/api/campaigns/${encodeURIComponent(cid)}/entities`, {
            method: 'PATCH',
            headers: { 'content-type': 'application/json', 'accept': 'application/json', ...getAuthHeaders() },
            body: JSON.stringify(payload)
          });
        } catch {}
      }

      function attachEvents() {
        Object.entries(toolButtons).forEach(([key, btn]) => {
          if (!btn) return;
          btn.addEventListener('click', () => setTool(key));
        });
        if (openingKindSelect) {
          openingKindSelect.addEventListener('change', () => {
            EDITOR.openingKind = openingKindSelect.value;
          });
          openingKindSelect.value = EDITOR.openingKind;
        }
        const setOpeningOrientation = (val) => {
          EDITOR.openingOrientation = val;
          if (openingOrientH) openingOrientH.classList.toggle('active', val === 'h');
          if (openingOrientV) openingOrientV.classList.toggle('active', val === 'v');
        };
        if (openingOrientH) openingOrientH.addEventListener('click', () => setOpeningOrientation('h'));
        if (openingOrientV) openingOrientV.addEventListener('click', () => setOpeningOrientation('v'));
        setOpeningOrientation(EDITOR.openingOrientation);
        if (objectKindSelect) {
          objectKindSelect.addEventListener('change', () => {
            EDITOR.objectKind = objectKindSelect.value;
          });
          objectKindSelect.value = EDITOR.objectKind;
        }
        if (tokenKindSelect) {
          tokenKindSelect.addEventListener('change', () => {
            EDITOR.tokenKind = tokenKindSelect.value;
          });
          tokenKindSelect.value = EDITOR.tokenKind;
        }
        floorSelect.addEventListener('change', () => {
          VIEW.floorId = floorSelect.value;
          render();
        });
        zoomInput.addEventListener('input', () => {
          VIEW.zoom = Number(zoomInput.value);
          render();
        });
        saveButton.addEventListener('click', () => saveState());
        canvas.addEventListener('click', handleCanvasClick);
        attachDragHandlers();
        window.addEventListener('resize', () => render());
      }

      function populateKindLists() {
        if (!floorKindList || !wallKindList || !openingKindList || !objectKindList) return;
        const floorKinds = new Set(DEFAULT_FLOOR_KINDS);
        const wallKinds = new Set(DEFAULT_WALL_KINDS);
        const openingKinds = new Set(DEFAULT_OPENING_KINDS);
        const objectKinds = new Set(DEFAULT_OBJECT_KINDS);
        const tokenKinds = new Set(DEFAULT_TOKEN_KINDS);

        if (STATE.battle && Array.isArray(STATE.battle.floors)) {
          for (const floor of STATE.battle.floors) {
            if (Array.isArray(floor.rooms)) {
              for (const room of floor.rooms) {
                const fk = room && room.floor && room.floor.kind;
                const wk = room && room.wall && room.wall.kind;
                if (fk) floorKinds.add(String(fk));
                if (wk) wallKinds.add(String(wk));
              }
            }
            if (Array.isArray(floor.openings)) {
              for (const o of floor.openings) {
                if (o && o.kind) openingKinds.add(String(o.kind));
                if (o && o.seam_kind) floorKinds.add(String(o.seam_kind));
              }
            }
            if (Array.isArray(floor.objects)) {
              for (const o of floor.objects) {
                if (o && o.kind) objectKinds.add(String(o.kind));
              }
            }
          }
        }

        const fill = (el, values) => {
          el.innerHTML = Array.from(values).sort().map(v => `<option value="${String(v).replace(/\"/g, '&quot;')}"></option>`).join('');
        };
        fill(floorKindList, floorKinds);
        fill(wallKindList, wallKinds);
        fill(openingKindList, openingKinds);
        fill(objectKindList, objectKinds);
        if (tokenKindList) fill(tokenKindList, tokenKinds);
      }

      async function init() {
        await loadBattle();
        await loadCampaign();
        setFloorOptions();
        populateKindLists();
        VIEW.zoom = Number(zoomInput.value);
        autoCenterCamera();
        renderStatus();
        attachEvents();
        render();
      }

      init().catch(err => {
        saveStatus.textContent = 'DB: error';
        console.error(err);
      });
    })();
  </script>
</body>
</html>
