<!-- Battlemat v7.07 -->
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Battlemat Next</title>
  <style>
    :root {
      color-scheme: dark;
      --bg: #0c0f14;
      --panel: #131722;
      --panel-2: #0f141c;
      --accent: #6fd3ff;
      --text: #e6ecf3;
      --muted: #97a2b3;
      --danger: #ff7a7a;
      --success: #63d18d;
      --grid: rgba(255,255,255,0.06);
      --room-outline: rgba(255,255,255,0.18);
    }

    * { box-sizing: border-box; }
    body {
      margin: 0;
      background: var(--bg);
      color: var(--text);
      font: 14px/1.4 ui-sans-serif, system-ui, -apple-system, Segoe UI, sans-serif;
    }

    #app {
      display: grid;
      grid-template-columns: 1fr 320px;
      min-height: 100vh;
    }

    #canvasWrap {
      position: relative;
      overflow: hidden;
      background: var(--bg);
    }

    canvas {
      display: block;
      width: 100%;
      height: 100%;
    }

    #toolbar {
      position: absolute;
      top: 12px;
      left: 12px;
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 8px 10px;
      background: rgba(15,20,28,0.85);
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: 8px;
      backdrop-filter: blur(8px);
      z-index: 10;
    }

    #toolbar select, #toolbar input, #toolbar button {
      background: #0f141c;
      color: var(--text);
      border: 1px solid rgba(255,255,255,0.12);
      border-radius: 6px;
      padding: 6px 8px;
      font-size: 13px;
    }

    #toolbar button {
      cursor: pointer;
    }

    #toolbar .toolBtn.active {
      border-color: var(--accent);
      box-shadow: 0 0 0 1px rgba(111,211,255,0.35) inset;
    }

    #toolbar .status {
      padding: 0 6px;
      font-size: 12px;
      color: var(--muted);
    }

    #toolbar .mini {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      font-size: 12px;
      color: var(--muted);
    }

    #toolbar .mini input {
      width: 14px;
      height: 14px;
      accent-color: var(--accent);
    }

    .toolGroup {
      display: none;
      align-items: center;
      gap: 8px;
    }

    #navBar {
      position: absolute;
      right: 12px;
      top: 12px;
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 8px 10px;
      background: rgba(15,20,28,0.85);
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: 8px;
      backdrop-filter: blur(8px);
      z-index: 10;
    }

    #navBar button, #navBar input, #navBar select {
      background: #0f141c;
      color: var(--text);
      border: 1px solid rgba(255,255,255,0.12);
      border-radius: 6px;
      font-size: 13px;
    }

    #navBar .status {
      padding: 0 6px;
      font-size: 12px;
      color: var(--muted);
    }

    #navBar .mini {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      font-size: 12px;
      color: var(--muted);
    }

    #navBar .mini input {
      width: 14px;
      height: 14px;
      accent-color: var(--accent);
    }

    #navBar .mini select {
      background: #0f141c;
      color: var(--text);
      border: 1px solid rgba(255,255,255,0.12);
      border-radius: 6px;
      font-size: 12px;
      padding: 2px 6px;
    }

    #navBar .toggles {
      display: flex;
      flex-direction: column;
      gap: 4px;
      align-items: flex-start;
    }

    .panPad {
      display: grid;
      grid-template-columns: 28px 28px 28px;
      grid-template-rows: 24px 28px 24px;
      grid-template-areas:
        ". up ."
        "left . right"
        ". down .";
      gap: 4px;
    }

    #panUp { grid-area: up; transform: translateY(12px); }
    #panDown { grid-area: down; transform: translateY(-12px); }
    #panLeft { grid-area: left; }
    #panRight { grid-area: right; }

    .panPad button {
      cursor: pointer;
      width: 28px;
      height: 28px;
      padding: 0;
      line-height: 1;
    }

    #sidebar {
      background: var(--panel);
      border-left: 1px solid rgba(255,255,255,0.08);
      padding: 12px;
      display: flex;
      flex-direction: column;
      gap: 12px;
    }
    section {
      background: var(--panel-2);
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: 10px;
      padding: 10px;
    }

    section h3 {
      margin: 0 0 8px 0;
      font-size: 13px;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: var(--muted);
    }

    .row {
      display: grid;
      grid-template-columns: 90px 1fr;
      gap: 6px;
      align-items: center;
      margin-bottom: 6px;
    }

    .row input, .row select, .row textarea {
      background: #0f141c;
      color: var(--text);
      border: 1px solid rgba(255,255,255,0.12);
      border-radius: 6px;
      padding: 6px 8px;
      font-size: 13px;
    }

    .row input[readonly] {
      opacity: 0.6;
    }

    #statusList {
      display: flex;
      flex-direction: column;
      gap: 6px;
      max-height: 240px;
      overflow: auto;
    }

    .statusItem {
      display: grid;
      grid-template-columns: 1fr auto;
      gap: 6px;
      align-items: center;
      padding: 6px 8px;
      border-radius: 8px;
      background: rgba(255,255,255,0.03);
      border: 1px solid rgba(255,255,255,0.06);
    }

    .statusItem .meta { color: var(--muted); font-size: 12px; }

    #statusMeta {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      margin-bottom: 8px;
    }

    .statusPill {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 4px 10px;
      border-radius: 999px;
      font-size: 12px;
      color: var(--text);
      background: rgba(255,255,255,0.06);
      border: 1px solid rgba(255,255,255,0.12);
    }

    .statusWrap {
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(15,20,28,0.6);
      overflow: hidden;
    }

    #statusTable {
      width: 100%;
      border-collapse: collapse;
      font-size: 13px;
    }

    #statusTable thead th {
      text-align: left;
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.06em;
      color: var(--muted);
      background: rgba(255,255,255,0.03);
      padding: 6px 8px;
    }

    #statusTable thead th:first-child { padding-left: 12px; }
    #statusTable tbody td {
      padding: 8px;
      border-bottom: 1px solid rgba(255,255,255,0.08);
    }
    #statusTable tbody tr:last-child td { border-bottom: none; }

    .statusNameCell { display: flex; align-items: center; gap: 6px; }
    .statusTurnMarker {
      width: 0; height: 0;
      border-top: 6px solid transparent;
      border-bottom: 6px solid transparent;
      border-left: 8px solid rgba(79,208,127,0.95);
    }
    .statusTurnMarker.inactive { border-left-color: transparent; }
    .statusName { font-weight: 600; }
    .status-friendly { color: #7fd3ff; }
    .status-neutral { color: var(--muted); }
    .status-hostile { color: rgba(255,140,110,0.95); }
    .statusRow.active { background: rgba(67,209,122,0.10); }
    .statusNum { text-align: center; font-variant-numeric: tabular-nums; }
    .statusCond { display: flex; align-items: center; gap: 6px; }
    .statusIntent {
      width: 14px; height: 14px;
      border-radius: 4px;
      border: 1px solid rgba(255,255,255,0.2);
      background: rgba(255,255,255,0.06);
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-size: 10px;
      color: #8fe8b2;
    }
    .statusIntent.on {
      border-color: rgba(79,208,127,0.9);
      background: rgba(79,208,127,0.2);
    }

    #chatLog {
      border: 1px solid rgba(255,255,255,0.12);
      border-radius: 10px;
      padding: 8px;
      background: rgba(255,255,255,0.03);
      max-height: 260px;
      overflow: auto;
      font-size: 12px;
      color: var(--text);
      display: flex;
      flex-direction: column;
      gap: 6px;
      margin-bottom: 10px;
    }
    .chatEntry {
      display: flex;
      gap: 8px;
      align-items: flex-start;
      line-height: 1.3;
      position: relative;
      padding-left: 20px;
    }
    .chatEntry.ack {
      color: rgba(190,195,205,0.85);
    }
    .chatEntry.canceled {
      color: rgba(220,120,120,0.9);
      text-decoration: line-through;
    }
    .chatEntry.processed {
      color: rgba(180,185,195,0.9);
    }
    .chatFocusArrow {
      position: absolute;
      left: 4px;
      top: 4px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 0;
      height: 0;
      border-top: 6px solid transparent;
      border-bottom: 6px solid transparent;
      border-left: 10px solid rgba(120,220,140,0.9);
    }
    .chatSpeaker {
      font-weight: 600;
      color: #7fd3ff;
      margin-right: 4px;
      white-space: nowrap;
    }
    .chatSpeaker.dm { color: var(--muted); }
    .chatText { white-space: pre-wrap; }

    #chatBar {
      display: flex;
      gap: 8px;
      align-items: center;
    }
    #chatBar select,
    #chatBar input {
      background: rgba(255,255,255,0.08);
      border: 1px solid rgba(255,255,255,0.18);
      color: var(--text);
      border-radius: 8px;
      padding: 6px 8px;
      font-size: 12px;
    }
    #chatSpeaker { min-width: 120px; }
    #chatInput { flex: 1; }
    #chatSend {
      padding: 6px 10px;
      border-radius: 8px;
      border: 1px solid rgba(255,255,255,0.2);
      background: rgba(255,255,255,0.08);
      color: var(--text);
      font-size: 12px;
      cursor: pointer;
    }

    #inspectorEmpty {
      color: var(--muted);
      font-size: 13px;
    }

    .btnRow {
      display: flex;
      gap: 6px;
      margin-top: 6px;
    }

    .btnRow button {
      flex: 1;
      padding: 6px 8px;
      border-radius: 6px;
      border: 1px solid rgba(255,255,255,0.12);
      background: #0f141c;
      color: var(--text);
      cursor: pointer;
    }

    .warning {
      color: var(--danger);
      font-size: 12px;
    }
  </style>
</head>
<body>
  <div id="app">
    <div id="canvasWrap">
      <canvas id="map"></canvas>
      <div id="toolbar">
        <button id="toolSelect" class="toolBtn active">Select</button>
        <button id="toolRoom" class="toolBtn">Room</button>
        <button id="toolPoly" class="toolBtn">Poly</button>
        <button id="toolOpening" class="toolBtn">Opening</button>
        <button id="toolObject" class="toolBtn">Object</button>
        <button id="toolToken" class="toolBtn">Token</button>
        <label class="status">Layer</label>
        <select id="layerSelect">
          <option value="all" selected>all</option>
          <option value="floors">floors</option>
          <option value="walls">walls</option>
          <option value="objects">objects</option>
          <option value="tokens">tokens</option>
        </select>
        <label class="mini"><input type="checkbox" id="handlesToggle" /> Handles</label>
        <select id="floorSelect"></select>
        <button id="btnUndo">Undo</button>
        <label class="mini"><input type="checkbox" id="fogToggle" checked /> Fog</label>
        <button id="btnSave">Save</button>
        <span id="saveStatus" class="status">DB: idle</span>
        <div id="openingGroup" class="toolGroup">
          <label class="status">Opening</label>
          <select id="openingKind">
            <option value="door.wood">door.wood</option>
            <option value="door">door</option>
            <option value="window">window</option>
            <option value="threshold">threshold</option>
            <option value="portal">portal</option>
          </select>
          <button id="openingOrientH" class="toolBtn">H</button>
          <button id="openingOrientV" class="toolBtn">V</button>
        </div>
        <div id="objectGroup" class="toolGroup">
          <label class="status">Object</label>
          <select id="objectKind">
            <option value="object">object</option>
            <option value="poi.view">poi.view</option>
            <option value="table.round">table.round</option>
            <option value="table.rect">table.rect</option>
            <option value="chair">chair</option>
            <option value="crate">crate</option>
            <option value="barrel">barrel</option>
            <option value="stairs">stairs</option>
            <option value="bed">bed</option>
          </select>
        </div>
        <div id="tokenGroup" class="toolGroup">
          <label class="status">Token</label>
          <select id="tokenKind">
            <option value="pc">pc</option>
            <option value="npc" selected>npc</option>
            <option value="monster">monster</option>
            <option value="creature">creature</option>
          </select>
        </div>
      </div>
      <div id="navBar">
        <div class="panPad">
          <div></div>
          <button id="panUp" title="Pan up">↑</button>
          <div></div>
          <button id="panLeft" title="Pan left">←</button>
          <div></div>
          <button id="panRight" title="Pan right">→</button>
          <div></div>
          <button id="panDown" title="Pan down">↓</button>
          <div></div>
        </div>
        <label class="status">Zoom</label>
        <input id="zoom" type="range" min="0.25" max="4" step="0.05" value="1" />
        <div class="toggles">
          <label class="mini"><input type="checkbox" id="labelBoldToggle" /> Bright Labels</label>
          <label class="mini"><input type="checkbox" id="hexGridToggle" checked /> Hexgrid</label>
          <label class="mini">Video
            <select id="videoQuality">
              <option value="low">Low</option>
              <option value="medium" selected>Medium</option>
              <option value="high">High</option>
              <option value="ultra">Ultra</option>
            </select>
          </label>
        </div>
      </div>
    </div>

    <aside id="sidebar">
      <section>
        <h3>Status</h3>
        <div id="statusMeta"></div>
        <div class="statusWrap">
          <table id="statusTable">
            <thead>
              <tr>
                <th>Actor</th>
                <th class="statusNum">Init</th>
                <th class="statusNum">HP</th>
                <th>Cond</th>
              </tr>
            </thead>
            <tbody id="statusBody"></tbody>
          </table>
        </div>
      </section>
      <section>
        <h3>Chat</h3>
        <div id="chatLog"></div>
        <div id="chatBar">
          <select id="chatSpeaker"></select>
          <button id="chatSend">Send</button>
          <input id="chatInput" type="text" placeholder="Type message..." />
        </div>
      </section>

      <section>
        <h3>Inspector</h3>
        <div id="inspectorEmpty">Select something to edit.</div>
        <div id="inspectorFields" hidden></div>
      </section>
    </aside>
  </div>
  <datalist id="floorKindList"></datalist>
  <datalist id="wallKindList"></datalist>
  <datalist id="openingKindList"></datalist>
  <datalist id="objectKindList"></datalist>
  <datalist id="tokenKindList"></datalist>

  <script>
    (() => {
      const canvas = document.getElementById('map');
      const canvasWrap = document.getElementById('canvasWrap');
      const ctx = canvas.getContext('2d');

      const toolButtons = {
        select: document.getElementById('toolSelect'),
        room: document.getElementById('toolRoom'),
        poly: document.getElementById('toolPoly'),
        opening: document.getElementById('toolOpening'),
        object: document.getElementById('toolObject'),
        token: document.getElementById('toolToken'),
      };

      const floorSelect = document.getElementById('floorSelect');
      const layerSelect = document.getElementById('layerSelect');
      const openingKindSelect = document.getElementById('openingKind');
      const openingOrientH = document.getElementById('openingOrientH');
      const openingOrientV = document.getElementById('openingOrientV');
      const objectKindSelect = document.getElementById('objectKind');
      const tokenKindSelect = document.getElementById('tokenKind');
      const openingGroup = document.getElementById('openingGroup');
      const objectGroup = document.getElementById('objectGroup');
      const tokenGroup = document.getElementById('tokenGroup');
      const zoomInput = document.getElementById('zoom');
      const panUp = document.getElementById('panUp');
      const panDown = document.getElementById('panDown');
      const panLeft = document.getElementById('panLeft');
      const panRight = document.getElementById('panRight');
      const hexGridToggle = document.getElementById('hexGridToggle');
      const labelBoldToggle = document.getElementById('labelBoldToggle');
      const handlesToggle = document.getElementById('handlesToggle');
      const fogToggle = document.getElementById('fogToggle');
      const videoSelect = document.getElementById('videoQuality');
      const saveButton = document.getElementById('btnSave');
      const undoButton = document.getElementById('btnUndo');
      const saveStatus = document.getElementById('saveStatus');
      const statusMeta = document.getElementById('statusMeta');
      const statusBody = document.getElementById('statusBody');
      const chatLog = document.getElementById('chatLog');
      const chatSpeaker = document.getElementById('chatSpeaker');
      const chatInput = document.getElementById('chatInput');
      const chatSend = document.getElementById('chatSend');
      const inspectorEmpty = document.getElementById('inspectorEmpty');
      const inspectorFields = document.getElementById('inspectorFields');
      const floorKindList = document.getElementById('floorKindList');
      const wallKindList = document.getElementById('wallKindList');
      const openingKindList = document.getElementById('openingKindList');
      const objectKindList = document.getElementById('objectKindList');
      const tokenKindList = document.getElementById('tokenKindList');

      const GRID = {
        size: 32,
        lineAlpha: 0.16,
        lineWidth: 1.25,
        labelAlpha: 0.38,
        labelFont: '600 12px ui-sans-serif, system-ui, -apple-system, Segoe UI, sans-serif'
      };
      const VIEW = { camera: { col: 0, row: 0 }, cameraWorld: { x: 0, y: 0 }, zoom: 1, floorId: '' };
      const STATE = { battle: null, campaign: null, entities: [] };
      const UI = { hexGrid: true, brightLabels: false, showHandles: false, handleHot: false, fogEnabled: true, video: 'medium' };
      const VIDEO_SCALE = { low: 1, medium: 1.5, high: 2, ultra: 3 };
      let renderDpr = window.devicePixelRatio || 1;
      const CHAT = { rows: [], byId: new Map(), lastTs: 0, timer: null };
      const EDITOR = {
        tool: 'select',
        selection: null,
        roomStart: null,
        roomHover: null,
        polyPoints: [],
        polyHover: null,
        dirty: false,
        drag: null,
        ignoreClick: false,
        openingKind: 'door.wood',
        openingOrientation: 'h',
        objectKind: 'object',
        tokenKind: 'npc'
      };
      const HISTORY = { stack: [], index: -1, limit: 20 };

      const DEFAULT_FLOOR_KINDS = [
        'wood_oak', 'wood', 'stone', 'cobble', 'brick', 'brick_dark', 'gravel', 'fog'
      ];
      const DEFAULT_WALL_KINDS = [
        'brick', 'brick_dark', 'wood_dark', 'wood', 'stone', 'cobble', 'none'
      ];
      const DEFAULT_OPENING_KINDS = [
        'door.wood', 'door', 'window', 'threshold', 'portal'
      ];
      const DEFAULT_OBJECT_KINDS = [
        'object', 'poi.view', 'table.rect', 'table.round', 'table.sqr', 'table.hot', 'table.cold', 'table.prep',
        'chair', 'bed', 'bed.double', 'bath', 'chest', 'hearth', 'cooking.hearth', 'stairs',
        'crate', 'barrel', 'keg'
      ];
      const DEFAULT_TOKEN_KINDS = ['pc', 'npc', 'monster', 'creature'];

      // Floors under wall bands can hide cutouts; keep false unless you want that effect.
      const FLOOR_UNDER_WALLS = false;

      const OPENING_STYLE = {
        door: { len: 1.5, thick: 0.25, color: '#9a6b3a' },
        window: { len: 1.2, thick: 0.5, color: '#7aaad6' },
        threshold: { len: 1.4, thick: 0.12, color: '#6f7884' },
        portal: { len: 1.3, thick: 0.22, color: '#6fd3ff' }
      };

      const FLOOR_COLORS = {
        fog: '#0e1117',
        wood: '#2a1f17',
        wood_oak: '#3a2b1e',
        cobble: '#45474a',
        stone: '#3f3f3f',
        default: '#1a1f2a'
      };

      const WALL_COLORS = {
        brick: '#3d2b23',
        brick_dark: '#2c1e19',
        wood_dark: '#2b231a',
        none: 'transparent',
        default: '#2d2f33'
      };

      const TEXTURE_FILES = {
        wood_oak: '/assets/sprites/wood_oak.png',
        wood_elm: '/assets/sprites/wood_elm.png',
        wood_dark: '/assets/sprites/wood_dark.png',
        stone: '/assets/sprites/stone.png',
        stone_cobble: '/assets/sprites/stone_cobble.png',
        brick_gray: '/assets/sprites/brick_gray.png',
        brick_red: '/assets/sprites/brick_red.png',
        brick_dark: '/assets/sprites/brick_dark.png',
        crosskeys: '/images/the_cross_keys_floor.jpg'
      };

      const TEXTURE_SCALES = {
        wall: {
          wood_oak: 0.15,
          wood_elm: 0.15,
          wood_dark: 0.15,
          stone: 0.5,
          stone_cobble: 0.1,
          brick_gray: 0.15,
          brick_red: 0.15,
          brick_dark: 0.15,
        },
        floor: {
          wood_oak: 0.15,
          wood_elm: 0.15,
          wood_dark: 0.15,
          stone: 0.25,
          stone_cobble: 0.15,
          brick_gray: 0.15,
          brick_red: 0.15,
          brick_dark: 0.15,
          crosskeys: 1.0
        }
      };

      const TEXTURE_ALIASES = {
        wall: {
          brick: 'brick_gray',
          wood: 'wood_oak',
          cobble: 'stone_cobble',
          stone: 'stone',
          gravel: 'stone_cobble'
        },
        floor: {
          wood: 'wood_oak',
          stone: 'stone',
          cobble: 'stone_cobble',
          gravel: 'stone_cobble',
          brick: 'brick_gray'
        }
      };

      const SPRITE_MAP = {
        'the.cross.keys': '/assets/sprites/the_cross_keys.png',
        'the.swan': '/assets/sprites/the_swan.png',
        'the.dolphin': '/assets/sprites/the_dolphin.png',
        'chair': '/assets/sprites/chair.png',
        'table.round': '/assets/sprites/table_round.png',
        'table.rect': '/assets/sprites/table_rectangle.png',
        'table.sqr': '/assets/sprites/table_square.png',
        'table.hot': '/assets/sprites/table_hot.png',
        'table.cold': '/assets/sprites/table_cold.png',
        'table.prep': '/assets/sprites/table_prep.png',
        'table.plate': '/assets/sprites/table_plate.png',
        'bed': '/assets/sprites/bed.png',
        'bed.double': '/assets/sprites/bed_double.png',
        'bath': '/assets/sprites/bath.png',
        'chest': '/assets/sprites/chest_closed.png',
        'hearth': '/assets/sprites/hearth.png',
        'cooking.hearth': '/assets/sprites/cooking_hearth.png',
        'stairs': '/assets/sprites/stairs.png',
        'stairs.up': '/assets/sprites/stairs_up.png',
        'stairs.down': '/assets/sprites/stairs_down.png',
        'crate': '/assets/sprites/crate.png',
        'barrel': '/assets/sprites/barrel.png',
        'keg': '/assets/sprites/keg.png',
        'token.pc': '/assets/sprites/token_pc.png',
        'token.npc': '/assets/sprites/token_npc.png'
      };

      const TOKEN_SPRITE_OPTIONS = [
        { label: 'Default', value: '' },
        { label: 'Token PC', value: '/assets/sprites/token_pc.png' },
        { label: 'Token NPC', value: '/assets/sprites/token_npc.png' },
        { label: 'Barbarian Female', value: '/assets/sprites/barbarian_female.png' },
        { label: 'Barbarian Male', value: '/assets/sprites/barbarian_male.png' },
        { label: 'Bard Female', value: '/assets/sprites/bard_female.png' },
        { label: 'Bard Male', value: '/assets/sprites/bard_male.png' },
        { label: 'Cleric Female', value: '/assets/sprites/cleric_female.png' },
        { label: 'Cleric Male', value: '/assets/sprites/cleric_male.png' },
        { label: 'Druid Female', value: '/assets/sprites/druid_female.png' },
        { label: 'Druid Male', value: '/assets/sprites/druid_male.png' },
        { label: 'Fighter Female', value: '/assets/sprites/fighter_female.png' },
        { label: 'Fighter Male', value: '/assets/sprites/fighter_male.png' },
        { label: 'Monk Female', value: '/assets/sprites/monk_female.png' },
        { label: 'Monk Male', value: '/assets/sprites/monk_male.png' },
        { label: 'Paladin Female', value: '/assets/sprites/paladin_female.png' },
        { label: 'Paladin Male', value: '/assets/sprites/paladin_male.png' },
        { label: 'Ranger Female', value: '/assets/sprites/ranger_female.png' },
        { label: 'Ranger Male', value: '/assets/sprites/ranger_male.png' },
        { label: 'Rogue Male', value: '/assets/sprites/rogue_male.png' },
        { label: 'Rogue Female', value: '/assets/sprites/rouge_female.png' },
        { label: 'Sorcerer Female', value: '/assets/sprites/sorcerer_female.png' },
        { label: 'Sorcerer Male', value: '/assets/sprites/sorcerer_male.png' },
        { label: 'Warlock Female', value: '/assets/sprites/warlock_female.png' },
        { label: 'Warlock Male', value: '/assets/sprites/warlock_male.png' },
        { label: 'Wizard Female', value: '/assets/sprites/wizard_female.png' },
        { label: 'Wizard Male', value: '/assets/sprites/wizard_male.png' },
        { label: 'Bear', value: '/assets/sprites/bear.png' },
        { label: 'Bugbear', value: '/assets/sprites/bugbear.png' },
        { label: 'Dire Wolf', value: '/assets/sprites/dire_wolf.png' },
        { label: 'Dragonkin Black', value: '/assets/sprites/dragonkin_black.png' },
        { label: 'Dragonkin Blue', value: '/assets/sprites/dragonkin_blue.png' },
        { label: 'Dragonkin Green', value: '/assets/sprites/dragonkin_green.png' },
        { label: 'Dragonkin Red', value: '/assets/sprites/dragonkin_red.png' },
        { label: 'Dragonkin White', value: '/assets/sprites/dragonkin_white.png' },
        { label: 'Ghoul', value: '/assets/sprites/ghoul.png' },
        { label: 'Giant Rat', value: '/assets/sprites/giant_rat.png' },
        { label: 'Giant Spider', value: '/assets/sprites/giant_spider.png' },
        { label: 'Goblin', value: '/assets/sprites/goblin.png' },
        { label: 'Guard', value: '/assets/sprites/guard.png' },
        { label: 'Hobgoblin', value: '/assets/sprites/hobgoblin.png' },
        { label: 'Lich', value: '/assets/sprites/lich.png' },
        { label: 'Mimic', value: '/assets/sprites/mimic.png' },
        { label: 'Ogre', value: '/assets/sprites/ogre.png' },
        { label: 'Orc', value: '/assets/sprites/orc.png' },
        { label: 'Skeleton', value: '/assets/sprites/skeleton.png' },
        { label: 'Skeleton Archer', value: '/assets/sprites/skeleton_archer.png' },
        { label: 'Wight', value: '/assets/sprites/wight.png' },
        { label: 'Wolf', value: '/assets/sprites/wolf.png' },
        { label: 'Wraith', value: '/assets/sprites/wraith.png' },
        { label: 'Wraith 2', value: '/assets/sprites/wraith2.png' },
        { label: 'Zombie', value: '/assets/sprites/zombie.png' }
      ];

      const SPRITE_ALIASES = {
        'table.rect': 'table_rectangle',
        'table.sqr': 'table_square',
        'table.round': 'table_round',
        'table.hot': 'table_hot',
        'table.cold': 'table_cold',
        'table.prep': 'table_prep',
        'table.plate': 'table_plate',
        'bed.double': 'bed_double',
        'stairs.up': 'stairs_up',
        'stairs.down': 'stairs_down',
        'cooking.hearth': 'cooking_hearth',
        'door.wood': 'door_wood',
        'door': 'door_wood',
        'window.open': 'window_open',
        'window': 'window',
        'pc': 'token_pc',
        'npc': 'token_npc'
      };

      function resolveSpriteUrl(kind) {
        const raw = String(kind || '').trim().toLowerCase();
        if (!raw) return null;
        if (SPRITE_MAP[raw]) return SPRITE_MAP[raw];
        const alias = SPRITE_ALIASES[raw] || raw.replace(/[^a-z0-9]+/g, '_');
        return `/assets/sprites/${alias}.png`;
      }

      function resolveOpeningSprite(kindRaw, openPct) {
        const k = String(kindRaw || '').toLowerCase();
        if (k.startsWith('window.open')) return resolveSpriteUrl('window.open');
        if (k.startsWith('window')) return resolveSpriteUrl('window');
        if (k.startsWith('door')) {
          return resolveSpriteUrl(k);
        }
        return null;
      }

      function colStep() { return 1.5 * GRID.size; }
      function rowStep() { return Math.sqrt(3) * GRID.size; }

      function hexToWorld(col, row) {
        const x = col * colStep();
        const y = -(row * rowStep() + (col & 1) * (rowStep() / 2));
        return { x, y };
      }

      function getCameraWorld() {
        if (VIEW.cameraWorld && Number.isFinite(VIEW.cameraWorld.x) && Number.isFinite(VIEW.cameraWorld.y)) {
          return VIEW.cameraWorld;
        }
        return hexToWorld(VIEW.camera.col, VIEW.camera.row);
      }

      function setCameraWorld(p) {
        if (!p) return;
        VIEW.cameraWorld = { x: p.x, y: p.y };
      }

      function setCameraFromHex(p) {
        if (!p) return;
        const world = hexToWorld(p.col, p.row);
        VIEW.camera.col = p.col;
        VIEW.camera.row = p.row;
        setCameraWorld(world);
      }

      function worldToScreen(p) {
        const cam = getCameraWorld();
        const w = canvas.width / renderDpr;
        const h = canvas.height / renderDpr;
        return {
          x: w / 2 + (p.x - cam.x) * VIEW.zoom,
          y: h / 2 + (p.y - cam.y) * VIEW.zoom,
        };
      }

      function screenToWorld(x, y) {
        const cam = getCameraWorld();
        const w = canvas.width / renderDpr;
        const h = canvas.height / renderDpr;
        const wx = (x - w / 2) / VIEW.zoom + cam.x;
        const wy = (y - h / 2) / VIEW.zoom + cam.y;
        return { x: wx, y: wy };
      }

      function axialToCube(q, r) {
        return { x: q, z: r, y: -q - r };
      }

      function cubeRound(c) {
        let rx = Math.round(c.x);
        let ry = Math.round(c.y);
        let rz = Math.round(c.z);
        const dx = Math.abs(rx - c.x);
        const dy = Math.abs(ry - c.y);
        const dz = Math.abs(rz - c.z);
        if (dx > dy && dx > dz) rx = -ry - rz;
        else if (dy > dz) ry = -rx - rz;
        else rz = -rx - ry;
        return { x: rx, y: ry, z: rz };
      }

      function worldToHex(p) {
        const size = GRID.size || 1;
        const qf = (2 / 3) * (p.x / size);
        const rf = ((-p.y) / size) / Math.sqrt(3) - (qf / 2);
        const col = Math.round(qf);
        const rowf = rf + (col - (col & 1)) / 2;
        const row = Math.round(rowf);
        return { col, row };
      }

      function roundHalf(v) {
        return Math.round(v * 2) / 2;
      }

      function worldToHexHalf(p) {
        const size = GRID.size || 1;
        const qf = (2 / 3) * (p.x / size);
        const rf = ((-p.y) / size) / Math.sqrt(3) - (qf / 2);
        const col = Math.round(qf);
        const rowf = rf + (col - (col & 1)) / 2;
        const row = roundHalf(rowf);
        return { col, row };
      }

      function rowFromWorldYForCol(yWorld, col) {
        const size = GRID.size || 1;
        const rowf = (-yWorld / (Math.sqrt(3) * size)) - (col & 1) * 0.5;
        return roundHalf(rowf);
      }

      function roundQuarter(v) {
        return Math.round(v * 4) / 4;
      }

      function formatStep(v) {
        const s = roundQuarter(v).toFixed(2);
        return s.replace(/\.00$/, '').replace(/(\.\d)0$/, '$1');
      }

      function openingHexFromWorld(p) {
        const size = GRID.size || 1;
        const qf = (2 / 3) * (p.x / size);
        const rf = ((-p.y) / size) / Math.sqrt(3) - (qf / 2);
        const col = Math.round(qf);
        const rowf = rf + (col - (col & 1)) / 2;
        const row = roundQuarter(rowf);
        return { col, row };
      }

      function openingHexLabelFromCoords(col, row) {
        if (!Number.isFinite(col) || !Number.isFinite(row)) return null;
        const rowNum = row + 1;
        return indexToLetters(col) + formatStep(rowNum);
      }

      function indexToLetters(idx) {
        let n = idx;
        let out = '';
        while (n >= 0) {
          out = String.fromCharCode(65 + (n % 26)) + out;
          n = Math.floor(n / 26) - 1;
        }
        return out;
      }

      function lettersToIndex(letters) {
        let n = 0;
        for (let i = 0; i < letters.length; i++) {
          n = n * 26 + (letters.charCodeAt(i) - 64);
        }
        return n - 1;
      }

      function toHexLabel(col, row) {
        return indexToLetters(col) + String(row + 1);
      }

      function parseHexLabel(label) {
        if (!label) return null;
        const m = String(label).trim().toUpperCase().match(/^([A-Z]+)(-?\d+(?:\.\d+)?)$/);
        if (!m) return null;
        const col = lettersToIndex(m[1]);
        const row = parseFloat(m[2]) - 1;
        return { col, row };
      }

      function getQueryParams() {
        return new URLSearchParams(window.location.search || '');
      }

      function escapeHtml(text) {
        return String(text ?? '')
          .replace(/&/g, '&amp;')
          .replace(/</g, '&lt;')
          .replace(/>/g, '&gt;')
          .replace(/"/g, '&quot;')
          .replace(/'/g, '&#39;');
      }

      function normStr(value) {
        return String(value ?? '').trim();
      }

      function getAuthHeaders() {
        const qp = getQueryParams();
        const token = (qp.get('token') || qp.get('auth') || qp.get('bearer') || '').trim();
        if (!token) return {};
        return { Authorization: 'Bearer ' + token };
      }

      function loadPrefs() {
        try {
          const grid = localStorage.getItem('bm_hexgrid');
          const bright = localStorage.getItem('bm_bright_labels');
          const handles = localStorage.getItem('bm_handles');
          const fog = localStorage.getItem('bm_fog');
          const video = localStorage.getItem('bm_video');
          if (grid != null) UI.hexGrid = grid === '1';
          if (bright != null) UI.brightLabels = bright === '1';
          if (handles != null) UI.showHandles = handles === '1';
          if (fog != null) UI.fogEnabled = fog === '1';
          if (video === 'low' || video === 'medium' || video === 'high' || video === 'ultra') UI.video = video;
        } catch {}
        if (hexGridToggle) hexGridToggle.checked = UI.hexGrid;
        if (labelBoldToggle) labelBoldToggle.checked = UI.brightLabels;
        if (handlesToggle) handlesToggle.checked = UI.showHandles;
        if (fogToggle) fogToggle.checked = UI.fogEnabled;
        if (videoSelect) videoSelect.value = UI.video;
      }

      function savePrefs() {
        try {
          localStorage.setItem('bm_hexgrid', UI.hexGrid ? '1' : '0');
          localStorage.setItem('bm_bright_labels', UI.brightLabels ? '1' : '0');
          localStorage.setItem('bm_handles', UI.showHandles ? '1' : '0');
          localStorage.setItem('bm_fog', UI.fogEnabled ? '1' : '0');
          localStorage.setItem('bm_video', UI.video);
        } catch {}
      }

      function setTool(tool) {
        EDITOR.tool = tool;
        Object.entries(toolButtons).forEach(([key, btn]) => {
          if (!btn) return;
          btn.classList.toggle('active', key === tool);
        });
        EDITOR.roomStart = null;
        EDITOR.polyPoints = [];
        EDITOR.polyHover = null;
        if (openingGroup) openingGroup.style.display = tool === 'opening' ? 'flex' : 'none';
        if (objectGroup) objectGroup.style.display = tool === 'object' ? 'flex' : 'none';
        if (tokenGroup) tokenGroup.style.display = tool === 'token' ? 'flex' : 'none';
        if (canvasWrap) canvasWrap.style.cursor = (tool === 'room' || tool === 'poly') ? 'crosshair' : 'default';
      }

      function drawHexOutline(gctx, center, size) {
        const pts = [];
        for (let i = 0; i < 6; i++) {
          const a = (Math.PI / 180) * (60 * i);
          pts.push({ x: center.x + size * Math.cos(a), y: center.y + size * Math.sin(a) });
        }
        gctx.beginPath();
        gctx.moveTo(pts[0].x, pts[0].y);
        for (let i = 1; i < pts.length; i++) gctx.lineTo(pts[i].x, pts[i].y);
        gctx.closePath();
        gctx.stroke();
      }

      function drawGridLayer(gctx) {
        if (!UI.hexGrid) return;
        const rect = canvas.getBoundingClientRect();
        const w = Math.max(1, rect.width);
        const h = Math.max(1, rect.height);
        const camHex = worldToHex(getCameraWorld());
        const colsR = Math.ceil((w / 2) / colStep()) + 4;
        const rowsR = Math.ceil((h / 2) / rowStep()) + 4;

        gctx.save();
        gctx.strokeStyle = `rgba(255,255,255,${GRID.lineAlpha})`;
        gctx.lineWidth = GRID.lineWidth;
        const size = GRID.size * VIEW.zoom;

        for (let dc = -colsR; dc <= colsR; dc++) {
          for (let dr = -rowsR; dr <= rowsR; dr++) {
            const col = camHex.col + dc;
            const row = camHex.row + dr;
            const p = worldToScreen(hexToWorld(col, row));
            if (p.x < -100 || p.x > w + 100 || p.y < -100 || p.y > h + 100) continue;
            drawHexOutline(gctx, p, size);
          }
        }

        const bright = !!UI.brightLabels;
        gctx.globalAlpha = bright ? 1 : GRID.labelAlpha;
        gctx.fillStyle = bright ? 'rgba(233,238,247,0.96)' : 'rgba(233,238,247,0.65)';
        const fontScale = Math.min(1.6, VIEW.zoom);
        const fontSize = Math.min(18, (bright ? 13 : 11) * fontScale);
        gctx.font = bright
          ? `900 ${fontSize}px ui-sans-serif, system-ui, -apple-system, Segoe UI, sans-serif`
          : `600 ${fontSize}px ui-sans-serif, system-ui, -apple-system, Segoe UI, sans-serif`;
        gctx.textAlign = 'center';
        gctx.textBaseline = 'middle';

        if (bright) {
          gctx.lineWidth = 3;
          gctx.strokeStyle = 'rgba(0,0,0,0.70)';
          gctx.lineJoin = 'round';
        }

        for (let dc = -colsR; dc <= colsR; dc++) {
          for (let dr = -rowsR; dr <= rowsR; dr++) {
            const col = camHex.col + dc;
            const row = camHex.row + dr;
            const p = worldToScreen(hexToWorld(col, row));
            if (p.x < -100 || p.x > w + 100 || p.y < -100 || p.y > h + 100) continue;
            const label = toHexLabel(col, row);
            const lx = p.x;
            const ly = p.y + 2;
            if (bright) gctx.strokeText(label, lx, ly);
            gctx.fillText(label, lx, ly);
          }
        }

        gctx.restore();
      }

      function drawHandle(gctx, center, size) {
        const r = size;
        gctx.beginPath();
        gctx.arc(center.x, center.y, r, 0, Math.PI * 2);
        gctx.stroke();
        gctx.beginPath();
        gctx.moveTo(center.x - r * 1.6, center.y);
        gctx.lineTo(center.x + r * 1.6, center.y);
        gctx.moveTo(center.x, center.y - r * 1.6);
        gctx.lineTo(center.x, center.y + r * 1.6);
        gctx.stroke();
      }

      function drawHandlesLayer(floor, gctx) {
        const show = UI.showHandles || UI.handleHot;
        if (!show || !floor) return;
        const objects = filterAlive(floor.objects || []);
        if (!objects.length) return;
        gctx.save();
        gctx.strokeStyle = 'rgba(255,145,0,0.9)';
        gctx.lineWidth = 1.5;
        const size = Math.max(4, Math.min(10, 6 * VIEW.zoom));
        for (const obj of objects) {
          const world = objectWorldCenter(obj);
          if (!world) continue;
          const center = worldToScreen(world);
          drawHandle(gctx, center, size);
        }
        gctx.restore();
      }

      function roomEdgeHandleWorlds(room) {
        if (!room || room.deleted) return null;
        if (isPolyRoom(room)) return null;
        const box = roomToWallBox(room);
        if (!box) return null;
        const cx = (box.center.x1 + box.center.x2) / 2;
        const cy = (box.center.y1 + box.center.y2) / 2;
        return {
          top: { x: cx, y: box.center.y1 },
          bottom: { x: cx, y: box.center.y2 },
          left: { x: box.center.x1, y: cy },
          right: { x: box.center.x2, y: cy },
          center: { x: cx, y: cy },
          rect: { x1: box.center.x1, y1: box.center.y1, x2: box.center.x2, y2: box.center.y2 }
        };
      }

      function getRectCornerData(room) {
        const labels = roomPointLabels(room);
        if (!labels || labels.length < 4) return null;
        const parsed = labels.map(l => ({ label: l, ...parseHexLabel(l) })).filter(p => Number.isFinite(p.col) && Number.isFinite(p.row));
        if (parsed.length < 4) return null;
        const cols = Array.from(new Set(parsed.map(p => p.col)));
        if (cols.length !== 2) return null;
        const leftCol = Math.min(...cols);
        const rightCol = Math.max(...cols);
        const leftPts = parsed.filter(p => p.col === leftCol);
        const rightPts = parsed.filter(p => p.col === rightCol);
        if (leftPts.length < 2 || rightPts.length < 2) return null;
        const topLeft = leftPts.reduce((a, b) => (a.row > b.row ? a : b));
        const botLeft = leftPts.reduce((a, b) => (a.row < b.row ? a : b));
        const topRight = rightPts.reduce((a, b) => (a.row > b.row ? a : b));
        const botRight = rightPts.reduce((a, b) => (a.row < b.row ? a : b));
        return { leftCol, rightCol, topLeft, botLeft, topRight, botRight };
      }

      function drawRoomEdgeHandles(floor, gctx) {
        const show = UI.showHandles || UI.handleHot;
        if (!show || !floor) return;
        const sel = EDITOR.selection;
        if (!sel || sel.type !== 'room' || !sel.item) return;
        if (String(sel.floorId) !== String(floor.id)) return;
        if (isPolyRoom(sel.item)) {
          const labels = roomPointLabels(sel.item);
          if (!Array.isArray(labels) || labels.length < 3) return;
          const pts = labels.map(parseHexLabel).filter(Boolean).map(hexToWorld);
          if (!pts.length) return;
          gctx.save();
          gctx.strokeStyle = 'rgba(255,145,0,0.95)';
          gctx.lineWidth = 1.6;
          const size = Math.max(5, Math.min(12, 7 * VIEW.zoom));
          for (const p of pts) {
            const sp = worldToScreen(p);
            drawHandle(gctx, sp, size);
          }
          gctx.restore();
          return;
        }
        const handles = roomEdgeHandleWorlds(sel.item);
        if (!handles) return;
        gctx.save();
        gctx.strokeStyle = 'rgba(255,145,0,0.95)';
        gctx.lineWidth = 1.6;
        const size = Math.max(5, Math.min(12, 7 * VIEW.zoom));
        const midTop = worldToScreen(handles.top);
        const midBot = worldToScreen(handles.bottom);
        const midLeft = worldToScreen(handles.left);
        const midRight = worldToScreen(handles.right);
        const midCenter = worldToScreen(handles.center);
        drawHandle(gctx, midTop, size);
        drawHandle(gctx, midBot, size);
        drawHandle(gctx, midLeft, size);
        drawHandle(gctx, midRight, size);
        drawHandle(gctx, midCenter, size);
        gctx.restore();
      }

      function getRoomHandleHit(room, screenPoint) {
        const handles = roomEdgeHandleWorlds(room);
        if (!handles) return null;
        const hitR = Math.max(8, Math.min(14, 9 * VIEW.zoom));
        const hitR2 = hitR * hitR;
        const hit = (p) => {
          const sp = worldToScreen(p);
          const dx = sp.x - screenPoint.x;
          const dy = sp.y - screenPoint.y;
          return dx * dx + dy * dy <= hitR2;
        };
        if (hit(handles.center)) return { type: 'room-move' };
        if (hit(handles.top)) return { type: 'room-edge', side: 'n' };
        if (hit(handles.bottom)) return { type: 'room-edge', side: 's' };
        if (hit(handles.left)) return { type: 'room-edge', side: 'w' };
        if (hit(handles.right)) return { type: 'room-edge', side: 'e' };
        return null;
      }

      function getPolyHandleHit(room, screenPoint) {
        if (!room || !isPolyRoom(room)) return null;
        const labels = roomPointLabels(room);
        if (!Array.isArray(labels) || labels.length < 3) return null;
        const pts = labels.map(parseHexLabel).filter(Boolean).map(hexToWorld);
        if (!pts.length) return null;
        const hitR = Math.max(8, Math.min(14, 9 * VIEW.zoom));
        const hitR2 = hitR * hitR;
        for (let i = 0; i < pts.length; i++) {
          const sp = worldToScreen(pts[i]);
          const dx = sp.x - screenPoint.x;
          const dy = sp.y - screenPoint.y;
          if (dx * dx + dy * dy <= hitR2) {
            return { type: 'poly-point', index: i };
          }
        }
        return null;
      }


      function drawRoomPreview(gctx) {
        if (EDITOR.tool !== 'room' || !EDITOR.roomStart || !EDITOR.roomHover) return;
        const start = EDITOR.roomStart.world ? EDITOR.roomStart.world : null;
        const end = EDITOR.roomHover.world ? EDITOR.roomHover.world : null;
        if (!start || !end) return;
        const wx1 = Math.min(start.x, end.x);
        const wx2 = Math.max(start.x, end.x);
        const wy1 = Math.min(start.y, end.y);
        const wy2 = Math.max(start.y, end.y);
        const p1 = worldToScreen({ x: wx1, y: wy1 });
        const p2 = worldToScreen({ x: wx2, y: wy2 });
        const sx1 = Math.min(p1.x, p2.x);
        const sy1 = Math.min(p1.y, p2.y);
        const sx2 = Math.max(p1.x, p2.x);
        const sy2 = Math.max(p1.y, p2.y);

        gctx.save();
        gctx.strokeStyle = 'rgba(88, 220, 120, 0.9)';
        gctx.lineWidth = 2;
        gctx.setLineDash([6, 6]);
        gctx.strokeRect(sx1, sy1, sx2 - sx1, sy2 - sy1);
        gctx.restore();
      }

      function drawPolyPreview(gctx) {
        if (EDITOR.tool !== 'poly' || !Array.isArray(EDITOR.polyPoints) || !EDITOR.polyPoints.length) return;
        const pts = EDITOR.polyPoints.map(p => p.world).filter(Boolean);
        if (!pts.length) return;
        const hover = EDITOR.polyHover && EDITOR.polyHover.world ? EDITOR.polyHover.world : null;
        gctx.save();
        gctx.strokeStyle = 'rgba(88, 220, 120, 0.9)';
        gctx.lineWidth = 2;
        gctx.setLineDash([6, 6]);
        gctx.beginPath();
        const first = worldToScreen(pts[0]);
        gctx.moveTo(first.x, first.y);
        for (let i = 1; i < pts.length; i++) {
          const p = worldToScreen(pts[i]);
          gctx.lineTo(p.x, p.y);
        }
        if (hover) {
          const ph = worldToScreen(hover);
          gctx.lineTo(ph.x, ph.y);
        }
        gctx.stroke();
        gctx.restore();
      }

      function roomCornersFromWorld(start, end) {
        const x1 = Math.min(start.x, end.x);
        const x2 = Math.max(start.x, end.x);
        const y1 = Math.min(start.y, end.y);
        const y2 = Math.max(start.y, end.y);
        const cornersWorld = [
          { x: x1, y: y1 },
          { x: x2, y: y1 },
          { x: x2, y: y2 },
          { x: x1, y: y2 }
        ];
        return cornersWorld.map((p) => {
          const hex = worldToHexHalf(p);
          return toHexLabel(hex.col, hex.row);
        });
      }

      function setPolyPoint(room, index, label) {
        if (!room) return;
        const points = Array.isArray(room.points) ? room.points
          : (Array.isArray(room.poly) ? room.poly : (Array.isArray(room.vertices) ? room.vertices : null));
        if (!Array.isArray(points) || index < 0 || index >= points.length) return;
        points[index] = label;
        if (Array.isArray(room.points)) room.points = points.slice();
        else if (Array.isArray(room.poly)) room.poly = points.slice();
        else if (Array.isArray(room.vertices)) room.vertices = points.slice();
        else room.points = points.slice();
      }

      function setRoomRectCorners(room, corners) {
        if (!room || !Array.isArray(corners) || corners.length !== 4) return;
        if (Array.isArray(room.points) && isRectPointList(room.points)) {
          room.points = corners.slice();
          return;
        }
        if (Array.isArray(room.corners)) {
          room.corners = corners.slice();
          return;
        }
        room.corners = corners.slice();
      }


      function clampZoom(value) {
        const min = zoomInput ? Number(zoomInput.min) : 0.25;
        const max = zoomInput ? Number(zoomInput.max) : 4;
        if (!Number.isFinite(min) || !Number.isFinite(max)) return value;
        return Math.max(min, Math.min(max, value));
      }

      function setZoom(value) {
        const next = clampZoom(value);
        VIEW.zoom = next;
        if (zoomInput) zoomInput.value = String(next);
        render();
      }

      function normalizeState(state) {
        if (!state || typeof state !== 'object') return { floors: [] };
        if (!Array.isArray(state.floors)) {
          const floorId = state.view && state.view.floorId ? String(state.view.floorId) : 'ground';
          state.floors = [{
            id: floorId,
            name: floorId,
            rooms: Array.isArray(state.rooms) ? state.rooms : [],
            openings: Array.isArray(state.openings) ? state.openings : [],
            objects: Array.isArray(state.objects) ? state.objects : []
          }];
        }
        for (const floor of state.floors) {
          if (!floor || typeof floor !== 'object') continue;
          floor.id = String(floor.id || 'floor');
          if (!Array.isArray(floor.rooms)) floor.rooms = [];
          if (!Array.isArray(floor.openings)) floor.openings = [];
          if (!Array.isArray(floor.objects)) floor.objects = [];
          for (const obj of floor.objects) {
            if (obj && obj.floorId == null) obj.floorId = floor.id;
          }
        }
        return state;
      }

      function extractScene(raw) {
        if (!raw || typeof raw !== 'object') return { scene: { floors: [] }, wrapper: null, recordId: '' };
        if (raw.records && typeof raw.records === 'object') {
          const activeId = raw.active && raw.active.recordId ? String(raw.active.recordId) : '';
          let recordId = activeId;
          let scene = recordId && raw.records[recordId] ? raw.records[recordId] : null;
          if (!scene) {
            const keys = Object.keys(raw.records);
            if (keys.length) {
              recordId = keys[0];
              scene = raw.records[recordId];
            }
          }
          if (!scene || typeof scene !== 'object') return { scene: { floors: [] }, wrapper: raw, recordId: recordId || '' };
          return { scene, wrapper: raw, recordId: recordId || '' };
        }
        return { scene: raw, wrapper: null, recordId: '' };
      }

      function applyViewFromState(scene) {
        const view = scene && scene.view ? scene.view : {};
        const floorId = view.floorId || view.floor_id || view.floor || null;
        if (floorId) VIEW.floorId = String(floorId);
        const camHex = view.camera_hex || view.cameraHex || null;
        if (camHex) {
          const p = parseHexLabel(camHex);
          if (p) setCameraFromHex(p);
        }
      }

      function resolveBattleId() {
        const qp = getQueryParams();
        return qp.get('battle_id') || qp.get('battleId') || qp.get('id');
      }

      async function loadBattle() {
        const battleId = resolveBattleId();
        if (!battleId) throw new Error('Missing battle_id');

        const isLocal = ['localhost', '127.0.0.1'].includes(window.location.hostname);
        const qp = getQueryParams();
        const devStateUrl = isLocal ? (qp.get('dev_state') || qp.get('state_url') || '') : '';
        if (devStateUrl) {
          const res = await fetch(devStateUrl, { cache: 'no-store' });
          if (!res.ok) throw new Error('Dev state load failed');
          const raw = await res.json();
          const extracted = extractScene(raw);
          STATE.wrapper = extracted.wrapper;
          STATE.recordId = extracted.recordId;
          STATE.battle = normalizeState(extracted.scene);
          applyViewFromState(STATE.battle);
          return;
        }

        const res = await fetch(`/api/battles/${encodeURIComponent(battleId)}`, {
          headers: { 'accept': 'application/json', ...getAuthHeaders() }
        });
        if (!res.ok) throw new Error('Battle load failed');
        const data = await res.json();
        const raw = data && data.state_json ? JSON.parse(data.state_json) : data;
        const extracted = extractScene(raw);
        STATE.wrapper = extracted.wrapper;
        STATE.recordId = extracted.recordId;
        STATE.battle = normalizeState(extracted.scene);
        applyViewFromState(STATE.battle);
        STATE.battle._battle_id = data.battle_id || battleId;
        STATE.battle._campaign_id = data.campaign_id || data.campaignId || null;
      }

      function getCampaignId() {
        return STATE.battle && (STATE.battle._campaign_id || STATE.battle.campaign_id || STATE.battle.campaignId) || null;
      }

      async function loadCampaign() {
        const cid = getCampaignId();
        if (!cid) return;
        const res = await fetch(`/api/campaigns/${encodeURIComponent(cid)}`, {
          headers: { 'accept': 'application/json', ...getAuthHeaders() }
        });
        if (!res.ok) return;
        const data = await res.json();
        let meta = data.meta_json || data.metaJson || null;
        if (typeof meta === 'string') {
          try { meta = JSON.parse(meta); } catch { meta = null; }
        }
        STATE.campaign = meta || {};
        STATE.entities = (STATE.campaign.world && Array.isArray(STATE.campaign.world.entities))
          ? STATE.campaign.world.entities
          : [];
      }

      function resolvePoiId() {
        const campaign = STATE.campaign || {};
        const index = campaign.poi_index || (campaign.world && campaign.world.poi_index) || null;
        const bid = STATE.battle && STATE.battle._battle_id;
        if (!index || !bid) return '';
        for (const [poi, battleId] of Object.entries(index)) {
          if (String(battleId) === String(bid)) return String(poi);
        }
        return '';
      }

      function buildTokens() {
        const poiId = resolvePoiId();
        const entities = Array.isArray(STATE.entities) ? STATE.entities : [];
        return entities
          .filter(e => e && !e.deleted && (!e.poi_id || e.poi_id === poiId))
          .map(e => {
            const loc = e.location || e.position || {};
            const hex = e.hex || loc.hex || '';
            const floorId = e.floorId || loc.floorId || loc.floor_id || e.floor_id || '';
            return {
              id: String(e.id || e.character_id || ''),
              characterId: e.character_id || e.characterId || '',
              name: e.name || e.label || e.title || e.id,
              hex,
              floorId,
              kind: e.kind || 'pc',
              sprite: e.sprite || (e.appearance && e.appearance.sprite) || '',
              hp: e.hp || (e.stats && e.stats.hp) || null,
              hp_max: e.hp_max || (e.stats && e.stats.hp_max) || null,
              init: e.init || (e.stats && e.stats.init) || null,
              side: e.side || (e.kind === 'npc' ? 'NPC' : 'PC'),
              hostility: e.hostility || (e.stats && e.stats.hostility) || '',
              conditions: e.conditions || (e.stats && e.stats.conditions) || null,
              __entity: e
            };
          });
      }

      function populateChatSpeakerSelect() {
        if (!chatSpeaker) return;
        const tokens = buildTokens();
        const names = [];
        for (const t of tokens) {
          const name = normStr(t.name || t.id);
          if (name && !names.includes(name)) names.push(name);
        }
        if (!names.includes('DM')) names.unshift('DM');
        if (!names.includes('Player')) names.push('Player');
        const active = document.activeElement === chatSpeaker;
        if (!active) {
          chatSpeaker.innerHTML = names.map(n => `<option value="${escapeHtml(n)}">${escapeHtml(n)}</option>`).join('');
        }
      }

      function renderStatus() {
        if (!statusBody || !statusMeta) return;
        const tokens = buildTokens();
        const turn = (STATE.battle && (STATE.battle.turn || STATE.battle.meta && STATE.battle.meta.turn)) || {};
        const round = turn.round ?? (STATE.battle && STATE.battle.meta && STATE.battle.meta.round);
        const activeId = turn.activeTokenId || turn.active_token_id || turn.activeToken || turn.active_token || '';
        const activeToken = tokens.find(t => String(t.id) === String(activeId) || String(t.characterId || '') === String(activeId));
        const activeName = activeToken ? activeToken.name : (turn.activeName || turn.active_name || '');

        statusMeta.innerHTML = [
          `<div class="statusPill">Round <strong>${round != null ? round : '–'}</strong></div>`,
          `<div class="statusPill">Active <strong>${activeName || '–'}</strong></div>`
        ].join('');

        const sorted = tokens.slice().sort((a, b) => {
          const ai = Number.isFinite(Number(a.init)) ? Number(a.init) : -9999;
          const bi = Number.isFinite(Number(b.init)) ? Number(b.init) : -9999;
          if (ai !== bi) return bi - ai;
          return String(a.name || a.id).localeCompare(String(b.name || b.id));
        });

        statusBody.innerHTML = sorted.map(t => {
          const isActive = activeId && (String(t.id) === String(activeId) || String(t.characterId || '') === String(activeId));
          const hostilityRaw = String((t.__entity && t.__entity.hostility) || t.hostility || '').toLowerCase();
          const isFriendly = String(t.kind || '').toLowerCase() === 'pc' || String(t.side || '').toUpperCase() === 'PC';
          const isHostile = hostilityRaw === 'hostile' || String(t.kind || '').toLowerCase() === 'monster';
          const hostility = isHostile ? 'hostile' : (isFriendly ? 'friendly' : 'neutral');
          const nameClass = `statusName status-${hostility}`;
          const markerClass = `statusTurnMarker${isActive ? '' : ' inactive'}`;
          const initText = Number.isFinite(Number(t.init)) ? String(t.init) : '–';
          const hpCur = Number.isFinite(Number(t.hp)) ? Number(t.hp) : null;
          const hpMax = Number.isFinite(Number(t.hp_max)) ? Number(t.hp_max) : null;
          const hpText = hpCur != null ? (hpMax != null ? `${hpCur}/${hpMax}` : String(hpCur)) : '–';
          const conditions = Array.isArray(t.conditions) ? t.conditions : (t.cond ? [t.cond] : []);
          const hasIntent = !!(t.__entity && (t.__entity.intent || t.__entity.intent_text || t.__entity.intentText));
          const intentClass = `statusIntent${hasIntent ? ' on' : ''}`;
          const condHtml = conditions.length ? conditions.map(c => `<span>${String(c)}</span>`).join(' ') : '';
          const intentHtml = `<span class="${intentClass}" title="Intent">${hasIntent ? '✓' : ''}</span>`;
          return `
            <tr class="statusRow${isActive ? ' active' : ''}">
              <td class="statusNameCell">
                <span class="${markerClass}" aria-hidden="true"></span>
                <span class="${nameClass}">${t.name || t.id}</span>
              </td>
              <td class="statusNum">${initText}</td>
              <td class="statusNum">${hpText}</td>
              <td><div class="statusCond">${condHtml}${intentHtml}</div></td>
            </tr>
          `;
        }).join('');
        populateChatSpeakerSelect();
      }

      function setFloorOptions() {
        floorSelect.innerHTML = '';
        const floors = STATE.battle ? STATE.battle.floors : [];
        floors.forEach(f => {
          const opt = document.createElement('option');
          opt.value = f.id;
          opt.textContent = f.name || f.id;
          floorSelect.appendChild(opt);
        });
        if (!VIEW.floorId && floors[0]) VIEW.floorId = floors[0].id;
        floorSelect.value = VIEW.floorId;
      }

      function pickFloor() {
        const floors = STATE.battle ? STATE.battle.floors : [];
        return floors.find(f => f.id === VIEW.floorId) || floors[0];
      }

      function autoCenterCamera() {
        if (!STATE.battle) return;
        const view = STATE.battle.view || {};
        if (view.camera_hex || view.cameraHex) return;
        const floor = pickFloor();
        if (!floor) return;
        let target = null;
        if (Array.isArray(floor.rooms) && floor.rooms.length) {
          const labels = roomPointLabels(floor.rooms[0]);
          const pts = labels.map(parseHexLabel).filter(Boolean);
          if (pts.length) {
            const avg = pts.reduce((acc, p) => ({ col: acc.col + p.col, row: acc.row + p.row }), { col: 0, row: 0 });
            target = { col: avg.col / pts.length, row: avg.row / pts.length };
          }
        }
        if (!target && Array.isArray(floor.objects) && floor.objects.length) {
          target = parseHexLabel(floor.objects[0].hex);
        }
        if (!target) {
          const tokens = buildTokens();
          if (tokens.length) target = parseHexLabel(tokens[0].hex);
        }
        if (target) setCameraFromHex({ col: Math.round(target.col), row: Math.round(target.row) });
      }

      function nudgeCamera(dxWorld, dyWorld) {
        const cam = getCameraWorld();
        const next = { x: cam.x + dxWorld, y: cam.y + dyWorld };
        setCameraWorld(next);
        render();
      }

      function chatStatusClass(status) {
        const raw = String(status || '').toLowerCase();
        if (raw === 'canceled') return 'canceled';
        if (raw === 'processed') return 'processed';
        if (raw === 'ack') return 'ack';
        return '';
      }

      function renderChat() {
        if (!chatLog) return;
        if (!CHAT.rows.length) {
          chatLog.innerHTML = '<div class="mini" style="opacity:0.7;">No chat yet.</div>';
          return;
        }
        chatLog.innerHTML = CHAT.rows.map(entry => {
          const speaker = normStr(entry.speaker || 'Player');
          const speakerKey = speaker.toLowerCase();
          const speakerClass = 'chatSpeaker' + (speakerKey === 'dm' ? ' dm' : '');
          const statusClass = chatStatusClass(entry.status);
          const text = escapeHtml(entry.text || '');
          return `<div class="chatEntry ${statusClass}">` +
            `<span class="${speakerClass}">${escapeHtml(speaker)}</span>` +
            `<span class="chatText">${text}</span>` +
          `</div>`;
        }).join('');
        chatLog.scrollTop = chatLog.scrollHeight;
      }

      function mergeChatRows(rows) {
        if (!Array.isArray(rows)) return;
        for (const entry of rows) {
          const id = entry.chat_id || entry.id || entry.chatId || entry.message_id || entry.messageId || null;
          if (!id) continue;
          if (CHAT.byId.has(id)) {
            const existing = CHAT.byId.get(id);
            Object.assign(existing, entry);
          } else {
            const row = { ...entry, chat_id: id };
            CHAT.byId.set(id, row);
            CHAT.rows.push(row);
          }
          const created = Number(entry.created_at || entry.createdAt || 0);
          if (Number.isFinite(created) && created > CHAT.lastTs) CHAT.lastTs = created;
        }
        CHAT.rows.sort((a, b) => (Number(a.created_at || 0) - Number(b.created_at || 0)));
      }

      async function fetchChat(sinceTs = null) {
        const cid = getCampaignId();
        if (!cid) return [];
        const qs = new URLSearchParams();
        qs.set('campaign_id', cid);
        if (sinceTs && Number.isFinite(Number(sinceTs))) qs.set('since_ts', String(Math.floor(sinceTs)));
        qs.set('limit', '200');
        const res = await fetch('/api/messages?' + qs.toString(), {
          headers: { 'accept': 'application/json', ...getAuthHeaders() }
        });
        if (!res.ok) throw new Error('Chat fetch failed');
        const data = await res.json();
        return Array.isArray(data && data.rows) ? data.rows : [];
      }

      async function pollChat() {
        try {
          const rows = await fetchChat(CHAT.lastTs || null);
          if (rows && rows.length) {
            mergeChatRows(rows);
            renderChat();
          }
        } catch (err) {
          console.warn('[Battlemat] chat fetch failed:', err);
        }
      }

      function startChatPolling() {
        if (CHAT.timer) clearInterval(CHAT.timer);
        CHAT.timer = setInterval(pollChat, 3000);
        pollChat();
      }

      async function sendChatMessage() {
        if (!chatInput) return;
        const text = normStr(chatInput.value);
        if (!text) return;
        const speaker = chatSpeaker ? normStr(chatSpeaker.value) || 'Player' : 'Player';
        const cid = getCampaignId();
        if (!cid) return;
        try {
          const res = await fetch('/api/messages', {
            method: 'POST',
            headers: {
              'content-type': 'application/json',
              ...getAuthHeaders()
            },
            body: JSON.stringify({
              campaign_id: cid,
              speaker,
              text,
              type: 'player',
              status: 'new'
            })
          });
          if (!res.ok) throw new Error('Chat send failed');
          chatInput.value = '';
          pollChat();
        } catch (err) {
          console.warn('[Battlemat] chat send failed:', err);
        }
      }

      function roomWallKind(room) {
        const wall = room && room.wall && typeof room.wall === 'object' ? room.wall : null;
        const kind = wall && wall.kind != null ? String(wall.kind) : '';
        const type = wall && wall.type != null ? String(wall.type) : '';
        return (kind || type || 'brick').toLowerCase();
      }

      function roomHasWalls(room) {
        const thickness = Number(room && room.thickness != null ? room.thickness : 0);
        return thickness > 0 && roomWallKind(room) !== 'none';
      }

      function parseEraseSides(room) {
        const raw = String(room && (room.wall_erase || room.wallErase || room.erase || '') || '');
        const out = new Set();
        for (const ch of raw.toUpperCase()) {
          if ('NSEW'.includes(ch)) out.add(ch);
        }
        return out;
      }

      function roomPointLabels(room) {
        if (!room || typeof room !== 'object') return [];
        const points = Array.isArray(room.points) ? room.points
          : (Array.isArray(room.poly) ? room.poly : (Array.isArray(room.vertices) ? room.vertices : null));
        if (Array.isArray(points) && points.length >= 3) return points;
        const corners = Array.isArray(room.corners) ? room.corners : [];
        return corners.length >= 3 ? corners : [];
      }

      function getRectPointStats(points) {
        if (!Array.isArray(points) || points.length < 4) return null;
        const parsed = points.map(parseHexLabel).filter(Boolean);
        if (parsed.length < 4) return null;
        const cols = Array.from(new Set(parsed.map(p => p.col)));
        const rows = Array.from(new Set(parsed.map(p => p.row)));
        if (cols.length !== 2 || rows.length !== 2) return null;
        return {
          cols: cols.sort((a, b) => a - b),
          rows: rows.sort((a, b) => a - b),
        };
      }

      function isRectPointList(points) {
        return !!getRectPointStats(points);
      }

      function isPolyRoom(room) {
        if (!room || typeof room !== 'object') return false;
        if (room.shape === 'poly' || room.isPoly === true) return true;
        if (Array.isArray(room.points) && room.points.length >= 3) return true;
        if (Array.isArray(room.poly) && room.poly.length >= 3) return true;
        if (Array.isArray(room.vertices) && room.vertices.length >= 3) return true;
        const points = Array.isArray(room.points) ? room.points
          : (Array.isArray(room.poly) ? room.poly : (Array.isArray(room.vertices) ? room.vertices : null));
        if (!Array.isArray(points) || points.length < 3) return false;
        if (!Array.isArray(room.corners) || room.corners.length < 3) return true;
        return !isRectPointList(points);
      }

      function roomWorldPoints(room) {
        const labels = roomPointLabels(room);
        if (!labels.length) return [];
        const pts = [];
        for (const label of labels) {
          const parsed = parseHexLabel(label);
          if (!parsed) continue;
          pts.push(hexToWorld(parsed.col, parsed.row));
        }
        return pts;
      }

      function roomPolygonScreen(room) {
        const pts = roomWorldPoints(room);
        if (pts.length < 3) return null;
        return pts.map(worldToScreen);
      }

      function roomToWallBox(room) {
        if (isPolyRoom(room)) return null;
        let corners = Array.isArray(room && room.corners) ? room.corners : [];
        if (corners.length !== 4) {
          const points = roomPointLabels(room);
          const stats = getRectPointStats(points);
          if (!stats) return null;
          const [c0, c1] = stats.cols;
          const [r0, r1] = stats.rows;
          const minRow = Math.min(r0, r1);
          const maxRow = Math.max(r0, r1);
          const minCol = Math.min(c0, c1);
          const maxCol = Math.max(c0, c1);
          corners = [
            toHexLabel(minCol, maxRow),
            toHexLabel(maxCol, maxRow),
            toHexLabel(maxCol, minRow),
            toHexLabel(minCol, minRow),
          ];
        }
        const tl = parseHexLabel(corners[0]);
        const tr = parseHexLabel(corners[1]);
        const br = parseHexLabel(corners[2]);
        const bl = parseHexLabel(corners[3]);
        if (!tl || !tr || !br || !bl) return null;

        const pTL = hexToWorld(tl.col, tl.row);
        const pTR = hexToWorld(tr.col, tr.row);
        const pBR = hexToWorld(br.col, br.row);
        const pBL = hexToWorld(bl.col, bl.row);

        const xL = (pTL.x + pBL.x) / 2;
        const xR = (pTR.x + pBR.x) / 2;
        const yTop = (pTL.y + pTR.y) / 2;
        const yBot = (pBL.y + pBR.y) / 2;

        const thicknessBase = Number(room && room.thickness != null ? room.thickness : 0);
        const t = roomHasWalls(room) ? thicknessBase : 0;
        const half = t / 2;

        // Treat corners as the wall centerline. Expand outward for wall band.
        const center = { x1: xL, y1: yTop, x2: xR, y2: yBot };
        const outer = { x1: xL - half, y1: yTop - half, x2: xR + half, y2: yBot + half };
        const inner = { x1: xL + half, y1: yTop + half, x2: xR - half, y2: yBot - half };

        return { xL, xR, yTop, yBot, thickness: t, center, outer, inner };
      }

      function roomFloorRectWorld(room, box) {
        if (!box) return null;
        const src = roomHasWalls(room) ? box.inner : box.center;
        return { x1: src.x1, y1: src.y1, x2: src.x2, y2: src.y2 };
      }

      function formatRoomPoints(room) {
        const labels = roomPointLabels(room);
        return labels.map(l => String(l).trim()).filter(Boolean).join(', ');
      }

      function cloneValue(value) {
        if (typeof structuredClone === 'function') return structuredClone(value);
        return JSON.parse(JSON.stringify(value));
      }

      function snapshotState() {
        return {
          battle: cloneValue(STATE.battle),
          entities: cloneValue(STATE.entities)
        };
      }

      function restoreState(snapshot) {
        if (!snapshot) return;
        STATE.battle = snapshot.battle ? cloneValue(snapshot.battle) : STATE.battle;
        STATE.entities = snapshot.entities ? cloneValue(snapshot.entities) : STATE.entities;
        setFloorOptions();
        renderStatus();
        render();
      }

      function pushHistory() {
        const snap = snapshotState();
        if (HISTORY.index < HISTORY.stack.length - 1) {
          HISTORY.stack = HISTORY.stack.slice(0, HISTORY.index + 1);
        }
        HISTORY.stack.push(snap);
        if (HISTORY.stack.length > HISTORY.limit) {
          HISTORY.stack.shift();
        }
        HISTORY.index = HISTORY.stack.length - 1;
        updateUndoButton();
      }

      function canUndo() {
        return HISTORY.index > 0;
      }

      function undo() {
        if (!canUndo()) return;
        HISTORY.index -= 1;
        restoreState(HISTORY.stack[HISTORY.index]);
        if (saveStatus) saveStatus.textContent = 'DB: idle';
        updateUndoButton();
      }

      function updateUndoButton() {
        if (undoButton) undoButton.disabled = !canUndo();
      }

      function parsePointList(text) {
        const raw = String(text || '')
          .split(',')
          .map(t => t.trim())
          .filter(Boolean);
        const out = [];
        for (const entry of raw) {
          const parsed = parseHexLabel(entry);
          if (!parsed) continue;
          out.push(entry.toUpperCase());
        }
        return out;
      }

      function buildWallSegments(rooms) {
        const segs = [];
        for (const room of filterAlive(rooms)) {
          const box = roomToWallBox(room);
          if (!box) continue;
          const t = Number.isFinite(box.thickness) ? box.thickness : 0;
          segs.push({ orientation: 'h', y: box.yTop, x1: box.xL, x2: box.xR, thickness: t });
          segs.push({ orientation: 'h', y: box.yBot, x1: box.xL, x2: box.xR, thickness: t });
          segs.push({ orientation: 'v', x: box.xL, y1: box.yTop, y2: box.yBot, thickness: t });
          segs.push({ orientation: 'v', x: box.xR, y1: box.yTop, y2: box.yBot, thickness: t });
        }
        return segs;
      }

      function wallSegDistance2(seg, p) {
        if (!seg || !p) return Infinity;
        if (seg.orientation === 'h') {
          const dy = Math.abs(p.y - seg.y);
          let dx = 0;
          if (p.x < seg.x1) dx = seg.x1 - p.x;
          else if (p.x > seg.x2) dx = p.x - seg.x2;
          return dx * dx + dy * dy;
        }
        const dx = Math.abs(p.x - seg.x);
        let dy = 0;
        if (p.y < seg.y1) dy = seg.y1 - p.y;
        else if (p.y > seg.y2) dy = p.y - seg.y2;
        return dx * dx + dy * dy;
      }

      function projectToWall(seg, p) {
        if (!seg || !p) return null;
        if (seg.orientation === 'h') {
          const x = Math.min(seg.x2, Math.max(seg.x1, p.x));
          return { x, y: seg.y };
        }
        const y = Math.min(seg.y2, Math.max(seg.y1, p.y));
        return { x: seg.x, y };
      }

      function snapWorldToWall(worldPoint, floor, orientation) {
        const want = orientation === 'v' ? 'v' : 'h';
        const segs = buildWallSegments(floor ? floor.rooms : []);
        let best = null;
        let bestD2 = Infinity;
        for (const seg of segs) {
          if (!seg || seg.orientation !== want) continue;
          const d2 = wallSegDistance2(seg, worldPoint);
          if (d2 < bestD2) {
            bestD2 = d2;
            best = seg;
          }
        }
        if (!best) return worldPoint;
        return projectToWall(best, worldPoint) || worldPoint;
      }

      function roomRectScreen(room) {
        const box = roomToWallBox(room);
        if (!box) return null;
        const rect = roomFloorRectWorld(room, box);
        if (!rect) return null;
        const p1 = worldToScreen({ x: rect.x1, y: rect.y1 });
        const p2 = worldToScreen({ x: rect.x2, y: rect.y2 });
        return {
          x1: Math.min(p1.x, p2.x),
          y1: Math.min(p1.y, p2.y),
          x2: Math.max(p1.x, p2.x),
          y2: Math.max(p1.y, p2.y),
          box
        };
      }

      function openingAllowsCutout(opening) {
        const flag = opening && (opening.cutout ?? opening.cutoutMode ?? opening.cutout_mode);
        if (flag === false) return false;
        if (flag == null) return true;
        const val = String(flag).toLowerCase();
        return val !== 'none' && val !== 'off' && val !== 'false';
      }

      function roomOuterRectWorld(room, box) {
        if (!box) return null;
        const src = roomHasWalls(room) ? (box.outer || box.center) : box.center;
        return { x1: src.x1, y1: src.y1, x2: src.x2, y2: src.y2 };
      }

      function drawFloorRoom(room, gctx) {
        if (isPolyRoom(room)) {
          const pts = roomWorldPoints(room);
          if (pts.length < 3) return;
          const screenPts = pts.map(worldToScreen);
          const fk = room.floor && room.floor.kind ? String(room.floor.kind) : 'default';
          const floorColor = FLOOR_COLORS[fk] || FLOOR_COLORS.default;
          const floorAnchor = pts[0];
          const floorRot = room.floor && (room.floor.rot ?? room.floor.rotDeg);
          const fill = getFillStyle(gctx, 'floor', fk, floorColor, floorAnchor, { allowFallback: false, rotDeg: floorRot });
          if (!fill) return;
          gctx.save();
          gctx.fillStyle = fill;
          gctx.beginPath();
          gctx.moveTo(screenPts[0].x, screenPts[0].y);
          for (let i = 1; i < screenPts.length; i++) gctx.lineTo(screenPts[i].x, screenPts[i].y);
          gctx.closePath();
          gctx.fill();
          gctx.restore();
          return;
        }
        const box = roomToWallBox(room);
        if (!box) return;
        const rect = FLOOR_UNDER_WALLS
          ? roomOuterRectWorld(room, box)
          : (box.center || roomFloorRectWorld(room, box));
        if (!rect) return;
        const p1 = worldToScreen({ x: rect.x1, y: rect.y1 });
        const p2 = worldToScreen({ x: rect.x2, y: rect.y2 });
        const x1 = Math.min(p1.x, p2.x);
        const y1 = Math.min(p1.y, p2.y);
        const x2 = Math.max(p1.x, p2.x);
        const y2 = Math.max(p1.y, p2.y);

        const fk = room.floor && room.floor.kind ? String(room.floor.kind) : 'default';
        const floorColor = FLOOR_COLORS[fk] || FLOOR_COLORS.default;
        const floorAnchor = { x: rect.x1, y: rect.y1 };
        const floorRot = room.floor && (room.floor.rot ?? room.floor.rotDeg);
        const fill = getFillStyle(gctx, 'floor', fk, floorColor, floorAnchor, { allowFallback: false, rotDeg: floorRot });
        if (!fill) return;
        gctx.fillStyle = fill;
        gctx.globalAlpha = 1;
        gctx.fillRect(x1, y1, x2 - x1, y2 - y1);
      }

      function drawFloorsLayer(floor, gctx, rooms) {
        const list = sortByZ(rooms || filterAlive(floor.rooms || []));
        list.forEach(room => drawFloorRoom(room, gctx));
      }

      function wallThicknessAtWorld(worldPoint, floor) {
        const segs = buildWallSegments(floor ? floor.rooms : []);
        let best = null;
        let bestD2 = Infinity;
        for (const seg of segs) {
          const d2 = wallSegDistance2(seg, worldPoint);
          if (d2 < bestD2) {
            bestD2 = d2;
            best = seg;
          }
        }
        return best && Number.isFinite(best.thickness) ? best.thickness : 0;
      }

      function openingCutoutRectsForFloor(floor, rooms, roomSets) {
        if (!floor || !Array.isArray(floor.openings)) return [];
        const out = [];
        for (const opening of filterAlive(floor.openings)) {
          if (!openingAllowsCutout(opening)) continue;
          if (roomSets && rooms) {
            const state = itemFogState(opening, floor, rooms, roomSets, openingWorldCenter);
            if (state === 'hidden') continue;
          }
          const world = openingWorldCenter(opening, floor);
          if (!world) continue;
          const orient = opening.orientation === 'v' ? 'v' : 'h';
          const kindRaw = String(opening.kind || '').toLowerCase();
          const kind =
            kindRaw.startsWith('window') ? 'window' :
            kindRaw.startsWith('portal') ? 'portal' :
            kindRaw.startsWith('threshold') ? 'threshold' : 'door';
          const style = OPENING_STYLE[kind] || OPENING_STYLE.door;
          const lenUnits = Number.isFinite(Number(opening.len ?? opening.length ?? opening.size))
            ? Number(opening.len ?? opening.length ?? opening.size)
            : style.len;
          const thickUnits = Number.isFinite(Number(opening.thick ?? opening.thickness))
            ? Number(opening.thick ?? opening.thickness)
            : style.thick;
          const len = GRID.size * lenUnits * VIEW.zoom;
          const thick = GRID.size * thickUnits * VIEW.zoom;
          const wallThickWorld = wallThicknessAtWorld(world, floor);
          const baseWallWorld = wallThickWorld > 0 ? wallThickWorld : (GRID.size * thickUnits);
          const center = worldToScreen(world);
          const cutLen = len * 1.1;
          const cutThick = baseWallWorld * VIEW.zoom * 1.1;
          const w = orient === 'v' ? cutThick : cutLen;
          const h = orient === 'v' ? cutLen : cutThick;
          out.push({ center, w, h });
        }
        return out;
      }

      function drawWallsLayer(floor, gctx, rooms, roomSets) {
        const list = sortByZ(rooms || filterAlive(floor.rooms || []));
        for (const room of list) {
          if (isPolyRoom(room)) {
            if (!roomHasWalls(room)) continue;
            const pts = roomWorldPoints(room);
            if (pts.length < 3) continue;
            const screenPts = pts.map(worldToScreen);
            const wk = roomWallKind(room);
            const wallColor = WALL_COLORS[wk] || WALL_COLORS.default;
            const wallAnchor = pts[0];
            const fill = getFillStyle(gctx, 'wall', wk, wallColor, wallAnchor, { allowFallback: false });
            if (!fill) continue;
            const thickness = Number(room.thickness || 0);
            const lineW = Math.max(1, thickness * VIEW.zoom);
            gctx.save();
            gctx.strokeStyle = fill;
            gctx.lineWidth = lineW;
            gctx.lineJoin = 'miter';
            gctx.beginPath();
            gctx.moveTo(screenPts[0].x, screenPts[0].y);
            for (let i = 1; i < screenPts.length; i++) gctx.lineTo(screenPts[i].x, screenPts[i].y);
            gctx.closePath();
            gctx.stroke();
            gctx.restore();
            continue;
          }
          const box = roomToWallBox(room);
          if (!box || !roomHasWalls(room)) continue;
          const outer = box.outer || box.center;
          const inner = box.inner || box.center;
          const o1 = worldToScreen({ x: outer.x1, y: outer.y1 });
          const o2 = worldToScreen({ x: outer.x2, y: outer.y2 });
          const i1 = worldToScreen({ x: inner.x1, y: inner.y1 });
          const i2 = worldToScreen({ x: inner.x2, y: inner.y2 });
          const ox1 = Math.min(o1.x, o2.x);
          const oy1 = Math.min(o1.y, o2.y);
          const ow = Math.abs(o2.x - o1.x);
          const oh = Math.abs(o2.y - o1.y);
          const ix1 = Math.min(i1.x, i2.x);
          const iy1 = Math.min(i1.y, i2.y);
          const iw = Math.abs(i2.x - i1.x);
          const ih = Math.abs(i2.y - i1.y);
          const wk = roomWallKind(room);
          const wallColor = WALL_COLORS[wk] || WALL_COLORS.default;
          const wallAnchor = { x: outer.x1, y: outer.y1 };
          const fill = getFillStyle(gctx, 'wall', wk, wallColor, wallAnchor, { allowFallback: false });
          if (!fill) continue;
          gctx.fillStyle = fill;
          gctx.beginPath();
          gctx.rect(ox1, oy1, ow, oh);
          gctx.rect(ix1, iy1, iw, ih);
          gctx.fill('evenodd');

          const erase = parseEraseSides(room);
          if (erase.size) {
            gctx.save();
            gctx.globalCompositeOperation = 'destination-out';
            const bleed = 2 * VIEW.zoom;
            const topH = Math.max(0, iy1 - oy1);
            const botH = Math.max(0, (oy1 + oh) - (iy1 + ih));
            const leftW = Math.max(0, ix1 - ox1);
            const rightW = Math.max(0, (ox1 + ow) - (ix1 + iw));
            const innerX = ox1 + leftW;
            const innerW = ow - leftW - rightW;
            if (erase.has('N') && topH > 0) {
              gctx.fillRect(innerX - bleed, oy1 - bleed, innerW + bleed * 2, topH + bleed * 2);
            }
            if (erase.has('S') && botH > 0) {
              gctx.fillRect(innerX - bleed, iy1 + ih - bleed, innerW + bleed * 2, botH + bleed * 2);
            }
            if (erase.has('W') && leftW > 0) {
              gctx.fillRect(ox1 - bleed, oy1 + topH, leftW + bleed, oh - topH - botH);
            }
            if (erase.has('E') && rightW > 0) {
              gctx.fillRect(ix1 + iw - bleed, oy1 + topH, rightW + bleed, oh - topH - botH);
            }
            gctx.restore();
          }
        }

        const cutouts = openingCutoutRectsForFloor(floor, rooms || filterAlive(floor.rooms || []), roomSets);
        if (cutouts.length) {
          gctx.save();
          gctx.globalCompositeOperation = 'destination-out';
          for (const cut of cutouts) {
            gctx.fillRect(cut.center.x - cut.w / 2, cut.center.y - cut.h / 2, cut.w, cut.h);
          }
          gctx.restore();
        }
      }

      function roomAnchorWorld(room) {
        const box = roomToWallBox(room);
        if (!box) return null;
        const src = roomHasWalls(room) ? box.inner : box.center;
        return { x: src.x1, y: src.y1 };
      }

      function roomCenterWorld(room) {
        const box = roomToWallBox(room);
        if (!box) return null;
        const src = roomHasWalls(room) ? box.inner : box.center;
        return { x: (src.x1 + src.x2) / 2, y: (src.y1 + src.y2) / 2 };
      }


      function openingWorldCenter(opening, floor) {
        const p = parseHexLabel(opening.hex);
        if (!p) return null;
        const world = hexToWorld(p.col, p.row);
        const orient = opening && opening.orientation === 'v' ? 'v' : 'h';
        return snapWorldToWall(world, floor, orient);
      }

      function openingFogState(opening, floor, rooms, roomSets) {
        if (!UI.fogEnabled) return 'visible';
        const world = openingWorldCenter(opening, floor);
        if (!world) return 'visible';
        const orient = opening && opening.orientation === 'v' ? 'v' : 'h';
        const offset = GRID.size * 0.35;
        const dx = orient === 'v' ? offset : 0;
        const dy = orient === 'v' ? 0 : offset;
        const a = { x: world.x + dx, y: world.y + dy };
        const b = { x: world.x - dx, y: world.y - dy };
        const roomA = findRoomForWorldPoint(rooms, a);
        const roomB = findRoomForWorldPoint(rooms, b);
        const stateForRoom = (room) => {
          if (!room || room.id == null) return 'visible';
          const id = String(room.id);
          if (roomSets.visible && roomSets.visible.has(id)) return 'visible';
          if (roomSets.explored && roomSets.explored.has(id)) return 'explored';
          if (roomSets.hidden && roomSets.hidden.has(id)) return 'hidden';
          return 'visible';
        };
        const sA = stateForRoom(roomA);
        const sB = stateForRoom(roomB);
        if (sA === 'visible' || sB === 'visible') return 'visible';
        if (sA === 'explored' || sB === 'explored') return 'explored';
        return 'hidden';
      }

      function drawOpening(opening, floor, gctx, fogState) {
        const world = openingWorldCenter(opening, floor);
        if (!world) return;
        const center = worldToScreen(world);
        const orient = opening.orientation === 'v' ? 'v' : 'h';
        const kindRaw = String(opening.kind || '').toLowerCase();
        const kind =
          kindRaw.startsWith('window') ? 'window' :
          kindRaw.startsWith('portal') ? 'portal' :
          kindRaw.startsWith('threshold') ? 'threshold' : 'door';
        if (UI.fogEnabled && kind === 'threshold') return;
        const style = OPENING_STYLE[kind] || OPENING_STYLE.door;
        const spriteUrl = resolveOpeningSprite(kindRaw, opening.openPct || 0);
        const lenUnits = Number.isFinite(Number(opening.len ?? opening.length ?? opening.size))
          ? Number(opening.len ?? opening.length ?? opening.size)
          : style.len;
        const thickUnits = Number.isFinite(Number(opening.thick ?? opening.thickness))
          ? Number(opening.thick ?? opening.thickness)
          : style.thick;
        const len = GRID.size * lenUnits * VIEW.zoom;
        const thick = GRID.size * thickUnits * VIEW.zoom;
        const hingeRaw = (opening.hinge || 'left').toLowerCase();
        const hinge = orient === 'v'
          ? (hingeRaw === 'bottom' ? 'right' : 'left')
          : (hingeRaw === 'right' ? 'right' : 'left');
        let swingDir = Number.isFinite(Number(opening.swing)) ? Number(opening.swing) : 1;
        if (swingDir === 0) swingDir = -1;
        const openPct = Math.max(0, Math.min(1, Number(opening.openPct ?? opening.open ?? 0)));
        const swingAngle = openPct * (Math.PI / 2) * (swingDir === 0 ? 1 : swingDir);
        const baseRot = orient === 'v' ? Math.PI / 2 : 0;
        const pivotX = hinge === 'right' ? len / 2 : -len / 2;
        if (spriteUrl) {
          const img = loadSprite(spriteUrl);
          if (img && img.complete && img.naturalWidth && img.naturalHeight) {
            gctx.save();
            if (fogState === 'explored') gctx.globalAlpha *= 0.6;
            gctx.translate(center.x, center.y);
            if (baseRot) gctx.rotate(baseRot);
            gctx.translate(pivotX, 0);
            if (swingAngle) gctx.rotate(swingAngle);
            gctx.translate(-pivotX, 0);
            gctx.drawImage(img, -len / 2, -thick / 2, len, thick);
            gctx.restore();
            return;
          }
          if (img && img.__bmStatus !== 'error') return;
        }
        gctx.save();
        if (fogState === 'explored') gctx.globalAlpha *= 0.6;
        gctx.translate(center.x, center.y);
        if (baseRot) gctx.rotate(baseRot);
        gctx.translate(pivotX, 0);
        if (swingAngle) gctx.rotate(swingAngle);
        gctx.translate(-pivotX, 0);
        gctx.fillStyle = style.color;
        gctx.fillRect(-len / 2, -thick / 2, len, thick);
        gctx.restore();
      }

      function objectWorldCenter(obj) {
        if (!obj) return null;
        const p = parseHexLabel(obj.hex);
        if (!p) return null;
        const base = hexToWorld(p.col, p.row);
        const ox = Number(obj.ox);
        const oy = Number(obj.oy);
        return {
          x: base.x + (Number.isFinite(ox) ? ox : 0) * GRID.size,
          y: base.y + (Number.isFinite(oy) ? oy : 0) * GRID.size,
        };
      }

      const spriteCache = new Map();
      function loadSprite(url) {
        if (!url) return null;
        if (spriteCache.has(url)) return spriteCache.get(url);
        const img = new Image();
        img.__bmStatus = 'loading';
        img.src = url;
        img.onload = () => {
          img.__bmStatus = 'ready';
          render();
        };
        img.onerror = () => {
          img.__bmStatus = 'error';
          render();
        };
        spriteCache.set(url, img);
        return img;
      }

      const LAYER_CANVASES = new Map();
      function getLayerContext(name, rect, dpr) {
        let layer = LAYER_CANVASES.get(name);
        if (!layer) {
          const canvas = document.createElement('canvas');
          const gctx = canvas.getContext('2d');
          layer = { canvas, ctx: gctx };
          LAYER_CANVASES.set(name, layer);
        }
        layer.canvas.width = rect.width * dpr;
        layer.canvas.height = rect.height * dpr;
        layer.ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        layer.ctx.clearRect(0, 0, rect.width, rect.height);
        return layer;
      }

      const PATTERN_CACHE = new WeakMap();

      function getPatternCache(gctx) {
        const cache = PATTERN_CACHE.get(gctx);
        if (cache) return cache;
        const created = new Map();
        PATTERN_CACHE.set(gctx, created);
        return created;
      }

      function resolveTextureDef(category, kind) {
        const cat = String(category || '').toLowerCase();
        const k0 = String(kind || '').toLowerCase();
        if (!cat || !k0) return null;
        if (k0 === 'fog' || k0 === 'none') return null;

        const aliases = TEXTURE_ALIASES[cat] || {};
        const key = (k0 in TEXTURE_FILES) ? k0 : (aliases[k0] || '');
        if (!key || !(key in TEXTURE_FILES)) return null;

        const scale = (TEXTURE_SCALES[cat] && Number.isFinite(Number(TEXTURE_SCALES[cat][key])))
          ? Number(TEXTURE_SCALES[cat][key])
          : 1;
        return { url: TEXTURE_FILES[key], scale };
      }

      function getTexturePattern(gctx, category, kind) {
        const def = resolveTextureDef(category, kind);
        if (!def) return null;
        const cache = getPatternCache(gctx);
        const cached = cache.get(def.url);
        if (cached && cached.pattern) return { pattern: cached.pattern, scale: def.scale };

        const img = loadSprite(def.url);
        if (!img || !img.complete) {
          if (img && !img.__patternHooked) {
            img.__patternHooked = true;
            img.onload = () => {
              img.__patternHooked = false;
              cache.delete(def.url);
              render();
            };
          }
          return null;
        }

        const pattern = gctx.createPattern(img, 'repeat');
        if (!pattern) return null;
        cache.set(def.url, { pattern });
        return { pattern, scale: def.scale };
      }

      function applyPatternTransform(pattern, scale, anchorWorld, rotDeg) {
        if (!pattern || typeof pattern.setTransform !== 'function') return;
        const cam = getCameraWorld();
        const rect = canvas.getBoundingClientRect();
        const anchor = anchorWorld || { x: 0, y: 0 };
        const originX = rect.width / 2 + (anchor.x - cam.x) * VIEW.zoom;
        const originY = rect.height / 2 + (anchor.y - cam.y) * VIEW.zoom;
        const s = (Number(scale) || 1) * VIEW.zoom;
        const m = new DOMMatrix();
        m.translateSelf(originX, originY);
        if (Number.isFinite(Number(rotDeg)) && Number(rotDeg) !== 0) {
          m.rotateSelf(Number(rotDeg));
        }
        m.scaleSelf(s, s);
        pattern.setTransform(m);
      }

      function getFillStyle(gctx, category, kind, fallback, anchorWorld, opts = {}) {
        const def = resolveTextureDef(category, kind);
        if (def) {
          const tex = getTexturePattern(gctx, category, kind);
          if (tex && tex.pattern) {
            applyPatternTransform(tex.pattern, tex.scale, anchorWorld, opts.rotDeg);
            return tex.pattern;
          }
          if (opts.allowFallback === false) return null;
        }
        return fallback;
      }

      function drawObject(obj, zIndex, gctx) {
        const world = objectWorldCenter(obj);
        if (!world) return;
        const center = worldToScreen(world);
        const url = obj.sprite || obj.spriteFile || resolveSpriteUrl(obj.kind);
        const scale = Number.isFinite(Number(obj.spriteScale)) ? Number(obj.spriteScale) : 1;
        const scaleX = Number.isFinite(Number(obj.spriteScaleX)) ? Number(obj.spriteScaleX) : scale;
        const scaleY = Number.isFinite(Number(obj.spriteScaleY)) ? Number(obj.spriteScaleY) : scale;
        const base = GRID.size * 1.15;
        let sizeW = base * scaleX * VIEW.zoom;
        let sizeH = base * scaleY * VIEW.zoom;
        const rotDeg = Number.isFinite(Number(obj.rotDeg)) ? Number(obj.rotDeg) : 0;
        const rot = rotDeg * Math.PI / 180;

        if (url) {
          const img = loadSprite(url);
          if (img && img.complete && img.naturalWidth && img.naturalHeight) {
            const ratio = img.naturalHeight / img.naturalWidth;
            sizeW = base * scaleX * VIEW.zoom;
            sizeH = base * ratio * scaleY * VIEW.zoom;
            gctx.save();
            gctx.translate(center.x, center.y);
            if (rot) gctx.rotate(rot);
            gctx.drawImage(img, -sizeW / 2, -sizeH / 2, sizeW, sizeH);
            gctx.restore();
            return;
          }
          if (img && img.__bmStatus !== 'error') {
            return;
          }
        }

        gctx.save();
        gctx.translate(center.x, center.y);
        if (rot) gctx.rotate(rot);
        gctx.fillStyle = '#2b2f3a';
        gctx.fillRect(-sizeW / 2, -sizeH / 2, sizeW, sizeH);
        gctx.strokeStyle = '#4a5568';
        gctx.strokeRect(-sizeW / 2, -sizeH / 2, sizeW, sizeH);
        gctx.fillStyle = '#cfd6df';
        gctx.font = `${10 * VIEW.zoom}px sans-serif`;
        gctx.textAlign = 'center';
        gctx.textBaseline = 'middle';
        const baseLabel = obj.name || obj.kind || 'obj';
        const displayZ = obj.z != null ? obj.z : (Number.isFinite(zIndex) ? zIndex : null);
        const label = displayZ != null ? `${baseLabel} (${displayZ})` : baseLabel;
        gctx.fillText(label, 0, 0);
        gctx.restore();
      }

      function drawToken(token, gctx) {
        const p = parseHexLabel(token.hex);
        if (!p) return;
        const center = worldToScreen(hexToWorld(p.col, p.row));
        const url = token.sprite || token.spriteFile || resolveSpriteUrl(token.kind) ||
          resolveSpriteUrl(token.side === 'NPC' ? 'token.npc' : 'token.pc');
        const base = GRID.size * 0.9;
        if (url) {
          const img = loadSprite(url);
          if (img && img.complete && img.naturalWidth && img.naturalHeight) {
            const ratio = img.naturalHeight / img.naturalWidth;
            const sizeW = base * VIEW.zoom;
            const sizeH = base * ratio * VIEW.zoom;
            gctx.drawImage(img, center.x - sizeW / 2, center.y - sizeH / 2, sizeW, sizeH);
            return;
          }
          if (img && img.__bmStatus !== 'error') return;
        }
        const r = GRID.size * 0.35 * VIEW.zoom;
        gctx.fillStyle = token.side === 'NPC' ? '#c95c5c' : '#5ca9c9';
        gctx.beginPath();
        gctx.arc(center.x, center.y, r, 0, Math.PI * 2);
        gctx.fill();
        gctx.fillStyle = '#0b0f14';
        gctx.font = `${11 * VIEW.zoom}px sans-serif`;
        gctx.textAlign = 'center';
        gctx.textBaseline = 'middle';
        const label = token.name ? token.name[0].toUpperCase() : '?';
        gctx.fillText(label, center.x, center.y);
      }

      function numOr(value, fallback) {
        const n = Number(value);
        return Number.isFinite(n) ? n : fallback;
      }

      function sortByZ(list) {
        if (!Array.isArray(list)) return [];
        const order = new Map();
        list.forEach((item, idx) => order.set(item, idx));
        return list.slice().sort((a, b) => {
          const za = numOr(a && a.z, order.get(a));
          const zb = numOr(b && b.z, order.get(b));
          return za - zb;
        });
      }

      function isDeleted(item) {
        return !!(item && item.deleted);
      }

      function filterAlive(list) {
        return Array.isArray(list) ? list.filter(item => item && !item.deleted) : [];
      }

      function roomAlwaysVisible(room) {
        if (!room || typeof room !== 'object') return false;
        const mode = String(room.fog_mode || room.fogMode || '').toLowerCase();
        if (mode === 'always' || mode === 'visible') return true;
        if (room.always_visible === true || room.alwaysVisible === true) return true;
        return false;
      }

      function getFogState() {
        const fog = STATE.battle && STATE.battle.fog ? STATE.battle.fog : null;
        if (!fog || fog.enabled === false) return null;
        return fog;
      }

      function getFogSets(floorId) {
        const fog = getFogState();
        if (!fog) return null;
        const key = String(floorId || '');
        const visibleMap = fog.visibleRoomIdsByFloor || {};
        const exploredMap = fog.exploredRoomIdsByFloor || {};
        let visible = visibleMap[key];
        let explored = exploredMap[key];
        if (!Array.isArray(visible) || !Array.isArray(explored)) {
          const lowerKey = key.toLowerCase();
          const findCase = (map) => {
            if (!map || typeof map !== 'object') return null;
            for (const k of Object.keys(map)) {
              if (String(k).toLowerCase() === lowerKey) return map[k];
            }
            return null;
          };
          if (!Array.isArray(visible)) visible = findCase(visibleMap);
          if (!Array.isArray(explored)) explored = findCase(exploredMap);
        }
        if (!Array.isArray(visible)) visible = [];
        if (!Array.isArray(explored)) explored = [];
        return {
          visible: new Set(visible.map(String)),
          explored: new Set(explored.map(String))
        };
      }

      function roomContainsWorld(room, worldPoint) {
        if (!room || !worldPoint) return false;
        if (isPolyRoom(room)) {
          const pts = roomWorldPoints(room);
          if (pts.length < 3) return false;
          return pointInPolygon(worldPoint, pts);
        }
        const box = roomToWallBox(room);
        if (!box) return false;
        const rect = roomFloorRectWorld(room, box) || box.center;
        if (!rect) return false;
        return worldPoint.x >= Math.min(rect.x1, rect.x2) &&
          worldPoint.x <= Math.max(rect.x1, rect.x2) &&
          worldPoint.y >= Math.min(rect.y1, rect.y2) &&
          worldPoint.y <= Math.max(rect.y1, rect.y2);
      }

      function findRoomForWorldPoint(rooms, worldPoint) {
        if (!Array.isArray(rooms) || !worldPoint) return null;
        for (const room of rooms) {
          if (!room || room.deleted) continue;
          if (roomContainsWorld(room, worldPoint)) return room;
        }
        return null;
      }

      function classifyRoomsForFog(floor) {
        const rooms = filterAlive(floor && floor.rooms ? floor.rooms : []);
        if (!UI.fogEnabled) return { visible: rooms, explored: [], hidden: [] };
        const sets = getFogSets(floor.id);
        if (!sets) return { visible: rooms, explored: [], hidden: [] };

        const visible = [];
        const explored = [];
        const hidden = [];
        for (const room of rooms) {
          const mode = String(room.fog_mode || room.fogMode || '').toLowerCase();
          if (mode === 'hidden') { hidden.push(room); continue; }
          if (mode === 'explored') { explored.push(room); continue; }
          if (roomAlwaysVisible(room) || mode === 'visible') {
            visible.push(room);
            continue;
          }
          const id = String(room.id || '');
          if (sets.visible.has(id)) {
            visible.push(room);
            continue;
          }
          if (sets.explored.has(id)) {
            explored.push(room);
            continue;
          }
          hidden.push(room);
        }
        return { visible, explored, hidden };
      }

      function buildFogRoomSets(groups) {
        const visible = new Set();
        const explored = new Set();
        const hidden = new Set();
        if (!groups) return { visible, explored, hidden };
        (groups.visible || []).forEach(r => { if (r && r.id != null) visible.add(String(r.id)); });
        (groups.explored || []).forEach(r => { if (r && r.id != null) explored.add(String(r.id)); });
        (groups.hidden || []).forEach(r => { if (r && r.id != null) hidden.add(String(r.id)); });
        return { visible, explored, hidden };
      }

      function tokenWorldCenter(token) {
        if (!token) return null;
        const p = parseHexLabel(token.hex);
        if (!p) return null;
        return hexToWorld(p.col, p.row);
      }

      function itemFogState(item, floor, rooms, roomSets, getWorld) {
        if (!UI.fogEnabled) return 'visible';
        const parentId = item && (item.parent_room || item.parentRoom || item.room_id || item.roomId);
        if (parentId) {
          const room = Array.isArray(rooms) ? rooms.find(r => r && String(r.id) === String(parentId)) : null;
          if (room && room.id != null) {
            const id = String(room.id);
            if (roomSets.hidden && roomSets.hidden.has(id)) return 'hidden';
            if (roomSets.explored && roomSets.explored.has(id)) return 'explored';
            if (roomSets.visible && roomSets.visible.has(id)) return 'visible';
          }
        }
        const world = getWorld ? getWorld(item, floor) : null;
        if (!world) return 'visible';
        const room = findRoomForWorldPoint(rooms, world);
        if (!room || room.id == null) return 'visible';
        const id = String(room.id);
        if (roomSets.hidden && roomSets.hidden.has(id)) return 'hidden';
        if (roomSets.explored && roomSets.explored.has(id)) return 'explored';
        return 'visible';
      }

      function drawFogOverlay(rooms, gctx) {
        if (!UI.fogEnabled || !rooms || !rooms.length) return;
        const fog = getFogState();
        if (!fog) return;
        const alpha = Number.isFinite(Number(fog.exploredAlpha)) ? Number(fog.exploredAlpha) : 0.55;
        const color = FLOOR_COLORS.fog || '#0e1117';
        gctx.save();
        gctx.fillStyle = color;
        gctx.globalAlpha = alpha;
        for (const room of rooms) {
          if (!room || room.deleted) continue;
          if (isPolyRoom(room)) {
            const pts = roomWorldPoints(room);
            if (pts.length < 3) continue;
            const screenPts = pts.map(worldToScreen);
            gctx.beginPath();
            gctx.moveTo(screenPts[0].x, screenPts[0].y);
            for (let i = 1; i < screenPts.length; i++) gctx.lineTo(screenPts[i].x, screenPts[i].y);
            gctx.closePath();
            gctx.fill();
            continue;
          }
          const box = roomToWallBox(room);
          if (!box) continue;
          const rect = roomHasWalls(room) ? (box.center || box.inner) : box.center;
          const p1 = worldToScreen({ x: rect.x1, y: rect.y1 });
          const p2 = worldToScreen({ x: rect.x2, y: rect.y2 });
          const x1 = Math.min(p1.x, p2.x);
          const y1 = Math.min(p1.y, p2.y);
          const x2 = Math.max(p1.x, p2.x);
          const y2 = Math.max(p1.y, p2.y);
          gctx.fillRect(x1, y1, x2 - x1, y2 - y1);
        }
        gctx.restore();
      }

      function render() {
        if (!STATE.battle) return;
        const baseDpr = window.devicePixelRatio || 1;
        const scale = VIDEO_SCALE[UI.video] ?? 1.5;
        const dpr = baseDpr * scale;
        renderDpr = dpr;
        const rect = canvas.getBoundingClientRect();
        canvas.width = rect.width * dpr;
        canvas.height = rect.height * dpr;
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        ctx.clearRect(0, 0, rect.width, rect.height);

        const floor = pickFloor();
        if (!floor) return;

        const layerMode = layerSelect ? layerSelect.value : 'all';
        const floorLayer = getLayerContext('floors', rect, dpr);
        const wallLayer = getLayerContext('walls', rect, dpr);
        const objectLayer = getLayerContext('objects', rect, dpr);
        const fogLayer = getLayerContext('fog', rect, dpr);
        const gridLayer = getLayerContext('grid', rect, dpr);
        const handleLayer = getLayerContext('handles', rect, dpr);
        const tokenLayer = getLayerContext('tokens', rect, dpr);

        const allRooms = filterAlive(floor.rooms || []);
        const fogRooms = classifyRoomsForFog(floor);
        const fogSets = buildFogRoomSets(fogRooms);
        const roomsToDraw = UI.fogEnabled ? fogRooms.visible.concat(fogRooms.explored) : allRooms;

        drawFloorsLayer(floor, floorLayer.ctx, roomsToDraw);
        drawWallsLayer(floor, wallLayer.ctx, roomsToDraw, fogSets);
        drawGridLayer(gridLayer.ctx);
        drawHandlesLayer(floor, handleLayer.ctx);
        drawRoomEdgeHandles(floor, handleLayer.ctx);

        const openingsAll = sortByZ(filterAlive(floor.openings || [])).map(o => {
          const fogState = openingFogState(o, floor, allRooms, fogSets);
          return { opening: o, fogState };
        }).filter(entry => entry.fogState !== 'hidden');
        const objects = sortByZ(filterAlive(floor.objects || [])).filter(o => {
          return itemFogState(o, floor, allRooms, fogSets, objectWorldCenter) !== 'hidden';
        });
        const poiObjects = objects.filter(o => String(o.kind || '').toLowerCase().startsWith('the.'));
        const normalObjects = objects.filter(o => !String(o.kind || '').toLowerCase().startsWith('the.'));
        const tokens = buildTokens()
          .filter(t => !t.floorId || t.floorId === floor.id)
          .filter(t => itemFogState(t, floor, allRooms, fogSets, tokenWorldCenter) !== 'hidden');
        const objectOpenings = [];
        const tokenOpenings = [];
        openingsAll.forEach(entry => {
          const kind = String(entry.opening.kind || '').toLowerCase();
          if (kind === 'door' || kind.startsWith('door.') || kind.startsWith('window')) {
            tokenOpenings.push(entry);
          } else {
            objectOpenings.push(entry);
          }
        });
        objectOpenings.forEach(entry => drawOpening(entry.opening, floor, objectLayer.ctx, entry.fogState));
        normalObjects.forEach((obj, idx) => drawObject(obj, idx, objectLayer.ctx));
        tokens.forEach(t => drawToken(t, tokenLayer.ctx));
        tokenOpenings.forEach(entry => drawOpening(entry.opening, floor, tokenLayer.ctx, entry.fogState));
        poiObjects.forEach((obj, idx) => drawObject(obj, idx, tokenLayer.ctx));
        drawFogOverlay(fogRooms.explored, fogLayer.ctx);

        ctx.clearRect(0, 0, rect.width, rect.height);
        if (layerMode === 'all' || layerMode === 'floors') {
          ctx.drawImage(floorLayer.canvas, 0, 0, rect.width, rect.height);
        }
        if (layerMode === 'all' || layerMode === 'objects') {
          ctx.drawImage(objectLayer.canvas, 0, 0, rect.width, rect.height);
        }
        if (layerMode === 'all') {
          ctx.drawImage(fogLayer.canvas, 0, 0, rect.width, rect.height);
        }
        if (layerMode === 'all' || layerMode === 'walls') {
          ctx.drawImage(wallLayer.canvas, 0, 0, rect.width, rect.height);
        }
        if (layerMode === 'all' || layerMode === 'tokens') {
          ctx.drawImage(tokenLayer.canvas, 0, 0, rect.width, rect.height);
        }
        if (layerMode === 'all' && UI.hexGrid) {
          ctx.drawImage(gridLayer.canvas, 0, 0, rect.width, rect.height);
        }
        if (layerMode === 'all' && (UI.showHandles || UI.handleHot)) {
          ctx.drawImage(handleLayer.canvas, 0, 0, rect.width, rect.height);
        }
        if (layerMode === 'all') {
          drawRoomPreview(ctx);
          drawPolyPreview(ctx);
        }
      }

      function updateInspector() {
        const sel = EDITOR.selection;
        if (!sel) {
          inspectorEmpty.hidden = false;
          inspectorFields.hidden = true;
          inspectorFields.innerHTML = '';
          return;
        }

        inspectorEmpty.hidden = true;
        inspectorFields.hidden = false;
        inspectorFields.innerHTML = '';

        const addField = (label, value, key, opts = {}) => {
          const row = document.createElement('div');
          row.className = 'row';
          const lab = document.createElement('label');
          lab.textContent = label;
          const input = document.createElement('input');
          if (opts.type) input.type = opts.type;
          if (opts.step != null) input.step = String(opts.step);
          if (opts.list) input.setAttribute('list', opts.list);
          input.value = value == null ? '' : String(value);
          if (opts.readonly) input.readOnly = true;
          input.addEventListener('input', () => {
            applyFieldChange(key, input.value);
          });
          row.appendChild(lab);
          row.appendChild(input);
          inspectorFields.appendChild(row);
        };
        const addSelectField = (label, value, key, options = []) => {
          const row = document.createElement('div');
          row.className = 'row';
          const lab = document.createElement('label');
          lab.textContent = label;
          const select = document.createElement('select');
          for (const opt of options) {
            const o = document.createElement('option');
            o.value = opt.value;
            o.textContent = opt.label;
            select.appendChild(o);
          }
          select.value = value == null ? '' : String(value);
          select.addEventListener('change', () => {
            applyFieldChange(key, select.value);
          });
          row.appendChild(lab);
          row.appendChild(select);
          inspectorFields.appendChild(row);
        };
        const addButtonRow = (buttons) => {
          const row = document.createElement('div');
          row.className = 'btnRow';
          buttons.forEach(({ label, onClick }) => {
            const btn = document.createElement('button');
            btn.textContent = label;
            btn.addEventListener('click', onClick);
            row.appendChild(btn);
          });
          inspectorFields.appendChild(row);
        };
        const bumpToken = (key, delta) => {
          const cur = Number(sel.item[key]);
          const next = Number.isFinite(cur) ? cur + delta : delta;
          applyFieldChange(key, String(next));
          updateInspector();
        };
        const setTokenSide = (side, kind) => {
          applyFieldChange('side', side);
          if (kind) applyFieldChange('kind', kind);
          updateInspector();
        };

        if (sel.type === 'room') {
          addField('Type', 'room', 'type', { readonly: true });
          addField('ID', sel.item.id, 'id', { readonly: true });
          addField('Name', sel.item.name || '', 'name');
          addField('Floor', sel.floorId, 'floorId');
          addField('Points', formatRoomPoints(sel.item), 'points');
          addField('Thickness', sel.item.thickness != null ? sel.item.thickness : '', 'thickness', { type: 'number', step: '1' });
          addField('Floor Kind', sel.item.floor && sel.item.floor.kind ? sel.item.floor.kind : '', 'floor.kind', { list: 'floorKindList' });
          addField('Floor Rot', sel.item.floor && (sel.item.floor.rot ?? sel.item.floor.rotDeg) ? (sel.item.floor.rot ?? sel.item.floor.rotDeg) : '', 'floor.rot', { type: 'number', step: '1' });
          addField('Wall Kind', sel.item.wall && sel.item.wall.kind ? sel.item.wall.kind : '', 'wall.kind', { list: 'wallKindList' });
          addField('Erase', sel.item.wall_erase || sel.item.wallErase || sel.item.erase || '', 'wall_erase');
          addField('Z', sel.item.z != null ? sel.item.z : '', 'z', { type: 'number', step: '1' });
          addSelectField('Fog', sel.item.fog_mode || sel.item.fogMode || '', 'fog_mode', [
            { value: '', label: 'Default' },
            { value: 'visible', label: 'Always Visible' },
            { value: 'explored', label: 'Always Explored' },
            { value: 'hidden', label: 'Always Hidden' }
          ]);
          addButtonRow([
            { label: 'To Front', onClick: () => reorderSelection('front') },
            { label: 'To Back', onClick: () => reorderSelection('back') },
          ]);
          addButtonRow([
            { label: 'Delete', onClick: () => deleteSelection() },
          ]);
        }

        if (sel.type === 'opening') {
          addField('Type', 'opening', 'type', { readonly: true });
          addField('ID', sel.item.id, 'id', { readonly: true });
          addField('Name', sel.item.name || '', 'name');
          addField('Kind', sel.item.kind || '', 'kind', { list: 'openingKindList' });
          addField('Hex', sel.item.hex || '', 'hex');
          addField('Floor', sel.floorId || '', 'floorId');
          addField('Orientation', sel.item.orientation || 'h', 'orientation');
          addField('Hinge', sel.item.hinge || '', 'hinge');
          addField('Swing', sel.item.swing != null ? sel.item.swing : '', 'swing', { type: 'number', step: '1' });
          addField('Open %', sel.item.openPct != null ? sel.item.openPct : 0, 'openPct', { type: 'number', step: '0.05' });
          addField('Length', sel.item.len != null ? sel.item.len : '', 'len', { type: 'number', step: '0.05' });
          addField('Thickness', sel.item.thickness != null ? sel.item.thickness : '', 'thickness', { type: 'number', step: '0.05' });
          addField('Z', sel.item.z != null ? sel.item.z : '', 'z', { type: 'number', step: '1' });
          addButtonRow([
            { label: 'To Front', onClick: () => reorderSelection('front') },
            { label: 'To Back', onClick: () => reorderSelection('back') },
          ]);
          addButtonRow([
            { label: 'Delete', onClick: () => deleteSelection() },
          ]);
        }

        if (sel.type === 'object') {
          addField('Type', 'object', 'type', { readonly: true });
          addField('ID', sel.item.id, 'id', { readonly: true });
          addField('Name', sel.item.name || '', 'name');
          addField('Kind', sel.item.kind || '', 'kind', { list: 'objectKindList' });
          addField('Hex', sel.item.hex || '', 'hex');
          addField('Floor', sel.item.floorId || '', 'floorId');
          addField('Parent Room', sel.item.parent_room || sel.item.parentRoom || sel.item.room_id || sel.item.roomId || '', 'parent_room');
          addField('Sprite', sel.item.sprite || sel.item.spriteFile || '', 'sprite');
          addField('Scale', sel.item.spriteScale != null ? sel.item.spriteScale : '', 'spriteScale', { type: 'number', step: '0.05' });
          addField('Scale X', sel.item.spriteScaleX != null ? sel.item.spriteScaleX : '', 'spriteScaleX', { type: 'number', step: '0.05' });
          addField('Scale Y', sel.item.spriteScaleY != null ? sel.item.spriteScaleY : '', 'spriteScaleY', { type: 'number', step: '0.05' });
          addField('Rot Deg', sel.item.rotDeg != null ? sel.item.rotDeg : '', 'rotDeg', { type: 'number', step: '1' });
          addField('Offset X', sel.item.ox != null ? sel.item.ox : '', 'ox', { type: 'number', step: '0.05' });
          addField('Offset Y', sel.item.oy != null ? sel.item.oy : '', 'oy', { type: 'number', step: '0.05' });
          addField('Z', sel.item.z != null ? sel.item.z : '', 'z', { type: 'number', step: '1' });
          addButtonRow([
            { label: 'To Front', onClick: () => reorderSelection('front') },
            { label: 'To Back', onClick: () => reorderSelection('back') },
          ]);
          addButtonRow([
            { label: 'Delete', onClick: () => deleteSelection() },
          ]);
        }

        if (sel.type === 'token') {
          addField('Type', 'token', 'type', { readonly: true });
          addField('ID', sel.item.id, 'id', { readonly: true });
          addField('Name', sel.item.name || '', 'name');
          addField('Kind', sel.item.kind || '', 'kind', { list: 'tokenKindList' });
          addField('Hex', sel.item.hex || '', 'hex');
          addField('Floor', sel.item.floorId || '', 'floorId');
          addField('POI', sel.item.poi_id || '', 'poi_id');
          addSelectField('Sprite', sel.item.sprite || '', 'sprite', TOKEN_SPRITE_OPTIONS);
          addField('Side', sel.item.side || '', 'side');
          addField('HP', sel.item.hp != null ? sel.item.hp : '', 'hp', { type: 'number', step: '1' });
          addField('Init', sel.item.init != null ? sel.item.init : '', 'init', { type: 'number', step: '1' });
          addField('Z', sel.item.z != null ? sel.item.z : '', 'z', { type: 'number', step: '1' });
          addButtonRow([
            { label: 'HP -1', onClick: () => bumpToken('hp', -1) },
            { label: 'HP +1', onClick: () => bumpToken('hp', 1) },
            { label: 'Init -1', onClick: () => bumpToken('init', -1) },
            { label: 'Init +1', onClick: () => bumpToken('init', 1) },
          ]);
          addButtonRow([
            { label: 'Set PC', onClick: () => setTokenSide('PC', 'pc') },
            { label: 'Set NPC', onClick: () => setTokenSide('NPC', 'npc') },
          ]);
          addButtonRow([
            { label: 'Delete', onClick: () => deleteSelection() },
          ]);
        }
      }
      function applyFieldChange(key, value) {
        const sel = EDITOR.selection;
        if (!sel) return;
        pushHistory();
        const item = sel.item;
        const num = (val, fallback = null) => {
          if (val == null || String(val).trim() === '') return fallback;
          const n = Number(val);
          return Number.isFinite(n) ? n : fallback;
        };

        if (sel.type === 'room') {
          if (key === 'name') item.name = value;
          if (key === 'floorId') moveRoomToFloor(item, value);
          if (key === 'points') {
            const points = parsePointList(value);
            if (points.length >= 3) {
              item.points = points;
            } else {
              delete item.points;
            }
          }
          if (key === 'fog_mode') {
            const v = String(value || '').trim().toLowerCase();
            if (!v) {
              delete item.fog_mode;
              delete item.fogMode;
            } else {
              item.fog_mode = v;
            }
          }
          if (key === 'thickness') item.thickness = num(value, 0);
          if (key === 'floor.kind') {
            item.floor = item.floor || {};
            item.floor.kind = value;
          }
          if (key === 'floor.rot') {
            item.floor = item.floor || {};
            const n = num(value, null);
            if (n == null) delete item.floor.rot;
            else item.floor.rot = n;
          }
          if (key === 'wall.kind') {
            item.wall = item.wall || {};
            item.wall.kind = value;
          }
          if (key === 'wall_erase') {
            const cleaned = String(value || '').toUpperCase().replace(/[^NSEW]/g, '');
            if (!cleaned) delete item.wall_erase;
            else item.wall_erase = cleaned;
          }
          if (key === 'z') item.z = num(value, null);
        }

        if (sel.type === 'opening') {
          if (key === 'name') item.name = value;
          if (key === 'kind') item.kind = value;
          if (key === 'hex') item.hex = value;
          if (key === 'floorId') moveOpeningToFloor(item, value);
          if (key === 'orientation') item.orientation = value;
          if (key === 'hinge') item.hinge = value;
          if (key === 'swing') item.swing = num(value, 1);
          if (key === 'openPct') item.openPct = Math.max(0, Math.min(1, num(value, 0)));
          if (key === 'len') {
            const n = num(value, null);
            if (n == null) delete item.len;
            else item.len = n;
          }
          if (key === 'thickness') {
            const n = num(value, null);
            if (n == null) delete item.thickness;
            else item.thickness = n;
          }
          if (key === 'z') item.z = num(value, null);
        }

        if (sel.type === 'object') {
          if (key === 'name') item.name = value;
          if (key === 'kind') item.kind = value;
          if (key === 'hex') item.hex = value;
          if (key === 'floorId') item.floorId = value;
          if (key === 'parent_room') {
            if (!value) {
              delete item.parent_room;
              delete item.parentRoom;
              delete item.room_id;
              delete item.roomId;
            } else {
              item.parent_room = value;
            }
          }
          if (key === 'sprite') item.sprite = value;
          if (key === 'spriteScale') item.spriteScale = num(value, 1);
          if (key === 'spriteScaleX') item.spriteScaleX = num(value, null);
          if (key === 'spriteScaleY') item.spriteScaleY = num(value, null);
          if (key === 'rotDeg') item.rotDeg = num(value, 0);
          if (key === 'ox') item.ox = num(value, 0);
          if (key === 'oy') item.oy = num(value, 0);
          if (key === 'z') item.z = num(value, null);
        }

        if (sel.type === 'token') {
          if (key === 'name') item.name = value;
          if (key === 'kind') item.kind = value;
          if (key === 'hex') item.hex = value;
          if (key === 'floorId') item.floorId = value;
          if (key === 'poi_id') item.poi_id = value;
          if (key === 'sprite') {
            if (!value) delete item.sprite;
            else item.sprite = value;
          }
          if (key === 'side') item.side = value;
          if (key === 'hp') item.hp = num(value, null);
          if (key === 'init') item.init = num(value, null);
          if (key === 'z') item.z = num(value, null);
          syncEntityFromToken(item);
          queueEntitySave(item);
          renderStatus();
        }

        EDITOR.dirty = true;
        render();
      }

      function updateRoomCorners(room, key, value) {
        const corners = Array.isArray(room.corners) ? room.corners.slice() : [];
        if (corners.length < 4) return;
        if (key === 'cornerTL') corners[0] = value;
        if (key === 'cornerBR') corners[2] = value;
        room.corners = corners;
      }

      function moveRoomToFloor(room, floorId) {
        const floors = STATE.battle.floors;
        const source = floors.find(f => f.rooms.includes(room));
        const target = floors.find(f => f.id === floorId);
        if (!source || !target) return;
        source.rooms = source.rooms.filter(r => r !== room);
        target.rooms.push(room);
        EDITOR.selection.floorId = floorId;
      }

      function moveOpeningToFloor(opening, floorId) {
        const floors = STATE.battle.floors;
        const source = floors.find(f => f.openings && f.openings.includes(opening));
        const target = floors.find(f => f.id === floorId);
        if (!source || !target) return;
        source.openings = source.openings.filter(o => o !== opening);
        if (!Array.isArray(target.openings)) target.openings = [];
        target.openings.push(opening);
        EDITOR.selection.floorId = floorId;
      }

      function reorderSelection(direction) {
        const sel = EDITOR.selection;
        if (!sel || !STATE.battle) return;
        const floor = STATE.battle.floors.find(f => String(f.id) === String(sel.floorId));
        if (!floor) return;
        pushHistory();

        let list = null;
        if (sel.type === 'room') list = floor.rooms;
        if (sel.type === 'opening') list = floor.openings;
        if (sel.type === 'object') list = floor.objects;
        if (!Array.isArray(list)) return;

        const idx = list.indexOf(sel.item);
        if (idx === -1) return;
        list.splice(idx, 1);
        if (direction === 'front') list.push(sel.item);
        else list.unshift(sel.item);

        // Persist order via z so reloads keep the stack.
        const zVals = list.map((item, i) => numOr(item && item.z, i));
        const maxZ = Math.max(0, ...zVals);
        const minZ = Math.min(0, ...zVals);
        sel.item.z = direction === 'front' ? maxZ + 1 : minZ - 1;

        EDITOR.dirty = true;
        updateInspector();
        render();
      }

      function selectItem(type, item, floorId) {
        EDITOR.selection = { type, item, floorId };
        updateInspector();
      }

      function clearSelection() {
        EDITOR.selection = null;
        updateInspector();
      }

      function deleteSelection() {
        const sel = EDITOR.selection;
        if (!sel) return;
        pushHistory();
        if (sel.type === 'token') {
          const entity = sel.item && sel.item.__entity;
          if (entity) {
            entity.deleted = true;
            saveEntityPatch(entity.id || sel.item.id, { deleted: true }, false);
          }
          renderStatus();
          clearSelection();
          render();
          return;
        }
        const floor = STATE.battle && Array.isArray(STATE.battle.floors)
          ? STATE.battle.floors.find(f => String(f.id) === String(sel.floorId))
          : null;
        if (!floor) return;
        if (sel.type === 'room') sel.item.deleted = true;
        if (sel.type === 'opening') sel.item.deleted = true;
        if (sel.type === 'object') sel.item.deleted = true;
        clearSelection();
        EDITOR.dirty = true;
        render();
      }

      function nearestItem(list, point, getPos, maxDist = 20) {
        let best = null;
        let bestD = Infinity;
        for (const item of list) {
          const pos = getPos(item);
          if (!pos) continue;
          const dx = pos.x - point.x;
          const dy = pos.y - point.y;
          const d = Math.sqrt(dx * dx + dy * dy);
          if (d < bestD && d <= maxDist) {
            bestD = d;
            best = item;
          }
        }
        return best;
      }

      function findSelectionAt(worldPoint) {
        const floor = pickFloor();
        if (!floor) return null;
        const screenPoint = worldToScreen(worldPoint);

        const tokens = buildTokens().filter(t => !t.floorId || t.floorId === floor.id);
        const token = nearestItem(tokens, screenPoint, t => {
          const pos = parseHexLabel(t.hex);
          return pos ? worldToScreen(hexToWorld(pos.col, pos.row)) : null;
        }, 18);
        if (token) return { type: 'token', item: token, floorId: floor.id };

        const objects = filterAlive(floor.objects || []);
        const object = nearestItem(objects, screenPoint, o => {
          const world = objectWorldCenter(o);
          return world ? worldToScreen(world) : null;
        }, 18);
        if (object) return { type: 'object', item: object, floorId: floor.id };

        const openings = filterAlive(floor.openings || []);
        const opening = nearestItem(openings, screenPoint, o => {
          const world = openingWorldCenter(o, floor);
          return world ? worldToScreen(world) : null;
        }, 14);
        if (opening) return { type: 'opening', item: opening, floorId: floor.id };

        for (const room of filterAlive(floor.rooms || [])) {
          if (isPolyRoom(room)) {
            const poly = roomPolygonScreen(room);
            if (!poly || poly.length < 3) continue;
            if (pointInPolygon(screenPoint, poly)) {
              return { type: 'room', item: room, floorId: floor.id };
            }
            continue;
          }
          const rectInfo = roomRectScreen(room);
          if (!rectInfo) continue;
          if (screenPoint.x >= rectInfo.x1 && screenPoint.x <= rectInfo.x2 &&
              screenPoint.y >= rectInfo.y1 && screenPoint.y <= rectInfo.y2) {
            return { type: 'room', item: room, floorId: floor.id };
          }
        }

        return null;
      }

      function pointInPolygon(point, vs) {
        let inside = false;
        for (let i = 0, j = vs.length - 1; i < vs.length; j = i++) {
          const xi = vs[i].x, yi = vs[i].y;
          const xj = vs[j].x, yj = vs[j].y;
          const intersect = ((yi > point.y) !== (yj > point.y)) &&
            (point.x < (xj - xi) * (point.y - yi) / (yj - yi + 0.00001) + xi);
          if (intersect) inside = !inside;
        }
        return inside;
      }

      function handleCanvasClick(ev) {
        if (EDITOR.ignoreClick) {
          EDITOR.ignoreClick = false;
          return;
        }
        const rect = canvas.getBoundingClientRect();
        const x = ev.clientX - rect.left;
        const y = ev.clientY - rect.top;
        const world = screenToWorld(x, y);
        const hex = (EDITOR.tool === 'room' || EDITOR.tool === 'poly') ? worldToHexHalf(world) : worldToHex(world);
        const hexLabel = toHexLabel(hex.col, hex.row);
        const hexWorld = hexToWorld(hex.col, hex.row);
        const floor = pickFloor();
        if (!floor) return;

        if (EDITOR.tool === 'select') {
          const sel = findSelectionAt(world);
          if (sel) selectItem(sel.type, sel.item, sel.floorId);
          else clearSelection();
          return;
        }

        if (EDITOR.tool === 'room') {
          if (!EDITOR.roomStart) {
            EDITOR.roomStart = { hex, world: hexWorld };
            return;
          }
          pushHistory();
          const start = EDITOR.roomStart;
          EDITOR.roomStart = null;
          const startWorld = start.world ? start.world : hexToWorld(start.hex.col, start.hex.row);
          const endWorld = hexWorld;
          const corners = roomCornersFromWorld(startWorld, endWorld);
          const room = {
            id: 'room_' + Date.now().toString(36),
            corners,
            thickness: 15,
            floor: { kind: 'wood_oak' },
            wall: { kind: 'brick' }
          };
          floor.rooms.push(room);
          selectItem('room', room, floor.id);
          EDITOR.dirty = true;
          render();
          return;
        }

        if (EDITOR.tool === 'poly') {
          const snap = worldToHexHalf(world);
          const snapWorld = hexToWorld(snap.col, snap.row);
          const label = toHexLabel(snap.col, snap.row);
          const points = Array.isArray(EDITOR.polyPoints) ? EDITOR.polyPoints : [];
          if (!points.length) {
            EDITOR.polyPoints = [{ hex: snap, world: snapWorld, label }];
            return;
          }
          const first = points[0].world;
          const firstScreen = worldToScreen(first);
          const curScreen = worldToScreen(snapWorld);
          const dx = firstScreen.x - curScreen.x;
          const dy = firstScreen.y - curScreen.y;
          const closeEnough = (dx * dx + dy * dy) <= 144; // 12px radius
          if (closeEnough && points.length >= 3) {
            pushHistory();
            const room = {
              id: 'room_' + Date.now().toString(36),
              shape: 'poly',
              points: points.map(p => p.label),
              thickness: 15,
              floor: { kind: 'wood_oak' },
              wall: { kind: 'brick' }
            };
            floor.rooms.push(room);
            selectItem('room', room, floor.id);
            EDITOR.polyPoints = [];
            EDITOR.polyHover = null;
            EDITOR.dirty = true;
            render();
            return;
          }
          EDITOR.polyPoints = points.concat({ hex: snap, world: snapWorld, label });
          render();
          return;
        }

        if (EDITOR.tool === 'opening') {
          const snapped = snapWorldToWall(world, floor, EDITOR.openingOrientation || 'h');
          const openHex = openingHexFromWorld(snapped);
          const openLabel = openingHexLabelFromCoords(openHex.col, openHex.row) || hexLabel;
          pushHistory();
          const opening = {
            id: 'opening_' + Date.now().toString(36),
            kind: EDITOR.openingKind || 'door.wood',
            hex: openLabel,
            orientation: EDITOR.openingOrientation || 'h',
            openPct: 0
          };
          floor.openings.push(opening);
          selectItem('opening', opening, floor.id);
          EDITOR.dirty = true;
          render();
          return;
        }

        if (EDITOR.tool === 'object') {
          pushHistory();
          const obj = {
            id: 'object_' + Date.now().toString(36),
            kind: EDITOR.objectKind || 'object',
            hex: hexLabel,
            floorId: floor.id
          };
          floor.objects.push(obj);
          selectItem('object', obj, floor.id);
          EDITOR.dirty = true;
          render();
          return;
        }

        if (EDITOR.tool === 'token') {
          pushHistory();
          const poiId = resolvePoiId();
          const entityId = `entity_${Date.now().toString(36)}_${Math.random().toString(36).slice(2, 6)}`;
          const tokenKind = (EDITOR.tokenKind || 'npc').toLowerCase();
          const tokenSide = tokenKind === 'pc' ? 'PC' : 'NPC';
          const entity = {
            id: entityId,
            name: 'Token',
            kind: tokenKind,
            poi_id: poiId || '',
            location: { hex: hexLabel, floorId: floor.id }
          };
          STATE.entities = Array.isArray(STATE.entities) ? STATE.entities : [];
          STATE.entities.push(entity);

          const token = {
            id: entityId,
            name: entity.name,
            kind: entity.kind,
            hex: entity.location.hex,
            floorId: entity.location.floorId,
            poi_id: entity.poi_id,
            side: entity.side || tokenSide,
            __entity: entity
          };
          selectItem('token', token, floor.id);
          syncEntityFromToken(token);
          queueEntitySave(token);
          renderStatus();
          EDITOR.dirty = true;
          render();
        }
      }

      function syncEntityFromToken(token) {
        const entity = token && token.__entity;
        if (!entity) return;
        entity.name = token.name;
        if (token.kind) entity.kind = token.kind;
        if (token.sprite) entity.sprite = token.sprite;
        if (!token.sprite && entity.sprite) delete entity.sprite;
        if (!entity.location || typeof entity.location !== 'object') entity.location = {};
        if (token.hex) entity.location.hex = token.hex;
        if (token.floorId) entity.location.floorId = token.floorId;
        if (token.poi_id) entity.poi_id = token.poi_id;
        if (token.side) entity.side = token.side;
        if (!entity.stats || typeof entity.stats !== 'object') entity.stats = {};
        if (token.hp != null) {
          entity.stats.hp = token.hp;
          entity.hp = token.hp;
        }
        if (token.init != null) {
          entity.stats.init = token.init;
          entity.init = token.init;
        }
      }

      function onDragMove(worldPoint) {
        const drag = EDITOR.drag;
        if (!drag) return;
        const hex = worldToHex(worldPoint);
        const hexLabel = toHexLabel(hex.col, hex.row);

        if (drag.type === 'token') {
          drag.item.hex = hexLabel;
          drag.item.floorId = VIEW.floorId || drag.floorId || drag.item.floorId;
          syncEntityFromToken(drag.item);
        } else if (drag.type === 'opening') {
          const orient = drag.item && drag.item.orientation === 'v' ? 'v' : 'h';
          const snapped = snapWorldToWall(worldPoint, pickFloor(), orient);
          const openHex = openingHexFromWorld(snapped);
          const openLabel = openingHexLabelFromCoords(openHex.col, openHex.row) || hexLabel;
          drag.item.hex = openLabel;
        } else if (drag.type === 'object') {
          const base = hexToWorld(hex.col, hex.row);
          const ox = (worldPoint.x - base.x) / GRID.size;
          const oy = (worldPoint.y - base.y) / GRID.size;
          drag.item.hex = hexLabel;
          drag.item.ox = Math.round(ox * 100) / 100;
          drag.item.oy = Math.round(oy * 100) / 100;
        } else if (drag.type === 'poly-point') {
          const snap = worldToHexHalf(worldPoint);
          const label = toHexLabel(snap.col, snap.row);
          setPolyPoint(drag.item, drag.index, label);
        } else if (drag.type === 'room-edge' || drag.type === 'room-move') {
          const handles = roomEdgeHandleWorlds(drag.item);
          if (!handles) return;
          const baseRect = drag.rect || handles.rect;
          const startWorld = drag.startWorld || worldPoint;
          const snapHex = worldToHexHalf(worldPoint);
          const snapWorld = hexToWorld(snapHex.col, snapHex.row);

          if (drag.type === 'room-move') {
            const dx = worldPoint.x - startWorld.x;
            const dy = worldPoint.y - startWorld.y;
            const corners = roomCornersFromWorld(
              { x: baseRect.x1 + dx, y: baseRect.y2 + dy },
              { x: baseRect.x2 + dx, y: baseRect.y1 + dy }
            );
            setRoomRectCorners(drag.item, corners);
          } else {
            const data = getRectCornerData(drag.item);
            if (!data) return;
            const { leftCol, rightCol, topLeft, botLeft, topRight, botRight } = data;
            if (drag.side === 'n') {
              const yTop = hexToWorld(snapHex.col, snapHex.row).y;
              const tlRow = rowFromWorldYForCol(yTop, leftCol);
              const trRow = rowFromWorldYForCol(yTop, rightCol);
              const corners = [
                toHexLabel(leftCol, tlRow),
                toHexLabel(rightCol, trRow),
                toHexLabel(rightCol, botRight.row),
                toHexLabel(leftCol, botLeft.row)
              ];
              setRoomRectCorners(drag.item, corners);
            } else if (drag.side === 's') {
              const yBot = hexToWorld(snapHex.col, snapHex.row).y;
              const blRow = rowFromWorldYForCol(yBot, leftCol);
              const brRow = rowFromWorldYForCol(yBot, rightCol);
              const corners = [
                toHexLabel(leftCol, topLeft.row),
                toHexLabel(rightCol, topRight.row),
                toHexLabel(rightCol, brRow),
                toHexLabel(leftCol, blRow)
              ];
              setRoomRectCorners(drag.item, corners);
            } else if (drag.side === 'w') {
              const newCol = snapHex.col;
              const yTop = hexToWorld(rightCol, topRight.row).y;
              const yBot = hexToWorld(rightCol, botRight.row).y;
              const tlRow = rowFromWorldYForCol(yTop, newCol);
              const blRow = rowFromWorldYForCol(yBot, newCol);
              const corners = [
                toHexLabel(newCol, tlRow),
                toHexLabel(rightCol, topRight.row),
                toHexLabel(rightCol, botRight.row),
                toHexLabel(newCol, blRow)
              ];
              setRoomRectCorners(drag.item, corners);
            } else if (drag.side === 'e') {
              const newCol = snapHex.col;
              const yTop = hexToWorld(leftCol, topLeft.row).y;
              const yBot = hexToWorld(leftCol, botLeft.row).y;
              const trRow = rowFromWorldYForCol(yTop, newCol);
              const brRow = rowFromWorldYForCol(yBot, newCol);
              const corners = [
                toHexLabel(leftCol, topLeft.row),
                toHexLabel(newCol, trRow),
                toHexLabel(newCol, brRow),
                toHexLabel(leftCol, botLeft.row)
              ];
              setRoomRectCorners(drag.item, corners);
            }
          }
        }
        EDITOR.dirty = true;
        render();
      }

      function attachDragHandlers() {
        canvas.addEventListener('mousedown', (ev) => {
          if (EDITOR.tool !== 'select') return;
          const rect = canvas.getBoundingClientRect();
          const x = ev.clientX - rect.left;
          const y = ev.clientY - rect.top;
          const world = screenToWorld(x, y);
          const screenPoint = { x, y };
          const floor = pickFloor();
        if (floor && EDITOR.selection && EDITOR.selection.type === 'room') {
          let hit = null;
          if (UI.showHandles || UI.handleHot) {
            hit = isPolyRoom(EDITOR.selection.item)
              ? getPolyHandleHit(EDITOR.selection.item, screenPoint)
              : getRoomHandleHit(EDITOR.selection.item, screenPoint);
          }
          if (hit) {
            EDITOR.drag = {
              type: hit.type,
              side: hit.side,
              index: hit.index,
              item: EDITOR.selection.item,
              floorId: EDITOR.selection.floorId,
              startWorld: world,
              rect: roomEdgeHandleWorlds(EDITOR.selection.item).rect,
              didMove: false,
              pushed: false
            };
            return;
          }
        }
        const sel = findSelectionAt(world);
        if (sel && sel.type === 'room') {
          selectItem(sel.type, sel.item, sel.floorId);
          const showHandles = UI.showHandles || UI.handleHot;
          if (showHandles) {
            const hit = isPolyRoom(sel.item)
              ? getPolyHandleHit(sel.item, screenPoint)
              : getRoomHandleHit(sel.item, screenPoint);
            if (hit) {
              EDITOR.drag = {
                type: hit.type,
                side: hit.side,
                index: hit.index,
                item: sel.item,
                floorId: sel.floorId,
                startWorld: world,
                rect: roomEdgeHandleWorlds(sel.item).rect,
                didMove: false,
                pushed: false
              };
              return;
            }
          }
          return;
        }
          if (!sel) return;
          selectItem(sel.type, sel.item, sel.floorId);
          EDITOR.drag = sel;
          EDITOR.drag.didMove = false;
          EDITOR.drag.pushed = false;
        });

        canvas.addEventListener('mousemove', (ev) => {
          if (!EDITOR.drag) return;
          EDITOR.drag.didMove = true;
          if (!EDITOR.drag.pushed) {
            pushHistory();
            EDITOR.drag.pushed = true;
          }
          const rect = canvas.getBoundingClientRect();
          const x = ev.clientX - rect.left;
          const y = ev.clientY - rect.top;
          const world = screenToWorld(x, y);
          onDragMove(world);
        });

        canvas.addEventListener('mousemove', (ev) => {
          if (EDITOR.drag) return;
          if (EDITOR.tool !== 'room' && EDITOR.tool !== 'poly') return;
          const rect = canvas.getBoundingClientRect();
          const x = ev.clientX - rect.left;
          const y = ev.clientY - rect.top;
          const world = screenToWorld(x, y);
          const hex = worldToHexHalf(world);
          const snapWorld = hexToWorld(hex.col, hex.row);
          if (EDITOR.tool === 'room') {
            EDITOR.roomHover = { hex, world: snapWorld };
          } else {
            EDITOR.polyHover = { hex, world: snapWorld };
          }
          render();
        });

        window.addEventListener('mouseup', () => {
          if (!EDITOR.drag) return;
          const dragged = EDITOR.drag;
          EDITOR.drag = null;
          if (dragged.didMove) {
            EDITOR.ignoreClick = true;
            updateInspector();
            if (dragged.type === 'token') {
              syncEntityFromToken(dragged.item);
              queueEntitySave(dragged.item);
              renderStatus();
            }
          }
        });
      }

      async function saveState() {
        const battleId = resolveBattleId();
        if (!battleId || !STATE.battle) return;
        saveStatus.textContent = 'DB: saving...';
        try {
          let payloadState = STATE.battle;
          if (STATE.wrapper && STATE.recordId) {
            const wrapper = STATE.wrapper;
            if (!wrapper.records || typeof wrapper.records !== 'object') wrapper.records = {};
            wrapper.records[STATE.recordId] = STATE.battle;
            if (!wrapper.active || typeof wrapper.active !== 'object') wrapper.active = { recordId: STATE.recordId };
            if (!wrapper.active.recordId) wrapper.active.recordId = STATE.recordId;
            payloadState = wrapper;
          }
          const body = JSON.stringify({ state_json: payloadState });
          const res = await fetch(`/api/battles/${encodeURIComponent(battleId)}`, {
            method: 'PUT',
            headers: { 'content-type': 'application/json', 'accept': 'application/json', ...getAuthHeaders() },
            body
          });
          if (!res.ok) throw new Error('Save failed');
          saveStatus.textContent = 'DB: saved';
          EDITOR.dirty = false;
        } catch (e) {
          saveStatus.textContent = 'DB: error';
        }
      }

      let entitySaveTimer = null;
      function queueEntitySave(token) {
        if (!getCampaignId()) return;
        if (entitySaveTimer) clearTimeout(entitySaveTimer);
        entitySaveTimer = setTimeout(() => saveEntity(token), 400);
      }

      async function saveEntityPatch(entityId, patch, createIfMissing) {
        const cid = getCampaignId();
        if (!cid || !entityId) return;
        const payload = {
          entity_id: entityId,
          patch: patch || {},
          create_if_missing: !!createIfMissing
        };
        try {
          await fetch(`/api/campaigns/${encodeURIComponent(cid)}/entities`, {
            method: 'PATCH',
            headers: { 'content-type': 'application/json', 'accept': 'application/json', ...getAuthHeaders() },
            body: JSON.stringify(payload)
          });
        } catch {}
      }

      async function saveEntity(token) {
        if (!token) return;
        const stats = {};
        if (token.hp != null) stats.hp = token.hp;
        if (token.init != null) stats.init = token.init;
        const patch = {
          name: token.name,
          kind: token.kind,
          side: token.side,
          poi_id: token.poi_id || resolvePoiId(),
          location: { hex: token.hex, floorId: token.floorId },
          ...(Object.keys(stats).length ? { stats } : {})
        };
        if (token.sprite) patch.sprite = token.sprite;
        else if (token.__entity && token.__entity.sprite) patch.sprite = null;
        saveEntityPatch(token.id, patch, true);
      }

      function attachEvents() {
        Object.entries(toolButtons).forEach(([key, btn]) => {
          if (!btn) return;
          btn.addEventListener('click', () => setTool(key));
        });
        if (openingKindSelect) {
          openingKindSelect.addEventListener('change', () => {
            EDITOR.openingKind = openingKindSelect.value;
          });
          openingKindSelect.value = EDITOR.openingKind;
        }
        const setOpeningOrientation = (val) => {
          EDITOR.openingOrientation = val;
          if (openingOrientH) openingOrientH.classList.toggle('active', val === 'h');
          if (openingOrientV) openingOrientV.classList.toggle('active', val === 'v');
        };
        if (openingOrientH) openingOrientH.addEventListener('click', () => setOpeningOrientation('h'));
        if (openingOrientV) openingOrientV.addEventListener('click', () => setOpeningOrientation('v'));
        setOpeningOrientation(EDITOR.openingOrientation);
        if (objectKindSelect) {
          objectKindSelect.addEventListener('change', () => {
            EDITOR.objectKind = objectKindSelect.value;
          });
          objectKindSelect.value = EDITOR.objectKind;
        }
        if (tokenKindSelect) {
          tokenKindSelect.addEventListener('change', () => {
            EDITOR.tokenKind = tokenKindSelect.value;
          });
          tokenKindSelect.value = EDITOR.tokenKind;
        }
        if (hexGridToggle) {
          hexGridToggle.addEventListener('change', () => {
            UI.hexGrid = !!hexGridToggle.checked;
            savePrefs();
            render();
          });
        }
        if (labelBoldToggle) {
          labelBoldToggle.addEventListener('change', () => {
            UI.brightLabels = !!labelBoldToggle.checked;
            savePrefs();
            render();
          });
        }
        if (handlesToggle) {
          handlesToggle.addEventListener('change', () => {
            UI.showHandles = !!handlesToggle.checked;
            savePrefs();
            render();
          });
        }
        if (fogToggle) {
          fogToggle.addEventListener('change', () => {
            UI.fogEnabled = !!fogToggle.checked;
            savePrefs();
            render();
          });
        }
        if (videoSelect) {
          videoSelect.addEventListener('change', () => {
            const next = videoSelect.value;
            if (next === 'low' || next === 'medium' || next === 'high' || next === 'ultra') {
              UI.video = next;
              savePrefs();
              render();
            }
          });
        }
        floorSelect.addEventListener('change', () => {
          VIEW.floorId = floorSelect.value;
          render();
        });
        if (layerSelect) {
          layerSelect.addEventListener('change', () => {
            render();
          });
        }
        zoomInput.addEventListener('input', () => {
          setZoom(Number(zoomInput.value));
        });
        if (canvasWrap) {
          canvasWrap.addEventListener('wheel', (ev) => {
            ev.preventDefault();
            const step = zoomInput ? Number(zoomInput.step) : 0.05;
            const delta = ev.deltaY > 0 ? -step : step;
            setZoom(VIEW.zoom + delta);
          }, { passive: false });
        }
        const nudgeStep = 1;
        if (panUp) panUp.addEventListener('click', () => nudgeCamera(0, -rowStep() * nudgeStep));
        if (panDown) panDown.addEventListener('click', () => nudgeCamera(0, rowStep() * nudgeStep));
        if (panLeft) panLeft.addEventListener('click', () => nudgeCamera(-colStep() * nudgeStep, 0));
        if (panRight) panRight.addEventListener('click', () => nudgeCamera(colStep() * nudgeStep, 0));
        if (undoButton) undoButton.addEventListener('click', () => undo());
        saveButton.addEventListener('click', () => saveState());
        if (chatSend) chatSend.addEventListener('click', () => sendChatMessage());
        if (chatInput) {
          chatInput.addEventListener('keydown', (ev) => {
            if (ev.key === 'Enter') {
              ev.preventDefault();
              sendChatMessage();
            }
          });
        }
        canvas.addEventListener('click', handleCanvasClick);
        attachDragHandlers();
        window.addEventListener('keydown', (ev) => {
          if ((ev.ctrlKey || ev.metaKey) && ev.key.toLowerCase() === 'z') {
            ev.preventDefault();
            undo();
            return;
          }
          if (ev.key !== 'Delete' && ev.key !== 'Backspace') return;
          const el = document.activeElement;
          if (el && ['INPUT', 'TEXTAREA', 'SELECT'].includes(el.tagName)) return;
          deleteSelection();
        });
        window.addEventListener('keydown', (ev) => {
          if (ev.key === 'Escape') {
            if (EDITOR.roomStart) {
              EDITOR.roomStart = null;
              render();
            }
            if (Array.isArray(EDITOR.polyPoints) && EDITOR.polyPoints.length) {
              EDITOR.polyPoints = [];
              EDITOR.polyHover = null;
              render();
            }
          }
        });
        window.addEventListener('keydown', (ev) => {
          if (ev.key === 'Control') {
            UI.handleHot = true;
            render();
          }
        });
        window.addEventListener('keyup', (ev) => {
          if (ev.key === 'Control') {
            UI.handleHot = false;
            render();
          }
        });
        window.addEventListener('resize', () => render());
        setTool(EDITOR.tool);
        updateUndoButton();
      }

      function populateKindLists() {
        if (!floorKindList || !wallKindList || !openingKindList || !objectKindList) return;
        const floorKinds = new Set(DEFAULT_FLOOR_KINDS);
        const wallKinds = new Set(DEFAULT_WALL_KINDS);
        const openingKinds = new Set(DEFAULT_OPENING_KINDS);
        const objectKinds = new Set(DEFAULT_OBJECT_KINDS);
        const tokenKinds = new Set(DEFAULT_TOKEN_KINDS);

        if (STATE.battle && Array.isArray(STATE.battle.floors)) {
          for (const floor of STATE.battle.floors) {
            if (Array.isArray(floor.rooms)) {
              for (const room of floor.rooms) {
                const fk = room && room.floor && room.floor.kind;
                const wk = room && room.wall && room.wall.kind;
                if (fk) floorKinds.add(String(fk));
                if (wk) wallKinds.add(String(wk));
              }
            }
            if (Array.isArray(floor.openings)) {
              for (const o of floor.openings) {
                if (o && o.kind) openingKinds.add(String(o.kind));
              }
            }
            if (Array.isArray(floor.objects)) {
              for (const o of floor.objects) {
                if (o && o.kind) objectKinds.add(String(o.kind));
              }
            }
          }
        }

        const fill = (el, values) => {
          el.innerHTML = Array.from(values).sort().map(v => `<option value="${String(v).replace(/\"/g, '&quot;')}"></option>`).join('');
        };
        fill(floorKindList, floorKinds);
        fill(wallKindList, wallKinds);
        fill(openingKindList, openingKinds);
        fill(objectKindList, objectKinds);
        if (tokenKindList) fill(tokenKindList, tokenKinds);
      }

      async function init() {
        await loadBattle();
        await loadCampaign();
        loadPrefs();
        setFloorOptions();
        populateKindLists();
        VIEW.zoom = Number(zoomInput.value);
        autoCenterCamera();
        pushHistory();
        renderStatus();
        attachEvents();
        render();
        startChatPolling();
      }

      init().catch(err => {
        saveStatus.textContent = 'DB: error';
        console.error(err);
      });
    })();
  </script>
</body>
</html>
