<!-- Battlemat v7.03 -->
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Battlemat Next</title>
  <style>
    :root {
      color-scheme: dark;
      --bg: #0c0f14;
      --panel: #131722;
      --panel-2: #0f141c;
      --accent: #6fd3ff;
      --text: #e6ecf3;
      --muted: #97a2b3;
      --danger: #ff7a7a;
      --success: #63d18d;
      --grid: rgba(255,255,255,0.06);
      --room-outline: rgba(255,255,255,0.18);
    }

    * { box-sizing: border-box; }
    body {
      margin: 0;
      background: var(--bg);
      color: var(--text);
      font: 14px/1.4 ui-sans-serif, system-ui, -apple-system, Segoe UI, sans-serif;
    }

    #app {
      display: grid;
      grid-template-columns: 1fr 320px;
      min-height: 100vh;
    }

    #canvasWrap {
      position: relative;
      overflow: hidden;
      background: var(--bg);
    }

    canvas {
      display: block;
      width: 100%;
      height: 100%;
    }

    #toolbar {
      position: absolute;
      top: 12px;
      left: 12px;
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 8px 10px;
      background: rgba(15,20,28,0.85);
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: 8px;
      backdrop-filter: blur(8px);
      z-index: 10;
    }

    #toolbar select, #toolbar input, #toolbar button {
      background: #0f141c;
      color: var(--text);
      border: 1px solid rgba(255,255,255,0.12);
      border-radius: 6px;
      padding: 6px 8px;
      font-size: 13px;
    }

    #toolbar button {
      cursor: pointer;
    }

    #toolbar .toolBtn.active {
      border-color: var(--accent);
      box-shadow: 0 0 0 1px rgba(111,211,255,0.35) inset;
    }

    #toolbar .status {
      padding: 0 6px;
      font-size: 12px;
      color: var(--muted);
    }

    #toolbar .mini {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      font-size: 12px;
      color: var(--muted);
    }

    #toolbar .mini input {
      width: 14px;
      height: 14px;
      accent-color: var(--accent);
    }

    .toolGroup {
      display: none;
      align-items: center;
      gap: 8px;
    }

    #navBar {
      position: absolute;
      left: 12px;
      bottom: 12px;
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 8px 10px;
      background: rgba(15,20,28,0.85);
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: 8px;
      backdrop-filter: blur(8px);
      z-index: 10;
    }

    #navBar button, #navBar input {
      background: #0f141c;
      color: var(--text);
      border: 1px solid rgba(255,255,255,0.12);
      border-radius: 6px;
      font-size: 13px;
    }

    #navBar .status {
      padding: 0 6px;
      font-size: 12px;
      color: var(--muted);
    }

    #navBar .mini {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      font-size: 12px;
      color: var(--muted);
    }

    #navBar .mini input {
      width: 14px;
      height: 14px;
      accent-color: var(--accent);
    }

    .panPad {
      display: grid;
      grid-template-columns: repeat(3, 28px);
      grid-template-rows: repeat(3, 28px);
      gap: 4px;
    }

    .panPad button {
      cursor: pointer;
      width: 28px;
      height: 28px;
      padding: 0;
      line-height: 1;
    }

    #sidebar {
      background: var(--panel);
      border-left: 1px solid rgba(255,255,255,0.08);
      padding: 12px;
      display: flex;
      flex-direction: column;
      gap: 12px;
    }
    section {
      background: var(--panel-2);
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: 10px;
      padding: 10px;
    }

    section h3 {
      margin: 0 0 8px 0;
      font-size: 13px;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: var(--muted);
    }

    .row {
      display: grid;
      grid-template-columns: 90px 1fr;
      gap: 6px;
      align-items: center;
      margin-bottom: 6px;
    }

    .row input, .row select, .row textarea {
      background: #0f141c;
      color: var(--text);
      border: 1px solid rgba(255,255,255,0.12);
      border-radius: 6px;
      padding: 6px 8px;
      font-size: 13px;
    }

    .row input[readonly] {
      opacity: 0.6;
    }

    #statusList {
      display: flex;
      flex-direction: column;
      gap: 6px;
      max-height: 240px;
      overflow: auto;
    }

    .statusItem {
      display: grid;
      grid-template-columns: 1fr auto;
      gap: 6px;
      align-items: center;
      padding: 6px 8px;
      border-radius: 8px;
      background: rgba(255,255,255,0.03);
      border: 1px solid rgba(255,255,255,0.06);
    }

    .statusItem .meta { color: var(--muted); font-size: 12px; }

    #inspectorEmpty {
      color: var(--muted);
      font-size: 13px;
    }

    .btnRow {
      display: flex;
      gap: 6px;
      margin-top: 6px;
    }

    .btnRow button {
      flex: 1;
      padding: 6px 8px;
      border-radius: 6px;
      border: 1px solid rgba(255,255,255,0.12);
      background: #0f141c;
      color: var(--text);
      cursor: pointer;
    }

    .warning {
      color: var(--danger);
      font-size: 12px;
    }
  </style>
</head>
<body>
  <div id="app">
    <div id="canvasWrap">
      <canvas id="map"></canvas>
      <div id="toolbar">
        <button id="toolSelect" class="toolBtn active">Select</button>
        <button id="toolRoom" class="toolBtn">Room</button>
        <button id="toolOpening" class="toolBtn">Opening</button>
        <button id="toolObject" class="toolBtn">Object</button>
        <button id="toolToken" class="toolBtn">Token</button>
        <label class="status">Layer</label>
        <select id="layerSelect">
          <option value="all" selected>all</option>
          <option value="floors">floors</option>
          <option value="walls">walls</option>
          <option value="objects">objects</option>
          <option value="tokens">tokens</option>
        </select>
        <label class="mini"><input type="checkbox" id="handlesToggle" /> Handles</label>
        <select id="floorSelect"></select>
        <button id="btnUndo">Undo</button>
        <label class="mini"><input type="checkbox" id="fogToggle" checked /> Fog</label>
        <button id="btnSave">Save</button>
        <span id="saveStatus" class="status">DB: idle</span>
        <div id="openingGroup" class="toolGroup">
          <label class="status">Opening</label>
          <select id="openingKind">
            <option value="door.wood">door.wood</option>
            <option value="door">door</option>
            <option value="window">window</option>
            <option value="threshold">threshold</option>
            <option value="portal">portal</option>
          </select>
          <button id="openingOrientH" class="toolBtn">H</button>
          <button id="openingOrientV" class="toolBtn">V</button>
        </div>
        <div id="objectGroup" class="toolGroup">
          <label class="status">Object</label>
          <select id="objectKind">
            <option value="object">object</option>
            <option value="poi.view">poi.view</option>
            <option value="table.round">table.round</option>
            <option value="table.rect">table.rect</option>
            <option value="chair">chair</option>
            <option value="crate">crate</option>
            <option value="barrel">barrel</option>
            <option value="stairs">stairs</option>
            <option value="bed">bed</option>
          </select>
        </div>
        <div id="tokenGroup" class="toolGroup">
          <label class="status">Token</label>
          <select id="tokenKind">
            <option value="pc">pc</option>
            <option value="npc" selected>npc</option>
            <option value="monster">monster</option>
            <option value="creature">creature</option>
          </select>
        </div>
      </div>
      <div id="navBar">
        <div class="panPad">
          <div></div>
          <button id="panUp" title="Pan up">↑</button>
          <div></div>
          <button id="panLeft" title="Pan left">←</button>
          <div></div>
          <button id="panRight" title="Pan right">→</button>
          <div></div>
          <button id="panDown" title="Pan down">↓</button>
          <div></div>
        </div>
        <label class="status">Zoom</label>
        <input id="zoom" type="range" min="0.25" max="4" step="0.05" value="1" />
        <label class="mini"><input type="checkbox" id="hexGridToggle" checked /> Hexgrid</label>
        <label class="mini"><input type="checkbox" id="labelBoldToggle" /> Bright Labels</label>
      </div>
    </div>

    <aside id="sidebar">
      <section>
        <h3>Status</h3>
        <div id="statusList"></div>
      </section>

      <section>
        <h3>Inspector</h3>
        <div id="inspectorEmpty">Select something to edit.</div>
        <div id="inspectorFields" hidden></div>
      </section>
    </aside>
  </div>
  <datalist id="floorKindList"></datalist>
  <datalist id="wallKindList"></datalist>
  <datalist id="openingKindList"></datalist>
  <datalist id="objectKindList"></datalist>
  <datalist id="tokenKindList"></datalist>

  <script>
    (() => {
      const canvas = document.getElementById('map');
      const canvasWrap = document.getElementById('canvasWrap');
      const ctx = canvas.getContext('2d');

      const toolButtons = {
        select: document.getElementById('toolSelect'),
        room: document.getElementById('toolRoom'),
        opening: document.getElementById('toolOpening'),
        object: document.getElementById('toolObject'),
        token: document.getElementById('toolToken'),
      };

      const floorSelect = document.getElementById('floorSelect');
      const layerSelect = document.getElementById('layerSelect');
      const openingKindSelect = document.getElementById('openingKind');
      const openingOrientH = document.getElementById('openingOrientH');
      const openingOrientV = document.getElementById('openingOrientV');
      const objectKindSelect = document.getElementById('objectKind');
      const tokenKindSelect = document.getElementById('tokenKind');
      const openingGroup = document.getElementById('openingGroup');
      const objectGroup = document.getElementById('objectGroup');
      const tokenGroup = document.getElementById('tokenGroup');
      const zoomInput = document.getElementById('zoom');
      const panUp = document.getElementById('panUp');
      const panDown = document.getElementById('panDown');
      const panLeft = document.getElementById('panLeft');
      const panRight = document.getElementById('panRight');
      const hexGridToggle = document.getElementById('hexGridToggle');
      const labelBoldToggle = document.getElementById('labelBoldToggle');
      const handlesToggle = document.getElementById('handlesToggle');
      const fogToggle = document.getElementById('fogToggle');
      const saveButton = document.getElementById('btnSave');
      const undoButton = document.getElementById('btnUndo');
      const saveStatus = document.getElementById('saveStatus');
      const statusList = document.getElementById('statusList');
      const inspectorEmpty = document.getElementById('inspectorEmpty');
      const inspectorFields = document.getElementById('inspectorFields');
      const floorKindList = document.getElementById('floorKindList');
      const wallKindList = document.getElementById('wallKindList');
      const openingKindList = document.getElementById('openingKindList');
      const objectKindList = document.getElementById('objectKindList');
      const tokenKindList = document.getElementById('tokenKindList');

      const GRID = {
        size: 32,
        lineAlpha: 0.16,
        lineWidth: 1.25,
        labelAlpha: 0.38,
        labelFont: '600 12px ui-sans-serif, system-ui, -apple-system, Segoe UI, sans-serif'
      };
      const VIEW = { camera: { col: 0, row: 0 }, cameraWorld: { x: 0, y: 0 }, zoom: 1, floorId: '' };
      const STATE = { battle: null, campaign: null, entities: [] };
      const UI = { hexGrid: true, brightLabels: false, showHandles: false, handleHot: false, fogEnabled: true };
      const EDITOR = {
        tool: 'select',
        selection: null,
        roomStart: null,
        roomHover: null,
        dirty: false,
        drag: null,
        ignoreClick: false,
        openingKind: 'door.wood',
        openingOrientation: 'h',
        objectKind: 'object',
        tokenKind: 'npc'
      };
      const HISTORY = { stack: [], index: -1, limit: 5 };

      const DEFAULT_FLOOR_KINDS = [
        'wood_oak', 'wood', 'stone', 'cobble', 'brick', 'brick_dark', 'gravel', 'fog'
      ];
      const DEFAULT_WALL_KINDS = [
        'brick', 'brick_dark', 'wood_dark', 'wood', 'stone', 'cobble', 'none'
      ];
      const DEFAULT_OPENING_KINDS = [
        'door.wood', 'door', 'window', 'threshold', 'portal'
      ];
      const DEFAULT_OBJECT_KINDS = [
        'object', 'poi.view', 'table.rect', 'table.round', 'table.sqr', 'table.hot', 'table.cold', 'table.prep',
        'chair', 'bed', 'bed.double', 'bath', 'chest', 'hearth', 'cooking.hearth', 'stairs',
        'crate', 'barrel', 'keg'
      ];
      const DEFAULT_TOKEN_KINDS = ['pc', 'npc', 'monster', 'creature'];

      // Floors under wall bands can hide cutouts; keep false unless you want that effect.
      const FLOOR_UNDER_WALLS = false;

      const OPENING_STYLE = {
        door: { len: 1.5, thick: 0.25, color: '#9a6b3a' },
        window: { len: 1.2, thick: 0.2, color: '#7aaad6' },
        threshold: { len: 1.4, thick: 0.12, color: '#6f7884' },
        portal: { len: 1.3, thick: 0.22, color: '#6fd3ff' }
      };

      const FLOOR_COLORS = {
        fog: '#0e1117',
        wood: '#2a1f17',
        wood_oak: '#3a2b1e',
        cobble: '#45474a',
        stone: '#3f3f3f',
        default: '#1a1f2a'
      };

      const WALL_COLORS = {
        brick: '#3d2b23',
        brick_dark: '#2c1e19',
        wood_dark: '#2b231a',
        none: 'transparent',
        default: '#2d2f33'
      };

      const TEXTURE_FILES = {
        wood_oak: '/assets/sprites/wood_oak.png',
        wood_elm: '/assets/sprites/wood_elm.png',
        wood_dark: '/assets/sprites/wood_dark.png',
        stone: '/assets/sprites/stone.png',
        stone_cobble: '/assets/sprites/stone_cobble.png',
        brick_gray: '/assets/sprites/brick_gray.png',
        brick_red: '/assets/sprites/brick_red.png',
        brick_dark: '/assets/sprites/brick_dark.png',
        crosskeys: '/images/the_cross_keys_floor.jpg'
      };

      const TEXTURE_SCALES = {
        wall: {
          wood_oak: 0.5,
          wood_elm: 0.5,
          wood_dark: 0.5,
          stone: 0.5,
          stone_cobble: 0.1,
          brick_gray: 0.15,
          brick_red: 0.15,
          brick_dark: 0.15,
        },
        floor: {
          wood_oak: 0.15,
          wood_elm: 0.15,
          wood_dark: 0.15,
          stone: 0.25,
          stone_cobble: 0.15,
          brick_gray: 0.15,
          brick_red: 0.15,
          brick_dark: 0.15,
          crosskeys: 1.0
        }
      };

      const TEXTURE_ALIASES = {
        wall: {
          brick: 'brick_gray',
          wood: 'wood_oak',
          cobble: 'stone_cobble',
          stone: 'stone',
          gravel: 'stone_cobble'
        },
        floor: {
          wood: 'wood_oak',
          stone: 'stone',
          cobble: 'stone_cobble',
          gravel: 'stone_cobble',
          brick: 'brick_gray'
        }
      };

      const SPRITE_MAP = {
        'poi.view': '/assets/sprites/cross_keys.png',
        'chair': '/assets/sprites/chair.png',
        'table.round': '/assets/sprites/table_round.png',
        'table.rect': '/assets/sprites/table_rectangle.png',
        'table.sqr': '/assets/sprites/table_square.png',
        'table.hot': '/assets/sprites/table_hot.png',
        'table.cold': '/assets/sprites/table_cold.png',
        'table.prep': '/assets/sprites/table_prep.png',
        'table.plate': '/assets/sprites/table_plate.png',
        'bed': '/assets/sprites/bed.png',
        'bed.double': '/assets/sprites/bed_double.png',
        'bath': '/assets/sprites/bath.png',
        'chest': '/assets/sprites/chest_closed.png',
        'hearth': '/assets/sprites/hearth.png',
        'cooking.hearth': '/assets/sprites/cooking_hearth.png',
        'stairs': '/assets/sprites/stairs.png',
        'stairs.up': '/assets/sprites/stairs_up.png',
        'stairs.down': '/assets/sprites/stairs_down.png',
        'crate': '/assets/sprites/crate.png',
        'barrel': '/assets/sprites/barrel.png',
        'keg': '/assets/sprites/keg.png'
      };

      function colStep() { return 1.5 * GRID.size; }
      function rowStep() { return Math.sqrt(3) * GRID.size; }

      function hexToWorld(col, row) {
        const x = col * colStep();
        const y = -(row * rowStep() + (col & 1) * (rowStep() / 2));
        return { x, y };
      }

      function getCameraWorld() {
        if (VIEW.cameraWorld && Number.isFinite(VIEW.cameraWorld.x) && Number.isFinite(VIEW.cameraWorld.y)) {
          return VIEW.cameraWorld;
        }
        return hexToWorld(VIEW.camera.col, VIEW.camera.row);
      }

      function setCameraWorld(p) {
        if (!p) return;
        VIEW.cameraWorld = { x: p.x, y: p.y };
      }

      function setCameraFromHex(p) {
        if (!p) return;
        const world = hexToWorld(p.col, p.row);
        VIEW.camera.col = p.col;
        VIEW.camera.row = p.row;
        setCameraWorld(world);
      }

      function worldToScreen(p) {
        const cam = getCameraWorld();
        const w = canvas.width / devicePixelRatio;
        const h = canvas.height / devicePixelRatio;
        return {
          x: w / 2 + (p.x - cam.x) * VIEW.zoom,
          y: h / 2 + (p.y - cam.y) * VIEW.zoom,
        };
      }

      function screenToWorld(x, y) {
        const cam = getCameraWorld();
        const w = canvas.width / devicePixelRatio;
        const h = canvas.height / devicePixelRatio;
        const wx = (x - w / 2) / VIEW.zoom + cam.x;
        const wy = (y - h / 2) / VIEW.zoom + cam.y;
        return { x: wx, y: wy };
      }

      function axialToCube(q, r) {
        return { x: q, z: r, y: -q - r };
      }

      function cubeRound(c) {
        let rx = Math.round(c.x);
        let ry = Math.round(c.y);
        let rz = Math.round(c.z);
        const dx = Math.abs(rx - c.x);
        const dy = Math.abs(ry - c.y);
        const dz = Math.abs(rz - c.z);
        if (dx > dy && dx > dz) rx = -ry - rz;
        else if (dy > dz) ry = -rx - rz;
        else rz = -rx - ry;
        return { x: rx, y: ry, z: rz };
      }

      function worldToHex(p) {
        const size = GRID.size || 1;
        const qf = (2 / 3) * (p.x / size);
        const rf = ((-p.y) / size) / Math.sqrt(3) - (qf / 2);
        const col = Math.round(qf);
        const rowf = rf + (col - (col & 1)) / 2;
        const row = Math.round(rowf);
        return { col, row };
      }

      function roundHalf(v) {
        return Math.round(v * 2) / 2;
      }

      function worldToHexHalf(p) {
        const size = GRID.size || 1;
        const qf = (2 / 3) * (p.x / size);
        const rf = ((-p.y) / size) / Math.sqrt(3) - (qf / 2);
        const col = Math.round(qf);
        const rowf = rf + (col - (col & 1)) / 2;
        const row = roundHalf(rowf);
        return { col, row };
      }

      function roundQuarter(v) {
        return Math.round(v * 4) / 4;
      }

      function formatStep(v) {
        const s = roundQuarter(v).toFixed(2);
        return s.replace(/\.00$/, '').replace(/(\.\d)0$/, '$1');
      }

      function openingHexFromWorld(p) {
        const size = GRID.size || 1;
        const qf = (2 / 3) * (p.x / size);
        const rf = ((-p.y) / size) / Math.sqrt(3) - (qf / 2);
        const col = Math.round(qf);
        const rowf = rf + (col - (col & 1)) / 2;
        const row = roundQuarter(rowf);
        return { col, row };
      }

      function openingHexLabelFromCoords(col, row) {
        if (!Number.isFinite(col) || !Number.isFinite(row)) return null;
        const rowNum = row + 1;
        return indexToLetters(col) + formatStep(rowNum);
      }

      function indexToLetters(idx) {
        let n = idx;
        let out = '';
        while (n >= 0) {
          out = String.fromCharCode(65 + (n % 26)) + out;
          n = Math.floor(n / 26) - 1;
        }
        return out;
      }

      function lettersToIndex(letters) {
        let n = 0;
        for (let i = 0; i < letters.length; i++) {
          n = n * 26 + (letters.charCodeAt(i) - 64);
        }
        return n - 1;
      }

      function toHexLabel(col, row) {
        return indexToLetters(col) + String(row + 1);
      }

      function parseHexLabel(label) {
        if (!label) return null;
        const m = String(label).trim().toUpperCase().match(/^([A-Z]+)(-?\d+(?:\.\d+)?)$/);
        if (!m) return null;
        const col = lettersToIndex(m[1]);
        const row = parseFloat(m[2]) - 1;
        return { col, row };
      }

      function getQueryParams() {
        return new URLSearchParams(window.location.search || '');
      }

      function getAuthHeaders() {
        const qp = getQueryParams();
        const token = (qp.get('token') || qp.get('auth') || qp.get('bearer') || '').trim();
        if (!token) return {};
        return { Authorization: 'Bearer ' + token };
      }

      function loadPrefs() {
        try {
          const grid = localStorage.getItem('bm_hexgrid');
          const bright = localStorage.getItem('bm_bright_labels');
          const handles = localStorage.getItem('bm_handles');
          const fog = localStorage.getItem('bm_fog');
          if (grid != null) UI.hexGrid = grid === '1';
          if (bright != null) UI.brightLabels = bright === '1';
          if (handles != null) UI.showHandles = handles === '1';
          if (fog != null) UI.fogEnabled = fog === '1';
        } catch {}
        if (hexGridToggle) hexGridToggle.checked = UI.hexGrid;
        if (labelBoldToggle) labelBoldToggle.checked = UI.brightLabels;
        if (handlesToggle) handlesToggle.checked = UI.showHandles;
        if (fogToggle) fogToggle.checked = UI.fogEnabled;
      }

      function savePrefs() {
        try {
          localStorage.setItem('bm_hexgrid', UI.hexGrid ? '1' : '0');
          localStorage.setItem('bm_bright_labels', UI.brightLabels ? '1' : '0');
          localStorage.setItem('bm_handles', UI.showHandles ? '1' : '0');
          localStorage.setItem('bm_fog', UI.fogEnabled ? '1' : '0');
        } catch {}
      }

      function setTool(tool) {
        EDITOR.tool = tool;
        Object.entries(toolButtons).forEach(([key, btn]) => {
          if (!btn) return;
          btn.classList.toggle('active', key === tool);
        });
        EDITOR.roomStart = null;
        if (openingGroup) openingGroup.style.display = tool === 'opening' ? 'flex' : 'none';
        if (objectGroup) objectGroup.style.display = tool === 'object' ? 'flex' : 'none';
        if (tokenGroup) tokenGroup.style.display = tool === 'token' ? 'flex' : 'none';
        if (canvasWrap) canvasWrap.style.cursor = tool === 'room' ? 'crosshair' : 'default';
      }

      function drawHexOutline(gctx, center, size) {
        const pts = [];
        for (let i = 0; i < 6; i++) {
          const a = (Math.PI / 180) * (60 * i);
          pts.push({ x: center.x + size * Math.cos(a), y: center.y + size * Math.sin(a) });
        }
        gctx.beginPath();
        gctx.moveTo(pts[0].x, pts[0].y);
        for (let i = 1; i < pts.length; i++) gctx.lineTo(pts[i].x, pts[i].y);
        gctx.closePath();
        gctx.stroke();
      }

      function drawGridLayer(gctx) {
        if (!UI.hexGrid) return;
        const rect = canvas.getBoundingClientRect();
        const w = Math.max(1, rect.width);
        const h = Math.max(1, rect.height);
        const camHex = worldToHex(getCameraWorld());
        const colsR = Math.ceil((w / 2) / colStep()) + 4;
        const rowsR = Math.ceil((h / 2) / rowStep()) + 4;

        gctx.save();
        gctx.strokeStyle = `rgba(255,255,255,${GRID.lineAlpha})`;
        gctx.lineWidth = GRID.lineWidth;
        const size = GRID.size * VIEW.zoom;

        for (let dc = -colsR; dc <= colsR; dc++) {
          for (let dr = -rowsR; dr <= rowsR; dr++) {
            const col = camHex.col + dc;
            const row = camHex.row + dr;
            const p = worldToScreen(hexToWorld(col, row));
            if (p.x < -100 || p.x > w + 100 || p.y < -100 || p.y > h + 100) continue;
            drawHexOutline(gctx, p, size);
          }
        }

        const bright = !!UI.brightLabels;
        gctx.globalAlpha = bright ? 1 : GRID.labelAlpha;
        gctx.fillStyle = bright ? 'rgba(233,238,247,0.96)' : 'rgba(233,238,247,0.65)';
        const fontScale = Math.min(1.6, VIEW.zoom);
        const fontSize = Math.min(18, (bright ? 13 : 11) * fontScale);
        gctx.font = bright
          ? `900 ${fontSize}px ui-sans-serif, system-ui, -apple-system, Segoe UI, sans-serif`
          : `600 ${fontSize}px ui-sans-serif, system-ui, -apple-system, Segoe UI, sans-serif`;
        gctx.textAlign = 'center';
        gctx.textBaseline = 'middle';

        if (bright) {
          gctx.lineWidth = 3;
          gctx.strokeStyle = 'rgba(0,0,0,0.70)';
          gctx.lineJoin = 'round';
        }

        for (let dc = -colsR; dc <= colsR; dc++) {
          for (let dr = -rowsR; dr <= rowsR; dr++) {
            const col = camHex.col + dc;
            const row = camHex.row + dr;
            const p = worldToScreen(hexToWorld(col, row));
            if (p.x < -100 || p.x > w + 100 || p.y < -100 || p.y > h + 100) continue;
            const label = toHexLabel(col, row);
            const lx = p.x;
            const ly = p.y + 2;
            if (bright) gctx.strokeText(label, lx, ly);
            gctx.fillText(label, lx, ly);
          }
        }

        gctx.restore();
      }

      function drawHandle(gctx, center, size) {
        const r = size;
        gctx.beginPath();
        gctx.arc(center.x, center.y, r, 0, Math.PI * 2);
        gctx.stroke();
        gctx.beginPath();
        gctx.moveTo(center.x - r * 1.6, center.y);
        gctx.lineTo(center.x + r * 1.6, center.y);
        gctx.moveTo(center.x, center.y - r * 1.6);
        gctx.lineTo(center.x, center.y + r * 1.6);
        gctx.stroke();
      }

      function drawHandlesLayer(floor, gctx) {
        const show = UI.showHandles || UI.handleHot;
        if (!show || !floor) return;
        const objects = filterAlive(floor.objects || []);
        if (!objects.length) return;
        gctx.save();
        gctx.strokeStyle = 'rgba(255,145,0,0.9)';
        gctx.lineWidth = 1.5;
        const size = Math.max(4, Math.min(10, 6 * VIEW.zoom));
        for (const obj of objects) {
          const world = objectWorldCenter(obj);
          if (!world) continue;
          const center = worldToScreen(world);
          drawHandle(gctx, center, size);
        }
        gctx.restore();
      }

      function drawRoomPreview(gctx) {
        if (EDITOR.tool !== 'room' || !EDITOR.roomStart || !EDITOR.roomHover) return;
        const start = EDITOR.roomStart;
        const end = EDITOR.roomHover;
        const minCol = Math.min(start.col, end.col);
        const maxCol = Math.max(start.col, end.col);
        const minRow = Math.min(start.row, end.row);
        const maxRow = Math.max(start.row, end.row);
        const tl = hexToWorld(minCol, maxRow);
        const br = hexToWorld(maxCol, minRow);
        const p1 = worldToScreen(tl);
        const p2 = worldToScreen(br);
        const x1 = Math.min(p1.x, p2.x);
        const y1 = Math.min(p1.y, p2.y);
        const x2 = Math.max(p1.x, p2.x);
        const y2 = Math.max(p1.y, p2.y);

        gctx.save();
        gctx.strokeStyle = 'rgba(88, 220, 120, 0.9)';
        gctx.lineWidth = 2;
        gctx.setLineDash([6, 6]);
        gctx.strokeRect(x1, y1, x2 - x1, y2 - y1);
        gctx.restore();
      }

      function clampZoom(value) {
        const min = zoomInput ? Number(zoomInput.min) : 0.25;
        const max = zoomInput ? Number(zoomInput.max) : 4;
        if (!Number.isFinite(min) || !Number.isFinite(max)) return value;
        return Math.max(min, Math.min(max, value));
      }

      function setZoom(value) {
        const next = clampZoom(value);
        VIEW.zoom = next;
        if (zoomInput) zoomInput.value = String(next);
        render();
      }

      function normalizeState(state) {
        if (!state || typeof state !== 'object') return { floors: [] };
        if (!Array.isArray(state.floors)) {
          const floorId = state.view && state.view.floorId ? String(state.view.floorId) : 'ground';
          state.floors = [{
            id: floorId,
            name: floorId,
            rooms: Array.isArray(state.rooms) ? state.rooms : [],
            openings: Array.isArray(state.openings) ? state.openings : [],
            objects: Array.isArray(state.objects) ? state.objects : []
          }];
        }
        for (const floor of state.floors) {
          if (!floor || typeof floor !== 'object') continue;
          floor.id = String(floor.id || 'floor');
          if (!Array.isArray(floor.rooms)) floor.rooms = [];
          if (!Array.isArray(floor.openings)) floor.openings = [];
          if (!Array.isArray(floor.objects)) floor.objects = [];
          for (const obj of floor.objects) {
            if (obj && obj.floorId == null) obj.floorId = floor.id;
          }
        }
        return state;
      }

      function extractScene(raw) {
        if (!raw || typeof raw !== 'object') return { scene: { floors: [] }, wrapper: null, recordId: '' };
        if (raw.records && typeof raw.records === 'object') {
          const activeId = raw.active && raw.active.recordId ? String(raw.active.recordId) : '';
          let recordId = activeId;
          let scene = recordId && raw.records[recordId] ? raw.records[recordId] : null;
          if (!scene) {
            const keys = Object.keys(raw.records);
            if (keys.length) {
              recordId = keys[0];
              scene = raw.records[recordId];
            }
          }
          if (!scene || typeof scene !== 'object') return { scene: { floors: [] }, wrapper: raw, recordId: recordId || '' };
          return { scene, wrapper: raw, recordId: recordId || '' };
        }
        return { scene: raw, wrapper: null, recordId: '' };
      }

      function applyViewFromState(scene) {
        const view = scene && scene.view ? scene.view : {};
        const floorId = view.floorId || view.floor_id || view.floor || null;
        if (floorId) VIEW.floorId = String(floorId);
        const camHex = view.camera_hex || view.cameraHex || null;
        if (camHex) {
          const p = parseHexLabel(camHex);
          if (p) setCameraFromHex(p);
        }
      }

      function resolveBattleId() {
        const qp = getQueryParams();
        return qp.get('battle_id') || qp.get('battleId') || qp.get('id');
      }

      async function loadBattle() {
        const battleId = resolveBattleId();
        if (!battleId) throw new Error('Missing battle_id');

        const isLocal = ['localhost', '127.0.0.1'].includes(window.location.hostname);
        const qp = getQueryParams();
        const devStateUrl = isLocal ? (qp.get('dev_state') || qp.get('state_url') || '') : '';
        if (devStateUrl) {
          const res = await fetch(devStateUrl, { cache: 'no-store' });
          if (!res.ok) throw new Error('Dev state load failed');
          const raw = await res.json();
          const extracted = extractScene(raw);
          STATE.wrapper = extracted.wrapper;
          STATE.recordId = extracted.recordId;
          STATE.battle = normalizeState(extracted.scene);
          applyViewFromState(STATE.battle);
          return;
        }

        const res = await fetch(`/api/battles/${encodeURIComponent(battleId)}`, {
          headers: { 'accept': 'application/json', ...getAuthHeaders() }
        });
        if (!res.ok) throw new Error('Battle load failed');
        const data = await res.json();
        const raw = data && data.state_json ? JSON.parse(data.state_json) : data;
        const extracted = extractScene(raw);
        STATE.wrapper = extracted.wrapper;
        STATE.recordId = extracted.recordId;
        STATE.battle = normalizeState(extracted.scene);
        applyViewFromState(STATE.battle);
        STATE.battle._battle_id = data.battle_id || battleId;
        STATE.battle._campaign_id = data.campaign_id || data.campaignId || null;
      }

      function getCampaignId() {
        return STATE.battle && (STATE.battle._campaign_id || STATE.battle.campaign_id || STATE.battle.campaignId) || null;
      }

      async function loadCampaign() {
        const cid = getCampaignId();
        if (!cid) return;
        const res = await fetch(`/api/campaigns/${encodeURIComponent(cid)}`, {
          headers: { 'accept': 'application/json', ...getAuthHeaders() }
        });
        if (!res.ok) return;
        const data = await res.json();
        let meta = data.meta_json || data.metaJson || null;
        if (typeof meta === 'string') {
          try { meta = JSON.parse(meta); } catch { meta = null; }
        }
        STATE.campaign = meta || {};
        STATE.entities = (STATE.campaign.world && Array.isArray(STATE.campaign.world.entities))
          ? STATE.campaign.world.entities
          : [];
      }

      function resolvePoiId() {
        const campaign = STATE.campaign || {};
        const index = campaign.poi_index || (campaign.world && campaign.world.poi_index) || null;
        const bid = STATE.battle && STATE.battle._battle_id;
        if (!index || !bid) return '';
        for (const [poi, battleId] of Object.entries(index)) {
          if (String(battleId) === String(bid)) return String(poi);
        }
        return '';
      }

      function buildTokens() {
        const poiId = resolvePoiId();
        const entities = Array.isArray(STATE.entities) ? STATE.entities : [];
        return entities
          .filter(e => e && !e.deleted && (!e.poi_id || e.poi_id === poiId))
          .map(e => {
            const loc = e.location || e.position || {};
            const hex = e.hex || loc.hex || '';
            const floorId = e.floorId || loc.floorId || loc.floor_id || e.floor_id || '';
            return {
              id: String(e.id || e.character_id || ''),
              name: e.name || e.label || e.title || e.id,
              hex,
              floorId,
              kind: e.kind || 'pc',
              hp: e.hp || (e.stats && e.stats.hp) || null,
              init: e.init || (e.stats && e.stats.init) || null,
              side: e.side || (e.kind === 'npc' ? 'NPC' : 'PC'),
              __entity: e
            };
          });
      }
      function renderStatus() {
        statusList.innerHTML = '';
        const tokens = buildTokens();
        for (const t of tokens) {
          const div = document.createElement('div');
          div.className = 'statusItem';
          div.innerHTML = `<div><strong>${t.name || t.id}</strong><div class="meta">${t.floorId || ''}</div></div><div class="meta">${t.hp != null ? t.hp : '-'} / ${t.init != null ? t.init : '-'}</div>`;
          statusList.appendChild(div);
        }
      }

      function setFloorOptions() {
        floorSelect.innerHTML = '';
        const floors = STATE.battle ? STATE.battle.floors : [];
        floors.forEach(f => {
          const opt = document.createElement('option');
          opt.value = f.id;
          opt.textContent = f.name || f.id;
          floorSelect.appendChild(opt);
        });
        if (!VIEW.floorId && floors[0]) VIEW.floorId = floors[0].id;
        floorSelect.value = VIEW.floorId;
      }

      function pickFloor() {
        const floors = STATE.battle ? STATE.battle.floors : [];
        return floors.find(f => f.id === VIEW.floorId) || floors[0];
      }

      function autoCenterCamera() {
        if (!STATE.battle) return;
        const view = STATE.battle.view || {};
        if (view.camera_hex || view.cameraHex) return;
        const floor = pickFloor();
        if (!floor) return;
        let target = null;
        if (Array.isArray(floor.rooms) && floor.rooms.length) {
          const labels = roomPointLabels(floor.rooms[0]);
          const pts = labels.map(parseHexLabel).filter(Boolean);
          if (pts.length) {
            const avg = pts.reduce((acc, p) => ({ col: acc.col + p.col, row: acc.row + p.row }), { col: 0, row: 0 });
            target = { col: avg.col / pts.length, row: avg.row / pts.length };
          }
        }
        if (!target && Array.isArray(floor.objects) && floor.objects.length) {
          target = parseHexLabel(floor.objects[0].hex);
        }
        if (!target) {
          const tokens = buildTokens();
          if (tokens.length) target = parseHexLabel(tokens[0].hex);
        }
        if (target) setCameraFromHex({ col: Math.round(target.col), row: Math.round(target.row) });
      }

      function nudgeCamera(dxWorld, dyWorld) {
        const cam = getCameraWorld();
        const next = { x: cam.x + dxWorld, y: cam.y + dyWorld };
        setCameraWorld(next);
        render();
      }

      function roomWallKind(room) {
        const wall = room && room.wall && typeof room.wall === 'object' ? room.wall : null;
        const kind = wall && wall.kind != null ? String(wall.kind) : '';
        const type = wall && wall.type != null ? String(wall.type) : '';
        return (kind || type || 'brick').toLowerCase();
      }

      function roomHasWalls(room) {
        const thickness = Number(room && room.thickness != null ? room.thickness : 0);
        return thickness > 0 && roomWallKind(room) !== 'none';
      }

      function roomPointLabels(room) {
        if (!room || typeof room !== 'object') return [];
        const points = Array.isArray(room.points) ? room.points
          : (Array.isArray(room.poly) ? room.poly : (Array.isArray(room.vertices) ? room.vertices : null));
        if (Array.isArray(points) && points.length >= 3) return points;
        const corners = Array.isArray(room.corners) ? room.corners : [];
        return corners.length >= 3 ? corners : [];
      }

      function isPolyRoom(room) {
        if (!room || typeof room !== 'object') return false;
        const points = Array.isArray(room.points) ? room.points
          : (Array.isArray(room.poly) ? room.poly : (Array.isArray(room.vertices) ? room.vertices : null));
        return Array.isArray(points) && points.length >= 3;
      }

      function roomWorldPoints(room) {
        const labels = roomPointLabels(room);
        if (!labels.length) return [];
        const pts = [];
        for (const label of labels) {
          const parsed = parseHexLabel(label);
          if (!parsed) continue;
          pts.push(hexToWorld(parsed.col, parsed.row));
        }
        return pts;
      }

      function roomPolygonScreen(room) {
        const pts = roomWorldPoints(room);
        if (pts.length < 3) return null;
        return pts.map(worldToScreen);
      }

      function roomToWallBox(room) {
        if (isPolyRoom(room)) return null;
        const corners = Array.isArray(room && room.corners) ? room.corners : [];
        if (corners.length !== 4) return null;
        const tl = parseHexLabel(corners[0]);
        const tr = parseHexLabel(corners[1]);
        const br = parseHexLabel(corners[2]);
        const bl = parseHexLabel(corners[3]);
        if (!tl || !tr || !br || !bl) return null;

        const pTL = hexToWorld(tl.col, tl.row);
        const pTR = hexToWorld(tr.col, tr.row);
        const pBR = hexToWorld(br.col, br.row);
        const pBL = hexToWorld(bl.col, bl.row);

        const xL = (pTL.x + pBL.x) / 2;
        const xR = (pTR.x + pBR.x) / 2;
        const yTop = (pTL.y + pTR.y) / 2;
        const yBot = (pBL.y + pBR.y) / 2;

        const thicknessBase = Number(room && room.thickness != null ? room.thickness : 0);
        const t = roomHasWalls(room) ? thicknessBase : 0;
        const half = t / 2;

        // Treat corners as the wall centerline. Expand outward for wall band.
        const center = { x1: xL, y1: yTop, x2: xR, y2: yBot };
        const outer = { x1: xL - half, y1: yTop - half, x2: xR + half, y2: yBot + half };
        const inner = { x1: xL + half, y1: yTop + half, x2: xR - half, y2: yBot - half };

        return { xL, xR, yTop, yBot, thickness: t, center, outer, inner };
      }

      function roomFloorRectWorld(room, box) {
        if (!box) return null;
        const src = roomHasWalls(room) ? box.inner : box.center;
        return { x1: src.x1, y1: src.y1, x2: src.x2, y2: src.y2 };
      }

      function formatRoomPoints(room) {
        const labels = roomPointLabels(room);
        return labels.map(l => String(l).trim()).filter(Boolean).join(', ');
      }

      function cloneValue(value) {
        if (typeof structuredClone === 'function') return structuredClone(value);
        return JSON.parse(JSON.stringify(value));
      }

      function snapshotState() {
        return {
          battle: cloneValue(STATE.battle),
          entities: cloneValue(STATE.entities)
        };
      }

      function restoreState(snapshot) {
        if (!snapshot) return;
        STATE.battle = snapshot.battle ? cloneValue(snapshot.battle) : STATE.battle;
        STATE.entities = snapshot.entities ? cloneValue(snapshot.entities) : STATE.entities;
        setFloorOptions();
        renderStatus();
        render();
      }

      function pushHistory() {
        const snap = snapshotState();
        if (HISTORY.index < HISTORY.stack.length - 1) {
          HISTORY.stack = HISTORY.stack.slice(0, HISTORY.index + 1);
        }
        HISTORY.stack.push(snap);
        if (HISTORY.stack.length > HISTORY.limit) {
          HISTORY.stack.shift();
        }
        HISTORY.index = HISTORY.stack.length - 1;
        updateUndoButton();
      }

      function canUndo() {
        return HISTORY.index > 0;
      }

      function undo() {
        if (!canUndo()) return;
        HISTORY.index -= 1;
        restoreState(HISTORY.stack[HISTORY.index]);
        if (saveStatus) saveStatus.textContent = 'DB: idle';
        updateUndoButton();
      }

      function updateUndoButton() {
        if (undoButton) undoButton.disabled = !canUndo();
      }

      function parsePointList(text) {
        const raw = String(text || '')
          .split(',')
          .map(t => t.trim())
          .filter(Boolean);
        const out = [];
        for (const entry of raw) {
          const parsed = parseHexLabel(entry);
          if (!parsed) continue;
          out.push(entry.toUpperCase());
        }
        return out;
      }

      function buildWallSegments(rooms) {
        const segs = [];
        for (const room of filterAlive(rooms)) {
          const box = roomToWallBox(room);
          if (!box) continue;
          const t = Number.isFinite(box.thickness) ? box.thickness : 0;
          segs.push({ orientation: 'h', y: box.yTop, x1: box.xL, x2: box.xR, thickness: t });
          segs.push({ orientation: 'h', y: box.yBot, x1: box.xL, x2: box.xR, thickness: t });
          segs.push({ orientation: 'v', x: box.xL, y1: box.yTop, y2: box.yBot, thickness: t });
          segs.push({ orientation: 'v', x: box.xR, y1: box.yTop, y2: box.yBot, thickness: t });
        }
        return segs;
      }

      function wallSegDistance2(seg, p) {
        if (!seg || !p) return Infinity;
        if (seg.orientation === 'h') {
          const dy = Math.abs(p.y - seg.y);
          let dx = 0;
          if (p.x < seg.x1) dx = seg.x1 - p.x;
          else if (p.x > seg.x2) dx = p.x - seg.x2;
          return dx * dx + dy * dy;
        }
        const dx = Math.abs(p.x - seg.x);
        let dy = 0;
        if (p.y < seg.y1) dy = seg.y1 - p.y;
        else if (p.y > seg.y2) dy = p.y - seg.y2;
        return dx * dx + dy * dy;
      }

      function projectToWall(seg, p) {
        if (!seg || !p) return null;
        if (seg.orientation === 'h') {
          const x = Math.min(seg.x2, Math.max(seg.x1, p.x));
          return { x, y: seg.y };
        }
        const y = Math.min(seg.y2, Math.max(seg.y1, p.y));
        return { x: seg.x, y };
      }

      function snapWorldToWall(worldPoint, floor, orientation) {
        const want = orientation === 'v' ? 'v' : 'h';
        const segs = buildWallSegments(floor ? floor.rooms : []);
        let best = null;
        let bestD2 = Infinity;
        for (const seg of segs) {
          if (!seg || seg.orientation !== want) continue;
          const d2 = wallSegDistance2(seg, worldPoint);
          if (d2 < bestD2) {
            bestD2 = d2;
            best = seg;
          }
        }
        if (!best) return worldPoint;
        return projectToWall(best, worldPoint) || worldPoint;
      }

      function roomRectScreen(room) {
        const box = roomToWallBox(room);
        if (!box) return null;
        const rect = roomFloorRectWorld(room, box);
        if (!rect) return null;
        const p1 = worldToScreen({ x: rect.x1, y: rect.y1 });
        const p2 = worldToScreen({ x: rect.x2, y: rect.y2 });
        return {
          x1: Math.min(p1.x, p2.x),
          y1: Math.min(p1.y, p2.y),
          x2: Math.max(p1.x, p2.x),
          y2: Math.max(p1.y, p2.y),
          box
        };
      }

      function openingAllowsCutout(opening) {
        const flag = opening && (opening.cutout ?? opening.cutoutMode ?? opening.cutout_mode);
        if (flag === false) return false;
        if (flag == null) return true;
        const val = String(flag).toLowerCase();
        return val !== 'none' && val !== 'off' && val !== 'false';
      }

      function roomOuterRectWorld(room, box) {
        if (!box) return null;
        const src = roomHasWalls(room) ? (box.outer || box.center) : box.center;
        return { x1: src.x1, y1: src.y1, x2: src.x2, y2: src.y2 };
      }

      function drawFloorRoom(room, gctx) {
        if (isPolyRoom(room)) {
          const pts = roomWorldPoints(room);
          if (pts.length < 3) return;
          const screenPts = pts.map(worldToScreen);
          const fk = room.floor && room.floor.kind ? String(room.floor.kind) : 'default';
          const floorColor = FLOOR_COLORS[fk] || FLOOR_COLORS.default;
          const floorAnchor = pts[0];
          const fill = getFillStyle(gctx, 'floor', fk, floorColor, floorAnchor, { allowFallback: false });
          if (!fill) return;
          gctx.save();
          gctx.fillStyle = fill;
          gctx.beginPath();
          gctx.moveTo(screenPts[0].x, screenPts[0].y);
          for (let i = 1; i < screenPts.length; i++) gctx.lineTo(screenPts[i].x, screenPts[i].y);
          gctx.closePath();
          gctx.fill();
          gctx.restore();
          return;
        }
        const box = roomToWallBox(room);
        if (!box) return;
        const rect = FLOOR_UNDER_WALLS
          ? roomOuterRectWorld(room, box)
          : (box.center || roomFloorRectWorld(room, box));
        if (!rect) return;
        const p1 = worldToScreen({ x: rect.x1, y: rect.y1 });
        const p2 = worldToScreen({ x: rect.x2, y: rect.y2 });
        const x1 = Math.min(p1.x, p2.x);
        const y1 = Math.min(p1.y, p2.y);
        const x2 = Math.max(p1.x, p2.x);
        const y2 = Math.max(p1.y, p2.y);

        const fk = room.floor && room.floor.kind ? String(room.floor.kind) : 'default';
        const floorColor = FLOOR_COLORS[fk] || FLOOR_COLORS.default;
        const floorAnchor = { x: rect.x1, y: rect.y1 };
        const fill = getFillStyle(gctx, 'floor', fk, floorColor, floorAnchor, { allowFallback: false });
        if (!fill) return;
        gctx.fillStyle = fill;
        gctx.globalAlpha = 1;
        gctx.fillRect(x1, y1, x2 - x1, y2 - y1);
      }

      function drawFloorsLayer(floor, gctx, rooms) {
        const list = sortByZ(rooms || filterAlive(floor.rooms || []));
        list.forEach(room => drawFloorRoom(room, gctx));
      }

      function wallThicknessAtWorld(worldPoint, floor) {
        const segs = buildWallSegments(floor ? floor.rooms : []);
        let best = null;
        let bestD2 = Infinity;
        for (const seg of segs) {
          const d2 = wallSegDistance2(seg, worldPoint);
          if (d2 < bestD2) {
            bestD2 = d2;
            best = seg;
          }
        }
        return best && Number.isFinite(best.thickness) ? best.thickness : 0;
      }

      function openingCutoutRectsForFloor(floor, rooms, roomSets) {
        if (!floor || !Array.isArray(floor.openings)) return [];
        const out = [];
        for (const opening of filterAlive(floor.openings)) {
          if (!openingAllowsCutout(opening)) continue;
          if (roomSets && rooms) {
            const state = itemFogState(opening, floor, rooms, roomSets, openingWorldCenter);
            if (state === 'hidden') continue;
          }
          const world = openingWorldCenter(opening, floor);
          if (!world) continue;
          const orient = opening.orientation === 'v' ? 'v' : 'h';
          const kindRaw = String(opening.kind || '').toLowerCase();
          const kind =
            kindRaw.startsWith('window') ? 'window' :
            kindRaw.startsWith('portal') ? 'portal' :
            kindRaw.startsWith('threshold') ? 'threshold' : 'door';
          const style = OPENING_STYLE[kind] || OPENING_STYLE.door;
          const lenUnits = Number.isFinite(Number(opening.len ?? opening.length ?? opening.size))
            ? Number(opening.len ?? opening.length ?? opening.size)
            : style.len;
          const thickUnits = Number.isFinite(Number(opening.thick ?? opening.thickness))
            ? Number(opening.thick ?? opening.thickness)
            : style.thick;
          const len = GRID.size * lenUnits * VIEW.zoom;
          const thick = GRID.size * thickUnits * VIEW.zoom;
          const wallThickWorld = wallThicknessAtWorld(world, floor);
          const baseWallWorld = wallThickWorld > 0 ? wallThickWorld : (GRID.size * thickUnits);
          const center = worldToScreen(world);
          const cutLen = len * 1.1;
          const cutThick = baseWallWorld * VIEW.zoom * 1.1;
          const w = orient === 'v' ? cutThick : cutLen;
          const h = orient === 'v' ? cutLen : cutThick;
          out.push({ center, w, h });
        }
        return out;
      }

      function drawWallsLayer(floor, gctx, rooms, roomSets) {
        const list = sortByZ(rooms || filterAlive(floor.rooms || []));
        for (const room of list) {
          if (isPolyRoom(room)) {
            if (!roomHasWalls(room)) continue;
            const pts = roomWorldPoints(room);
            if (pts.length < 3) continue;
            const screenPts = pts.map(worldToScreen);
            const wk = roomWallKind(room);
            const wallColor = WALL_COLORS[wk] || WALL_COLORS.default;
            const wallAnchor = pts[0];
            const fill = getFillStyle(gctx, 'wall', wk, wallColor, wallAnchor, { allowFallback: false });
            if (!fill) continue;
            const thickness = Number(room.thickness || 0);
            const lineW = Math.max(1, thickness * VIEW.zoom);
            gctx.save();
            gctx.strokeStyle = fill;
            gctx.lineWidth = lineW;
            gctx.lineJoin = 'miter';
            gctx.beginPath();
            gctx.moveTo(screenPts[0].x, screenPts[0].y);
            for (let i = 1; i < screenPts.length; i++) gctx.lineTo(screenPts[i].x, screenPts[i].y);
            gctx.closePath();
            gctx.stroke();
            gctx.restore();
            continue;
          }
          const box = roomToWallBox(room);
          if (!box || !roomHasWalls(room)) continue;
          const outer = box.outer || box.center;
          const inner = box.inner || box.center;
          const o1 = worldToScreen({ x: outer.x1, y: outer.y1 });
          const o2 = worldToScreen({ x: outer.x2, y: outer.y2 });
          const i1 = worldToScreen({ x: inner.x1, y: inner.y1 });
          const i2 = worldToScreen({ x: inner.x2, y: inner.y2 });
          const ox1 = Math.min(o1.x, o2.x);
          const oy1 = Math.min(o1.y, o2.y);
          const ow = Math.abs(o2.x - o1.x);
          const oh = Math.abs(o2.y - o1.y);
          const ix1 = Math.min(i1.x, i2.x);
          const iy1 = Math.min(i1.y, i2.y);
          const iw = Math.abs(i2.x - i1.x);
          const ih = Math.abs(i2.y - i1.y);
          const wk = roomWallKind(room);
          const wallColor = WALL_COLORS[wk] || WALL_COLORS.default;
          const wallAnchor = { x: outer.x1, y: outer.y1 };
          const fill = getFillStyle(gctx, 'wall', wk, wallColor, wallAnchor, { allowFallback: false });
          if (!fill) continue;
          gctx.fillStyle = fill;
          gctx.beginPath();
          gctx.rect(ox1, oy1, ow, oh);
          gctx.rect(ix1, iy1, iw, ih);
          gctx.fill('evenodd');
        }

        const cutouts = openingCutoutRectsForFloor(floor, rooms || filterAlive(floor.rooms || []), roomSets);
        if (cutouts.length) {
          gctx.save();
          gctx.globalCompositeOperation = 'destination-out';
          for (const cut of cutouts) {
            gctx.fillRect(cut.center.x - cut.w / 2, cut.center.y - cut.h / 2, cut.w, cut.h);
          }
          gctx.restore();
        }
      }

      function roomAnchorWorld(room) {
        const box = roomToWallBox(room);
        if (!box) return null;
        const src = roomHasWalls(room) ? box.inner : box.center;
        return { x: src.x1, y: src.y1 };
      }

      function roomCenterWorld(room) {
        const box = roomToWallBox(room);
        if (!box) return null;
        const src = roomHasWalls(room) ? box.inner : box.center;
        return { x: (src.x1 + src.x2) / 2, y: (src.y1 + src.y2) / 2 };
      }

      function seamAnchorWorld(opening, floor, seamKind, openingWorld) {
        const anchorId = opening.seam_anchor || opening.seamAnchor || opening.seam_room || opening.seamRoom || '';
        if (floor && Array.isArray(floor.rooms) && anchorId) {
          const room = floor.rooms.find(r => r && r.id === anchorId);
          const anchor = room ? roomAnchorWorld(room) : null;
          if (anchor) return anchor;
        }

        const targetKind = String(seamKind || '').toLowerCase();
        if (!floor || !Array.isArray(floor.rooms) || !targetKind || !openingWorld) return { x: 0, y: 0 };
        let bestRoom = null;
        let bestD2 = Infinity;
        for (const room of floor.rooms) {
          const fk = room && room.floor && room.floor.kind ? String(room.floor.kind).toLowerCase() : '';
          if (!fk) continue;
          if (fk !== targetKind) continue;
          const center = roomCenterWorld(room);
          if (!center) continue;
          const dx = center.x - openingWorld.x;
          const dy = center.y - openingWorld.y;
          const d2 = dx * dx + dy * dy;
          if (d2 < bestD2) {
            bestD2 = d2;
            bestRoom = room;
          }
        }
        const anchor = bestRoom ? roomAnchorWorld(bestRoom) : null;
        return anchor || { x: 0, y: 0 };
      }

      function openingWorldCenter(opening, floor) {
        const p = parseHexLabel(opening.hex);
        if (!p) return null;
        const world = hexToWorld(p.col, p.row);
        const orient = opening && opening.orientation === 'v' ? 'v' : 'h';
        return snapWorldToWall(world, floor, orient);
      }

      function openingFogState(opening, floor, rooms, roomSets) {
        if (!UI.fogEnabled) return 'visible';
        const world = openingWorldCenter(opening, floor);
        if (!world) return 'visible';
        const orient = opening && opening.orientation === 'v' ? 'v' : 'h';
        const offset = GRID.size * 0.35;
        const dx = orient === 'v' ? offset : 0;
        const dy = orient === 'v' ? 0 : offset;
        const a = { x: world.x + dx, y: world.y + dy };
        const b = { x: world.x - dx, y: world.y - dy };
        const roomA = findRoomForWorldPoint(rooms, a);
        const roomB = findRoomForWorldPoint(rooms, b);
        const stateForRoom = (room) => {
          if (!room || room.id == null) return 'visible';
          const id = String(room.id);
          if (roomSets.visible && roomSets.visible.has(id)) return 'visible';
          if (roomSets.explored && roomSets.explored.has(id)) return 'explored';
          if (roomSets.hidden && roomSets.hidden.has(id)) return 'hidden';
          return 'visible';
        };
        const sA = stateForRoom(roomA);
        const sB = stateForRoom(roomB);
        if (sA === 'visible' || sB === 'visible') return 'visible';
        if (sA === 'explored' || sB === 'explored') return 'explored';
        return 'hidden';
      }

      function drawOpening(opening, floor, gctx, fogState) {
        const world = openingWorldCenter(opening, floor);
        if (!world) return;
        const center = worldToScreen(world);
        const orient = opening.orientation === 'v' ? 'v' : 'h';
        const kindRaw = String(opening.kind || '').toLowerCase();
        const kind =
          kindRaw.startsWith('window') ? 'window' :
          kindRaw.startsWith('portal') ? 'portal' :
          kindRaw.startsWith('threshold') ? 'threshold' : 'door';
        const style = OPENING_STYLE[kind] || OPENING_STYLE.door;
        const lenUnits = Number.isFinite(Number(opening.len ?? opening.length ?? opening.size))
          ? Number(opening.len ?? opening.length ?? opening.size)
          : style.len;
        const thickUnits = Number.isFinite(Number(opening.thick ?? opening.thickness))
          ? Number(opening.thick ?? opening.thickness)
          : style.thick;
        const len = GRID.size * lenUnits * VIEW.zoom;
        const thick = GRID.size * thickUnits * VIEW.zoom;
        const seamKind = opening.seam_kind || opening.seamKind || '';
        const seamMode = String(opening.seam_mode || opening.seamMode || '').toLowerCase();
        const seamColor = seamKind ? (FLOOR_COLORS[String(seamKind)] || FLOOR_COLORS.default) : null;
        const seamAnchor = seamKind ? seamAnchorWorld(opening, floor, String(seamKind), world) : null;
        const allowSeamFill = seamMode === 'fill' || seamMode === 'seam';
        const seamFill = seamKind && allowSeamFill
          ? getFillStyle(gctx, 'floor', String(seamKind), seamColor, seamAnchor)
          : null;
        const seamLen = len * 1.15;
        const seamThick = thick * 1.6;
        if (seamFill) {
          gctx.save();
          if (fogState === 'explored') gctx.globalAlpha *= 0.6;
          gctx.translate(center.x, center.y);
          gctx.fillStyle = seamFill;
          if (orient === 'v') {
            gctx.fillRect(-seamThick / 2, -seamLen / 2, seamThick, seamLen);
          } else {
            gctx.fillRect(-seamLen / 2, -seamThick / 2, seamLen, seamThick);
          }
          gctx.restore();
        }
        gctx.save();
        if (fogState === 'explored') gctx.globalAlpha *= 0.6;
        gctx.translate(center.x, center.y);
        if (orient === 'v') gctx.rotate(Math.PI / 2);
        gctx.fillStyle = style.color;
        gctx.fillRect(-len / 2, -thick / 2, len, thick);
        gctx.restore();
      }

      function objectWorldCenter(obj) {
        if (!obj) return null;
        const p = parseHexLabel(obj.hex);
        if (!p) return null;
        const base = hexToWorld(p.col, p.row);
        const ox = Number(obj.ox);
        const oy = Number(obj.oy);
        return {
          x: base.x + (Number.isFinite(ox) ? ox : 0) * GRID.size,
          y: base.y + (Number.isFinite(oy) ? oy : 0) * GRID.size,
        };
      }

      const spriteCache = new Map();
      function loadSprite(url) {
        if (!url) return null;
        if (spriteCache.has(url)) return spriteCache.get(url);
        const img = new Image();
        img.__bmStatus = 'loading';
        img.src = url;
        img.onload = () => {
          img.__bmStatus = 'ready';
          render();
        };
        img.onerror = () => {
          img.__bmStatus = 'error';
          render();
        };
        spriteCache.set(url, img);
        return img;
      }

      const LAYER_CANVASES = new Map();
      function getLayerContext(name, rect, dpr) {
        let layer = LAYER_CANVASES.get(name);
        if (!layer) {
          const canvas = document.createElement('canvas');
          const gctx = canvas.getContext('2d');
          layer = { canvas, ctx: gctx };
          LAYER_CANVASES.set(name, layer);
        }
        layer.canvas.width = rect.width * dpr;
        layer.canvas.height = rect.height * dpr;
        layer.ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        layer.ctx.clearRect(0, 0, rect.width, rect.height);
        return layer;
      }

      const PATTERN_CACHE = new WeakMap();

      function getPatternCache(gctx) {
        const cache = PATTERN_CACHE.get(gctx);
        if (cache) return cache;
        const created = new Map();
        PATTERN_CACHE.set(gctx, created);
        return created;
      }

      function resolveTextureDef(category, kind) {
        const cat = String(category || '').toLowerCase();
        const k0 = String(kind || '').toLowerCase();
        if (!cat || !k0) return null;
        if (k0 === 'fog' || k0 === 'none') return null;

        const aliases = TEXTURE_ALIASES[cat] || {};
        const key = (k0 in TEXTURE_FILES) ? k0 : (aliases[k0] || '');
        if (!key || !(key in TEXTURE_FILES)) return null;

        const scale = (TEXTURE_SCALES[cat] && Number.isFinite(Number(TEXTURE_SCALES[cat][key])))
          ? Number(TEXTURE_SCALES[cat][key])
          : 1;
        return { url: TEXTURE_FILES[key], scale };
      }

      function getTexturePattern(gctx, category, kind) {
        const def = resolveTextureDef(category, kind);
        if (!def) return null;
        const cache = getPatternCache(gctx);
        const cached = cache.get(def.url);
        if (cached && cached.pattern) return { pattern: cached.pattern, scale: def.scale };

        const img = loadSprite(def.url);
        if (!img || !img.complete) {
          if (img && !img.__patternHooked) {
            img.__patternHooked = true;
            img.onload = () => {
              img.__patternHooked = false;
              cache.delete(def.url);
              render();
            };
          }
          return null;
        }

        const pattern = gctx.createPattern(img, 'repeat');
        if (!pattern) return null;
        cache.set(def.url, { pattern });
        return { pattern, scale: def.scale };
      }

      function applyPatternTransform(pattern, scale, anchorWorld) {
        if (!pattern || typeof pattern.setTransform !== 'function') return;
        const cam = getCameraWorld();
        const rect = canvas.getBoundingClientRect();
        const anchor = anchorWorld || { x: 0, y: 0 };
        const originX = rect.width / 2 + (anchor.x - cam.x) * VIEW.zoom;
        const originY = rect.height / 2 + (anchor.y - cam.y) * VIEW.zoom;
        const s = (Number(scale) || 1) * VIEW.zoom;
        const m = new DOMMatrix();
        m.a = s;
        m.d = s;
        m.e = originX;
        m.f = originY;
        pattern.setTransform(m);
      }

      function getFillStyle(gctx, category, kind, fallback, anchorWorld, opts = {}) {
        const def = resolveTextureDef(category, kind);
        if (def) {
          const tex = getTexturePattern(gctx, category, kind);
          if (tex && tex.pattern) {
            applyPatternTransform(tex.pattern, tex.scale, anchorWorld);
            return tex.pattern;
          }
          if (opts.allowFallback === false) return null;
        }
        return fallback;
      }

      function drawObject(obj, zIndex, gctx) {
        const world = objectWorldCenter(obj);
        if (!world) return;
        const center = worldToScreen(world);
        const url = obj.sprite || obj.spriteFile || SPRITE_MAP[obj.kind];
        const scale = Number.isFinite(Number(obj.spriteScale)) ? Number(obj.spriteScale) : 1;
        const scaleX = Number.isFinite(Number(obj.spriteScaleX)) ? Number(obj.spriteScaleX) : scale;
        const scaleY = Number.isFinite(Number(obj.spriteScaleY)) ? Number(obj.spriteScaleY) : scale;
        const base = GRID.size * 1.15;
        let sizeW = base * scaleX * VIEW.zoom;
        let sizeH = base * scaleY * VIEW.zoom;
        const rotDeg = Number.isFinite(Number(obj.rotDeg)) ? Number(obj.rotDeg) : 0;
        const rot = rotDeg * Math.PI / 180;

        if (url) {
          const img = loadSprite(url);
          if (img && img.complete && img.naturalWidth && img.naturalHeight) {
            const ratio = img.naturalHeight / img.naturalWidth;
            sizeW = base * scaleX * VIEW.zoom;
            sizeH = base * ratio * scaleY * VIEW.zoom;
            gctx.save();
            gctx.translate(center.x, center.y);
            if (rot) gctx.rotate(rot);
            gctx.drawImage(img, -sizeW / 2, -sizeH / 2, sizeW, sizeH);
            gctx.restore();
            return;
          }
          if (img && img.__bmStatus !== 'error') {
            return;
          }
        }

        gctx.save();
        gctx.translate(center.x, center.y);
        if (rot) gctx.rotate(rot);
        gctx.fillStyle = '#2b2f3a';
        gctx.fillRect(-sizeW / 2, -sizeH / 2, sizeW, sizeH);
        gctx.strokeStyle = '#4a5568';
        gctx.strokeRect(-sizeW / 2, -sizeH / 2, sizeW, sizeH);
        gctx.fillStyle = '#cfd6df';
        gctx.font = `${10 * VIEW.zoom}px sans-serif`;
        gctx.textAlign = 'center';
        gctx.textBaseline = 'middle';
        const baseLabel = obj.name || obj.kind || 'obj';
        const displayZ = obj.z != null ? obj.z : (Number.isFinite(zIndex) ? zIndex : null);
        const label = displayZ != null ? `${baseLabel} (${displayZ})` : baseLabel;
        gctx.fillText(label, 0, 0);
        gctx.restore();
      }

      function drawToken(token, gctx) {
        const p = parseHexLabel(token.hex);
        if (!p) return;
        const center = worldToScreen(hexToWorld(p.col, p.row));
        const r = GRID.size * 0.35 * VIEW.zoom;
        gctx.fillStyle = token.side === 'NPC' ? '#c95c5c' : '#5ca9c9';
        gctx.beginPath();
        gctx.arc(center.x, center.y, r, 0, Math.PI * 2);
        gctx.fill();
        gctx.fillStyle = '#0b0f14';
        gctx.font = `${11 * VIEW.zoom}px sans-serif`;
        gctx.textAlign = 'center';
        gctx.textBaseline = 'middle';
        const label = token.name ? token.name[0].toUpperCase() : '?';
        gctx.fillText(label, center.x, center.y);
      }

      function numOr(value, fallback) {
        const n = Number(value);
        return Number.isFinite(n) ? n : fallback;
      }

      function sortByZ(list) {
        if (!Array.isArray(list)) return [];
        const order = new Map();
        list.forEach((item, idx) => order.set(item, idx));
        return list.slice().sort((a, b) => {
          const za = numOr(a && a.z, order.get(a));
          const zb = numOr(b && b.z, order.get(b));
          return za - zb;
        });
      }

      function isDeleted(item) {
        return !!(item && item.deleted);
      }

      function filterAlive(list) {
        return Array.isArray(list) ? list.filter(item => item && !item.deleted) : [];
      }

      function roomAlwaysVisible(room) {
        if (!room || typeof room !== 'object') return false;
        const mode = String(room.fog_mode || room.fogMode || '').toLowerCase();
        if (mode === 'always' || mode === 'visible') return true;
        if (room.always_visible === true || room.alwaysVisible === true) return true;
        return false;
      }

      function getFogState() {
        const fog = STATE.battle && STATE.battle.fog ? STATE.battle.fog : null;
        if (!fog || fog.enabled === false) return null;
        return fog;
      }

      function getFogSets(floorId) {
        const fog = getFogState();
        if (!fog) return null;
        const key = String(floorId || '');
        const visibleMap = fog.visibleRoomIdsByFloor || {};
        const exploredMap = fog.exploredRoomIdsByFloor || {};
        let visible = visibleMap[key];
        let explored = exploredMap[key];
        if (!Array.isArray(visible) || !Array.isArray(explored)) {
          const lowerKey = key.toLowerCase();
          const findCase = (map) => {
            if (!map || typeof map !== 'object') return null;
            for (const k of Object.keys(map)) {
              if (String(k).toLowerCase() === lowerKey) return map[k];
            }
            return null;
          };
          if (!Array.isArray(visible)) visible = findCase(visibleMap);
          if (!Array.isArray(explored)) explored = findCase(exploredMap);
        }
        if (!Array.isArray(visible)) visible = [];
        if (!Array.isArray(explored)) explored = [];
        return {
          visible: new Set(visible.map(String)),
          explored: new Set(explored.map(String))
        };
      }

      function roomContainsWorld(room, worldPoint) {
        if (!room || !worldPoint) return false;
        if (isPolyRoom(room)) {
          const pts = roomWorldPoints(room);
          if (pts.length < 3) return false;
          return pointInPolygon(worldPoint, pts);
        }
        const box = roomToWallBox(room);
        if (!box) return false;
        const rect = roomFloorRectWorld(room, box) || box.center;
        if (!rect) return false;
        return worldPoint.x >= Math.min(rect.x1, rect.x2) &&
          worldPoint.x <= Math.max(rect.x1, rect.x2) &&
          worldPoint.y >= Math.min(rect.y1, rect.y2) &&
          worldPoint.y <= Math.max(rect.y1, rect.y2);
      }

      function findRoomForWorldPoint(rooms, worldPoint) {
        if (!Array.isArray(rooms) || !worldPoint) return null;
        for (const room of rooms) {
          if (!room || room.deleted) continue;
          if (roomContainsWorld(room, worldPoint)) return room;
        }
        return null;
      }

      function classifyRoomsForFog(floor) {
        const rooms = filterAlive(floor && floor.rooms ? floor.rooms : []);
        if (!UI.fogEnabled) return { visible: rooms, explored: [], hidden: [] };
        const sets = getFogSets(floor.id);
        if (!sets) return { visible: rooms, explored: [], hidden: [] };

        const visible = [];
        const explored = [];
        const hidden = [];
        for (const room of rooms) {
          const mode = String(room.fog_mode || room.fogMode || '').toLowerCase();
          if (mode === 'hidden') { hidden.push(room); continue; }
          if (mode === 'explored') { explored.push(room); continue; }
          if (roomAlwaysVisible(room) || mode === 'visible') {
            visible.push(room);
            continue;
          }
          const id = String(room.id || '');
          if (sets.visible.has(id)) {
            visible.push(room);
            continue;
          }
          if (sets.explored.has(id)) {
            explored.push(room);
            continue;
          }
          hidden.push(room);
        }
        return { visible, explored, hidden };
      }

      function buildFogRoomSets(groups) {
        const visible = new Set();
        const explored = new Set();
        const hidden = new Set();
        if (!groups) return { visible, explored, hidden };
        (groups.visible || []).forEach(r => { if (r && r.id != null) visible.add(String(r.id)); });
        (groups.explored || []).forEach(r => { if (r && r.id != null) explored.add(String(r.id)); });
        (groups.hidden || []).forEach(r => { if (r && r.id != null) hidden.add(String(r.id)); });
        return { visible, explored, hidden };
      }

      function tokenWorldCenter(token) {
        if (!token) return null;
        const p = parseHexLabel(token.hex);
        if (!p) return null;
        return hexToWorld(p.col, p.row);
      }

      function itemFogState(item, floor, rooms, roomSets, getWorld) {
        if (!UI.fogEnabled) return 'visible';
        const world = getWorld ? getWorld(item, floor) : null;
        if (!world) return 'visible';
        const room = findRoomForWorldPoint(rooms, world);
        if (!room || room.id == null) return 'visible';
        const id = String(room.id);
        if (roomSets.hidden && roomSets.hidden.has(id)) return 'hidden';
        if (roomSets.explored && roomSets.explored.has(id)) return 'explored';
        return 'visible';
      }

      function drawFogOverlay(rooms, gctx) {
        if (!UI.fogEnabled || !rooms || !rooms.length) return;
        const fog = getFogState();
        if (!fog) return;
        const alpha = Number.isFinite(Number(fog.exploredAlpha)) ? Number(fog.exploredAlpha) : 0.55;
        const color = FLOOR_COLORS.fog || '#0e1117';
        gctx.save();
        gctx.fillStyle = color;
        gctx.globalAlpha = alpha;
        for (const room of rooms) {
          if (!room || room.deleted) continue;
          if (isPolyRoom(room)) {
            const pts = roomWorldPoints(room);
            if (pts.length < 3) continue;
            const screenPts = pts.map(worldToScreen);
            gctx.beginPath();
            gctx.moveTo(screenPts[0].x, screenPts[0].y);
            for (let i = 1; i < screenPts.length; i++) gctx.lineTo(screenPts[i].x, screenPts[i].y);
            gctx.closePath();
            gctx.fill();
            continue;
          }
          const box = roomToWallBox(room);
          if (!box) continue;
          const rect = roomHasWalls(room) ? (box.center || box.inner) : box.center;
          const p1 = worldToScreen({ x: rect.x1, y: rect.y1 });
          const p2 = worldToScreen({ x: rect.x2, y: rect.y2 });
          const x1 = Math.min(p1.x, p2.x);
          const y1 = Math.min(p1.y, p2.y);
          const x2 = Math.max(p1.x, p2.x);
          const y2 = Math.max(p1.y, p2.y);
          gctx.fillRect(x1, y1, x2 - x1, y2 - y1);
        }
        gctx.restore();
      }

      function render() {
        if (!STATE.battle) return;
        const dpr = window.devicePixelRatio || 1;
        const rect = canvas.getBoundingClientRect();
        canvas.width = rect.width * dpr;
        canvas.height = rect.height * dpr;
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        ctx.clearRect(0, 0, rect.width, rect.height);

        const floor = pickFloor();
        if (!floor) return;

        const layerMode = layerSelect ? layerSelect.value : 'all';
        const floorLayer = getLayerContext('floors', rect, dpr);
        const wallLayer = getLayerContext('walls', rect, dpr);
        const objectLayer = getLayerContext('objects', rect, dpr);
        const fogLayer = getLayerContext('fog', rect, dpr);
        const gridLayer = getLayerContext('grid', rect, dpr);
        const handleLayer = getLayerContext('handles', rect, dpr);
        const tokenLayer = getLayerContext('tokens', rect, dpr);

        const allRooms = filterAlive(floor.rooms || []);
        const fogRooms = classifyRoomsForFog(floor);
        const fogSets = buildFogRoomSets(fogRooms);
        const roomsToDraw = UI.fogEnabled ? fogRooms.visible.concat(fogRooms.explored) : allRooms;

        drawFloorsLayer(floor, floorLayer.ctx, roomsToDraw);
        drawWallsLayer(floor, wallLayer.ctx, roomsToDraw, fogSets);
        drawGridLayer(gridLayer.ctx);
        drawHandlesLayer(floor, handleLayer.ctx);

        const openings = sortByZ(filterAlive(floor.openings || [])).map(o => {
          const fogState = openingFogState(o, floor, allRooms, fogSets);
          return { opening: o, fogState };
        }).filter(entry => entry.fogState !== 'hidden');
        const objects = sortByZ(filterAlive(floor.objects || [])).filter(o => {
          return itemFogState(o, floor, allRooms, fogSets, objectWorldCenter) !== 'hidden';
        });
        const tokens = buildTokens()
          .filter(t => !t.floorId || t.floorId === floor.id)
          .filter(t => itemFogState(t, floor, allRooms, fogSets, tokenWorldCenter) !== 'hidden');
        openings.forEach(entry => drawOpening(entry.opening, floor, objectLayer.ctx, entry.fogState));
        objects.forEach((obj, idx) => drawObject(obj, idx, objectLayer.ctx));
        tokens.forEach(t => drawToken(t, tokenLayer.ctx));
        drawFogOverlay(fogRooms.explored, fogLayer.ctx);

        ctx.clearRect(0, 0, rect.width, rect.height);
        if (layerMode === 'all' || layerMode === 'floors') {
          ctx.drawImage(floorLayer.canvas, 0, 0, rect.width, rect.height);
        }
        if (layerMode === 'all' || layerMode === 'walls') {
          ctx.drawImage(wallLayer.canvas, 0, 0, rect.width, rect.height);
        }
        if (layerMode === 'all' || layerMode === 'objects') {
          ctx.drawImage(objectLayer.canvas, 0, 0, rect.width, rect.height);
        }
        if (layerMode === 'all' || layerMode === 'tokens') {
          ctx.drawImage(tokenLayer.canvas, 0, 0, rect.width, rect.height);
        }
        if (layerMode === 'all') {
          ctx.drawImage(fogLayer.canvas, 0, 0, rect.width, rect.height);
        }
        if (layerMode === 'all' && UI.hexGrid) {
          ctx.drawImage(gridLayer.canvas, 0, 0, rect.width, rect.height);
        }
        if (layerMode === 'all' && (UI.showHandles || UI.handleHot)) {
          ctx.drawImage(handleLayer.canvas, 0, 0, rect.width, rect.height);
        }
        if (layerMode === 'all') {
          drawRoomPreview(ctx);
        }
      }

      function updateInspector() {
        const sel = EDITOR.selection;
        if (!sel) {
          inspectorEmpty.hidden = false;
          inspectorFields.hidden = true;
          inspectorFields.innerHTML = '';
          return;
        }

        inspectorEmpty.hidden = true;
        inspectorFields.hidden = false;
        inspectorFields.innerHTML = '';

        const addField = (label, value, key, opts = {}) => {
          const row = document.createElement('div');
          row.className = 'row';
          const lab = document.createElement('label');
          lab.textContent = label;
          const input = document.createElement('input');
          if (opts.type) input.type = opts.type;
          if (opts.step != null) input.step = String(opts.step);
          if (opts.list) input.setAttribute('list', opts.list);
          input.value = value == null ? '' : String(value);
          if (opts.readonly) input.readOnly = true;
          input.addEventListener('input', () => {
            applyFieldChange(key, input.value);
          });
          row.appendChild(lab);
          row.appendChild(input);
          inspectorFields.appendChild(row);
        };
        const addSelectField = (label, value, key, options = []) => {
          const row = document.createElement('div');
          row.className = 'row';
          const lab = document.createElement('label');
          lab.textContent = label;
          const select = document.createElement('select');
          for (const opt of options) {
            const o = document.createElement('option');
            o.value = opt.value;
            o.textContent = opt.label;
            select.appendChild(o);
          }
          select.value = value == null ? '' : String(value);
          select.addEventListener('change', () => {
            applyFieldChange(key, select.value);
          });
          row.appendChild(lab);
          row.appendChild(select);
          inspectorFields.appendChild(row);
        };
        const addButtonRow = (buttons) => {
          const row = document.createElement('div');
          row.className = 'btnRow';
          buttons.forEach(({ label, onClick }) => {
            const btn = document.createElement('button');
            btn.textContent = label;
            btn.addEventListener('click', onClick);
            row.appendChild(btn);
          });
          inspectorFields.appendChild(row);
        };
        const bumpToken = (key, delta) => {
          const cur = Number(sel.item[key]);
          const next = Number.isFinite(cur) ? cur + delta : delta;
          applyFieldChange(key, String(next));
          updateInspector();
        };
        const setTokenSide = (side, kind) => {
          applyFieldChange('side', side);
          if (kind) applyFieldChange('kind', kind);
          updateInspector();
        };

        if (sel.type === 'room') {
          addField('Type', 'room', 'type', { readonly: true });
          addField('ID', sel.item.id, 'id', { readonly: true });
          addField('Name', sel.item.name || '', 'name');
          addField('Floor', sel.floorId, 'floorId');
          addField('Points', formatRoomPoints(sel.item), 'points');
          addField('Thickness', sel.item.thickness != null ? sel.item.thickness : '', 'thickness', { type: 'number', step: '1' });
          addField('Floor Kind', sel.item.floor && sel.item.floor.kind ? sel.item.floor.kind : '', 'floor.kind', { list: 'floorKindList' });
          addField('Wall Kind', sel.item.wall && sel.item.wall.kind ? sel.item.wall.kind : '', 'wall.kind', { list: 'wallKindList' });
          addSelectField('Fog', sel.item.fog_mode || sel.item.fogMode || '', 'fog_mode', [
            { value: '', label: 'Default' },
            { value: 'visible', label: 'Always Visible' },
            { value: 'explored', label: 'Always Explored' },
            { value: 'hidden', label: 'Always Hidden' }
          ]);
          addButtonRow([
            { label: 'To Front', onClick: () => reorderSelection('front') },
            { label: 'To Back', onClick: () => reorderSelection('back') },
          ]);
          addButtonRow([
            { label: 'Delete', onClick: () => deleteSelection() },
          ]);
        }

        if (sel.type === 'opening') {
          addField('Type', 'opening', 'type', { readonly: true });
          addField('ID', sel.item.id, 'id', { readonly: true });
          addField('Name', sel.item.name || '', 'name');
          addField('Kind', sel.item.kind || '', 'kind', { list: 'openingKindList' });
          addField('Hex', sel.item.hex || '', 'hex');
          addField('Floor', sel.floorId || '', 'floorId');
          addField('Orientation', sel.item.orientation || 'h', 'orientation');
          addField('Open %', sel.item.openPct != null ? sel.item.openPct : 0, 'openPct', { type: 'number', step: '0.05' });
          addField('Length', sel.item.len != null ? sel.item.len : '', 'len', { type: 'number', step: '0.05' });
          addField('Thickness', sel.item.thickness != null ? sel.item.thickness : '', 'thickness', { type: 'number', step: '0.05' });
          addField('Seam', sel.item.seam_kind || '', 'seam_kind');
          addField('Seam Mode', sel.item.seam_mode || '', 'seam_mode');
          addField('Seam Anchor', sel.item.seam_anchor || '', 'seam_anchor');
          addButtonRow([
            { label: 'To Front', onClick: () => reorderSelection('front') },
            { label: 'To Back', onClick: () => reorderSelection('back') },
          ]);
          addButtonRow([
            { label: 'Delete', onClick: () => deleteSelection() },
          ]);
        }

        if (sel.type === 'object') {
          addField('Type', 'object', 'type', { readonly: true });
          addField('ID', sel.item.id, 'id', { readonly: true });
          addField('Name', sel.item.name || '', 'name');
          addField('Kind', sel.item.kind || '', 'kind', { list: 'objectKindList' });
          addField('Hex', sel.item.hex || '', 'hex');
          addField('Floor', sel.item.floorId || '', 'floorId');
          addField('Sprite', sel.item.sprite || sel.item.spriteFile || '', 'sprite');
          addField('Scale', sel.item.spriteScale != null ? sel.item.spriteScale : '', 'spriteScale', { type: 'number', step: '0.05' });
          addField('Scale X', sel.item.spriteScaleX != null ? sel.item.spriteScaleX : '', 'spriteScaleX', { type: 'number', step: '0.05' });
          addField('Scale Y', sel.item.spriteScaleY != null ? sel.item.spriteScaleY : '', 'spriteScaleY', { type: 'number', step: '0.05' });
          addField('Rot Deg', sel.item.rotDeg != null ? sel.item.rotDeg : '', 'rotDeg', { type: 'number', step: '1' });
          addField('Offset X', sel.item.ox != null ? sel.item.ox : '', 'ox', { type: 'number', step: '0.05' });
          addField('Offset Y', sel.item.oy != null ? sel.item.oy : '', 'oy', { type: 'number', step: '0.05' });
          addButtonRow([
            { label: 'To Front', onClick: () => reorderSelection('front') },
            { label: 'To Back', onClick: () => reorderSelection('back') },
          ]);
          addButtonRow([
            { label: 'Delete', onClick: () => deleteSelection() },
          ]);
        }

        if (sel.type === 'token') {
          addField('Type', 'token', 'type', { readonly: true });
          addField('ID', sel.item.id, 'id', { readonly: true });
          addField('Name', sel.item.name || '', 'name');
          addField('Kind', sel.item.kind || '', 'kind', { list: 'tokenKindList' });
          addField('Hex', sel.item.hex || '', 'hex');
          addField('Floor', sel.item.floorId || '', 'floorId');
          addField('POI', sel.item.poi_id || '', 'poi_id');
          addField('Side', sel.item.side || '', 'side');
          addField('HP', sel.item.hp != null ? sel.item.hp : '', 'hp', { type: 'number', step: '1' });
          addField('Init', sel.item.init != null ? sel.item.init : '', 'init', { type: 'number', step: '1' });
          addButtonRow([
            { label: 'HP -1', onClick: () => bumpToken('hp', -1) },
            { label: 'HP +1', onClick: () => bumpToken('hp', 1) },
            { label: 'Init -1', onClick: () => bumpToken('init', -1) },
            { label: 'Init +1', onClick: () => bumpToken('init', 1) },
          ]);
          addButtonRow([
            { label: 'Set PC', onClick: () => setTokenSide('PC', 'pc') },
            { label: 'Set NPC', onClick: () => setTokenSide('NPC', 'npc') },
          ]);
          addButtonRow([
            { label: 'Delete', onClick: () => deleteSelection() },
          ]);
        }
      }
      function applyFieldChange(key, value) {
        const sel = EDITOR.selection;
        if (!sel) return;
        pushHistory();
        const item = sel.item;
        const num = (val, fallback = null) => {
          if (val == null || String(val).trim() === '') return fallback;
          const n = Number(val);
          return Number.isFinite(n) ? n : fallback;
        };

        if (sel.type === 'room') {
          if (key === 'name') item.name = value;
          if (key === 'floorId') moveRoomToFloor(item, value);
          if (key === 'points') {
            const points = parsePointList(value);
            if (points.length >= 3) {
              item.points = points;
            } else {
              delete item.points;
            }
          }
          if (key === 'fog_mode') {
            const v = String(value || '').trim().toLowerCase();
            if (!v) {
              delete item.fog_mode;
              delete item.fogMode;
            } else {
              item.fog_mode = v;
            }
          }
          if (key === 'thickness') item.thickness = num(value, 0);
          if (key === 'floor.kind') {
            item.floor = item.floor || {};
            item.floor.kind = value;
          }
          if (key === 'wall.kind') {
            item.wall = item.wall || {};
            item.wall.kind = value;
          }
        }

        if (sel.type === 'opening') {
          if (key === 'name') item.name = value;
          if (key === 'kind') item.kind = value;
          if (key === 'hex') item.hex = value;
          if (key === 'floorId') moveOpeningToFloor(item, value);
          if (key === 'orientation') item.orientation = value;
          if (key === 'openPct') item.openPct = Math.max(0, Math.min(1, num(value, 0)));
          if (key === 'len') {
            const n = num(value, null);
            if (n == null) delete item.len;
            else item.len = n;
          }
          if (key === 'thickness') {
            const n = num(value, null);
            if (n == null) delete item.thickness;
            else item.thickness = n;
          }
          if (key === 'seam_kind') item.seam_kind = value;
          if (key === 'seam_mode') item.seam_mode = value;
          if (key === 'seam_anchor') item.seam_anchor = value;
        }

        if (sel.type === 'object') {
          if (key === 'name') item.name = value;
          if (key === 'kind') item.kind = value;
          if (key === 'hex') item.hex = value;
          if (key === 'floorId') item.floorId = value;
          if (key === 'sprite') item.sprite = value;
          if (key === 'spriteScale') item.spriteScale = num(value, 1);
          if (key === 'spriteScaleX') item.spriteScaleX = num(value, null);
          if (key === 'spriteScaleY') item.spriteScaleY = num(value, null);
          if (key === 'rotDeg') item.rotDeg = num(value, 0);
          if (key === 'ox') item.ox = num(value, 0);
          if (key === 'oy') item.oy = num(value, 0);
        }

        if (sel.type === 'token') {
          if (key === 'name') item.name = value;
          if (key === 'kind') item.kind = value;
          if (key === 'hex') item.hex = value;
          if (key === 'floorId') item.floorId = value;
          if (key === 'poi_id') item.poi_id = value;
          if (key === 'side') item.side = value;
          if (key === 'hp') item.hp = num(value, null);
          if (key === 'init') item.init = num(value, null);
          syncEntityFromToken(item);
          queueEntitySave(item);
          renderStatus();
        }

        EDITOR.dirty = true;
        render();
      }

      function updateRoomCorners(room, key, value) {
        const corners = Array.isArray(room.corners) ? room.corners.slice() : [];
        if (corners.length < 4) return;
        if (key === 'cornerTL') corners[0] = value;
        if (key === 'cornerBR') corners[2] = value;
        room.corners = corners;
      }

      function moveRoomToFloor(room, floorId) {
        const floors = STATE.battle.floors;
        const source = floors.find(f => f.rooms.includes(room));
        const target = floors.find(f => f.id === floorId);
        if (!source || !target) return;
        source.rooms = source.rooms.filter(r => r !== room);
        target.rooms.push(room);
        EDITOR.selection.floorId = floorId;
      }

      function moveOpeningToFloor(opening, floorId) {
        const floors = STATE.battle.floors;
        const source = floors.find(f => f.openings && f.openings.includes(opening));
        const target = floors.find(f => f.id === floorId);
        if (!source || !target) return;
        source.openings = source.openings.filter(o => o !== opening);
        if (!Array.isArray(target.openings)) target.openings = [];
        target.openings.push(opening);
        EDITOR.selection.floorId = floorId;
      }

      function reorderSelection(direction) {
        const sel = EDITOR.selection;
        if (!sel || !STATE.battle) return;
        const floor = STATE.battle.floors.find(f => String(f.id) === String(sel.floorId));
        if (!floor) return;
        pushHistory();

        let list = null;
        if (sel.type === 'room') list = floor.rooms;
        if (sel.type === 'opening') list = floor.openings;
        if (sel.type === 'object') list = floor.objects;
        if (!Array.isArray(list)) return;

        const idx = list.indexOf(sel.item);
        if (idx === -1) return;
        list.splice(idx, 1);
        if (direction === 'front') list.push(sel.item);
        else list.unshift(sel.item);

        // Persist order via z so reloads keep the stack.
        const zVals = list.map((item, i) => numOr(item && item.z, i));
        const maxZ = Math.max(0, ...zVals);
        const minZ = Math.min(0, ...zVals);
        sel.item.z = direction === 'front' ? maxZ + 1 : minZ - 1;

        EDITOR.dirty = true;
        render();
      }

      function selectItem(type, item, floorId) {
        EDITOR.selection = { type, item, floorId };
        updateInspector();
      }

      function clearSelection() {
        EDITOR.selection = null;
        updateInspector();
      }

      function deleteSelection() {
        const sel = EDITOR.selection;
        if (!sel) return;
        pushHistory();
        if (sel.type === 'token') {
          const entity = sel.item && sel.item.__entity;
          if (entity) {
            entity.deleted = true;
            saveEntityPatch(entity.id || sel.item.id, { deleted: true }, false);
          }
          renderStatus();
          clearSelection();
          render();
          return;
        }
        const floor = STATE.battle && Array.isArray(STATE.battle.floors)
          ? STATE.battle.floors.find(f => String(f.id) === String(sel.floorId))
          : null;
        if (!floor) return;
        if (sel.type === 'room') sel.item.deleted = true;
        if (sel.type === 'opening') sel.item.deleted = true;
        if (sel.type === 'object') sel.item.deleted = true;
        clearSelection();
        EDITOR.dirty = true;
        render();
      }

      function nearestItem(list, point, getPos, maxDist = 20) {
        let best = null;
        let bestD = Infinity;
        for (const item of list) {
          const pos = getPos(item);
          if (!pos) continue;
          const dx = pos.x - point.x;
          const dy = pos.y - point.y;
          const d = Math.sqrt(dx * dx + dy * dy);
          if (d < bestD && d <= maxDist) {
            bestD = d;
            best = item;
          }
        }
        return best;
      }

      function findSelectionAt(worldPoint) {
        const floor = pickFloor();
        if (!floor) return null;
        const screenPoint = worldToScreen(worldPoint);

        const tokens = buildTokens().filter(t => !t.floorId || t.floorId === floor.id);
        const token = nearestItem(tokens, screenPoint, t => {
          const pos = parseHexLabel(t.hex);
          return pos ? worldToScreen(hexToWorld(pos.col, pos.row)) : null;
        }, 18);
        if (token) return { type: 'token', item: token, floorId: floor.id };

        const objects = filterAlive(floor.objects || []);
        const object = nearestItem(objects, screenPoint, o => {
          const world = objectWorldCenter(o);
          return world ? worldToScreen(world) : null;
        }, 18);
        if (object) return { type: 'object', item: object, floorId: floor.id };

        const openings = filterAlive(floor.openings || []);
        const opening = nearestItem(openings, screenPoint, o => {
          const world = openingWorldCenter(o, floor);
          return world ? worldToScreen(world) : null;
        }, 14);
        if (opening) return { type: 'opening', item: opening, floorId: floor.id };

        for (const room of filterAlive(floor.rooms || [])) {
          if (isPolyRoom(room)) {
            const poly = roomPolygonScreen(room);
            if (!poly || poly.length < 3) continue;
            if (pointInPolygon(screenPoint, poly)) {
              return { type: 'room', item: room, floorId: floor.id };
            }
            continue;
          }
          const rectInfo = roomRectScreen(room);
          if (!rectInfo) continue;
          if (screenPoint.x >= rectInfo.x1 && screenPoint.x <= rectInfo.x2 &&
              screenPoint.y >= rectInfo.y1 && screenPoint.y <= rectInfo.y2) {
            return { type: 'room', item: room, floorId: floor.id };
          }
        }

        return null;
      }

      function pointInPolygon(point, vs) {
        let inside = false;
        for (let i = 0, j = vs.length - 1; i < vs.length; j = i++) {
          const xi = vs[i].x, yi = vs[i].y;
          const xj = vs[j].x, yj = vs[j].y;
          const intersect = ((yi > point.y) !== (yj > point.y)) &&
            (point.x < (xj - xi) * (point.y - yi) / (yj - yi + 0.00001) + xi);
          if (intersect) inside = !inside;
        }
        return inside;
      }

      function handleCanvasClick(ev) {
        if (EDITOR.ignoreClick) {
          EDITOR.ignoreClick = false;
          return;
        }
        const rect = canvas.getBoundingClientRect();
        const x = ev.clientX - rect.left;
        const y = ev.clientY - rect.top;
        const world = screenToWorld(x, y);
        const hex = (EDITOR.tool === 'room') ? worldToHexHalf(world) : worldToHex(world);
        const hexLabel = toHexLabel(hex.col, hex.row);
        const floor = pickFloor();
        if (!floor) return;

        if (EDITOR.tool === 'select') {
          const sel = findSelectionAt(world);
          if (sel) selectItem(sel.type, sel.item, sel.floorId);
          else clearSelection();
          return;
        }

        if (EDITOR.tool === 'room') {
          if (!EDITOR.roomStart) {
            EDITOR.roomStart = hex;
            return;
          }
          pushHistory();
          const start = EDITOR.roomStart;
          EDITOR.roomStart = null;
          const minCol = Math.min(start.col, hex.col);
          const maxCol = Math.max(start.col, hex.col);
          const minRow = Math.min(start.row, hex.row);
          const maxRow = Math.max(start.row, hex.row);
          const room = {
            id: 'room_' + Date.now().toString(36),
            corners: [
              toHexLabel(minCol, maxRow),
              toHexLabel(maxCol, maxRow),
              toHexLabel(maxCol, minRow),
              toHexLabel(minCol, minRow)
            ],
            thickness: 12,
            floor: { kind: 'wood_oak' },
            wall: { kind: 'brick' }
          };
          floor.rooms.push(room);
          selectItem('room', room, floor.id);
          EDITOR.dirty = true;
          render();
          return;
        }

        if (EDITOR.tool === 'opening') {
          const snapped = snapWorldToWall(world, floor, EDITOR.openingOrientation || 'h');
          const openHex = openingHexFromWorld(snapped);
          const openLabel = openingHexLabelFromCoords(openHex.col, openHex.row) || hexLabel;
          pushHistory();
          const opening = {
            id: 'opening_' + Date.now().toString(36),
            kind: EDITOR.openingKind || 'door.wood',
            hex: openLabel,
            orientation: EDITOR.openingOrientation || 'h',
            openPct: 0
          };
          floor.openings.push(opening);
          selectItem('opening', opening, floor.id);
          EDITOR.dirty = true;
          render();
          return;
        }

        if (EDITOR.tool === 'object') {
          pushHistory();
          const obj = {
            id: 'object_' + Date.now().toString(36),
            kind: EDITOR.objectKind || 'object',
            hex: hexLabel,
            floorId: floor.id
          };
          floor.objects.push(obj);
          selectItem('object', obj, floor.id);
          EDITOR.dirty = true;
          render();
          return;
        }

        if (EDITOR.tool === 'token') {
          pushHistory();
          const poiId = resolvePoiId();
          const entityId = `entity_${Date.now().toString(36)}_${Math.random().toString(36).slice(2, 6)}`;
          const tokenKind = (EDITOR.tokenKind || 'npc').toLowerCase();
          const tokenSide = tokenKind === 'pc' ? 'PC' : 'NPC';
          const entity = {
            id: entityId,
            name: 'Token',
            kind: tokenKind,
            poi_id: poiId || '',
            location: { hex: hexLabel, floorId: floor.id }
          };
          STATE.entities = Array.isArray(STATE.entities) ? STATE.entities : [];
          STATE.entities.push(entity);

          const token = {
            id: entityId,
            name: entity.name,
            kind: entity.kind,
            hex: entity.location.hex,
            floorId: entity.location.floorId,
            poi_id: entity.poi_id,
            side: entity.side || tokenSide,
            __entity: entity
          };
          selectItem('token', token, floor.id);
          syncEntityFromToken(token);
          queueEntitySave(token);
          renderStatus();
          EDITOR.dirty = true;
          render();
        }
      }

      function syncEntityFromToken(token) {
        const entity = token && token.__entity;
        if (!entity) return;
        entity.name = token.name;
        if (token.kind) entity.kind = token.kind;
        if (!entity.location || typeof entity.location !== 'object') entity.location = {};
        if (token.hex) entity.location.hex = token.hex;
        if (token.floorId) entity.location.floorId = token.floorId;
        if (token.poi_id) entity.poi_id = token.poi_id;
        if (token.side) entity.side = token.side;
        if (!entity.stats || typeof entity.stats !== 'object') entity.stats = {};
        if (token.hp != null) {
          entity.stats.hp = token.hp;
          entity.hp = token.hp;
        }
        if (token.init != null) {
          entity.stats.init = token.init;
          entity.init = token.init;
        }
      }

      function onDragMove(worldPoint) {
        const drag = EDITOR.drag;
        if (!drag) return;
        const hex = worldToHex(worldPoint);
        const hexLabel = toHexLabel(hex.col, hex.row);

        if (drag.type === 'token') {
          drag.item.hex = hexLabel;
          drag.item.floorId = VIEW.floorId || drag.floorId || drag.item.floorId;
          syncEntityFromToken(drag.item);
        } else if (drag.type === 'opening') {
          const orient = drag.item && drag.item.orientation === 'v' ? 'v' : 'h';
          const snapped = snapWorldToWall(worldPoint, pickFloor(), orient);
          const openHex = openingHexFromWorld(snapped);
          const openLabel = openingHexLabelFromCoords(openHex.col, openHex.row) || hexLabel;
          drag.item.hex = openLabel;
        } else if (drag.type === 'object') {
          const base = hexToWorld(hex.col, hex.row);
          const ox = (worldPoint.x - base.x) / GRID.size;
          const oy = (worldPoint.y - base.y) / GRID.size;
          drag.item.hex = hexLabel;
          drag.item.ox = Math.round(ox * 100) / 100;
          drag.item.oy = Math.round(oy * 100) / 100;
        }
        EDITOR.dirty = true;
        render();
      }

      function attachDragHandlers() {
        canvas.addEventListener('mousedown', (ev) => {
          if (EDITOR.tool !== 'select') return;
          const rect = canvas.getBoundingClientRect();
          const x = ev.clientX - rect.left;
          const y = ev.clientY - rect.top;
          const world = screenToWorld(x, y);
          const sel = findSelectionAt(world);
          if (!sel) return;
          if (sel.type === 'room') return;
          selectItem(sel.type, sel.item, sel.floorId);
          EDITOR.drag = sel;
          EDITOR.drag.didMove = false;
          EDITOR.drag.pushed = false;
        });

        canvas.addEventListener('mousemove', (ev) => {
          if (!EDITOR.drag) return;
          EDITOR.drag.didMove = true;
          if (!EDITOR.drag.pushed) {
            pushHistory();
            EDITOR.drag.pushed = true;
          }
          const rect = canvas.getBoundingClientRect();
          const x = ev.clientX - rect.left;
          const y = ev.clientY - rect.top;
          const world = screenToWorld(x, y);
          onDragMove(world);
        });

        canvas.addEventListener('mousemove', (ev) => {
          if (EDITOR.drag) return;
          if (EDITOR.tool !== 'room') return;
          const rect = canvas.getBoundingClientRect();
          const x = ev.clientX - rect.left;
          const y = ev.clientY - rect.top;
          const world = screenToWorld(x, y);
          EDITOR.roomHover = worldToHexHalf(world);
          render();
        });

        window.addEventListener('mouseup', () => {
          if (!EDITOR.drag) return;
          const dragged = EDITOR.drag;
          EDITOR.drag = null;
          if (dragged.didMove) {
            EDITOR.ignoreClick = true;
            updateInspector();
            if (dragged.type === 'token') {
              syncEntityFromToken(dragged.item);
              queueEntitySave(dragged.item);
              renderStatus();
            }
          }
        });
      }

      async function saveState() {
        const battleId = resolveBattleId();
        if (!battleId || !STATE.battle) return;
        saveStatus.textContent = 'DB: saving...';
        try {
          let payloadState = STATE.battle;
          if (STATE.wrapper && STATE.recordId) {
            const wrapper = STATE.wrapper;
            if (!wrapper.records || typeof wrapper.records !== 'object') wrapper.records = {};
            wrapper.records[STATE.recordId] = STATE.battle;
            if (!wrapper.active || typeof wrapper.active !== 'object') wrapper.active = { recordId: STATE.recordId };
            if (!wrapper.active.recordId) wrapper.active.recordId = STATE.recordId;
            payloadState = wrapper;
          }
          const body = JSON.stringify({ state_json: payloadState });
          const res = await fetch(`/api/battles/${encodeURIComponent(battleId)}`, {
            method: 'PUT',
            headers: { 'content-type': 'application/json', 'accept': 'application/json', ...getAuthHeaders() },
            body
          });
          if (!res.ok) throw new Error('Save failed');
          saveStatus.textContent = 'DB: saved';
          EDITOR.dirty = false;
        } catch (e) {
          saveStatus.textContent = 'DB: error';
        }
      }

      let entitySaveTimer = null;
      function queueEntitySave(token) {
        if (!getCampaignId()) return;
        if (entitySaveTimer) clearTimeout(entitySaveTimer);
        entitySaveTimer = setTimeout(() => saveEntity(token), 400);
      }

      async function saveEntityPatch(entityId, patch, createIfMissing) {
        const cid = getCampaignId();
        if (!cid || !entityId) return;
        const payload = {
          entity_id: entityId,
          patch: patch || {},
          create_if_missing: !!createIfMissing
        };
        try {
          await fetch(`/api/campaigns/${encodeURIComponent(cid)}/entities`, {
            method: 'PATCH',
            headers: { 'content-type': 'application/json', 'accept': 'application/json', ...getAuthHeaders() },
            body: JSON.stringify(payload)
          });
        } catch {}
      }

      async function saveEntity(token) {
        if (!token) return;
        const stats = {};
        if (token.hp != null) stats.hp = token.hp;
        if (token.init != null) stats.init = token.init;
        const patch = {
          name: token.name,
          kind: token.kind,
          side: token.side,
          poi_id: token.poi_id || resolvePoiId(),
          location: { hex: token.hex, floorId: token.floorId },
          ...(Object.keys(stats).length ? { stats } : {})
        };
        saveEntityPatch(token.id, patch, true);
      }

      function attachEvents() {
        Object.entries(toolButtons).forEach(([key, btn]) => {
          if (!btn) return;
          btn.addEventListener('click', () => setTool(key));
        });
        if (openingKindSelect) {
          openingKindSelect.addEventListener('change', () => {
            EDITOR.openingKind = openingKindSelect.value;
          });
          openingKindSelect.value = EDITOR.openingKind;
        }
        const setOpeningOrientation = (val) => {
          EDITOR.openingOrientation = val;
          if (openingOrientH) openingOrientH.classList.toggle('active', val === 'h');
          if (openingOrientV) openingOrientV.classList.toggle('active', val === 'v');
        };
        if (openingOrientH) openingOrientH.addEventListener('click', () => setOpeningOrientation('h'));
        if (openingOrientV) openingOrientV.addEventListener('click', () => setOpeningOrientation('v'));
        setOpeningOrientation(EDITOR.openingOrientation);
        if (objectKindSelect) {
          objectKindSelect.addEventListener('change', () => {
            EDITOR.objectKind = objectKindSelect.value;
          });
          objectKindSelect.value = EDITOR.objectKind;
        }
        if (tokenKindSelect) {
          tokenKindSelect.addEventListener('change', () => {
            EDITOR.tokenKind = tokenKindSelect.value;
          });
          tokenKindSelect.value = EDITOR.tokenKind;
        }
        if (hexGridToggle) {
          hexGridToggle.addEventListener('change', () => {
            UI.hexGrid = !!hexGridToggle.checked;
            savePrefs();
            render();
          });
        }
        if (labelBoldToggle) {
          labelBoldToggle.addEventListener('change', () => {
            UI.brightLabels = !!labelBoldToggle.checked;
            savePrefs();
            render();
          });
        }
        if (handlesToggle) {
          handlesToggle.addEventListener('change', () => {
            UI.showHandles = !!handlesToggle.checked;
            savePrefs();
            render();
          });
        }
        if (fogToggle) {
          fogToggle.addEventListener('change', () => {
            UI.fogEnabled = !!fogToggle.checked;
            savePrefs();
            render();
          });
        }
        floorSelect.addEventListener('change', () => {
          VIEW.floorId = floorSelect.value;
          render();
        });
        if (layerSelect) {
          layerSelect.addEventListener('change', () => {
            render();
          });
        }
        zoomInput.addEventListener('input', () => {
          setZoom(Number(zoomInput.value));
        });
        if (canvasWrap) {
          canvasWrap.addEventListener('wheel', (ev) => {
            ev.preventDefault();
            const step = zoomInput ? Number(zoomInput.step) : 0.05;
            const delta = ev.deltaY > 0 ? -step : step;
            setZoom(VIEW.zoom + delta);
          }, { passive: false });
        }
        const nudgeStep = 1;
        if (panUp) panUp.addEventListener('click', () => nudgeCamera(0, -rowStep() * nudgeStep));
        if (panDown) panDown.addEventListener('click', () => nudgeCamera(0, rowStep() * nudgeStep));
        if (panLeft) panLeft.addEventListener('click', () => nudgeCamera(-colStep() * nudgeStep, 0));
        if (panRight) panRight.addEventListener('click', () => nudgeCamera(colStep() * nudgeStep, 0));
        if (undoButton) undoButton.addEventListener('click', () => undo());
        saveButton.addEventListener('click', () => saveState());
        canvas.addEventListener('click', handleCanvasClick);
        attachDragHandlers();
        window.addEventListener('keydown', (ev) => {
          if ((ev.ctrlKey || ev.metaKey) && ev.key.toLowerCase() === 'z') {
            ev.preventDefault();
            undo();
            return;
          }
          if (ev.key !== 'Delete' && ev.key !== 'Backspace') return;
          const el = document.activeElement;
          if (el && ['INPUT', 'TEXTAREA', 'SELECT'].includes(el.tagName)) return;
          deleteSelection();
        });
        window.addEventListener('keydown', (ev) => {
          if (ev.key === 'Escape') {
            if (EDITOR.roomStart) {
              EDITOR.roomStart = null;
              render();
            }
          }
        });
        window.addEventListener('keydown', (ev) => {
          if (ev.key === 'Control') {
            UI.handleHot = true;
            render();
          }
        });
        window.addEventListener('keyup', (ev) => {
          if (ev.key === 'Control') {
            UI.handleHot = false;
            render();
          }
        });
        window.addEventListener('resize', () => render());
        setTool(EDITOR.tool);
        updateUndoButton();
      }

      function populateKindLists() {
        if (!floorKindList || !wallKindList || !openingKindList || !objectKindList) return;
        const floorKinds = new Set(DEFAULT_FLOOR_KINDS);
        const wallKinds = new Set(DEFAULT_WALL_KINDS);
        const openingKinds = new Set(DEFAULT_OPENING_KINDS);
        const objectKinds = new Set(DEFAULT_OBJECT_KINDS);
        const tokenKinds = new Set(DEFAULT_TOKEN_KINDS);

        if (STATE.battle && Array.isArray(STATE.battle.floors)) {
          for (const floor of STATE.battle.floors) {
            if (Array.isArray(floor.rooms)) {
              for (const room of floor.rooms) {
                const fk = room && room.floor && room.floor.kind;
                const wk = room && room.wall && room.wall.kind;
                if (fk) floorKinds.add(String(fk));
                if (wk) wallKinds.add(String(wk));
              }
            }
            if (Array.isArray(floor.openings)) {
              for (const o of floor.openings) {
                if (o && o.kind) openingKinds.add(String(o.kind));
                if (o && o.seam_kind) floorKinds.add(String(o.seam_kind));
              }
            }
            if (Array.isArray(floor.objects)) {
              for (const o of floor.objects) {
                if (o && o.kind) objectKinds.add(String(o.kind));
              }
            }
          }
        }

        const fill = (el, values) => {
          el.innerHTML = Array.from(values).sort().map(v => `<option value="${String(v).replace(/\"/g, '&quot;')}"></option>`).join('');
        };
        fill(floorKindList, floorKinds);
        fill(wallKindList, wallKinds);
        fill(openingKindList, openingKinds);
        fill(objectKindList, objectKinds);
        if (tokenKindList) fill(tokenKindList, tokenKinds);
      }

      async function init() {
        await loadBattle();
        await loadCampaign();
        loadPrefs();
        setFloorOptions();
        populateKindLists();
        VIEW.zoom = Number(zoomInput.value);
        autoCenterCamera();
        pushHistory();
        renderStatus();
        attachEvents();
        render();
      }

      init().catch(err => {
        saveStatus.textContent = 'DB: error';
        console.error(err);
      });
    })();
  </script>
</body>
</html>
