<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Roof Designer</title>
  <style>
    :root {
      color-scheme: dark;
      --bg: #0b0f14;
      --panel: rgba(18, 22, 30, 0.96);
      --panel-border: rgba(255,255,255,0.08);
      --text: #e6e9ef;
      --muted: #9aa5b1;
      --accent: #6aa9ff;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      background: var(--bg);
      color: var(--text);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, sans-serif;
    }
    #toolbar {
      position: sticky;
      top: 0;
      z-index: 10;
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 10px 12px;
      background: var(--panel);
      border-bottom: 1px solid var(--panel-border);
      flex-wrap: wrap;
    }
    #toolbar label {
      font-size: 13px;
      color: var(--muted);
    }
    #toolbar input[type="text"],
    #toolbar input[type="number"],
    #toolbar select {
      padding: 6px 8px;
      border-radius: 6px;
      border: 1px solid var(--panel-border);
      background: #0f141c;
      color: var(--text);
    }
    #pointsInput {
      min-width: 420px;
      max-width: 70vw;
    }
    #toolbar button {
      padding: 6px 10px;
      border-radius: 6px;
      border: 1px solid var(--panel-border);
      background: #0f141c;
      color: var(--text);
      cursor: pointer;
    }
    #toolbar button.active {
      border-color: var(--accent);
      box-shadow: 0 0 0 1px rgba(106,169,255,0.35);
    }
    #toolbar .info {
      font-size: 12px;
      color: var(--muted);
      margin-left: auto;
    }
    #canvasWrap {
      padding: 16px;
    }
    canvas {
      display: block;
      background: #0b0f14;
      border: 1px solid rgba(255,255,255,0.06);
      border-radius: 8px;
    }
    .group {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding-right: 8px;
      border-right: 1px solid rgba(255,255,255,0.06);
    }
  </style>
</head>
<body>
  <div id="toolbar">
    <div class="group">
      <label for="pointsInput">Points</label>
    <input id="pointsInput" type="text" placeholder="HA96.5, HA87.5, HK87.5, HK85, HX84.5, HX96" />
      <button id="btnApply">Apply</button>
    </div>
    <div class="group">
      <label>Tile</label>
      <select id="tileKind">
        <option value="slate" selected>slate</option>
        <option value="thatch">thatch</option>
        <option value="terracotta">terracotta</option>
        <option value="grass">grass</option>
      </select>
      <label>Scale</label>
      <input id="tileScale" type="number" step="0.01" value="0.2" />
      <label>Rot</label>
      <input id="tileRot" type="number" step="1" value="0" />
    </div>
    <div class="group">
      <label>Part</label>
      <select id="partKind">
        <option value="ridge">ridge</option>
        <option value="ridge_long">ridge_long</option>
        <option value="cap">cap</option>
        <option value="hip">hip</option>
        <option value="dormer_small">dormer_small</option>
        <option value="dormer_large">dormer_large</option>
        <option value="chimney">chimney</option>
      </select>
      <label>Scale</label>
      <input id="partScale" type="number" step="0.05" value="1" />
      <label>Rot</label>
      <input id="partRot" type="number" step="1" value="0" />
      <button id="btnPlace" class="active">Place</button>
      <button id="btnDelete">Delete</button>
    </div>
    <div class="group">
      <label>Mode</label>
      <button id="btnModeParts" class="active">Parts</button>
      <button id="btnModeRects">Rects</button>
    </div>
    <div class="group">
      <label>ShapeÂ°</label>
      <input id="rectShapeAngle" type="number" step="1" value="0" />
      <label>Tail</label>
      <select id="rectTail">
        <option value="both" selected>Both</option>
        <option value="start">Start</option>
        <option value="end">End</option>
      </select>
      <label>Rot</label>
      <select id="rectRot">
        <option value="0" selected>0</option>
        <option value="90">90</option>
        <option value="180">180</option>
        <option value="270">270</option>
      </select>
      <label>Cap</label>
      <input type="checkbox" id="rectCap" checked />
      <label>Cap W</label>
      <input id="rectCapWidth" type="number" step="0.5" value="4" />
      <label>Cap Col</label>
      <input id="rectCapColor" type="color" value="#4b4f54" />
      <label>Spine W</label>
      <input id="rectSpineWidth" type="number" step="0.5" value="3" />
      <label>Z</label>
      <input id="rectZ" type="number" step="1" value="0" />
      <button id="btnRectFront">Front</button>
      <button id="btnRectBack">Back</button>
    </div>
    <label><input type="checkbox" id="gridToggle" checked /> Hexgrid</label>
    <label><input type="checkbox" id="snapToggle" checked /> Snap 0.5</label>
    <label><input type="checkbox" id="boundaryToggle" checked /> Clamp to Boundary</label>
    <button id="btnExportPng">Export PNG</button>
    <button id="btnCopyJson">Copy JSON</button>
    <span id="info" class="info"></span>
  </div>
  <div id="canvasWrap">
    <canvas id="roofCanvas"></canvas>
  </div>

  <script>
    (() => {
      const GRID = { size: 32, lineAlpha: 0.22, lineWidth: 1.1 };
      const VIEW = { cameraWorld: { x: 0, y: 0 }, zoom: 1 };
      const UI = { hexGrid: true, snapHalf: true, snapBoundary: true };
      const STATE = {
        points: [],
        worldPoints: [],
        tile: { kind: 'slate', scale: 0.2, rotDeg: 0 },
        parts: [],
        rects: [],
        selection: null,
        placeMode: true,
        mode: 'parts'
      };

      const TILE_TEXTURES = {
        slate: { url: '/assets/sprites/slate.png', scale: 0.2, color: '#3a434a' },
        terracotta: { url: '/assets/sprites/terracotta.png', scale: 0.2, color: '#6a3a2a' },
        thatch: { url: '/assets/sprites/thatch.png', scale: 0.2, color: '#6a5a3a' },
        grass: { url: '/assets/sprites/grass.png', scale: 0.2, color: '#2f5a2f' }
      };

      const PART_CATALOG = {
        ridge: { w: 2.0, h: 0.5, color: '#b9b1a5' },
        ridge_long: { w: 3.5, h: 0.5, color: '#b9b1a5' },
        cap: { w: 0.6, h: 0.6, color: '#c8bfae' },
        hip: { w: 1.2, h: 0.8, color: '#bfa996' },
        dormer_small: { w: 0.9, h: 0.9, color: '#7f8fa6' },
        dormer_large: { w: 1.4, h: 1.2, color: '#7f8fa6' },
        chimney: { w: 0.6, h: 0.9, color: '#9a5a4a' }
      };

      const spriteCache = new Map();
      const SPINE_SPRITE_URL = '/assets/sprites/roof_spine.png';

      const canvas = document.getElementById('roofCanvas');
      const ctx = canvas.getContext('2d');
      const pointsInput = document.getElementById('pointsInput');
      const btnApply = document.getElementById('btnApply');
      const gridToggle = document.getElementById('gridToggle');
      const snapToggle = document.getElementById('snapToggle');
      const boundaryToggle = document.getElementById('boundaryToggle');
      const tileKind = document.getElementById('tileKind');
      const tileScale = document.getElementById('tileScale');
      const tileRot = document.getElementById('tileRot');
      const partKind = document.getElementById('partKind');
      const partScale = document.getElementById('partScale');
      const partRot = document.getElementById('partRot');
      const btnPlace = document.getElementById('btnPlace');
      const btnDelete = document.getElementById('btnDelete');
      const btnModeParts = document.getElementById('btnModeParts');
      const btnModeRects = document.getElementById('btnModeRects');
      const rectShapeAngle = document.getElementById('rectShapeAngle');
      const rectTail = document.getElementById('rectTail');
      const rectRot = document.getElementById('rectRot');
      const rectCap = document.getElementById('rectCap');
      const rectCapWidth = document.getElementById('rectCapWidth');
      const rectCapColor = document.getElementById('rectCapColor');
      const rectSpineWidth = document.getElementById('rectSpineWidth');
      const rectZ = document.getElementById('rectZ');
      const btnRectFront = document.getElementById('btnRectFront');
      const btnRectBack = document.getElementById('btnRectBack');
      const btnExportPng = document.getElementById('btnExportPng');
      const btnCopyJson = document.getElementById('btnCopyJson');
      const info = document.getElementById('info');

      let renderDpr = window.devicePixelRatio || 1;
      let drag = null;

      function indexToLetters(idx) {
        let n = idx;
        let out = '';
        while (n >= 0) {
          out = String.fromCharCode(65 + (n % 26)) + out;
          n = Math.floor(n / 26) - 1;
        }
        return out;
      }

      function lettersToIndex(letters) {
        let n = 0;
        for (let i = 0; i < letters.length; i++) {
          n = n * 26 + (letters.charCodeAt(i) - 64);
        }
        return n - 1;
      }

      function toHexLabel(col, row) {
        return indexToLetters(col) + String(row + 1);
      }

      function parseHexLabel(label) {
        if (!label) return null;
        const m = String(label).trim().toUpperCase().match(/^([A-Z]+)(-?\d+(?:\.\d+)?)$/);
        if (!m) return null;
        const col = lettersToIndex(m[1]);
        const row = parseFloat(m[2]) - 1;
        return { col, row };
      }

      function parsePointList(text) {
        const raw = String(text || '')
          .split(',')
          .map(t => t.trim())
          .filter(Boolean);
        const out = [];
        for (const entry of raw) {
          const parsed = parseHexLabel(entry);
          if (!parsed) continue;
          out.push(entry.toUpperCase());
        }
        return out;
      }

      function colStep() { return 1.5 * GRID.size; }
      function rowStep() { return Math.sqrt(3) * GRID.size; }

      function hexToWorld(col, row) {
        const x = col * colStep();
        const y = -(row * rowStep() + (col & 1) * (rowStep() / 2));
        return { x, y };
      }

      function worldToHex(p) {
        const size = GRID.size || 1;
        const qf = (2 / 3) * (p.x / size);
        const rf = ((-p.y) / size) / Math.sqrt(3) - (qf / 2);
        const col = Math.round(qf);
        const rowf = rf + (col - (col & 1)) / 2;
        const row = Math.round(rowf);
        return { col, row };
      }

      function roundHalf(v) {
        return Math.round(v * 2) / 2;
      }

      function worldToHexHalf(p) {
        const size = GRID.size || 1;
        const qf = (2 / 3) * (p.x / size);
        const rf = ((-p.y) / size) / Math.sqrt(3) - (qf / 2);
        const col = Math.round(qf);
        const rowf = rf + (col - (col & 1)) / 2;
        const row = roundHalf(rowf);
        return { col, row };
      }

      function worldToScreen(p) {
        const cam = VIEW.cameraWorld;
        const w = canvas.width / renderDpr;
        const h = canvas.height / renderDpr;
        return {
          x: w / 2 + (p.x - cam.x) * VIEW.zoom,
          y: h / 2 + (p.y - cam.y) * VIEW.zoom,
        };
      }

      function screenToWorld(x, y) {
        const cam = VIEW.cameraWorld;
        const w = canvas.width / renderDpr;
        const h = canvas.height / renderDpr;
        const wx = (x - w / 2) / VIEW.zoom + cam.x;
        const wy = (y - h / 2) / VIEW.zoom + cam.y;
        return { x: wx, y: wy };
      }

      function setCanvasForBounds(bounds) {
        const pad = GRID.size * 2;
        const width = Math.max(240, (bounds.maxX - bounds.minX) + pad * 2);
        const height = Math.max(240, (bounds.maxY - bounds.minY) + pad * 2);
        renderDpr = window.devicePixelRatio || 1;
        canvas.width = width * renderDpr;
        canvas.height = height * renderDpr;
        canvas.style.width = `${width}px`;
        canvas.style.height = `${height}px`;
        ctx.setTransform(renderDpr, 0, 0, renderDpr, 0, 0);
      }

      function computeBounds(pts) {
        let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
        for (const p of pts) {
          minX = Math.min(minX, p.x);
          minY = Math.min(minY, p.y);
          maxX = Math.max(maxX, p.x);
          maxY = Math.max(maxY, p.y);
        }
        return { minX, minY, maxX, maxY };
      }

      function drawHexOutline(gctx, center, size) {
        const pts = [];
        for (let i = 0; i < 6; i++) {
          const a = (Math.PI / 180) * (60 * i);
          pts.push({ x: center.x + size * Math.cos(a), y: center.y + size * Math.sin(a) });
        }
        gctx.beginPath();
        gctx.moveTo(pts[0].x, pts[0].y);
        for (let i = 1; i < pts.length; i++) gctx.lineTo(pts[i].x, pts[i].y);
        gctx.closePath();
        gctx.stroke();
      }

      function drawGridLayer(gctx) {
        if (!UI.hexGrid) return;
        const rectW = canvas.width / renderDpr;
        const rectH = canvas.height / renderDpr;
        const camHex = worldToHex(VIEW.cameraWorld);
        const colsR = Math.ceil((rectW / 2) / colStep()) + 4;
        const rowsR = Math.ceil((rectH / 2) / rowStep()) + 4;
        gctx.save();
        gctx.strokeStyle = `rgba(255,255,255,${GRID.lineAlpha})`;
        gctx.lineWidth = GRID.lineWidth;
        const size = GRID.size * VIEW.zoom;
        for (let dc = -colsR; dc <= colsR; dc++) {
          for (let dr = -rowsR; dr <= rowsR; dr++) {
            const col = camHex.col + dc;
            const row = camHex.row + dr;
            const p = worldToScreen(hexToWorld(col, row));
            if (p.x < -100 || p.x > rectW + 100 || p.y < -100 || p.y > rectH + 100) continue;
            drawHexOutline(gctx, p, size);
          }
        }
        gctx.restore();
      }

      function loadSprite(url) {
        if (!url) return null;
        if (spriteCache.has(url)) return spriteCache.get(url);
        const img = new Image();
        img.__rdStatus = 'loading';
        img.src = url;
        img.onload = () => { img.__rdStatus = 'ready'; render(); };
        img.onerror = () => { img.__rdStatus = 'error'; render(); };
        spriteCache.set(url, img);
        return img;
      }

      function applyPatternTransform(pattern, scale, anchorWorld, rotDeg) {
        if (!pattern || typeof pattern.setTransform !== 'function') return;
        const rectW = canvas.width / renderDpr;
        const rectH = canvas.height / renderDpr;
        const anchor = anchorWorld || { x: 0, y: 0 };
        const originX = rectW / 2 + (anchor.x - VIEW.cameraWorld.x) * VIEW.zoom;
        const originY = rectH / 2 + (anchor.y - VIEW.cameraWorld.y) * VIEW.zoom;
        const s = (Number(scale) || 1) * VIEW.zoom;
        const m = new DOMMatrix();
        m.translateSelf(originX, originY);
        if (Number.isFinite(Number(rotDeg)) && Number(rotDeg) !== 0) {
          m.rotateSelf(Number(rotDeg));
        }
        m.scaleSelf(s, s);
        pattern.setTransform(m);
      }

      function getTexturePattern(kind) {
        const def = TILE_TEXTURES[kind];
        if (!def) return null;
        const img = loadSprite(def.url);
        if (!img || !img.complete || !img.naturalWidth || !img.naturalHeight) return null;
        const pat = ctx.createPattern(img, 'repeat');
        return { pattern: pat, scale: def.scale, color: def.color };
      }

      function drawPolygonBase(gctx) {
        if (STATE.worldPoints.length < 3) return;
        const screenPts = STATE.worldPoints.map(worldToScreen);
        gctx.save();
        gctx.beginPath();
        gctx.moveTo(screenPts[0].x, screenPts[0].y);
        for (let i = 1; i < screenPts.length; i++) gctx.lineTo(screenPts[i].x, screenPts[i].y);
        gctx.closePath();
        if (!STATE.rects.length) {
          const tileKindVal = STATE.tile.kind;
          const def = TILE_TEXTURES[tileKindVal];
          let fill = null;
          if (def) {
            const tex = getTexturePattern(tileKindVal);
            if (tex && tex.pattern) {
              const scale = Number.isFinite(Number(STATE.tile.scale)) ? Number(STATE.tile.scale) : tex.scale;
              applyPatternTransform(tex.pattern, scale, STATE.worldPoints[0], STATE.tile.rotDeg || 0);
              fill = tex.pattern;
            } else {
              fill = def.color;
            }
          }
          if (fill) {
            gctx.fillStyle = fill;
            gctx.fill();
          }
        }
        gctx.strokeStyle = 'rgba(106,169,255,0.85)';
        gctx.lineWidth = 2;
        gctx.stroke();
        gctx.restore();
      }

      function partWorld(part) {
        const parsed = parseHexLabel(part.hex);
        if (!parsed) return null;
        const base = hexToWorld(parsed.col, parsed.row);
        const ox = Number(part.ox) || 0;
        const oy = Number(part.oy) || 0;
        return { x: base.x + ox * GRID.size, y: base.y + oy * GRID.size };
      }

      function pointInPolygon(p, poly) {
        let inside = false;
        for (let i = 0, j = poly.length - 1; i < poly.length; j = i++) {
          const xi = poly[i].x, yi = poly[i].y;
          const xj = poly[j].x, yj = poly[j].y;
          const intersect = ((yi > p.y) !== (yj > p.y)) &&
            (p.x < (xj - xi) * (p.y - yi) / (yj - yi + 0.0000001) + xi);
          if (intersect) inside = !inside;
        }
        return inside;
      }

      function closestPointOnSegment(p, a, b) {
        const abx = b.x - a.x;
        const aby = b.y - a.y;
        const apx = p.x - a.x;
        const apy = p.y - a.y;
        const abLen2 = abx * abx + aby * aby;
        if (abLen2 <= 0.000001) return { x: a.x, y: a.y };
        let t = (apx * abx + apy * aby) / abLen2;
        t = Math.max(0, Math.min(1, t));
        return { x: a.x + abx * t, y: a.y + aby * t };
      }

      function closestPointOnPolygon(p, poly) {
        let best = null;
        let bestD2 = Infinity;
        for (let i = 0; i < poly.length; i++) {
          const a = poly[i];
          const b = poly[(i + 1) % poly.length];
          const c = closestPointOnSegment(p, a, b);
          const dx = p.x - c.x;
          const dy = p.y - c.y;
          const d2 = dx * dx + dy * dy;
          if (d2 < bestD2) {
            bestD2 = d2;
            best = c;
          }
        }
        return best || p;
      }

      function setPartFromWorld(part, world) {
        let target = world;
        if (UI.snapBoundary && STATE.worldPoints.length >= 3) {
          if (!pointInPolygon(target, STATE.worldPoints)) {
            target = closestPointOnPolygon(target, STATE.worldPoints);
          }
        }
        const snap = UI.snapHalf ? worldToHexHalf(target) : worldToHex(target);
        part.hex = toHexLabel(snap.col, snap.row);
        const base = hexToWorld(snap.col, snap.row);
        part.ox = (target.x - base.x) / GRID.size;
        part.oy = (target.y - base.y) / GRID.size;
      }

      function drawParts(gctx) {
        for (const part of STATE.parts) {
          const world = partWorld(part);
          if (!world) continue;
          const center = worldToScreen(world);
          const def = PART_CATALOG[part.kind] || { w: 1, h: 1, color: '#888' };
          const scale = Number.isFinite(Number(part.scale)) ? Number(part.scale) : 1;
          const rot = (Number(part.rotDeg) || 0) * Math.PI / 180;
          const sizeW = GRID.size * def.w * scale * VIEW.zoom;
          const sizeH = GRID.size * def.h * scale * VIEW.zoom;
          const spriteUrl = `/assets/sprites/roof_parts/${part.kind}.png`;
          const img = loadSprite(spriteUrl);

          gctx.save();
          gctx.translate(center.x, center.y);
          if (rot) gctx.rotate(rot);
          if (img && img.complete && img.naturalWidth && img.naturalHeight) {
            gctx.drawImage(img, -sizeW / 2, -sizeH / 2, sizeW, sizeH);
          } else if (!img || img.__rdStatus === 'error') {
            gctx.fillStyle = def.color;
            gctx.fillRect(-sizeW / 2, -sizeH / 2, sizeW, sizeH);
            gctx.strokeStyle = '#2b2f3a';
            gctx.strokeRect(-sizeW / 2, -sizeH / 2, sizeW, sizeH);
            gctx.fillStyle = '#e6e9ef';
            gctx.font = `${10 * VIEW.zoom}px ui-sans-serif, system-ui, -apple-system, Segoe UI, sans-serif`;
            gctx.textAlign = 'center';
            gctx.textBaseline = 'middle';
            gctx.fillText(part.kind, 0, 0);
          }
          if (STATE.selection && STATE.selection.type === 'part' && STATE.selection.id === part.id) {
            gctx.strokeStyle = '#6aa9ff';
            gctx.lineWidth = 2;
            gctx.strokeRect(-sizeW / 2, -sizeH / 2, sizeW, sizeH);
          }
          gctx.restore();
        }
      }

      function rectCorners(rect) {
        const minX = Math.min(rect.x1, rect.x2);
        const maxX = Math.max(rect.x1, rect.x2);
        const minY = Math.min(rect.y1, rect.y2);
        const maxY = Math.max(rect.y1, rect.y2);
        return { minX, maxX, minY, maxY };
      }

      function rotatePoints(points, center, deg) {
        const rad = (deg || 0) * Math.PI / 180;
        if (!rad) return points;
        const cos = Math.cos(rad);
        const sin = Math.sin(rad);
        return points.map(p => {
          const dx = p.x - center.x;
          const dy = p.y - center.y;
          return {
            x: center.x + dx * cos - dy * sin,
            y: center.y + dx * sin + dy * cos
          };
        });
      }

      function topCutPolygon(rect, angleDegRaw) {
        const { minX, maxX, minY, maxY } = rectCorners(rect);
        const widthW = Math.abs(maxX - minX);
        const heightW = Math.abs(maxY - minY);
        const midX = (minX + maxX) / 2;
        const midY = (minY + maxY) / 2;
        const angleDeg = Number.isFinite(Number(angleDegRaw)) ? Number(angleDegRaw) : 45;
        const theta = Math.max(1, Math.min(89, angleDeg)) * Math.PI / 180;
        const tail = rect.cutTail || 'both';
        const rotDeg = Number(rect.cutRot) || 0;

        if (widthW >= heightW) {
          const halfH = heightW / 2;
          let cutDepth = halfH / Math.tan(theta);
          cutDepth = Math.min(cutDepth, widthW / 2 - 0.001);
          cutDepth = Math.max(0, cutDepth);
          const leftCut = tail === 'both' || tail === 'start';
          const rightCut = tail === 'both' || tail === 'end';
          const pts = [];
          if (leftCut) {
            pts.push({ x: minX + cutDepth, y: minY });
          } else {
            pts.push({ x: minX, y: minY });
          }
          if (rightCut) {
            pts.push({ x: maxX - cutDepth, y: minY });
            pts.push({ x: maxX, y: midY });
            pts.push({ x: maxX - cutDepth, y: maxY });
          } else {
            pts.push({ x: maxX, y: minY });
            pts.push({ x: maxX, y: maxY });
          }
          if (leftCut) {
            pts.push({ x: minX + cutDepth, y: maxY });
            pts.push({ x: minX, y: midY });
          } else {
            pts.push({ x: minX, y: maxY });
          }
          return rotatePoints(pts, { x: midX, y: midY }, rotDeg);
        }

        const halfW = widthW / 2;
        let cutDepth = halfW / Math.tan(theta);
        cutDepth = Math.min(cutDepth, heightW / 2 - 0.001);
        cutDepth = Math.max(0, cutDepth);
        const topCut = tail === 'both' || tail === 'start';
        const bottomCut = tail === 'both' || tail === 'end';
        const pts = [];
        if (topCut) {
          pts.push({ x: minX, y: minY + cutDepth });
          pts.push({ x: midX, y: minY });
          pts.push({ x: maxX, y: minY + cutDepth });
        } else {
          pts.push({ x: minX, y: minY });
          pts.push({ x: maxX, y: minY });
        }
        if (bottomCut) {
          pts.push({ x: maxX, y: maxY - cutDepth });
          pts.push({ x: midX, y: maxY });
          pts.push({ x: minX, y: maxY - cutDepth });
        } else {
          pts.push({ x: maxX, y: maxY });
          pts.push({ x: minX, y: maxY });
        }
        return rotatePoints(pts, { x: midX, y: midY }, rotDeg);
      }

      function bottomCutPolygon(rect, angleDegRaw) {
        const { minX, maxX, minY, maxY } = rectCorners(rect);
        const widthW = Math.abs(maxX - minX);
        const heightW = Math.abs(maxY - minY);
        const midX = (minX + maxX) / 2;
        const midY = (minY + maxY) / 2;
        const angleDeg = Number.isFinite(Number(angleDegRaw)) ? Number(angleDegRaw) : 45;
        const theta = Math.max(1, Math.min(89, angleDeg)) * Math.PI / 180;
        const tail = rect.cutTail || 'both';
        const rotDeg = Number(rect.cutRot) || 0;

        if (widthW >= heightW) {
          const halfH = heightW / 2;
          let cutDepth = halfH / Math.tan(theta);
          cutDepth = Math.min(cutDepth, widthW / 2 - 0.001);
          cutDepth = Math.max(0, cutDepth);
          const leftCut = tail === 'both' || tail === 'start';
          const rightCut = tail === 'both' || tail === 'end';
          const pts = [
            { x: minX, y: minY },
            { x: maxX, y: minY },
          ];
          if (rightCut) pts.push({ x: maxX - cutDepth, y: midY });
          pts.push({ x: maxX, y: maxY });
          pts.push({ x: minX, y: maxY });
          if (leftCut) pts.push({ x: minX + cutDepth, y: midY });
          return rotatePoints(pts, { x: midX, y: midY }, rotDeg);
        }

        const halfW = widthW / 2;
        let cutDepth = halfW / Math.tan(theta);
        cutDepth = Math.min(cutDepth, heightW / 2 - 0.001);
        cutDepth = Math.max(0, cutDepth);
        const topCut = tail === 'both' || tail === 'start';
        const bottomCut = tail === 'both' || tail === 'end';
        const pts = [{ x: minX, y: minY }];
        if (topCut) pts.push({ x: midX, y: minY + cutDepth });
        pts.push({ x: maxX, y: minY });
        pts.push({ x: maxX, y: maxY });
        if (bottomCut) pts.push({ x: midX, y: maxY - cutDepth });
        pts.push({ x: minX, y: maxY });
        return rotatePoints(pts, { x: midX, y: midY }, rotDeg);
      }

      function rectDisplayPolygon(rect) {
        const { minX, maxX, minY, maxY } = rectCorners(rect);
        const angle = Number(rect.shapeAngle);
        if (!Number.isFinite(angle) || Math.abs(angle) < 1e-6) {
          return [
            { x: minX, y: minY },
            { x: maxX, y: minY },
            { x: maxX, y: maxY },
            { x: minX, y: maxY }
          ];
        }
        if (angle > 0) return topCutPolygon(rect, Math.abs(angle));
        return bottomCutPolygon(rect, Math.abs(angle));
      }

      function normalizeRect(rect, index) {
        if (!rect || typeof rect !== 'object') return;
        if (!Number.isFinite(Number(rect.shapeAngle))) {
          const legacyType = rect.type || 'base';
          const legacyAngle = Number.isFinite(Number(rect.cutAngle)) ? Number(rect.cutAngle) : 45;
          rect.shapeAngle = legacyType === 'top' ? Math.abs(legacyAngle) : 0;
        }
        rect.shapeAngle = Number(rect.shapeAngle) || 0;
        rect.cutTail = rect.cutTail || 'both';
        rect.cutRot = Number(rect.cutRot) || 0;
        rect.cap = rect.cap !== false;
        rect.capWidth = Number(rect.capWidth) || 4;
        rect.capColor = rect.capColor || '#4b4f54';
        rect.spineWidth = Number(rect.spineWidth) || 3;
        rect.z = Number.isFinite(Number(rect.z)) ? Number(rect.z) : index;
      }

      function drawCapForRect(gctx, rect) {
        if (rect.cap === false) return;
        const poly = rectDisplayPolygon(rect);
        const screenPts = poly.map(worldToScreen);
        gctx.save();
        gctx.lineJoin = 'round';
        gctx.lineCap = 'round';
        gctx.strokeStyle = rect.capColor || '#4b4f54';
        gctx.lineWidth = Number.isFinite(Number(rect.capWidth)) ? Number(rect.capWidth) : 4;
        gctx.beginPath();
        gctx.moveTo(screenPts[0].x, screenPts[0].y);
        for (let i = 1; i < screenPts.length; i++) gctx.lineTo(screenPts[i].x, screenPts[i].y);
        gctx.closePath();
        gctx.stroke();
        gctx.restore();
      }

      function drawSpineForRect(gctx, rect, clipRectFn, clipTopFn) {
        const img = loadSprite(SPINE_SPRITE_URL);
        const { minX, maxX, minY, maxY } = rectCorners(rect);
        const widthW = Math.abs(maxX - minX);
        const heightW = Math.abs(maxY - minY);
        const midX = (minX + maxX) / 2;
        const midY = (minY + maxY) / 2;
        const center = worldToScreen({ x: midX, y: midY });
        const spineThickness = (Number.isFinite(Number(rect.spineWidth)) ? Number(rect.spineWidth) : 3) * VIEW.zoom;
        const buildSpine = (lenPx, thickPx) => {
          if (!img || !img.complete || !img.naturalWidth || !img.naturalHeight) return null;
          const off = document.createElement('canvas');
          off.width = Math.max(1, Math.round(lenPx));
          off.height = Math.max(1, Math.round(thickPx));
          const oc = off.getContext('2d');
          oc.drawImage(img, 0, 0, off.width, off.height);
          const fadeLen = Math.min(off.width * 0.15, off.height * 6);
          oc.save();
          // Remove pixels near each end to create a soft taper.
          oc.globalCompositeOperation = 'destination-out';
          const gradL = oc.createLinearGradient(0, 0, fadeLen, 0);
          gradL.addColorStop(0, 'rgba(0,0,0,1)');
          gradL.addColorStop(1, 'rgba(0,0,0,0)');
          oc.fillStyle = gradL;
          oc.fillRect(0, 0, fadeLen, off.height);
          const gradR = oc.createLinearGradient(off.width, 0, off.width - fadeLen, 0);
          gradR.addColorStop(0, 'rgba(0,0,0,1)');
          gradR.addColorStop(1, 'rgba(0,0,0,0)');
          oc.fillStyle = gradR;
          oc.fillRect(off.width - fadeLen, 0, fadeLen, off.height);
          oc.restore();
          return off;
        };

        gctx.save();
        clipRectFn();
        clipTopFn();
        if (widthW >= heightW) {
          const len = widthW * VIEW.zoom;
          const spineImg = buildSpine(len, spineThickness);
          if (spineImg) {
            gctx.drawImage(spineImg, center.x - len / 2, center.y - spineThickness / 2);
          } else {
            gctx.strokeStyle = 'rgba(180,170,150,0.9)';
            gctx.lineWidth = Math.max(2, spineThickness * 0.35);
            gctx.beginPath();
            gctx.moveTo(center.x - len / 2, center.y);
            gctx.lineTo(center.x + len / 2, center.y);
            gctx.stroke();
          }
        } else {
          const len = heightW * VIEW.zoom;
          const spineImg = buildSpine(len, spineThickness);
          if (spineImg) {
            gctx.translate(center.x, center.y);
            gctx.rotate(Math.PI / 2);
            gctx.drawImage(spineImg, -len / 2, -spineThickness / 2);
          } else {
            gctx.strokeStyle = 'rgba(180,170,150,0.9)';
            gctx.lineWidth = Math.max(2, spineThickness * 0.35);
            gctx.beginPath();
            gctx.moveTo(center.x, center.y - len / 2);
            gctx.lineTo(center.x, center.y + len / 2);
            gctx.stroke();
          }
        }
        gctx.restore();
      }

      function rectCornerPoints(rect) {
        const { minX, maxX, minY, maxY } = rectCorners(rect);
        return [
          { x: minX, y: minY },
          { x: maxX, y: minY },
          { x: maxX, y: maxY },
          { x: minX, y: maxY }
        ];
      }

      function farthestRectCorner(rect, point) {
        const corners = rectCornerPoints(rect);
        let best = corners[0];
        let bestD2 = -Infinity;
        for (const c of corners) {
          const dx = c.x - point.x;
          const dy = c.y - point.y;
          const d2 = dx * dx + dy * dy;
          if (d2 > bestD2) {
            bestD2 = d2;
            best = c;
          }
        }
        return best;
      }

      function rectCenter(rect) {
        const { minX, maxX, minY, maxY } = rectCorners(rect);
        return { x: (minX + maxX) / 2, y: (minY + maxY) / 2 };
      }

      function rectOverlap(a, b) {
        const ra = rectCorners(a);
        const rb = rectCorners(b);
        const minX = Math.max(ra.minX, rb.minX);
        const maxX = Math.min(ra.maxX, rb.maxX);
        const minY = Math.max(ra.minY, rb.minY);
        const maxY = Math.min(ra.maxY, rb.maxY);
        if (minX >= maxX || minY >= maxY) return null;
        return { minX, maxX, minY, maxY };
      }

      function rectSpineAngle(rect) {
        const { minX, maxX, minY, maxY } = rectCorners(rect);
        const widthW = Math.abs(maxX - minX);
        const heightW = Math.abs(maxY - minY);
        return widthW >= heightW ? 0 : Math.PI / 2;
      }

      function rectSpineLine(rect) {
        const { minX, maxX, minY, maxY } = rectCorners(rect);
        const widthW = Math.abs(maxX - minX);
        const heightW = Math.abs(maxY - minY);
        if (widthW >= heightW) {
          const y = (minY + maxY) / 2;
          return { orientation: 'h', a: { x: minX, y }, b: { x: maxX, y } };
        }
        const x = (minX + maxX) / 2;
        return { orientation: 'v', a: { x, y: minY }, b: { x, y: maxY } };
      }

      function spineIntersection(a, b) {
        if (!a || !b || a.orientation === b.orientation) return null;
        if (a.orientation === 'h') {
          return { x: b.a.x, y: a.a.y };
        }
        return { x: a.a.x, y: b.a.y };
      }

      function overlapCorners(overlap) {
        return [
          { x: overlap.minX, y: overlap.minY },
          { x: overlap.maxX, y: overlap.minY },
          { x: overlap.maxX, y: overlap.maxY },
          { x: overlap.minX, y: overlap.maxY }
        ];
      }

      function sideFromSpine(spine, otherCenter) {
        if (spine.orientation === 'h') {
          return otherCenter.y < spine.a.y ? 'top' : 'bottom';
        }
        return otherCenter.x < spine.a.x ? 'left' : 'right';
      }

      function pickValleyCorner(overlap, rectA, rectB) {
        const spineA = rectSpineLine(rectA);
        const spineB = rectSpineLine(rectB);
        const centerA = rectCenter(rectA);
        const centerB = rectCenter(rectB);
        const sideA = sideFromSpine(spineA, centerB);
        const sideB = sideFromSpine(spineB, centerA);
        let x = null;
        let y = null;
        const pickX = (side) => (side === 'left' ? overlap.minX : overlap.maxX);
        const pickY = (side) => (side === 'top' ? overlap.minY : overlap.maxY);
        if (sideA === 'left' || sideA === 'right') x = pickX(sideA);
        if (sideA === 'top' || sideA === 'bottom') y = pickY(sideA);
        if (sideB === 'left' || sideB === 'right') x = x ?? pickX(sideB);
        if (sideB === 'top' || sideB === 'bottom') y = y ?? pickY(sideB);
        if (x == null) x = overlap.minX;
        if (y == null) y = overlap.minY;
        return { x, y };
      }

      function rectSideCorners(rect, side) {
        const { minX, maxX, minY, maxY } = rectCorners(rect);
        if (side === 'left') return [{ x: minX, y: minY }, { x: minX, y: maxY }];
        if (side === 'right') return [{ x: maxX, y: minY }, { x: maxX, y: maxY }];
        if (side === 'top') return [{ x: minX, y: minY }, { x: maxX, y: minY }];
        if (side === 'bottom') return [{ x: minX, y: maxY }, { x: maxX, y: maxY }];
        return [];
      }

      function pickValleyCorners(overlap, rectA, rectB) {
        const spineA = rectSpineLine(rectA);
        const centerB = rectCenter(rectB);
        const sideA = sideFromSpine(spineA, centerB);
        const corners = rectSideCorners(rectA, sideA);
        if (corners.length) return corners;
        const one = pickValleyCorner(overlap, rectA, rectB);
        return [one];
      }

      function valleyLinesBetweenRects(a, b) {
        const overlap = rectOverlap(a, b);
        if (!overlap) return [];
        const spineA = rectSpineLine(a);
        const spineB = rectSpineLine(b);
        if (spineA.orientation === spineB.orientation) return [];
        const intersection = spineIntersection(spineA, spineB);
        if (!intersection) return [];
        const corners = pickValleyCorners(overlap, a, b);
        return corners.map(corner => ({ a: corner, b: intersection }));
      }

      function getValleyLinesForRect(rect) {
        const out = [];
        for (const other of STATE.rects) {
          if (other.id === rect.id) continue;
          const lines = valleyLinesBetweenRects(rect, other);
          for (const line of lines) out.push({ ...line, otherCenter: rectCenter(other) });
        }
        return out;
      }

      function clipToHalfPlaneWorld(gctx, a, b, keep) {
        const dx = b.x - a.x;
        const dy = b.y - a.y;
        const len = Math.hypot(dx, dy) || 1;
        const ux = dx / len;
        const uy = dy / len;
        const nx = -uy;
        const ny = ux;
        const sign = ((keep.x - a.x) * nx + (keep.y - a.y) * ny) >= 0 ? 1 : -1;
        const big = 100000;
        const p0 = { x: a.x - ux * big, y: a.y - uy * big };
        const p1 = { x: a.x + ux * big, y: a.y + uy * big };
        const p2 = { x: p1.x + nx * sign * big, y: p1.y + ny * sign * big };
        const p3 = { x: p0.x + nx * sign * big, y: p0.y + ny * sign * big };
        const s0 = worldToScreen(p0);
        const s1 = worldToScreen(p1);
        const s2 = worldToScreen(p2);
        const s3 = worldToScreen(p3);
        gctx.beginPath();
        gctx.moveTo(s0.x, s0.y);
        gctx.lineTo(s1.x, s1.y);
        gctx.lineTo(s2.x, s2.y);
        gctx.lineTo(s3.x, s3.y);
        gctx.closePath();
        gctx.clip();
      }

      function lineSide(p, a, b) {
        return Math.sign((b.x - a.x) * (p.y - a.y) - (b.y - a.y) * (p.x - a.x));
      }

      function pickKeepPoint(rect, halfCenter, line, otherCenter) {
        if (!otherCenter) return halfCenter;
        const sideOther = lineSide(otherCenter, line.a, line.b);
        if (!sideOther) return halfCenter;
        const candidates = [
          halfCenter,
          rectCenter(rect),
          ...rectCornerPoints(rect)
        ];
        let best = halfCenter;
        let bestScore = Infinity;
        for (const c of candidates) {
          const sideC = lineSide(c, line.a, line.b);
          if (!sideC) continue;
          const score = sideC * sideOther; // negative is opposite
          if (score < bestScore) {
            bestScore = score;
            best = c;
          }
        }
        return best;
      }

      function chooseDiagonal(overlap, c1, c2) {
        const diag1 = { a: { x: overlap.minX, y: overlap.minY }, b: { x: overlap.maxX, y: overlap.maxY } };
        const diag2 = { a: { x: overlap.minX, y: overlap.maxY }, b: { x: overlap.maxX, y: overlap.minY } };
        const s1 = lineSide(c1, diag1.a, diag1.b);
        const s2 = lineSide(c2, diag1.a, diag1.b);
        if (s1 && s2 && s1 !== s2) return diag1;
        const t1 = lineSide(c1, diag2.a, diag2.b);
        const t2 = lineSide(c2, diag2.a, diag2.b);
        if (t1 && t2 && t1 !== t2) return diag2;
        return diag1;
      }

      function rectPoints(rect) {
        const { minX, maxX, minY, maxY } = rectCorners(rect);
        const midX = (minX + maxX) / 2;
        const midY = (minY + maxY) / 2;
        return [
          { x: minX, y: minY },
          { x: maxX, y: minY },
          { x: maxX, y: maxY },
          { x: minX, y: maxY },
          { x: midX, y: minY },
          { x: maxX, y: midY },
          { x: midX, y: maxY },
          { x: minX, y: midY },
          { x: midX, y: midY }
        ];
      }

      function rectInsidePolygon(rect) {
        if (!STATE.worldPoints.length) return true;
        const pts = rectPoints(rect);
        for (const p of pts) {
          if (!pointInPolygon(p, STATE.worldPoints)) return false;
        }
        return true;
      }

      function interpolateRect(a, b, t) {
        return {
          x1: a.x1 + (b.x1 - a.x1) * t,
          y1: a.y1 + (b.y1 - a.y1) * t,
          x2: a.x2 + (b.x2 - a.x2) * t,
          y2: a.y2 + (b.y2 - a.y2) * t
        };
      }

      function clampRectToPolygon(orig, target) {
        if (!UI.snapBoundary || !STATE.worldPoints.length) return target;
        if (rectInsidePolygon(target)) return target;
        let lo = 0;
        let hi = 1;
        let best = orig;
        for (let i = 0; i < 16; i++) {
          const mid = (lo + hi) / 2;
          const test = interpolateRect(orig, target, mid);
          if (rectInsidePolygon(test)) {
            best = test;
            lo = mid;
          } else {
            hi = mid;
          }
        }
        return best;
      }

      function rectHandles(rect) {
        const { minX, maxX, minY, maxY } = rectCorners(rect);
        return [
          { edge: 'n', world: { x: (minX + maxX) / 2, y: minY } },
          { edge: 'e', world: { x: maxX, y: (minY + maxY) / 2 } },
          { edge: 's', world: { x: (minX + maxX) / 2, y: maxY } },
          { edge: 'w', world: { x: minX, y: (minY + maxY) / 2 } },
        ];
      }

      function drawRectHandles(gctx, rect) {
        const handles = rectHandles(rect);
        gctx.save();
        gctx.strokeStyle = 'rgba(255,210,102,0.95)';
        gctx.fillStyle = 'rgba(255,210,102,0.25)';
        gctx.lineWidth = 2;
        for (const h of handles) {
          const p = worldToScreen(h.world);
          gctx.beginPath();
          gctx.arc(p.x, p.y, 10, 0, Math.PI * 2);
          gctx.fill();
          gctx.stroke();
        }
        gctx.restore();
      }

      function findRectHandleAtScreen(rect, x, y) {
        const handles = rectHandles(rect);
        for (const h of handles) {
          const p = worldToScreen(h.world);
          const dx = x - p.x;
          const dy = y - p.y;
          const hit = 22;
          if ((dx * dx + dy * dy) <= hit * hit) return h.edge;
        }
        return null;
      }

      function drawRects(gctx) {
        const sorted = [...STATE.rects].sort((a, b) => (Number(a.z) || 0) - (Number(b.z) || 0));
        for (const rect of sorted) {
          normalizeRect(rect, 0);
          const { minX, maxX, minY, maxY } = rectCorners(rect);
          const tl = worldToScreen({ x: minX, y: minY });
          const br = worldToScreen({ x: maxX, y: maxY });
          const w = br.x - tl.x;
          const h = br.y - tl.y;
          gctx.save();
          const tileKindVal = rect.tileKind || STATE.tile.kind;
          const def = TILE_TEXTURES[tileKindVal];
          let fill = null;
          if (def) {
            const tex = getTexturePattern(tileKindVal);
            if (tex && tex.pattern) {
              const scale = Number.isFinite(Number(STATE.tile.scale)) ? Number(STATE.tile.scale) : tex.scale;
              const widthW = Math.abs(maxX - minX);
              const heightW = Math.abs(maxY - minY);
              const baseRot = Number(STATE.tile.rotDeg) || 0;
              const midX = (minX + maxX) / 2;
              const midY = (minY + maxY) / 2;
              const valleyLines = [];
              const clipShape = () => {
                const poly = rectDisplayPolygon(rect);
                const p0 = worldToScreen(poly[0]);
                gctx.beginPath();
                gctx.moveTo(p0.x, p0.y);
                for (let i = 1; i < poly.length; i++) {
                  const pi = worldToScreen(poly[i]);
                  gctx.lineTo(pi.x, pi.y);
                }
                gctx.closePath();
                gctx.clip();
              };
              const clipRect = () => {
                const p1 = worldToScreen({ x: minX, y: minY });
                const p2 = worldToScreen({ x: maxX, y: maxY });
                gctx.beginPath();
                gctx.rect(p1.x, p1.y, p2.x - p1.x, p2.y - p1.y);
                gctx.clip();
              };
              const clipHalf = (x1, y1, x2, y2) => {
                const p1 = worldToScreen({ x: x1, y: y1 });
                const p2 = worldToScreen({ x: x2, y: y2 });
                gctx.beginPath();
                gctx.rect(p1.x, p1.y, p2.x - p1.x, p2.y - p1.y);
                gctx.clip();
              };
              const spine = rectSpineLine(rect);
              const fillHalf = (x1, y1, x2, y2, rotDeg, halfTag) => {
                gctx.save();
                clipRect();
                clipShape();
                const halfCenter = { x: (x1 + x2) / 2, y: (y1 + y2) / 2 };
                for (const line of valleyLines) {
                  if (spine.orientation === 'h') {
                    const isTop = line.a.y <= midY;
                    if ((halfTag === 'top' && !isTop) || (halfTag === 'bottom' && isTop)) continue;
                  } else {
                    const isLeft = line.a.x <= midX;
                    if ((halfTag === 'left' && !isLeft) || (halfTag === 'right' && isLeft)) continue;
                  }
                  const keepPoint = pickKeepPoint(rect, halfCenter, line, line.otherCenter);
                  clipToHalfPlaneWorld(gctx, line.a, line.b, keepPoint);
                }
                clipHalf(x1, y1, x2, y2);
                applyPatternTransform(tex.pattern, scale, { x: x1, y: y1 }, rotDeg);
                gctx.fillStyle = tex.pattern;
                const p1 = worldToScreen({ x: x1, y: y1 });
                const p2 = worldToScreen({ x: x2, y: y2 });
                gctx.fillRect(p1.x, p1.y, p2.x - p1.x, p2.y - p1.y);
                gctx.restore();
              };
              const shadeHalf = (x1, y1, x2, y2, alpha) => {
                gctx.save();
                clipRect();
                clipShape();
                clipHalf(x1, y1, x2, y2);
                gctx.fillStyle = `rgba(0,0,0,${alpha})`;
                const p1 = worldToScreen({ x: x1, y: y1 });
                const p2 = worldToScreen({ x: x2, y: y2 });
                gctx.fillRect(p1.x, p1.y, p2.x - p1.x, p2.y - p1.y);
                gctx.restore();
              };
              if (heightW > widthW) {
                // vertical spine: split left/right
                fillHalf(minX, minY, midX, maxY, baseRot + 90, 'left');
                fillHalf(midX, minY, maxX, maxY, baseRot + 270, 'right');
              } else {
                // horizontal spine: split top/bottom
                fillHalf(minX, midY, maxX, maxY, baseRot + 0, 'bottom');
                fillHalf(minX, minY, maxX, midY, baseRot + 180, 'top');
              }
              // subtle shadowing on north/east sides
              shadeHalf(minX, minY, maxX, midY, 0.08); // north
              shadeHalf(midX, minY, maxX, maxY, 0.05); // east
              drawSpineForRect(gctx, rect, clipRect, clipShape);
              fill = tex.pattern;
            } else {
              fill = def.color;
            }
          }
          if (!fill) {
            gctx.fillStyle = 'rgba(255,210,102,0.08)';
            gctx.fillRect(tl.x, tl.y, w, h);
          }

          drawCapForRect(gctx, rect);

          if (STATE.selection && STATE.selection.type === 'rect' && STATE.selection.id === rect.id) {
            gctx.strokeStyle = '#6aa9ff';
            gctx.lineWidth = 2;
            gctx.strokeRect(tl.x - 2, tl.y - 2, w + 4, h + 4);
          }
          gctx.restore();
        }
        if (drag && drag.type === 'rect-new' && drag.preview) {
          const temp = rectCorners(drag.preview);
          const tl = worldToScreen({ x: temp.minX, y: temp.minY });
          const br = worldToScreen({ x: temp.maxX, y: temp.maxY });
          gctx.save();
          gctx.setLineDash([6, 4]);
          gctx.strokeStyle = 'rgba(255,210,102,0.9)';
          gctx.lineWidth = 2;
          gctx.strokeRect(tl.x, tl.y, br.x - tl.x, br.y - tl.y);
          gctx.restore();
        }
      }

      function render() {
        const rectW = canvas.width / renderDpr;
        const rectH = canvas.height / renderDpr;
        ctx.clearRect(0, 0, rectW, rectH);
        drawGridLayer(ctx);
        drawPolygonBase(ctx);
        drawRects(ctx);
        if (STATE.selection && STATE.selection.type === 'rect') {
          const rect = STATE.rects.find(r => r.id === STATE.selection.id);
          if (rect) drawRectHandles(ctx, rect);
        }
        drawParts(ctx);
      }

      function loadPoints(raw) {
        const points = parsePointList(raw);
        STATE.points = points;
        STATE.worldPoints = points.map(label => {
          const parsed = parseHexLabel(label);
          return parsed ? hexToWorld(parsed.col, parsed.row) : null;
        }).filter(Boolean);
        if (STATE.worldPoints.length >= 3) {
          const bounds = computeBounds(STATE.worldPoints);
          VIEW.cameraWorld = {
            x: (bounds.minX + bounds.maxX) / 2,
            y: (bounds.minY + bounds.maxY) / 2
          };
          setCanvasForBounds(bounds);
          if (info) info.textContent = `${STATE.points.length} points | ${STATE.parts.length} parts | ${STATE.rects.length} rects`;
          render();
        } else {
          if (info) info.textContent = 'Enter at least 3 points';
        }
      }

      function findPartAtScreen(x, y) {
        for (let i = STATE.parts.length - 1; i >= 0; i--) {
          const part = STATE.parts[i];
          const world = partWorld(part);
          if (!world) continue;
          const center = worldToScreen(world);
          const def = PART_CATALOG[part.kind] || { w: 1, h: 1 };
          const scale = Number.isFinite(Number(part.scale)) ? Number(part.scale) : 1;
          const sizeW = GRID.size * def.w * scale * VIEW.zoom;
          const sizeH = GRID.size * def.h * scale * VIEW.zoom;
          const left = center.x - sizeW / 2;
          const top = center.y - sizeH / 2;
          if (x >= left && x <= left + sizeW && y >= top && y <= top + sizeH) return part;
        }
        return null;
      }

      function findRectAtScreen(x, y) {
        const sorted = [...STATE.rects].sort((a, b) => (Number(a.z) || 0) - (Number(b.z) || 0));
        for (let i = sorted.length - 1; i >= 0; i--) {
          const rect = sorted[i];
          const { minX, maxX, minY, maxY } = rectCorners(rect);
          const tl = worldToScreen({ x: minX, y: minY });
          const br = worldToScreen({ x: maxX, y: maxY });
          if (x >= tl.x && x <= br.x && y >= tl.y && y <= br.y) return rect;
        }
        return null;
      }

      function addPartAt(world) {
        const kind = partKind.value;
        const part = {
          id: `part_${Date.now().toString(36)}_${Math.random().toString(36).slice(2, 6)}`,
          kind,
          hex: 'A1',
          ox: 0,
          oy: 0,
          scale: Number(partScale.value) || 1,
          rotDeg: Number(partRot.value) || 0
        };
        setPartFromWorld(part, world);
        STATE.parts.push(part);
        STATE.selection = { type: 'part', id: part.id };
      }

      function updateSelectionUI() {
        const sel = STATE.selection;
        if (!sel) return;
        if (sel.type === 'part') {
          const part = STATE.parts.find(p => p.id === sel.id);
          if (!part) return;
          partKind.value = part.kind;
          partScale.value = String(part.scale ?? 1);
          partRot.value = String(part.rotDeg ?? 0);
        } else if (sel.type === 'rect') {
          const rect = STATE.rects.find(r => r.id === sel.id);
          if (!rect) return;
          normalizeRect(rect, 0);
          rectShapeAngle.value = String(rect.shapeAngle ?? 0);
          rectTail.value = rect.cutTail || 'both';
          rectRot.value = String(rect.cutRot ?? 0);
          rectCap.checked = rect.cap !== false;
          rectCapWidth.value = String(rect.capWidth ?? 4);
          rectCapColor.value = rect.capColor || '#4b4f54';
          rectSpineWidth.value = String(rect.spineWidth ?? 3);
          rectZ.value = String(rect.z ?? 0);
        }
      }

      canvas.addEventListener('mousedown', (ev) => {
        const rect = canvas.getBoundingClientRect();
        const x = ev.clientX - rect.left;
        const y = ev.clientY - rect.top;
        const hitPart = findPartAtScreen(x, y);
        const hitRect = hitPart ? null : findRectAtScreen(x, y);

        if (hitPart) {
          STATE.selection = { type: 'part', id: hitPart.id };
          updateSelectionUI();
          const world = partWorld(hitPart);
          drag = {
            type: 'part',
            id: hitPart.id,
            offset: world ? { x: world.x - screenToWorld(x, y).x, y: world.y - screenToWorld(x, y).y } : { x: 0, y: 0 }
          };
          render();
          return;
        }
        if (hitRect) {
          STATE.selection = { type: 'rect', id: hitRect.id };
          const handle = findRectHandleAtScreen(hitRect, x, y);
          if (handle) {
            drag = {
              type: 'rect-handle',
              id: hitRect.id,
              edge: handle,
              startWorld: screenToWorld(x, y),
              startRect: { ...hitRect }
            };
          } else {
            drag = {
              type: 'rect',
              id: hitRect.id,
              startWorld: screenToWorld(x, y)
            };
          }
          render();
          return;
        }

        if (STATE.mode === 'rects') {
          drag = { type: 'rect-new', startWorld: screenToWorld(x, y) };
          STATE.selection = null;
          render();
          return;
        }

        if (STATE.placeMode) {
          const world = screenToWorld(x, y);
          addPartAt(world);
          updateSelectionUI();
          render();
          return;
        }

        STATE.selection = null;
        render();
      });

      window.addEventListener('mousemove', (ev) => {
        if (!drag) return;
        const rect = canvas.getBoundingClientRect();
        const x = ev.clientX - rect.left;
        const y = ev.clientY - rect.top;
        const world = screenToWorld(x, y);
        if (drag.type === 'part') {
          const part = STATE.parts.find(p => p.id === drag.id);
          if (!part) return;
          const target = { x: world.x + drag.offset.x, y: world.y + drag.offset.y };
          setPartFromWorld(part, target);
          render();
        } else if (drag.type === 'rect-new') {
          const start = drag.startWorld;
          drag.preview = {
            x1: start.x,
            y1: start.y,
            x2: world.x,
            y2: world.y
          };
          render();
        } else if (drag.type === 'rect') {
          const rectObj = STATE.rects.find(r => r.id === drag.id);
          if (!rectObj) return;
          const dx = world.x - drag.startWorld.x;
          const dy = world.y - drag.startWorld.y;
          const orig = { ...rectObj };
          const candidate = {
            x1: rectObj.x1 + dx,
            x2: rectObj.x2 + dx,
            y1: rectObj.y1 + dy,
            y2: rectObj.y2 + dy
          };
          const clamped = clampRectToPolygon(orig, candidate);
          rectObj.x1 = clamped.x1;
          rectObj.x2 = clamped.x2;
          rectObj.y1 = clamped.y1;
          rectObj.y2 = clamped.y2;
          drag.startWorld = world;
        } else if (drag.type === 'rect-handle') {
          const rectObj = STATE.rects.find(r => r.id === drag.id);
          if (!rectObj) return;
          const minSize = GRID.size * 0.5;
          const candidate = { ...drag.startRect };
          if (drag.edge === 'n') {
            candidate.y1 = Math.min(world.y, candidate.y2 - minSize);
          } else if (drag.edge === 's') {
            candidate.y2 = Math.max(world.y, candidate.y1 + minSize);
          } else if (drag.edge === 'w') {
            candidate.x1 = Math.min(world.x, candidate.x2 - minSize);
          } else if (drag.edge === 'e') {
            candidate.x2 = Math.max(world.x, candidate.x1 + minSize);
          }
          const clamped = clampRectToPolygon(drag.startRect, candidate);
          rectObj.x1 = clamped.x1;
          rectObj.x2 = clamped.x2;
          rectObj.y1 = clamped.y1;
          rectObj.y2 = clamped.y2;
          render();
        }
      });

      window.addEventListener('mouseup', () => {
        if (drag && drag.type === 'rect-new' && drag.preview) {
          const rectObj = {
            id: `rect_${Date.now().toString(36)}_${Math.random().toString(36).slice(2, 6)}`,
            x1: drag.preview.x1,
            y1: drag.preview.y1,
            x2: drag.preview.x2,
            y2: drag.preview.y2,
            shapeAngle: Number(rectShapeAngle.value) || 0,
            cutTail: rectTail.value,
            cutRot: Number(rectRot.value) || 0,
            cap: rectCap.checked,
            capWidth: Number(rectCapWidth.value) || 4,
            capColor: rectCapColor.value || '#4b4f54',
            spineWidth: Number(rectSpineWidth.value) || 3,
            z: Number(rectZ.value) || STATE.rects.length
          };
          normalizeRect(rectObj, STATE.rects.length);
          if (rectInsidePolygon(rectObj)) {
            STATE.rects.push(rectObj);
            STATE.selection = { type: 'rect', id: rectObj.id };
          }
          if (info) info.textContent = `${STATE.points.length} points | ${STATE.parts.length} parts | ${STATE.rects.length} rects`;
        }
        drag = null;
        render();
      });

      btnApply.addEventListener('click', () => loadPoints(pointsInput.value));
      gridToggle.addEventListener('change', () => {
        UI.hexGrid = gridToggle.checked;
        render();
      });
      snapToggle.addEventListener('change', () => {
        UI.snapHalf = snapToggle.checked;
      });
      boundaryToggle.addEventListener('change', () => {
        UI.snapBoundary = boundaryToggle.checked;
      });

      tileKind.addEventListener('change', () => {
        STATE.tile.kind = tileKind.value;
        render();
      });
      tileScale.addEventListener('input', () => {
        STATE.tile.scale = Number(tileScale.value) || STATE.tile.scale;
        render();
      });
      tileRot.addEventListener('input', () => {
        STATE.tile.rotDeg = Number(tileRot.value) || 0;
        render();
      });

      partKind.addEventListener('change', () => {
        if (STATE.selection && STATE.selection.type === 'part') {
          const part = STATE.parts.find(p => p.id === STATE.selection.id);
          if (part) part.kind = partKind.value;
          render();
        }
      });
      partScale.addEventListener('input', () => {
        if (STATE.selection && STATE.selection.type === 'part') {
          const part = STATE.parts.find(p => p.id === STATE.selection.id);
          if (part) part.scale = Number(partScale.value) || 1;
          render();
        }
      });
      partRot.addEventListener('input', () => {
        if (STATE.selection && STATE.selection.type === 'part') {
          const part = STATE.parts.find(p => p.id === STATE.selection.id);
          if (part) part.rotDeg = Number(partRot.value) || 0;
          render();
        }
      });

      btnPlace.addEventListener('click', () => {
        STATE.placeMode = !STATE.placeMode;
        btnPlace.classList.toggle('active', STATE.placeMode);
      });

      btnDelete.addEventListener('click', () => {
        if (!STATE.selection) return;
        if (STATE.selection.type === 'part') {
          STATE.parts = STATE.parts.filter(p => p.id !== STATE.selection.id);
        } else if (STATE.selection.type === 'rect') {
          STATE.rects = STATE.rects.filter(r => r.id !== STATE.selection.id);
        }
        STATE.selection = null;
        render();
      });

      rectShapeAngle.addEventListener('input', () => {
        if (STATE.selection && STATE.selection.type === 'rect') {
          const rect = STATE.rects.find(r => r.id === STATE.selection.id);
          if (rect) rect.shapeAngle = Number(rectShapeAngle.value) || 0;
          render();
        }
      });

      rectTail.addEventListener('change', () => {
        if (STATE.selection && STATE.selection.type === 'rect') {
          const rect = STATE.rects.find(r => r.id === STATE.selection.id);
          if (rect) rect.cutTail = rectTail.value;
          render();
        }
      });

      rectRot.addEventListener('change', () => {
        if (STATE.selection && STATE.selection.type === 'rect') {
          const rect = STATE.rects.find(r => r.id === STATE.selection.id);
          if (rect) rect.cutRot = Number(rectRot.value) || 0;
          render();
        }
      });

      rectCap.addEventListener('change', () => {
        if (STATE.selection && STATE.selection.type === 'rect') {
          const rect = STATE.rects.find(r => r.id === STATE.selection.id);
          if (rect) rect.cap = rectCap.checked;
          render();
        }
      });

      rectCapWidth.addEventListener('input', () => {
        if (STATE.selection && STATE.selection.type === 'rect') {
          const rect = STATE.rects.find(r => r.id === STATE.selection.id);
          if (rect) rect.capWidth = Number(rectCapWidth.value) || 4;
          render();
        }
      });

      rectCapColor.addEventListener('input', () => {
        if (STATE.selection && STATE.selection.type === 'rect') {
          const rect = STATE.rects.find(r => r.id === STATE.selection.id);
          if (rect) rect.capColor = rectCapColor.value;
          render();
        }
      });

      rectSpineWidth.addEventListener('input', () => {
        if (STATE.selection && STATE.selection.type === 'rect') {
          const rect = STATE.rects.find(r => r.id === STATE.selection.id);
          if (rect) rect.spineWidth = Number(rectSpineWidth.value) || 3;
          render();
        }
      });

      rectZ.addEventListener('input', () => {
        if (STATE.selection && STATE.selection.type === 'rect') {
          const rect = STATE.rects.find(r => r.id === STATE.selection.id);
          if (rect) rect.z = Number(rectZ.value) || 0;
          render();
        }
      });

      btnRectFront.addEventListener('click', () => {
        if (!(STATE.selection && STATE.selection.type === 'rect')) return;
        const rect = STATE.rects.find(r => r.id === STATE.selection.id);
        if (!rect) return;
        const maxZ = STATE.rects.reduce((m, r) => Math.max(m, Number(r.z) || 0), 0);
        rect.z = maxZ + 1;
        rectZ.value = String(rect.z);
        render();
      });

      btnRectBack.addEventListener('click', () => {
        if (!(STATE.selection && STATE.selection.type === 'rect')) return;
        const rect = STATE.rects.find(r => r.id === STATE.selection.id);
        if (!rect) return;
        const minZ = STATE.rects.reduce((m, r) => Math.min(m, Number(r.z) || 0), 0);
        rect.z = minZ - 1;
        rectZ.value = String(rect.z);
        render();
      });

      btnExportPng.addEventListener('click', () => {
        const link = document.createElement('a');
        link.download = 'roof.png';
        link.href = canvas.toDataURL('image/png');
        link.click();
      });

      btnCopyJson.addEventListener('click', async () => {
        for (let i = 0; i < STATE.rects.length; i++) normalizeRect(STATE.rects[i], i);
        const payload = {
          points: STATE.points,
          tile: STATE.tile,
          rects: STATE.rects.map(r => ({
            x1: r.x1,
            y1: r.y1,
            x2: r.x2,
            y2: r.y2,
            shapeAngle: r.shapeAngle,
            cutTail: r.cutTail,
            cutRot: r.cutRot,
            cap: r.cap,
            capWidth: r.capWidth,
            capColor: r.capColor,
            spineWidth: r.spineWidth,
            z: r.z
          })),
          parts: STATE.parts.map(p => ({
            kind: p.kind,
            hex: p.hex,
            ox: p.ox,
            oy: p.oy,
            scale: p.scale,
            rotDeg: p.rotDeg
          }))
        };
        const text = JSON.stringify(payload, null, 2);
        try {
          await navigator.clipboard.writeText(text);
          if (info) info.textContent = 'Copied JSON';
        } catch {
          if (info) info.textContent = 'Copy failed';
        }
      });

      const qp = new URLSearchParams(window.location.search || '');
      const qPoints = qp.get('points');
      const defaultPoints = 'HA96.5, HA87.5, HK87.5, HK85, HX84.5, HX96';
      if (qPoints) {
        pointsInput.value = qPoints;
        loadPoints(qPoints);
      } else {
        pointsInput.value = defaultPoints;
        loadPoints(defaultPoints);
      }

      function setMode(mode) {
        STATE.mode = mode;
        if (btnModeParts) btnModeParts.classList.toggle('active', mode === 'parts');
        if (btnModeRects) btnModeRects.classList.toggle('active', mode === 'rects');
      }

      if (btnModeParts) btnModeParts.addEventListener('click', () => setMode('parts'));
      if (btnModeRects) btnModeRects.addEventListener('click', () => setMode('rects'));
    })();
  </script>
</body>
</html>
