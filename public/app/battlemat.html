<!--
Battlemat Core
Version: set in JS (VERSION)
-->
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Battlemat Core</title>
  <style>
    :root{
      --bg:#0f1115;
      --panel:#161a22;
      --panel2:#121621;
      --text:#e9eef7;
      --muted:#9aa6bb;
      --border:rgba(255,255,255,0.12);
      --border2:rgba(255,255,255,0.08);
      --good:#43d17a;
      --bad:#ff5a5a;
    }
    html,body{height:100%;margin:0;}
    body{
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;
      background:var(--bg);
      color:var(--text);
      display:grid;
      grid-template-rows:auto 1fr;
    }
    #topbar{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
      padding:10px 12px;
      background:var(--panel);
      border-bottom:1px solid var(--border2);
    }
    #status{
      display:flex;
      align-items:center;
      gap:10px;
      min-height:26px;
      flex-wrap:wrap;
    }
    .pill{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding:4px 10px;
      border-radius:999px;
      background:rgba(255,255,255,0.08);
      border:1px solid var(--border);
      font-size:12px;
      color:var(--text);
      white-space:nowrap;
    }
    .dot{width:8px;height:8px;border-radius:50%;background:var(--good);box-shadow:0 0 0 2px rgba(67,209,122,0.15);}
    .mini{font-size:12px;color:var(--muted);display:inline-flex;align-items:center;gap:6px;white-space:nowrap;}
    .mini input[type="text"]{
      width:72px;
      padding:4px 8px;
      border-radius:8px;
      border:1px solid var(--border);
      background:rgba(0,0,0,0.25);
      color:var(--text);
      outline:none;
    }
    select{
      padding:4px 8px;
      border-radius:8px;
      border:1px solid var(--border);
      background:rgba(0,0,0,0.25);
      color:var(--text);
      outline:none;
      font-size:12px;
    }
    button{
      padding:6px 10px;
      border-radius:10px;
      border:1px solid var(--border);
      background:rgba(255,255,255,0.08);
      color:var(--text);
      cursor:pointer;
      font-size:12px;
    }
    button:hover{background:rgba(255,255,255,0.12);}
    .sep{width:1px;height:18px;background:var(--border2);margin:0 2px;}

    #controls{
      display:flex;
      align-items:center;
      gap:8px;
      flex-wrap:wrap;
      justify-content:flex-end;
    }

    #layout{
      display:grid;
      grid-template-columns: 1fr 320px;
      gap:12px;
      padding:12px;
      min-height:0;
    }

    #canvasWrap{
      background:#0b0d12;
      border:1px solid var(--border);
      border-radius:12px;
      box-shadow:0 10px 30px rgba(0,0,0,0.35);
      overflow:hidden;
      min-height:0;
    }

    canvas{width:100%;height:100%;display:block;background:#0b0d12;}

    #sidebar{
      background:var(--panel2);
      border:1px solid var(--border);
      border-radius:12px;
      padding:12px;
      overflow:auto;
      min-height:0;
    }

    #sidebar h3{
      margin:0 0 8px 0;
      font-size:13px;
      color:var(--text);
      letter-spacing:0.02em;
    }

    #kvs{
      display:grid;
      grid-template-columns: 1fr auto;
      gap:6px 10px;
      font-size:12px;
      color:var(--muted);
      margin-bottom:12px;
    }

    #turns{
      font-size:12px;
      color:var(--muted);
      display:flex;
      flex-direction:column;
      gap:6px;
      margin-bottom:12px;
    }

    .turnRow{
      display:flex;
      justify-content:space-between;
      gap:10px;
      padding:6px 8px;
      border:1px solid rgba(255,255,255,0.10);
      border-radius:10px;
      background:rgba(255,255,255,0.04);
    }
    .turnRow.active{border-color:rgba(67,209,122,0.35); background:rgba(67,209,122,0.08); color:var(--text);}

    #errorBox{
      border:1px solid rgba(255,90,90,0.35);
      background:rgba(255,90,90,0.08);
      border-radius:12px;
      padding:10px;
      font-size:12px;
      color:var(--text);
      white-space:pre-wrap;
    }

    .dpad{
      display:inline-flex;
      gap:6px;
      align-items:center;
      margin-left:6px;
    }
    .dpad button{padding:6px 8px; border-radius:10px; min-width:34px;}

    @media (max-width: 980px){
      #layout{grid-template-columns:1fr;}
    }
  </style>
</head>
<body>
  <div id="topbar">
    <div id="status">
      <div class="pill" title="Battlemat version" id="versionPill"><span class="dot"></span><span id="versionText"></span></div>
      <div class="mini">Scene <select id="sceneSelect"></select></div>
      <div class="sep"></div>
      <div class="mini">Floor <select id="floorSelect"></select></div>
      <div class="pill" title="DevicePixelRatio × Supersample">
        DPR <span id="dprText">?</span>
        &nbsp;·&nbsp; SS <span id="ssText">?</span>
      </div>
    </div>

    <div id="controls">
      <label class="mini"><input type="checkbox" id="fogToggle" checked /> Fog</label>
      <label class="mini"><input type="checkbox" id="spriteToggle" checked /> Sprites</label>
      <label class="mini"><input type="checkbox" id="labelBoldToggle" /> Bright Labels</label>

      <div class="mini">SS
        <select id="ssSelect" title="Supersample quality">
          <option value="1">1×</option>
          <option value="2">2×</option>
          <option value="3" selected>3×</option>
        </select>
      </div>

      <div class="mini">Center
        <select id="centerOn" title="Follow a PC token"></select>
      </div>

      <div class="mini">Jump
        <input id="jumpHex" type="text" value="U16" />
        <button id="btnJump">Go</button>
      </div>

      <button id="btnRedraw">Redraw</button>

      <div class="dpad" title="Pan camera">
        <button id="btnLeft">←</button>
        <button id="btnUp">↑</button>
        <button id="btnDown">↓</button>
        <button id="btnRight">→</button>
      </div>

      <div class="dpad" title="Zoom">
        <button id="btnZoomOut">−</button>
        <button id="btnZoomIn">+</button>
      </div>
      <div class="mini" title="Map zoom"><span id="zoomText">100%</span></div>
    </div>
  </div>

  <div id="layout">
    <div id="canvasWrap"><canvas id="canvas" aria-label="Battlemat canvas"></canvas></div>
    <div id="sidebar">
      <h3>Status</h3>
      <div id="kvs"></div>

      <h3>Initiative</h3>
      <div id="turns"></div>

      <div id="errorBox" hidden></div>
    </div>
  </div>

  <script>
  // =====================================================================================
  // Battlemat Core Rewrite
  // Goals: small core renderer (hexes + camera + layers + orientation + fog) + supersample.
  // =====================================================================================

  const VERSION = 'v6.49';

  // ===== DOM =====
  const getEl = (id) => document.getElementById(id);
  const els = {
    canvas: getEl('canvas'),
    canvasWrap: getEl('canvasWrap'),
    versionText: getEl('versionText'),
    sceneSelect: getEl('sceneSelect'),
    fogToggle: getEl('fogToggle'),
    spriteToggle: getEl('spriteToggle'),
    labelBoldToggle: getEl('labelBoldToggle'),
    floorSelect: getEl('floorSelect'),
    centerOn: getEl('centerOn'),
    jumpHex: getEl('jumpHex'),
    errorBox: getEl('errorBox'),
    dprText: getEl('dprText'),
    ssText: getEl('ssText'),
    ssSelect: getEl('ssSelect'),
    zoomText: getEl('zoomText'),
    kvs: getEl('kvs'),
    turns: getEl('turns'),
    btnLeft: getEl('btnLeft'),
    btnRight: getEl('btnRight'),
    btnUp: getEl('btnUp'),
    btnDown: getEl('btnDown'),
    btnZoomOut: getEl('btnZoomOut'),
    btnZoomIn: getEl('btnZoomIn'),
    btnRedraw: getEl('btnRedraw'),
    btnJump: getEl('btnJump'),
  };

  const canvas = els.canvas;
  const ctx = canvas.getContext('2d', { alpha: false, desynchronized: true });

  // Offscreen wall layer (we punch openings out of walls here, then composite onto main canvas)
  const wallCanvas = document.createElement('canvas');
  const wallCtx = wallCanvas.getContext('2d', { alpha: true, desynchronized: true });

  const elVersion = els.versionText;
  const elSceneSelect = els.sceneSelect;
  const elFogToggle = els.fogToggle;
  const elSpriteToggle = els.spriteToggle;
  const elLabelBoldToggle = els.labelBoldToggle;
  const elFloorSelect = els.floorSelect;
  const elCenterOn = els.centerOn;
  const elJumpHex = els.jumpHex;
  const elError = els.errorBox;
  const elDpr = els.dprText;
  const elSs = els.ssText;
  const elSsSelect = els.ssSelect;

  if (elVersion) elVersion.textContent = VERSION;
  document.title = 'Battlemat Core ' + VERSION;

  // ===== Constants =====
  const sqrt3 = Math.sqrt(3);

  const GRID = {
    // Flat-top hex geometry: size is center-to-vertex.
    baseSize: 42,
    size: 42,
    lineWidth: 2,
    lineAlpha: 0.10,
    labelAlpha: 0.18,
    labelFont: 'bold 12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial',
  };

  const COLORS = {
    bg: '#0b0d12',
    wall: '#666',
    door: '#b67a2c',
    window: '#bfe2ff',

    floorStone: 'rgb(223, 208, 165)',
    floorWood:  'rgb(213, 181, 140)',

    // Placeholder prop colors (used when sprites are off or missing)
    objectWood: 'rgb(173, 131, 89)',
    chestWood:  'rgb(110, 72, 40)',
    stairsWood: 'rgb(140, 98, 64)',

    // Beds (placeholder colors)
    bedFabric: 'rgb(173, 131, 89)', // match table color
    bedPillow: 'rgb(175, 159, 141)',

    // Hearth (placeholder color)
    hearth: 'rgb(147, 53, 53)',
    floorCobble: 'rgb(154, 160, 166)',

    tokenHero: '#4aa3ff',
    tokenEnemy: '#111',
    tokenTextDark: 'rgba(0,0,0,0.72)',
    tokenTextLight: 'rgba(255,255,255,0.88)',

    fogUnseen: 'rgb(128,128,128)',
    fogExplored: 'rgb(170,170,170)',
  };

  const VIEW = {
    // Camera is in hex coords (col,row), row 0 is "row 1" at the bottom.
    camera: { col: 6, row: 6 },
    anchor: { x: 0, y: 0 },

    // Active floor id (single-floor states still work)
    floorId: null,

    // If set, camera will automatically follow that token id (and flip floors when needed)
    followTokenId: null,

    // DevicePixelRatio × supersample scale (set in resize())
    dpr: 1,
  };

  const PAN_STEP = 2;
  const STORAGE_PREFIX = (() => {
    const bid = resolveBattleIdFromUrl();
    return bid ? ('battlemat.' + bid + '.') : 'battlemat.';
  })();
  const STORAGE_SS = STORAGE_PREFIX + 'supersample';
  const STORAGE_ZOOM = STORAGE_PREFIX + 'zoom';

  // ===== Remote state (DB/API) =====
  const DEFAULT_POLL_MS = 1000;
  let CURRENT_STATE = null;
  let STATE_URL = null;
  let STATE_POLL_TIMER = null;
  let LAST_STATE_JSON = '';
  let LAST_RENDER_SIGNATURE = '';
  let SPRITE_LOAD_TICK = 0;

  function getQueryParams(search = window.location.search) {
    const s = String(search || '').trim();
    const out = new Map();
    if (!s || s === '?') return out;
    const q = (s[0] === '?') ? s.slice(1) : s;
    for (const part of q.split('&')) {
      if (!part) continue;
      const [kRaw, vRaw] = part.split('=');
      const k = decodeURIComponent((kRaw || '').replaceAll('+', ' ')).trim();
      const v = decodeURIComponent((vRaw || '').replaceAll('+', ' ')).trim();
      if (k) out.set(k, v);
    }
    return out;
  }

  function resolveBattleIdFromUrl() {
    const qp = getQueryParams();
    const bid = (
      qp.get('battle_id') ||
      qp.get('battleId') ||
      qp.get('battle') ||
      qp.get('id') ||
      ''
    ).trim();
    return bid || null;
  }

  function resolveStateUrl() {
    const qp = getQueryParams();
    const fromQuery = qp.get('stateUrl') || qp.get('state_url') || qp.get('state') || '';
    const fromWindow = (window && window.BATTLE_STATE_URL) ? String(window.BATTLE_STATE_URL) : '';
    const url = (fromQuery || fromWindow || '').trim();
    if (url) return url;

    // Canonical site routing: /play/27 -> /app/battlemat?battle_id=27
    // We can auto-derive the API URL from battle_id.
    const battleId = resolveBattleIdFromUrl();
    if (battleId) return `/api/battles/${encodeURIComponent(battleId)}`;

    return null;
  }

  function resolvePollMs() {
    const qp = getQueryParams();
    const qv = qp.get('pollMs') || qp.get('poll_ms') || '';
    const wv = (window && window.BATTLE_STATE_POLL_MS != null) ? String(window.BATTLE_STATE_POLL_MS) : '';
    const raw = (qv || wv || '').trim();
    if (raw === '') return DEFAULT_POLL_MS;
    const n = Number(raw);
    if (!Number.isFinite(n)) return DEFAULT_POLL_MS;
    return Math.max(0, Math.floor(n));
  }

  async function fetchStateOnce(url) {
    const u = String(url || '').trim();
    if (!u) return null;

    // Cache-bust so you can serve plain JSON from static hosting or through proxies.
    const sep = u.includes('?') ? '&' : '?';
    const fetchUrl = u + sep + '_ts=' + Date.now();

    const res = await fetch(fetchUrl, {
      method: 'GET',
      cache: 'no-store',
      headers: { 'Accept': 'application/json' },
    });

    if (!res.ok) throw new Error('State fetch failed: ' + res.status + ' ' + res.statusText);

    const txt = await res.text();
    const jsonText = txt.trim();
    if (!jsonText) throw new Error('State fetch returned empty body');

    let parsedOuter;
    try { parsedOuter = JSON.parse(jsonText); }
    catch (e) {
      throw new Error('State fetch returned non-JSON: ' + (e && e.message ? e.message : String(e)));
    }

    // Common DB shape: { ..., state_json: "{...}" }
    if (parsedOuter && typeof parsedOuter === 'object' && parsedOuter.state_json != null) {
      const sj = parsedOuter.state_json;

      if (typeof sj === 'string') {
        const sjText = sj.trim();
        if (!sjText) throw new Error('Battle record has empty state_json');

        let parsedState;
        try { parsedState = JSON.parse(sjText); }
        catch (e) {
          throw new Error('Battle record has invalid state_json JSON: ' + (e && e.message ? e.message : String(e)));
        }

        // Use state_json text for change detection (avoids redrawing if other DB fields change).
        return { parsed: parsedState, jsonText: sjText };
      }

      // state_json provided as object already
      try {
        const stable = JSON.stringify(sj);
        return { parsed: sj, jsonText: stable };
      } catch {
        // Fallback: if it can't stringify, still apply it
        return { parsed: sj, jsonText: '[[state_json_object]]' };
      }
    }

    // If the endpoint returns the scene JSON directly.
    return { parsed: parsedOuter, jsonText };
  }

  let CURRENT_RAW_STATE = null; // last raw payload from DB/API (world wrapper OR legacy)

  function stableJsonTextFor(raw) {
    try { return JSON.stringify(raw); } catch { return '[[unstringifiable_state]]'; }
  }

  function applyViewFromState(state) {
    // If the state specifies a floor/camera, apply it.
    try {
      const st = state;
      const floors = getFloorsFromState(st);
      const fid = pickActiveFloorId(st, floors);
      VIEW.floorId = fid;

      const camHex = st && st.view && st.view.camera_hex ? String(st.view.camera_hex) : null;
      if (camHex) {
        const p = parseHexId(camHex);
        VIEW.camera.col = p.col;
        VIEW.camera.row = p.row;
      }
    } catch {}
  }

  function setCanonicalStateFromRaw(raw, jsonTextHint) {
    CURRENT_RAW_STATE = raw;
    LAST_STATE_JSON = String(jsonTextHint != null ? jsonTextHint : stableJsonTextFor(raw));

    // Normalize (world wrapper -> active record scene; legacy scene -> scene)
    const scene = normalizeStateForRenderer(raw) || FALLBACK_STATE_MIN;
    CURRENT_STATE = scene;

    // Keep VIEW synced to the scene.
    applyViewFromState(scene);
  }

  function applyFetchedState(parsed, jsonText) {
    setCanonicalStateFromRaw(parsed, jsonText);
  }

  async function pollStateLoop() {
    if (!STATE_URL) return;

    try {
      const got = await fetchStateOnce(STATE_URL);
      if (!got) return;

      // Only apply when the server payload changes.
      if (got.jsonText !== LAST_STATE_JSON) {
        applyFetchedState(got.parsed, got.jsonText);
        safeRedraw();
      }
    } catch (e) {
      console.warn('[Battlemat] state poll error:', e);
      // Show last error in UI, but don't spam.
      if (elError) {
        elError.hidden = false;
        elError.textContent = 'State fetch error:' + String.fromCharCode(10) + String(e && e.stack ? e.stack : e);
      }
    }
  }

  function startStatePolling() {
    const pollMs = resolvePollMs();
    if (!STATE_URL) return;

    // Always do one immediate fetch.
    pollStateLoop();

    if (pollMs <= 0) return;
    if (STATE_POLL_TIMER) clearInterval(STATE_POLL_TIMER);
    STATE_POLL_TIMER = setInterval(pollStateLoop, pollMs);
  }

  // ===== Sprites (core, optional) =====
  const SPRITES = {
    basePath: '/assets/sprites/',
    cache: new Map(),
    defs: {
      // Objects
      'bed':         { file: 'bed.png', rotate: 'deg' },
      'bed.double':  { file: 'bed_double.png', rotate: 'deg' },
      'chair':       { file: 'chair.png', rotate: 'deg' },
      'table.round': { file: 'table_round.png', rotate: 'deg' },
      'table.rect':  { file: 'table_rectangle.png', rotate: 'deg' },
      'table.sqr':   { file: 'table_square.png', rotate: 'deg' },
      'chest':       { file: 'chest_closed.png', rotate: 'deg' },
      'hearth':      { file: 'hearth.png', rotate: 'deg' },
      'cooking.hearth': { file: 'cooking_hearth.png', rotate: 'deg' },
      'stairs':      { file: 'stairs.png', rotate: 'deg' },

      // New 1-hex props
      'keg':         { file: 'keg.png', rotate: 'deg' },
      'barrel':      { file: 'barrel.png', rotate: 'deg' },
      'crate':       { file: 'crate.png', rotate: 'deg' },

      // Doors (prefer dot-style kinds, but keep aliases for convenience/compat)
      'door':         { file: 'door_wood.png', rotate: 'none' },
      'door.wood':    { file: 'door_wood.png', rotate: 'none' },
      'door_wood':    { file: 'door_wood.png', rotate: 'none' },
      'bath':        { file: 'bath.png', rotate: 'deg' },

      // Tokens (optional)
      'token.pc':    { file: 'token_pc.png', rotate: 'none' },
      'token.npc':   { file: 'token_npc.png', rotate: 'none' },
    }
  };

  function getSpriteDef(kind) {
    const k = String(kind || '').toLowerCase();
    return SPRITES.defs[k] || null;
  }

  function scheduleSpriteRedraw() {
    // Debounce redraws when multiple images finish loading at once.
    if (scheduleSpriteRedraw._pending) return;
    scheduleSpriteRedraw._pending = true;
    requestAnimationFrame(() => {
      scheduleSpriteRedraw._pending = false;
      SPRITE_LOAD_TICK++;
      if (elSpriteToggle && elSpriteToggle.checked) safeRedraw();
    });
  }

  function loadSprite(file) {
    const f = String(file || '').trim();
    if (!f) return null;

    if (SPRITES.cache.has(f)) return SPRITES.cache.get(f);

    const img = new Image();
    img.decoding = 'async';
    img.addEventListener('load', () => scheduleSpriteRedraw(), { once: true });
    img.addEventListener('error', () => scheduleSpriteRedraw(), { once: true });
    img.src = SPRITES.basePath + f;

    SPRITES.cache.set(f, img);
    return img;
  }

  function drawSpriteImage(img, opts = {}) {
    // Unified sprite draw: fit=contain or stretch, optional anchor and rotation.
    if (!img || !img.complete || !img.naturalWidth || !img.naturalHeight) return false;

    const x = Number(opts.x || 0);
    const y = Number(opts.y || 0);
    const w = Number(opts.w || 0);
    const h = Number(opts.h || 0);
    const fit = String(opts.fit || 'contain').toLowerCase();
    const rotRad = Number(opts.rotRad || 0);
    const ax = clamp(Number(opts.anchorX != null ? opts.anchorX : 0.5), 0, 1);
    const ay = clamp(Number(opts.anchorY != null ? opts.anchorY : 0.5), 0, 1);

    let dw = w;
    let dh = h;

    if (fit === 'contain') {
      const iw = img.naturalWidth;
      const ih = img.naturalHeight;
      const s = Math.min(w / iw, h / ih);
      dw = iw * s;
      dh = ih * s;
    }

    ctx.save();
    ctx.translate(x, y);
    if (rotRad) ctx.rotate(rotRad);
    ctx.drawImage(img, -dw * ax, -dh * ay, dw, dh);
    ctx.restore();
    return true;
  }

  // ===== Repeat textures (optional) =====
  // One texture catalog; per-category scales + aliases.
  const TEXTURES = {
    files: {
      wood_oak:     'wood_oak.png',
      wood_elm:     'wood_elm.png',
      wood_dark:    'wood_dark.png',

      stone_cobble: 'stone_cobble.png',
      stone_gravel: 'stone_gravel.png',

      brick_gray:   'brick_gray.png',
      brick_red:    'brick_red.png',
      brick_dark:   'brick_dark.png',
    },

    scales: {
      wall: {
        wood_oak:     0.50,
        wood_elm:     0.50,
        wood_dark:    0.50,

        stone_cobble: 0.45,
        stone_gravel: 0.55,

        brick_gray:   0.40,
        brick_red:    0.20,
        brick_dark:   0.40,
      },
      floor: {
        wood_oak:     0.50,
        wood_elm:     0.50,
        wood_dark:    0.50,

        stone_cobble: 0.45,
        stone_gravel: 0.55,

        brick_gray:   0.40,
        brick_red:    0.40,
        brick_dark:   0.40,
      },
    },

    aliases: {
      wall: {
        brick:  'brick_gray',
        wood:   'wood_oak',
        cobble: 'stone_cobble',
        stone:  'stone_cobble',
        gravel: 'stone_gravel',
      },
      floor: {
        wood:   'wood_oak',
        stone:  'stone_cobble',
        cobble: 'stone_cobble',
        gravel: 'stone_gravel',
        brick:  'brick_gray',
      },
    },
  };

  function resolveTextureDef(category, kind) {
    const cat = String(category || '').toLowerCase();
    const k0 = String(kind || '').toLowerCase();
    if (!cat || !k0) return null;

    const files = TEXTURES && TEXTURES.files ? TEXTURES.files : null;
    const scales = (TEXTURES && TEXTURES.scales && TEXTURES.scales[cat]) ? TEXTURES.scales[cat] : null;
    const aliases = (TEXTURES && TEXTURES.aliases && TEXTURES.aliases[cat]) ? TEXTURES.aliases[cat] : null;
    if (!files || !scales) return null;

    const key = (k0 in files) ? k0 : (aliases && aliases[k0] ? String(aliases[k0]).toLowerCase() : '');
    if (!key || !(key in files)) return null;

    return { file: files[key], scale: (key in scales) ? Number(scales[key]) : 1 };
  }

  const PATTERN_CACHE = new Map();

  const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v));
  const isFiniteNum = (v) => Number.isFinite(Number(v));

  // Snap CSS-space coords to the device-pixel grid to avoid 1px seams at high zoom.
  // VIEW.dpr is devicePixelRatio × supersample, so snapping to 1/VIEW.dpr lines up with the backing store.
  function snapCss(v) {
    const d = Number(VIEW && VIEW.dpr) || 1;
    return Math.round(Number(v) * d) / d;
  }

  function snappedRectFromCenter(centerS, w, h) {
    const x1 = snapCss(centerS.x - w / 2);
    const y1 = snapCss(centerS.y - h / 2);
    const x2 = snapCss(centerS.x + w / 2);
    const y2 = snapCss(centerS.y + h / 2);
    return { x: x1, y: y1, w: Math.max(0, x2 - x1), h: Math.max(0, y2 - y1) };
  }

  // ===== Supersample + Zoom =====
  let SUPERSAMPLE = 3;
  let ZOOM = 1;

  function effectivePatternScale(defScale) {
    // Patterns should zoom with the map so tiles stay visually consistent.
    return clamp((Number(defScale) || 1) * (Number(ZOOM) || 1), 0.02, 10);
  }

  function getRepeatPatternForCtx(targetCtx, tex) {
    const file = (typeof tex === 'string') ? tex : (tex && tex.file);
    const defScale = (tex && typeof tex === 'object' && isFiniteNum(tex.scale)) ? Number(tex.scale) : 1;

    const f = String(file || '').trim();
    if (!f) return null;

    const ctxKey = (targetCtx === wallCtx) ? 'wall' : 'main';
    const effScale = effectivePatternScale(defScale);
    const key = ctxKey + '|' + f + '|s=' + String(effScale.toFixed(4));

    const cached = PATTERN_CACHE.get(key);
    if (cached && cached.pattern) return cached.pattern;

    const img = loadSprite(f);
    if (!img || !img.complete || !img.naturalWidth || !img.naturalHeight) return null;

    const pat = targetCtx.createPattern(img, 'repeat');
    if (!pat) return null;

    if (typeof pat.setTransform === 'function') {
      pat.setTransform(new DOMMatrix([effScale, 0, 0, effScale, 0, 0]));
      PATTERN_CACHE.set(key, { pattern: pat });
      return pat;
    }

    // Fallback: pre-scale into an offscreen tile canvas, then pattern that.
    const tw = Math.max(1, Math.round(img.naturalWidth * effScale));
    const th = Math.max(1, Math.round(img.naturalHeight * effScale));
    const tile = document.createElement('canvas');
    tile.width = tw;
    tile.height = th;
    const tctx = tile.getContext('2d');
    tctx.imageSmoothingEnabled = true;
    try { tctx.imageSmoothingQuality = 'high'; } catch {}
    tctx.drawImage(img, 0, 0, tw, th);

    const pat2 = targetCtx.createPattern(tile, 'repeat');
    if (!pat2) return null;

    PATTERN_CACHE.set(key, { pattern: pat2 });
    return pat2;
  }

  function readSupersample() {
    const raw = localStorage.getItem(STORAGE_SS);
    const v = parseFloat(raw != null ? raw : '3');
    if (!Number.isFinite(v)) return 3;
    return clamp(v, 1, 3);
  }

  function setSupersample(v) {
    const n = clamp(parseFloat(String(v)), 1, 3);
    localStorage.setItem(STORAGE_SS, String(n));
    SUPERSAMPLE = n;
    if (elSsSelect) elSsSelect.value = String(n);
    resize();
  }

  function readZoom() {
    const raw = localStorage.getItem(STORAGE_ZOOM);
    const v = parseFloat(raw != null ? raw : '1');
    if (!Number.isFinite(v)) return 1;
    return clamp(v, 0.60, 2.25);
  }

  function applyZoom() {
    GRID.size = GRID.baseSize * ZOOM;
  }

  function syncZoomUI() {
    const el = els.zoomText;
    if (el) el.textContent = Math.round(ZOOM * 100) + '%';
  }

  function setZoom(v, opts = {}) {
    const n = clamp(parseFloat(String(v)), 0.60, 2.25);
    ZOOM = n;
    applyZoom();
    if (opts.persist !== false) localStorage.setItem(STORAGE_ZOOM, String(n));
    syncZoomUI();
    safeRedraw();
  }

  // ===== Canonical state (demo) =====
  // PHASE 1 of "World Record" support:
  // - We now support *either* a legacy battlemat state OR a world-record wrapper.
  // - World-record wrapper format:
  //     { world, version, meta, active:{recordId,floorId,camera_hex}, records:{[recordId]:<sceneState>}, links:[] }
  // - The renderer continues to run on a *sceneState* (floors/openings/objects/tokens).
  // - normalizeStateForRenderer() extracts the active scene and hydrates it for the current renderer.
  //
  // NOTE: Embedded data is intentionally JSON (not JS object-literal) so you can copy/paste into state_json.
  // Keep it JSON-valid: double quotes only, no comments, no trailing commas.

const EMBEDDED_WORLD_JSON = `{
	"world": "Saffrondale",
	"otherWorlds": {
		"Wynpole": {
			"world": "Wynpole",
			"version": 1,
			"meta": { "scale": "1 hex = 5 ft" },
			"active": { "recordId": "WynpoleSquare", "floorId": "ground", "camera_hex": "D4" },
			"records": {
				"WynpoleSquare": {
					"meta": { "title": "Wynpole – Village Square", "battleId": "local", "round": 1 },
					"view": { "camera_hex": "D4", "floorId": "ground" },
					"floors": [
						{
							"id": "ground",
							"name": "Ground",
							"rooms": [
								{ "id": "Square", "corners": ["B6", "F6", "F2", "B2"], "thickness": 12, "floor": { "kind": "cobble" }, "wall": { "kind": "none" } }
							],
							"openings": [],
							"objects": []
						}
					],
					"tokens": []
				}
			},
			"links": []
		}
	},
	"version": 1,
	"meta": { "scale": "1 hex = 5 ft", "fogMode": "room" },
	"active": { "recordId": "CrossKeysInn", "floorId": "upper", "camera_hex": "U16" },
	"records": {
		"NewSceneId": {
			"meta": { "title": "Street View", "battleId": "local", "round": 1 },
			"view": { "camera_hex": "U14", "floorId": "ground" },
			"fog": {
				"enabled": true,
				"mode": "room",
				"visibleRoomIdsByFloor": { "ground": [] },
				"exploredRoomIdsByFloor": { "ground": [] },
				"autoCompute": true,
				"autoExplore": true,
				"maxDepth": 1,
				"unseenAlpha": 0.92,
				"exploredAlpha": 0.55
			},
			"floors": [
				{
					"id": "ground",
					"name": "Ground",
					"rooms": [
                    	{ "id": "BuildingL26", "corners": ["L26", "V26", "V21", "L21"], "thickness": 15, "floor": { "kind": "fog" }, "wall": { "kind": "wood_dark" } },
                        { "id": "BuildingAJ21", "corners": ["AJ21", "AP21", "AP12", "AJ12"], "thickness": 15, "floor": { "kind": "fog" }, "wall": { "kind": "wood_dark" } },
                        { "id": "BuildingAP30", "corners": ["AP30", "AV30", "AV12", "AP12"], "thickness": 15, "floor": { "kind": "fog" }, "wall": { "kind": "wood_dark" } },
                        { "id": "BuildingAP30", "corners": ["AV20", "AZ20", "AZ12", "AV12"], "thickness": 15, "floor": { "kind": "fog" }, "wall": { "kind": "wood_dark" } },
						{ "id": "CrossKeysUpperFloor", "buildingId": "CrossKeysInn", "corners": ["L21", "AJ21", "AJ12", "L12"], "thickness": 15, "floor": { "kind": "fog" }, "wall": { "kind": "wood_dark" } }
					],
					"openings": [
						{ "id": "door_1", "kind": "door.wood", "hex": "D6", "orientation": "h", "openPct": 0.0 }
					],
					"objects": [
						{ "id": "crate_1", "kind": "crate", "hex": "D4", "rotDeg": 0, "spriteScale": 1.25 }
					]
				}
			],
			"tokens": [
				{ "id": "pc1", "name": "Hero", "side": "PC", "hex": "D4", "label": "H", "init": 10, "hp": 20, "floorId": "ground" }
			]
		},

		"CrossKeysInn": {
			"meta": { "title": "Cross Keys Inn — Demo (upper + ground)", "battleId": "local", "round": 1 },
			"view": { "camera_hex": "U16", "floorId": "upper" },
			"fog": {
				"enabled": true,
				"mode": "room",
				"visibleRoomIdsByFloor": { "upper": [], "ground": [] },
				"exploredRoomIdsByFloor": { "upper": ["Hallway1", "Hallway2"], "ground": ["Kitchen"] },
				"autoCompute": true,
				"autoExplore": true,
				"maxDepth": 1,
				"unseenAlpha": 0.92,
				"exploredAlpha": 0.55
			},
			"floors": [
				{
					"id": "upper",
					"name": "Upper",
					"rooms": [
						{ "id": "KingStreet", "corners": ["L12", "AP12", "AP8", "L8"], "thickness": 15, "floor": { "kind": "cobble" }, "wall": { "kind": "none" } },
                        { "id": "HighStreet", "corners": ["F24", "L24", "L8", "F8"], "thickness": 15, "floor": { "kind": "cobble" }, "wall": { "kind": "none" } },
						{ "id": "CrossKeysUpperFloor", "buildingId": "CrossKeysInn", "corners": ["L21", "AJ21", "AJ12", "L12"], "thickness": 15, "floor": { "kind": "fog" }, "wall": { "kind": "wood_dark" } },
						{ "id": "Hallway1", "buildingId": "CrossKeysInn", "corners": ["AD21", "AF21", "AF12", "AD12"], "thickness": 15, "floor": { "kind": "wood_oak" }, "wall": { "kind": "wood_dark" } },
						{ "id": "Hallway2", "buildingId": "CrossKeysInn", "corners": ["R17", "AD17", "AD15", "R15"], "thickness": 15, "floor": { "kind": "wood_oak" }, "wall": { "kind": "wood_dark" } },
						{ "id": "Hallway3", "buildingId": "CrossKeysInn", "corners": ["P21", "R21", "R12", "P12"], "thickness": 15, "floor": { "kind": "wood_oak" }, "wall": { "kind": "wood_dark" } },
						{ "id": "1stFloorStairsDown", "buildingId": "CrossKeysInn", "corners": ["AA21.5", "AD21", "AD19.5", "AA20"], "thickness": 15, "floor": { "kind": "wood_oak" }, "wall": { "kind": "wood_dark" } },

						{ "id": "Bedroom1", "buildingId": "CrossKeysInn", "corners": ["L21", "P21", "P18", "L18"], "thickness": 15, "floor": { "kind": "wood_oak" }, "wall": { "kind": "wood_dark" } },
						{ "id": "Bedroom2", "buildingId": "CrossKeysInn", "corners": ["L18", "P18", "P15", "L15"], "thickness": 15, "floor": { "kind": "wood_oak" }, "wall": { "kind": "wood_dark" } },
						{ "id": "Bedroom3", "buildingId": "CrossKeysInn", "corners": ["L15", "P15", "P12", "L12"], "thickness": 15, "floor": { "kind": "wood_oak" }, "wall": { "kind": "wood_dark" } },
						{ "id": "Bedroom4", "buildingId": "CrossKeysInn", "corners": ["R15", "X15", "X12", "R12"], "thickness": 15, "floor": { "kind": "wood_oak" }, "wall": { "kind": "wood_dark" } },
						{ "id": "Bedroom5", "buildingId": "CrossKeysInn", "corners": ["R21", "X21", "X17", "R17"], "thickness": 15, "floor": { "kind": "wood_oak" }, "wall": { "kind": "wood_dark" } },
						{ "id": "Bedroom5_closet", "buildingId": "CrossKeysInn", "corners": ["X21", "Y21.5", "Y20", "X19.5"], "thickness": 15, "floor": { "kind": "wood_oak" }, "wall": { "kind": "wood_dark" } },
						{ "id": "Bathroom6", "buildingId": "CrossKeysInn", "corners": ["Y20", "AD19.5", "AD17", "Y17.5"], "thickness": 15, "floor": { "kind": "wood_oak" }, "wall": { "kind": "wood_dark" } },
						{ "id": "Bathroom6_closet", "buildingId": "CrossKeysInn", "corners": ["Y21.5", "AA21.5", "AA20", "Y20"], "thickness": 15, "floor": { "kind": "wood_oak" }, "wall": { "kind": "wood_dark" } },
						{ "id": "Bedroom7", "buildingId": "CrossKeysInn", "corners": ["X15", "AD15", "AD12", "X12"], "thickness": 15, "floor": { "kind": "wood_oak" }, "wall": { "kind": "wood_dark" } },
						{ "id": "Bedroom8", "buildingId": "CrossKeysInn", "corners": ["AF15", "AJ15", "AJ12", "AF12"], "thickness": 15, "floor": { "kind": "wood_oak" }, "wall": { "kind": "wood_dark" } },
						{ "id": "Bedroom9", "buildingId": "CrossKeysInn", "corners": ["AF19", "AJ19", "AJ15", "AF15"], "thickness": 15, "floor": { "kind": "wood_oak" }, "wall": { "kind": "wood_dark" } },
						{ "id": "Bedroom10", "buildingId": "CrossKeysInn", "corners": ["AF21", "AJ21", "AJ19", "AF19"], "thickness": 15, "floor": { "kind": "wood_oak" }, "wall": { "kind": "wood_dark" } }
					],
					"openings": [
						{ "id": "door_room1", "kind": "door.wood", "hex": "P19", "orientation": "v", "openPct": 1.0, "hinge": "right", "swing": 1 },
						{ "id": "door_room2", "kind": "door.wood", "hex": "P16", "orientation": "v", "openPct": 1.0, "hinge": "right", "swing": 1 },
						{ "id": "door_room3", "kind": "door.wood", "hex": "P13", "orientation": "v", "openPct": 1.0, "hinge": "right", "swing": 1 },
						{ "id": "door_room4", "kind": "door.wood", "hex": "U15.5", "orientation": "h", "openPct": 1.0, "hinge": "left", "swing": 1 },

						{ "id": "door_room5", "kind": "door.wood", "hex": "V17", "orientation": "h", "openPct": 1.0 },
						{ "id": "door_to_closet", "kind": "door.wood", "hex": "X20.25", "orientation": "v", "openPct": 1.0, "swing": 1 },
						{ "id": "door_room6", "kind": "door.wood", "hex": "AB17", "orientation": "h", "openPct": 1.0 },
						{ "id": "door_room6_closet", "kind": "door.wood", "hex": "Z19.5", "orientation": "h", "openPct": 1.0, "swing": 1 },
						{ "id": "door_room7", "kind": "door.wood", "hex": "AA15.5", "orientation": "h", "openPct": 1.0, "hinge": "right", "swing": 1 },

						{ "id": "door_room8", "kind": "door.wood", "hex": "AF13", "orientation": "v", "hinge": "left", "openPct": 0.0 },
						{ "id": "door_room9", "kind": "door.wood", "hex": "AF17", "orientation": "v", "openPct": 0.0 },
						{ "id": "door_room10", "kind": "door.wood", "hex": "AF20", "orientation": "v", "openPct": 0.0 },

						{ "id": "portal_down_AB20", "kind": "portal", "hex": "AB20", "trigger": "enter", "to": { "floorId": "ground", "hex": "Z20" } },

						{ "id": "bedroom1_window1", "kind": "window", "hex": "L20", "orientation": "v" },
						{ "id": "bedroom1_window2", "kind": "window", "hex": "L19", "orientation": "v" },
						{ "id": "bedroom2_window1", "kind": "window", "hex": "L17", "orientation": "v" },
						{ "id": "bedroom2_window2", "kind": "window", "hex": "L16", "orientation": "v" },
						{ "id": "bedroom3_window1", "kind": "window", "hex": "L14", "orientation": "v" },
						{ "id": "bedroom3_window2", "kind": "window", "hex": "L13", "orientation": "v" },
						{ "id": "bedroom3_window3", "kind": "window", "hex": "M12.5", "orientation": "h" },
						{ "id": "bedroom3_window4", "kind": "window", "hex": "N12", "orientation": "h" },
						{ "id": "hallway3_window1", "kind": "window", "hex": "Q12.5", "orientation": "h" },
						{ "id": "bedroom4_window1", "kind": "window", "hex": "U12.5", "orientation": "h" },
						{ "id": "bedroom4_window2", "kind": "window", "hex": "V12", "orientation": "h" },
						{ "id": "bedroom5_window1", "kind": "window", "hex": "Z12", "orientation": "h" },
						{ "id": "bedroom5_window2", "kind": "window", "hex": "AA12.5", "orientation": "h" },
						{ "id": "hallway1_window1", "kind": "window", "hex": "AE12.5", "orientation": "h" },
						{ "id": "bedroom8_window1", "kind": "window", "hex": "AH12", "orientation": "h" },

						{ "id": "thresh_R16", "kind": "threshold", "hex": "R16", "orientation": "v", "parent": "Hallway2" },
						{ "id": "thresh_AD16", "kind": "threshold", "hex": "AD16", "orientation": "v", "parent": "Hallway2" },
						{ "id": "thresh_AD20", "kind": "threshold", "hex": "AD20.25", "orientation": "v", "parent": "1stFloorStairsDown" }
					],
					"objects": [
						{ "id": "room1_bed1", "kind": "bed", "hex": "M21", "ox": -0.5, "oy": 0.7, "spriteScale": 2.3 },
						{ "id": "room1_bed2", "kind": "bed", "hex": "N20", "ox": 0.0, "oy": -0.17, "spriteScale": 2.3 },
						{ "id": "room1_bed3", "kind": "bed", "hex": "O21", "ox": 0.5, "oy": 0.7, "spriteScale": 2.3 },

						{ "id": "room2_bed1", "kind": "bed", "hex": "M18", "rotDeg": 270, "spriteScale": 2.3 },
						{ "id": "room2_bed2", "kind": "bed", "hex": "M16", "rotDeg": 270, "spriteScale": 2.3 },

						{ "id": "room3_bed1", "kind": "bed", "hex": "M15", "ox": -0.5, "oy": 0.7, "spriteScale": 2.3 },
						{ "id": "room3_bed2", "kind": "bed", "hex": "N14", "ox": 0.0, "oy": -0.17, "spriteScale": 2.3 },
						{ "id": "room3_bed3", "kind": "bed", "hex": "O15", "ox": 0.5, "oy": 0.7, "spriteScale": 2.3 },

						{ "id": "room4_bed", "kind": "bed.double", "hex": "S14", "rotDeg": 270, "spriteScale": 2.4 },
						{ "id": "room4_chair1", "kind": "chair", "hex": "W14", "rotDeg": 60, "ox": -0.2, "oy": 0.0, "spriteScale": 0.8 },
						{ "id": "room4_chair2", "kind": "chair", "hex": "W13", "rotDeg": 120, "ox": -0.2, "oy": 0.0, "spriteScale": 0.8 },
						{ "id": "room4_chair3", "kind": "chair", "hex": "U13", "rotDeg": 240, "ox": 0.2, "oy": 0.0, "spriteScale": 0.8 },
						{ "id": "room4_table", "kind": "table.round", "hex": "V13", "rotDeg": 0, "spriteScale": 1.8 },
						{ "id": "room4_chest", "kind": "chest", "hex": "S15", "ox": 0.0, "oy": -0.25, "spriteScale": 0.75 },
						{ "id": "room4_hearth", "kind": "hearth", "hex": "X14", "rotDeg": 90, "ox": -0.5, "oy": -0.3, "spriteScale": 1.1 },
						{ "id": "room4_side1", "kind": "table.sqr", "hex": "S13", "ox": -1.0, "oy": 0.0, "rotDeg": 90, "spriteScale": 0.5 },
						{ "id": "room4_side2", "kind": "table.sqr", "hex": "S15", "ox": -1.0, "oy": 0.0, "rotDeg": 90, "spriteScale": 0.5 },

						{ "id": "room5_bed", "kind": "bed.double", "hex": "S20", "rotDeg": 270, "spriteScale": 2.4 },
						{ "id": "room5_chair1", "kind": "chair", "hex": "W21", "rotDeg": 60, "ox": -0.2, "oy": 0.0, "spriteScale": 0.8 },
						{ "id": "room5_chair2", "kind": "chair", "hex": "W20", "rotDeg": 120, "ox": -0.2, "oy": 0.0, "spriteScale": 0.8 },
						{ "id": "room5_chair3", "kind": "chair", "hex": "U20", "rotDeg": 240, "ox": 0.2, "oy": 0.0, "spriteScale": 0.8 },
						{ "id": "room5_chair4", "kind": "chair", "hex": "U21", "rotDeg": 300, "ox": 0.2, "oy": 0.0, "spriteScale": 0.8 },
						{ "id": "room5_table", "kind": "table.round", "hex": "V20", "rotDeg": 0, "spriteScale": 1.8 },
						{ "id": "room5_chest", "kind": "chest", "hex": "S18", "rotDeg": 180, "ox": 0.0, "oy": 0.25, "spriteScale": 0.75 },
						{ "id": "room5_hearth", "kind": "hearth", "hex": "X18", "rotDeg": 90, "ox": -0.56, "oy": 0.0, "spriteScale": 1.1 },
						{ "id": "room5_side1", "kind": "table.sqr", "hex": "S21", "rotDeg": 90, "ox": -1.0, "oy": 0.0, "spriteScale": 0.5 },
						{ "id": "room5_side2", "kind": "table.sqr", "hex": "S19", "rotDeg": 90, "ox": -1.0, "oy": 0.0, "spriteScale": 0.5 },

						{ "id": "room6_hearth", "kind": "hearth", "hex": "Z18", "rotDeg": 270, "ox": -0.94, "oy": 0.0, "spriteScale": 1.1 },
						{ "id": "room6_bath", "kind": "bath", "hex": "AB19", "ox": 0.0, "oy": 0.5, "spriteScale": 2.5 },

						{ "id": "room7_bed", "kind": "bed.double", "hex": "AC14", "rotDeg": 90, "ox": 0.0, "oy": 0.0, "spriteScale": 2.4 },
						{ "id": "room7_chair1", "kind": "chair", "hex": "AA14", "rotDeg": 60, "ox": -0.2, "oy": 0.0, "spriteScale": 0.8 },
						{ "id": "room7_chair3", "kind": "chair", "hex": "Y13", "rotDeg": 240, "ox": 0.2, "oy": 0.0, "spriteScale": 0.8 },
						{ "id": "room7_chair4", "kind": "chair", "hex": "Y14", "rotDeg": 300, "ox": 0.2, "oy": 0.0, "spriteScale": 0.8 },
						{ "id": "room7_table", "kind": "table.round", "hex": "Z13", "rotDeg": 0, "spriteScale": 1.8 },
						{ "id": "room7_chest", "kind": "chest", "hex": "AC15", "rotDeg": 0, "ox": 0.0, "oy": -0.25, "spriteScale": 0.75 },
						{ "id": "room7_hearth", "kind": "hearth", "hex": "X14", "rotDeg": 270, "ox": 0.5, "oy": -0.3, "spriteScale": 1.1 },
						{ "id": "room7_side1", "kind": "table.sqr", "hex": "AC13", "rotDeg": 90, "ox": 1.0, "oy": 0.0, "spriteScale": 0.5 },
						{ "id": "room7_side2", "kind": "table.sqr", "hex": "AC15", "rotDeg": 90, "ox": 1.0, "oy": 0.0, "spriteScale": 0.5 },

						{ "id": "room8_bed1", "kind": "bed", "hex": "AG15", "ox": -0.5, "oy": 0.7, "spriteScale": 2.3 },
						{ "id": "room8_bed2", "kind": "bed", "hex": "AH14", "ox": 0.0, "oy": -0.17, "spriteScale": 2.3 },
						{ "id": "room8_bed3", "kind": "bed", "hex": "AI15", "ox": 0.5, "oy": 0.7, "spriteScale": 2.3 },

						{ "id": "room9_bed1", "kind": "bed", "hex": "AI19", "rotDeg": 90, "spriteScale": 2.3 },
						{ "id": "room9_bed2", "kind": "bed", "hex": "AI18", "rotDeg": 90, "spriteScale": 2.3 },
						{ "id": "room9_bed3", "kind": "bed", "hex": "AI17", "rotDeg": 90, "spriteScale": 2.3 },
						{ "id": "room9_bed4", "kind": "bed", "hex": "AI16", "rotDeg": 90, "spriteScale": 2.3 },

						{ "id": "room10_bed1", "kind": "bed", "hex": "AI21", "rotDeg": 90, "spriteScale": 2.3 },

						{ "id": "stairs_down_to_ground", "kind": "stairs", "hex": "AC21", "rotDeg": 270, "ox": -1.0, "oy": 0.43, "spriteScaleX": 1.95, "spriteScaleY": 3.1 }
					]
				},
				{
					"id": "ground",
					"name": "Ground",
					"rooms": [
						{ "id": "CrossKeysGroundFloor", "buildingId": "CrossKeysInn", "corners": ["M21.5", "AJ21", "AJ12.5", "M13"], "thickness": 15, "floor": { "kind": "fog" }, "wall": { "kind": "brick" } },
						{ "id": "Pub", "buildingId": "CrossKeysInn", "corners": ["M21.5", "X21", "X12.5", "M13"], "thickness": 15, "floor": { "kind": "wood_oak" }, "wall": { "kind": "brick" } },
						{ "id": "Kitchen", "buildingId": "CrossKeysInn", "corners": ["X19.5", "AJ19.5", "AJ12.5", "X12.5"], "thickness": 15, "floor": { "kind": "wood_oak" }, "wall": { "kind": "brick" } },
						{ "id": "StairsUp", "buildingId": "CrossKeysInn", "corners": ["X21", "AA21.5", "AA20", "X19.5"], "thickness": 15, "floor": { "kind": "wood_oak" }, "wall": { "kind": "brick" } },
						{ "id": "Pantry", "buildingId": "CrossKeysInn", "corners": ["AA21.5", "AJ21", "AJ19.5", "AA20"], "thickness": 15, "floor": { "kind": "wood_oak" }, "wall": { "kind": "brick" } }
					],
					"openings": [
						{ "id": "pub_window1", "kind": "window", "hex": "M20", "orientation": "v" },
						{ "id": "pub_window2", "kind": "window", "hex": "M19", "orientation": "v" },
						{ "id": "pub_window3", "kind": "window", "hex": "M15", "orientation": "v" },
						{ "id": "pub_window4", "kind": "window", "hex": "M14", "orientation": "v" },
						{ "id": "pub_window5", "kind": "window", "hex": "N12.5", "orientation": "h" },
						{ "id": "pub_window6", "kind": "window", "hex": "O12", "orientation": "h" },
						{ "id": "pub_window7", "kind": "window", "hex": "P12.5", "orientation": "h" },
						{ "id": "pub_window8", "kind": "window", "hex": "Z12.5", "orientation": "h" },
						{ "id": "pub_window9", "kind": "window", "hex": "AB12.5", "orientation": "h" },

						{ "id": "kitchen_door", "kind": "door", "hex": "X14", "orientation": "v", "openPct": 1.0 },
						{ "id": "door_to_upstairs", "kind": "door", "hex": "X20.25", "orientation": "v", "openPct": 1.0, "swing": 1 },
						{ "id": "door_out1", "kind": "door", "hex": "M17", "orientation": "v", "openPct": 1.0 },
						{ "id": "door_out2", "kind": "door", "hex": "U13", "orientation": "h", "openPct": 1.0 },
						{ "id": "door_pantry", "kind": "door.wood", "hex": "AE20", "orientation": "h", "openPct": 1.0, "swing": 1 },

						{ "id": "portal_up_AA21", "kind": "portal", "hex": "AA21", "trigger": "enter", "to": { "floorId": "upper", "hex": "AC21" } },
						{ "id": "portal_up_AA20", "kind": "portal", "hex": "AA20", "trigger": "enter", "to": { "floorId": "upper", "hex": "AC20" } }
					],
					"objects": [
						{ "id": "pub_table1", "kind": "table.rect", "hex": "O20", "rotDeg": 90, "spriteScale": 3.5 },
						{ "id": "pub_table1_c1", "kind": "chair", "hex": "P20", "rotDeg": 90, "spriteScale": 0.75 },
						{ "id": "pub_table1_c2", "kind": "chair", "hex": "P19", "rotDeg": 90, "spriteScale": 0.75 },
						{ "id": "pub_table1_c3", "kind": "chair", "hex": "N20", "rotDeg": 270, "spriteScale": 0.75 },
						{ "id": "pub_table1_c4", "kind": "chair", "hex": "N19", "rotDeg": 270, "spriteScale": 0.75 },

						{ "id": "pub_table2", "kind": "table.rect", "hex": "O15", "rotDeg": 30, "spriteScale": 3.5 },
						{ "id": "pub_table2_c1", "kind": "chair", "hex": "O16", "rotDeg": 30, "spriteScale": 0.75 },
						{ "id": "pub_table2_c2", "kind": "chair", "hex": "P15", "rotDeg": 30, "spriteScale": 0.75 },
						{ "id": "pub_table2_c3", "kind": "chair", "hex": "O14", "rotDeg": 210, "spriteScale": 0.75 },
						{ "id": "pub_table2_c4", "kind": "chair", "hex": "N14", "rotDeg": 210, "spriteScale": 0.75 },

						{ "id": "pub_table3", "kind": "table.rect", "hex": "S20", "rotDeg": 150, "spriteScale": 3.5 },
						{ "id": "pub_table3_c1", "kind": "chair", "hex": "T19", "rotDeg": 150, "spriteScale": 0.75 },
						{ "id": "pub_table3_c2", "kind": "chair", "hex": "S19", "rotDeg": 150, "spriteScale": 0.75 },
						{ "id": "pub_table3_c3", "kind": "chair", "hex": "R20", "rotDeg": 330, "spriteScale": 0.75 },
						{ "id": "pub_table3_c4", "kind": "chair", "hex": "S21", "rotDeg": 330, "spriteScale": 0.75 },

						{ "id": "pub_table4", "kind": "table.round", "hex": "Q18", "rotDeg": 0, "spriteScale": 2.4 },
						{ "id": "pub_table4_c1", "kind": "chair", "hex": "Q19", "rotDeg": 0, "spriteScale": 0.75 },
						{ "id": "pub_table4_c2", "kind": "chair", "hex": "P17", "rotDeg": 240, "spriteScale": 0.75 },
						{ "id": "pub_table4_c3", "kind": "chair", "hex": "R17", "rotDeg": 120, "spriteScale": 0.75 },

						{ "id": "pub_table5", "kind": "table.round", "hex": "S15", "rotDeg": 0, "spriteScale": 2.4 },
						{ "id": "pub_table5_c1", "kind": "chair", "hex": "T15", "rotDeg": 60, "spriteScale": 0.75 },
						{ "id": "pub_table5_c2", "kind": "chair", "hex": "S14", "rotDeg": 180, "spriteScale": 0.75 },
						{ "id": "pub_table5_c3", "kind": "chair", "hex": "R15", "rotDeg": 300, "spriteScale": 0.75 },

						{ "id": "pub_table6", "kind": "table.round", "hex": "V17", "rotDeg": 0, "spriteScale": 2.4 },
						{ "id": "pub_table6_c1", "kind": "chair", "hex": "V18", "rotDeg": 0, "spriteScale": 0.75 },
						{ "id": "pub_table6_c2", "kind": "chair", "hex": "U17", "rotDeg": 240, "spriteScale": 0.75 },
						{ "id": "pub_table6_c3", "kind": "chair", "hex": "W17", "rotDeg": 120, "spriteScale": 0.75 },
						{ "id": "pub_table6_c4", "kind": "chair", "hex": "U18", "rotDeg": 300, "spriteScale": 0.75 },
						{ "id": "pub_table6_c5", "kind": "chair", "hex": "V16", "rotDeg": 180, "spriteScale": 0.75 },

						{ "id": "pub_hearth", "kind": "hearth", "hex": "X18", "rotDeg": 90, "ox": -0.56, "oy": 0.0, "spriteScale": 1.65 },

						{ "id": "stairs_up_to_upper", "kind": "stairs", "hex": "Y21", "rotDeg": 270, "ox": 1.0, "oy": 0.43, "spriteScaleX": 1.95, "spriteScaleY": 3.1 },
						{ "id": "stairs_down_to_basement", "kind": "stairs", "hex": "AC21", "rotDeg": 270, "ox": -1.0, "oy": 0.43, "spriteScaleX": 1.95, "spriteScaleY": 3.1 },

						{ "id": "kitchen_hearth", "kind": "cooking.hearth", "hex": "Z18", "rotDeg": 270, "ox": -0.94, "oy": 0.0, "spriteScale": 2.42 },
						{ "id": "kitchen_prep_table", "kind": "table.rect", "hex": "Z15.5", "rotDeg": 90, "ox": 0.0, "oy": -0.5, "spriteScale": 3.0 },
						{ "id": "kitchen_sort_table", "kind": "table.rect", "hex": "AC18", "rotDeg": 0, "ox": 0.0, "oy": -0.5, "spriteScale": 3.0 },
						{ "id": "kitchen_misc_table", "kind": "table.rect", "hex": "AF16.5", "rotDeg": 90, "ox": 0.0, "oy": -0.5, "spriteScale": 3.0 },
						{ "id": "kitchen_plate_table", "kind": "table.rect", "hex": "AC15.5", "rotDeg": 90, "ox": 0.0, "oy": -0.5, "spriteScale": 3.0 },
						{ "id": "kitchen_chop_block", "kind": "table.sqr", "hex": "AA16", "ox": 0.0, "oy": 0.0, "rotDeg": 90, "spriteScale": 1.25 },
						{ "id": "kitchen_keg1", "kind": "keg", "hex": "AI14", "ox": 0.5, "oy": 0.0, "rotDeg": 0, "spriteScale": 2.0 },
						{ "id": "kitchen_keg2", "kind": "keg", "hex": "AI15", "ox": 0.5, "oy": 0.0, "rotDeg": 0, "spriteScale": 2.0 },
						{ "id": "kitchen_keg3", "kind": "keg", "hex": "AI16", "ox": 0.5, "oy": 0.0, "rotDeg": 0, "spriteScale": 2.0 },
						{ "id": "kitchen_crate1", "kind": "crate", "hex": "AI19", "ox": 0.5, "oy": -0.5, "rotDeg": 0, "spriteScale": 1.25 },
						{ "id": "kitchen_crate2", "kind": "crate", "hex": "AI18", "ox": 0.5, "oy": 0.0, "rotDeg": 60, "spriteScale": 1.25 },
						{ "id": "kitchen_barrel1", "kind": "barrel", "hex": "AH19", "rotDeg": 0, "spriteScale": 1.25 }
					]
				}
			],
			"tokens": [
				{ "id": "a", "name": "Aelar", "side": "PC", "hex": "AE19", "label": "A", "init": 14, "hp": 42, "floorId": "upper" },
				{ "id": "b", "name": "Bran", "side": "PC", "hex": "T15", "label": "B", "init": 12, "hp": 35, "floorId": "ground", "spriteFile": "ranger_male.png" },
				{ "id": "g1", "name": "Goblin 1", "side": "NPC", "hex": "U19", "label": "G1", "init": 10, "hp": 8, "floorId": "upper" },
				{ "id": "g2", "name": "Goblin 2", "side": "NPC", "hex": "V19", "label": "G2", "init": 10, "hp": 8, "floorId": "upper" },
				{ "id": "g3", "name": "Goblin 3", "side": "NPC", "hex": "W19", "label": "G3", "init": 10, "hp": 8, "floorId": "upper" }
			]
		}
	},
	"links": []
}`;

  let WORLD_STATE = null; // holds the last parsed *world record* (if provided)

  const FALLBACK_STATE_MIN = {
    meta: { title: 'Fallback', battleId: 'local', round: 1 },
    floors: [],
    tokens: []
  };

  function cloneDeepSafe(obj) {
    if (obj == null) return obj;
    if (typeof structuredClone === 'function') return structuredClone(obj);
    return JSON.parse(JSON.stringify(obj));
  }

  // ===== Data normalization =====
  function numOr(v, d = 0) {
    const n = Number(v);
    return Number.isFinite(n) ? n : d;
  }

  function normStr(v, d = '') {
    const s = (v == null) ? '' : String(v);
    return s.trim() || d;
  }

  function normKind(v, d = '') {
    return normStr(v, d).toLowerCase();
  }

  function normOrient(v) {
    const o = normKind(v, 'h');
    return (o === 'v' || o === 'vert' || o === 'vertical') ? 'v' : 'h';
  }

  function normDoorKind(kind) {
    const k = normKind(kind, 'door');
    // Unify common door aliases.
    if (k === 'door_wood' || k === 'doorwood' || k === 'door.wood' || k === 'door-wood') return 'door.wood';
    if (k === 'door_stone' || k === 'doorstone' || k === 'door.stone' || k === 'door-stone') return 'door.stone';
    if (k.startsWith('door.') || k.startsWith('door_') || k === 'door') return k;
    return k;
  }

  function normalizeRooms(list) {
    const rooms = Array.isArray(list) ? list : [];
    for (const r of rooms) {
      if (!r || typeof r !== 'object') continue;
      if (r.id != null) r.id = String(r.id);
      if (Array.isArray(r.corners)) r.corners = r.corners.map(c => String(c));
      r.thickness = numOr(r.thickness, numOr(r.wallThickness, 15));
      if (!r.floor || typeof r.floor !== 'object') r.floor = {};
      if (!r.wall || typeof r.wall !== 'object') r.wall = {};
      r.floor.kind = normKind(r.floor.kind, normKind(r.floor.type, 'wood'));
      r.wall.kind = normKind(r.wall.kind, normKind(r.wall.type, 'brick'));
    }
    return rooms;
  }

  function normalizeOpenings(list) {
    const openings = Array.isArray(list) ? list : [];
    for (const o of openings) {
      if (!o || typeof o !== 'object') continue;
      if (o.id != null) o.id = String(o.id);
      o.hex = normStr(o.hex);
      o.orientation = normOrient(o.orientation);

      const k0 = normKind(o.kind, 'door');
      o.kind = (k0 === 'door' || k0.startsWith('door') || k0.startsWith('door_') || k0.startsWith('door.'))
        ? normDoorKind(k0)
        : k0;

      if (o.openPct == null && o.open != null) o.openPct = o.open;
      if (o.openPct == null && o.open_pct != null) o.openPct = o.open_pct;
      o.openPct = clamp(numOr(o.openPct, 0), 0, 1);

      if (o.span != null) o.span = clamp(numOr(o.span, 1), 0.5, 4);
      if (o.spriteScale != null) o.spriteScale = numOr(o.spriteScale, 1);
      if (o.spriteScaleX != null) o.spriteScaleX = numOr(o.spriteScaleX, 1);
      if (o.spriteScaleY != null) o.spriteScaleY = numOr(o.spriteScaleY, 1);

      if (o.parent != null) o.parent = String(o.parent);
      if (o.hinge != null) o.hinge = String(o.hinge);
      if (o.swing != null) o.swing = numOr(o.swing, o.swing);
    }
    return openings;
  }

  function normalizeObjects(list, floorIdFallback = null) {
    const objects = Array.isArray(list) ? list : [];
    for (const o of objects) {
      if (!o || typeof o !== 'object') continue;
      if (o.id != null) o.id = String(o.id);
      o.kind = normKind(o.kind, 'object');
      o.hex = normStr(o.hex);

      if (o.floorId == null && o.floor_id != null) o.floorId = o.floor_id;
      if (o.floorId == null && floorIdFallback != null) o.floorId = String(floorIdFallback);
      if (o.floorId != null) o.floorId = String(o.floorId);

      if (o.ox != null) o.ox = numOr(o.ox, 0);
      if (o.oy != null) o.oy = numOr(o.oy, 0);
      if (o.rotDeg != null) o.rotDeg = numOr(o.rotDeg, 0);

      if (o.spriteScale != null) o.spriteScale = numOr(o.spriteScale, 1);
      if (o.spriteScaleX != null) o.spriteScaleX = numOr(o.spriteScaleX, 1);
      if (o.spriteScaleY != null) o.spriteScaleY = numOr(o.spriteScaleY, 1);
    }
    return objects;
  }

  function normalizeTokens(list, floorIdFallback = null) {
    const tokens = Array.isArray(list) ? list : [];
    for (const t of tokens) {
      if (!t || typeof t !== 'object') continue;
      if (t.id != null) t.id = String(t.id);
      t.hex = normStr(t.hex);

      const side = normStr(t.side ?? t.team ?? t.faction, 'NPC').toUpperCase();
      t.side = (side === 'PC' || side === 'NPC') ? side : 'NPC';

      if (t.floorId == null && t.floor_id != null) t.floorId = t.floor_id;
      if (t.floorId == null && floorIdFallback != null) t.floorId = String(floorIdFallback);
      if (t.floorId != null) t.floorId = String(t.floorId);

      if (t.init != null) t.init = numOr(t.init, 0);
      if (t.hp != null) t.hp = numOr(t.hp, t.hp);

      if (t.label != null) t.label = String(t.label);
      if (t.name != null) t.name = String(t.name);
    }
    return tokens;
  }

  function normalizeSceneShape(scene) {
    if (!scene || typeof scene !== 'object') return null;

    if (!scene.meta || typeof scene.meta !== 'object') scene.meta = {};
    if (!scene.view || typeof scene.view !== 'object') scene.view = {};

    // Normalize floors into an array. If we only have legacy top-level rooms/openings/objects,
    // fold them into a single floor.
    let floors = null;

    if (Array.isArray(scene.floors)) {
      floors = scene.floors;
    } else if (scene.floors && typeof scene.floors === 'object') {
      floors = Object.entries(scene.floors).map(([id, data]) => ({ id, ...(data || {}) }));
      scene.floors = floors;
    } else {
      const fid = String(scene.view.floorId || scene.view.floor_id || scene.view.floor || 'floor1');
      floors = [{
        id: fid,
        name: 'Floor',
        rooms: Array.isArray(scene.rooms) ? scene.rooms : [],
        openings: Array.isArray(scene.openings) ? scene.openings : [],
        objects: Array.isArray(scene.objects) ? scene.objects : [],
      }];
      scene.floors = floors;
    }

    // Ensure view.floorId is set to a valid floor id.
    const firstId = floors && floors.length ? String(floors[0].id ?? 'floor1') : 'floor1';
    const wanted = String(scene.view.floorId || scene.view.floor_id || scene.view.floor || '') || '';
    const ok = wanted && floors.some(f => String(f && f.id) === wanted);
    scene.view.floorId = ok ? wanted : firstId;

    // Normalize per-floor arrays.
    for (const f of floors) {
      if (!f || typeof f !== 'object') continue;
      if (f.id == null) f.id = firstId;
      f.id = String(f.id);
      if (f.name != null) f.name = String(f.name);

      f.rooms = normalizeRooms(f.rooms);
      f.openings = normalizeOpenings(f.openings);
      f.objects = normalizeObjects(f.objects, f.id);
    }

    // Normalize tokens.
    const tok = (scene.tokens != null) ? scene.tokens : (scene.actors != null ? scene.actors : []);
    scene.tokens = normalizeTokens(tok, scene.view.floorId);

    // Keep legacy top-level lists present but consistent (for compatibility).
    scene.rooms = floors[0] ? floors[0].rooms : [];
    scene.openings = floors[0] ? floors[0].openings : [];

    return scene;
  }

  function hydrateSceneForRenderer(scene) {
    if (!scene || typeof scene !== 'object') return null;

    // Prevent double-hydration if we normalize the same object more than once.
    // We keep this marker internal; it's only used in-memory.
    if (scene.__hydratedObjectsFlat) return scene;

    // Normalize shape + fields before we derive any compatibility views.
    normalizeSceneShape(scene);

    // If objects are stored per-floor, also expose a top-level flattened list so older rendering paths continue to work.
    // Always rebuild the flattened list so we never accidentally duplicate entries.
    scene.objects = [];

    if (Array.isArray(scene.floors)) {
      for (const f of scene.floors) {
        if (!f || typeof f !== 'object') continue;
        const fid = f.id;
        if (Array.isArray(f.objects) && f.objects.length) {
          for (const o of f.objects) {
            if (!o || typeof o !== 'object') continue;
            if (!('floorId' in o) && fid) o.floorId = fid;
            scene.objects.push(o);
          }
        }
      }
    }

    scene.__hydratedObjectsFlat = true;
    return scene;
  }

  function normalizeStateForRenderer(rawState) {
    if (!rawState || typeof rawState !== 'object') return null;

    // World-record wrapper
    if (rawState.records && rawState.active && rawState.active.recordId) {
      WORLD_STATE = rawState;
      const recordId = rawState.active.recordId;
      const rec = rawState.records ? rawState.records[recordId] : null;
      if (!rec) {
        console.warn('[Battlemat] World record missing active record:', recordId);
        return null;
      }

      const scene = cloneDeepSafe(rec);
      if (!scene.view || typeof scene.view !== 'object') scene.view = {};

      // Active pointer overrides scene view (camera/floor)
      if (rawState.active.camera_hex) scene.view.camera_hex = rawState.active.camera_hex;
      if (rawState.active.floorId) scene.view.floorId = rawState.active.floorId;

      // Carry through helpful context for UI/debugging (non-canonical for now)
      scene.__activeRecordId = recordId;
      scene.__worldName = rawState.world || null;

      return hydrateSceneForRenderer(scene);
    }

    // Legacy battlemat state
    WORLD_STATE = null;
    return hydrateSceneForRenderer(cloneDeepSafe(rawState));
  }

  function readEmbeddedWorld() {
    try {
      return JSON.parse(EMBEDDED_WORLD_JSON);
    } catch (e) {
      console.warn('[Battlemat] Embedded world JSON parse failed:', e);
      return null;
    }
  }

  // PHASE 2: Allow the host page (or a future DB bootstrap) to provide state_json up-front.
  // If present, it should be either:
  //   - a JSON string (world-record wrapper OR legacy scene state), OR
  //   - a parsed object (same)
  // We intentionally support multiple variable names to make integration easy.
  function readBootstrapState() {
    const injected =
      (typeof window !== 'undefined' && (window.__BATTLEMAT_BOOTSTRAP_STATE_JSON ?? window.BATTLEMAT_BOOTSTRAP_STATE_JSON)) ||
      null;

    if (!injected) return readEmbeddedWorld();

    try {
      if (typeof injected === 'string') return JSON.parse(injected);
      if (typeof injected === 'object') return injected;
    } catch (e) {
      console.warn('[Battlemat] Bootstrap state parse failed; falling back to embedded demo:', e);
      return readEmbeddedWorld();
    }

    console.warn('[Battlemat] Bootstrap state was neither string nor object; falling back to embedded demo.');
    return readEmbeddedWorld();
  }

  // This is the in-page demo default. It is parsed from JSON so it matches state_json storage.
  const DEFAULT_STATE = normalizeStateForRenderer(readBootstrapState()) || FALLBACK_STATE_MIN;

  // Debug helper: lets you easily copy the canonical "raw" JSON (world wrapper if present).
  // Note: This returns the last parsed WORLD_STATE if you loaded a world wrapper; otherwise it returns DEFAULT_STATE.
  if (typeof window !== 'undefined') {
    window.BattlematExportRawState = function () {
      const raw = WORLD_STATE || DEFAULT_STATE;
      return JSON.stringify(raw, null, 2);
    };
  }
  function parseMaybeJson(rawOrJson) {
    if (rawOrJson == null) return null;
    if (typeof rawOrJson === 'string') {
      try { return JSON.parse(rawOrJson); } catch { return null; }
    }
    if (typeof rawOrJson === 'object') return rawOrJson;
    return null;
  }

  function cameraHexFromView() {
    try {
      return colToLetters(VIEW.camera.col) + String((Math.round(VIEW.camera.row) + 1));
    } catch {
      return null;
    }
  }

  function ensureWorldWrapper(recordId) {
    const rid = String(recordId || 'Scene').trim() || 'Scene';
    if (WORLD_STATE && WORLD_STATE.records && WORLD_STATE.active) return WORLD_STATE;

    const scene = cloneDeepSafe(CURRENT_STATE || DEFAULT_STATE || FALLBACK_STATE_MIN);
    const floorId =
      VIEW.floorId ||
      (scene.view && scene.view.floorId) ||
      (Array.isArray(scene.floors) && scene.floors[0] ? scene.floors[0].id : null) ||
      null;

    const camHex = cameraHexFromView() || (scene.view && scene.view.camera_hex) || null;

    WORLD_STATE = {
      world: (scene.__worldName || 'World'),
      version: 1,
      meta: { scale: '1 hex = 5 ft' },
      active: { recordId: rid, floorId, camera_hex: camHex },
      records: { [rid]: scene },
      links: []
    };

    return WORLD_STATE;
  }

  function parsePathParts(path) {
    if (Array.isArray(path)) return path.slice();
    const s = String(path || '').trim();
    if (!s) return [];

    const out = [];
    let i = 0;

    while (i < s.length) {
      const ch = s[i];

      if (ch === '.') { i++; continue; }

      if (ch === '[') {
        i++;
        let numStr = '';
        while (i < s.length && s[i] !== ']') {
          numStr += s[i];
          i++;
        }
        i++; // skip ]
        const n = Number(numStr);
        if (!Number.isFinite(n)) throw new Error('Bad array index in path: ' + numStr);
        out.push(n);
        continue;
      }

      // plain token
      let tok = '';
      while (i < s.length) {
        const c = s[i];
        if (c === '.' || c === '[') break;
        tok += c;
        i++;
      }
      tok = tok.trim();
      if (tok) out.push(tok);
    }

    return out;
  }

  function getContainerForSet(root, parts) {
    let cur = root;

    for (let i = 0; i < parts.length - 1; i++) {
      const k = parts[i];
      const nextK = parts[i + 1];
      const nextIsIndex = typeof nextK === 'number';

      if (typeof k === 'number') {
        if (!Array.isArray(cur)) throw new Error('Path expects array at segment ' + i);
        if (cur[k] == null) cur[k] = nextIsIndex ? [] : {};
        cur = cur[k];
      } else {
        if (cur[k] == null) cur[k] = nextIsIndex ? [] : {};
        cur = cur[k];
      }
    }

    return cur;
  }

  function applyOnePatch(root, patch) {
    const op = String(patch && (patch.op || 'set')).toLowerCase();
    const parts = parsePathParts(patch && (patch.pathParts || patch.path));
    if (!parts.length) throw new Error('Patch missing path');

    const parent = getContainerForSet(root, parts);
    const key = parts[parts.length - 1];

    if (op === 'delete' || op === 'del' || op === 'remove') {
      if (typeof key === 'number') {
        if (!Array.isArray(parent)) throw new Error('Delete expects array at leaf');
        parent.splice(key, 1);
      } else {
        delete parent[key];
      }
      return;
    }

    if (op === 'merge') {
      const val = patch && patch.value;
      const curVal = (typeof key === 'number') ? parent[key] : parent[key];

      if (val && typeof val === 'object' && !Array.isArray(val) &&
          curVal && typeof curVal === 'object' && !Array.isArray(curVal)) {
        Object.assign(curVal, val);
      } else {
        if (typeof key === 'number') {
          if (!Array.isArray(parent)) throw new Error('Set expects array at leaf');
          parent[key] = val;
        } else {
          parent[key] = val;
        }
      }
      return;
    }

    // default: set
    if (typeof key === 'number') {
      if (!Array.isArray(parent)) throw new Error('Set expects array at leaf');
      parent[key] = patch.value;
    } else {
      parent[key] = patch.value;
    }
  }

  function refreshFromWorld() {
    if (WORLD_STATE && WORLD_STATE.records && WORLD_STATE.active && WORLD_STATE.active.recordId) {
      setCanonicalStateFromRaw(WORLD_STATE, stableJsonTextFor(WORLD_STATE));
      return;
    }
    if (CURRENT_RAW_STATE) {
      setCanonicalStateFromRaw(CURRENT_RAW_STATE, LAST_STATE_JSON);
      return;
    }
    CURRENT_STATE = DEFAULT_STATE;
    applyViewFromState(CURRENT_STATE);
  }

  window.BattlematGetWorld = function () {
    return WORLD_STATE ? cloneDeepSafe(WORLD_STATE) : null;
  };

  window.BattlematGetWorldJson = function () {
    return WORLD_STATE ? JSON.stringify(WORLD_STATE, null, 2) : null;
  };

  window.BattlematSetWorldState = function (rawOrJson) {
    const parsed = parseMaybeJson(rawOrJson);
    if (!parsed) throw new Error('BattlematSetWorldState: invalid JSON');
    setCanonicalStateFromRaw(parsed, (typeof rawOrJson === 'string') ? rawOrJson : null);
    safeRedraw();
    return true;
  };

  window.BattlematEnsureWorld = function (recordId) {
    ensureWorldWrapper(recordId || 'Scene');
    refreshFromWorld();
    safeRedraw();
    return true;
  };

  window.BattlematSetActive = function (recordId, floorId, camera_hex) {
    const w = ensureWorldWrapper();
    const rid = String(recordId || '').trim();
    if (!rid) throw new Error('BattlematSetActive: recordId required');
    if (!w.records || !w.records[rid]) throw new Error('BattlematSetActive: unknown recordId ' + rid);

    if (!w.active || typeof w.active !== 'object') w.active = { recordId: rid };
    w.active.recordId = rid;
    if (floorId != null) w.active.floorId = String(floorId);
    if (camera_hex != null) w.active.camera_hex = String(camera_hex);

    refreshFromWorld();
    safeRedraw();
    return true;
  };

  window.BattlematApplyPatches = function (patches) {
    const w = ensureWorldWrapper();
    const list = Array.isArray(patches) ? patches : [patches];
    for (const p of list) applyOnePatch(w, p);
    refreshFromWorld();
    safeRedraw();
    return true;
  };

  // ===== State access =====
  function getState() {
    // 1) If we have a fetched state, use it.
    if (CURRENT_STATE && typeof CURRENT_STATE === 'object') return CURRENT_STATE;

    // 2) Otherwise fall back to injected state.
    const injected = (window && window.BATTLE_STATE != null) ? window.BATTLE_STATE : null;
    const raw = injected != null ? injected : DEFAULT_STATE;
    if (typeof raw === 'string') {
      try { return JSON.parse(raw); } catch { return DEFAULT_STATE; }
    }
    return raw;
  }


  // ===== State compatibility helpers =====
  // v6.20+: tolerate older schema variants while keeping the renderer deterministic.
  function getTokensArray(state) {
    const s = (state && typeof state === 'object') ? state : null;
    const arr = s && (s.tokens != null ? s.tokens : s.actors);
    return Array.isArray(arr) ? arr : [];
  }

  function getMeta(state) {
    const s = (state && typeof state === 'object') ? state : null;
    return (s && s.meta && typeof s.meta === 'object') ? s.meta : {};
  }

  function getLastAction(state) {
    const s = (state && typeof state === 'object') ? state : null;
    if (!s) return '';
    if (s.last_action != null && s.last_action !== '') return String(s.last_action);
    if (s.lastAction != null && s.lastAction !== '') {
      const v = String(s.lastAction);
      s.last_action = v;
      return v;
    }
    return '';
  }

  function getNarration(state) {
    const s = (state && typeof state === 'object') ? state : null;
    if (!s) return '';
    if (s.narration != null && s.narration !== '') return String(s.narration);
    if (s.narrative != null && s.narrative !== '') {
      const v = String(s.narrative);
      s.narration = v;
      return v;
    }
    return '';
  }

  function renderSignatureFor(state, opts = {}) {
    const s = (state && typeof state === 'object') ? state : {};
    const {
      narration,
      narrative,
      narrationText,
      last_action,
      lastAction,
      lastActionText,
      ...rest
    } = s;

    const sig = {
      ...rest,
      __render: {
        view: { floorId: VIEW.floorId, camera: VIEW.camera },
        zoom: ZOOM,
        supersample: SUPERSAMPLE,
        ui: {
          fog: !!opts.fogEnabled,
          sprites: !!opts.spritesEnabled,
          labels: !!opts.labelsEnabled,
        },
        spritesLoaded: SPRITE_LOAD_TICK,
      },
    };

    return stableJsonTextFor(sig);
  }

  // ===== Hex id helpers =====
  function colToLetters(col) {
    let n = col + 1;
    let s = '';
    while (n > 0) {
      const r = (n - 1) % 26;
      s = String.fromCharCode(65 + r) + s;
      n = Math.floor((n - 1) / 26);
    }
    return s;
  }

  function lettersToCol(letters) {
    const u = String(letters).toUpperCase();
    let n = 0;
    for (let i = 0; i < u.length; i++) {
      const c = u.charCodeAt(i);
      if (c < 65 || c > 90) throw new Error('Bad column letters');
      n = n * 26 + (c - 64);
    }
    return n - 1;
  }

  function parseHexId(hex) {
    const m = String(hex).trim().toUpperCase().match(/^([A-Z]+)([0-9]+)$/);
    if (!m) throw new Error('Bad hex: ' + hex);
    return { col: lettersToCol(m[1]), row: parseInt(m[2], 10) - 1 };
  }

  function parseHex(hex) {
    try { return parseHexId(hex); } catch { return null; }
  }


  // Openings (doors/windows/thresholds) may use quarter-step rows (e.g. AD20.25)
  // to support odd hall geometries. Corners already allow arbitrary decimals.
  function isQuarterStep(n) {
    const v = Number(n);
    if (!Number.isFinite(v)) return false;
    return Math.abs(v * 4 - Math.round(v * 4)) < 1e-6;
  }

  function parseOpeningHexId(hex) {
    const m = String(hex).trim().toUpperCase().match(/^([A-Z]+)([0-9]+(?:\.[0-9]+)?)$/);
    if (!m) throw new Error('Bad opening hex: ' + hex);

    const col = lettersToCol(m[1]);
    const rowNum = parseFloat(m[2]);
    if (!isQuarterStep(rowNum)) throw new Error('Opening hex must be in 0.25 steps (e.g. 20, 20.25, 20.5, 20.75): ' + hex);

    return { col, row: rowNum - 1 };
  }

  function parseOpeningHex(hex) {
    try { return parseOpeningHexId(hex); } catch { return null; }
  }

  // Objects can optionally sit on half/quarter rows too (e.g. O20.5), which is handy for
  // 1/2-hex placement without needing ox/oy micro-adjustments.
  function parseObjectHexId(hex) {
    const m = String(hex).trim().toUpperCase().match(/^([A-Z]+)([0-9]+(?:\.[0-9]+)?)$/);
    if (!m) throw new Error('Bad object hex: ' + hex);

    const col = lettersToCol(m[1]);
    const rowNum = parseFloat(m[2]);
    if (!isQuarterStep(rowNum)) throw new Error('Object hex must be in 0.25 steps (e.g. 20, 20.25, 20.5, 20.75): ' + hex);

    return { col, row: rowNum - 1 };
  }

  function parseObjectHex(hex) {
    try { return parseObjectHexId(hex); } catch { return null; }
  }

  function parseCornerHexId(hex) {
    const m = String(hex).trim().toUpperCase().match(/^([A-Z]+)([0-9]+(?:\.[0-9]+)?)$/);
    if (!m) throw new Error('Bad corner hex: ' + hex);

    const col = lettersToCol(m[1]);
    const rowNum = parseFloat(m[2]);
    if (!Number.isFinite(rowNum)) throw new Error('Bad corner row: ' + hex);

    return { col, row: rowNum - 1 };
  }

  function hexId(col, row) {
    return colToLetters(col) + String(row + 1);
  }

  // ===== World geometry (flat-top) =====
  function colStep() { return 1.5 * GRID.size; }
  function rowStep() { return sqrt3 * GRID.size; }

  // Row 0 is bottom row ("1"), row increases upward.
  function hexCenterWorld(col, row) {
    const x = col * colStep();
    const y = -(row * rowStep() + (col & 1) * (rowStep() / 2));
    return { x, y };
  }

  // ===== Camera transform =====
  function cameraWorld() { return hexCenterWorld(VIEW.camera.col, VIEW.camera.row); }

  function worldToScreen(p) {
    const cam = cameraWorld();
    return { x: VIEW.anchor.x + (p.x - cam.x), y: VIEW.anchor.y + (p.y - cam.y) };
  }

  // ===== Floors (multi-floor) =====
  function getFloorsFromState(state) {
    const f = state && state.floors;
    if (Array.isArray(f)) return f;

    if (f && typeof f === 'object') {
      return Object.entries(f).map(([id, data]) => ({ id, ...(data || {}) }));
    }

    return [{
      id: (state && state.view && (state.view.floorId || state.view.floor_id || state.view.floor)) ? String(state.view.floorId || state.view.floor_id || state.view.floor) : 'floor1',
      name: 'Floor',
      rooms: Array.isArray(state && state.rooms) ? state.rooms : [],
      openings: Array.isArray(state && state.openings) ? state.openings : [],
      objects: Array.isArray(state && state.objects) ? state.objects : [],
    }];
  }

  function pickActiveFloorId(state, floors) {
    const wanted = state && state.view ? (state.view.floorId || state.view.floor_id || state.view.floor || state.view.level) : null;
    const w = wanted != null ? String(wanted) : '';
    if (w && floors.some(f => String(f.id) === w)) return w;
    return floors.length ? String(floors[0].id) : 'floor1';
  }

  function floorById(floors, id) {
    const target = String(id || '');
    return floors.find(f => String(f.id) === target) || null;
  }

  function entityFloorId(e) {
    if (!e || typeof e !== 'object') return '';
    return String(e.floorId || e.floor_id || e.floor || e.level || e.z || '');
  }

  function tokensOnFloor(state, floorId) {
    const all = getTokensArray(state);
    return all.filter(t => {
      const fid = entityFloorId(t);
      return fid ? fid === String(floorId) : true;
    });
  }

  // ===== Rooms / walls geometry =====
  function roomWallKind(room) {
    const w = (room && room.wall && typeof room.wall === 'object') ? room.wall : null;
    const k = (w && w.kind != null) ? String(w.kind) : '';
    const t = (w && w.type != null) ? String(w.type) : '';
    return String((k || t || 'brick')).toLowerCase();
  }

  function roomHasWalls(room) {
    const thick = Number(room && room.thickness != null ? room.thickness : 0);
    const wk = roomWallKind(room);
    return thick > 0 && wk !== 'none';
  }

  function roomToWallBox(room) {
    const corners = Array.isArray(room && room.corners) ? room.corners : [];
    if (corners.length !== 4) throw new Error('Room corners must be [TL, TR, BR, BL]');

    const tl = parseCornerHexId(corners[0]);
    const tr = parseCornerHexId(corners[1]);
    const br = parseCornerHexId(corners[2]);
    const bl = parseCornerHexId(corners[3]);

    const pTL = hexCenterWorld(tl.col, tl.row);
    const pTR = hexCenterWorld(tr.col, tr.row);
    const pBR = hexCenterWorld(br.col, br.row);
    const pBL = hexCenterWorld(bl.col, bl.row);

    const xL = (pTL.x + pBL.x) / 2;
    const xR = (pTR.x + pBR.x) / 2;
    const yTop = (pTL.y + pTR.y) / 2;
    const yBot = (pBL.y + pBR.y) / 2;

    const thicknessBase = Number(room && room.thickness != null ? room.thickness : 20);
    // room.thickness is specified at 100% zoom; scale by ZOOM so walls stay proportional.
    const thickness = thicknessBase * (Number(ZOOM) || 1);

    const t = roomHasWalls(room) ? thickness : 0;

    const half = t / 2;

    const mid = { x1: xL, y1: yTop, x2: xR, y2: yBot };
    const floor = { x1: xL + half, y1: yTop + half, x2: xR - half, y2: yBot - half };

    return { xL, xR, yTop, yBot, thickness: t, mid, floor };
  }

  function roomFloorRectWorld(room, box) {
    const src = (roomHasWalls(room) ? box.floor : box.mid);
    return { x1: src.x1, y1: src.y1, x2: src.x2, y2: src.y2 };
  }

  function buildWallSegments(rooms) {
    const segs = [];
    for (const r of (Array.isArray(rooms) ? rooms : [])) {
      if (!r || !roomHasWalls(r)) continue;
      const box = roomToWallBox(r);
      const t = box.thickness;

      const color = (r && r.color) ? String(r.color) : COLORS.wall;
      const wallKind = roomWallKind(r);

      segs.push({ orientation: 'h', y: box.yTop, x1: box.xL, x2: box.xR, thickness: t, color, wallKind });
      segs.push({ orientation: 'h', y: box.yBot, x1: box.xL, x2: box.xR, thickness: t, color, wallKind });
      segs.push({ orientation: 'v', x: box.xL, y1: box.yTop, y2: box.yBot, thickness: t, color, wallKind });
      segs.push({ orientation: 'v', x: box.xR, y1: box.yTop, y2: box.yBot, thickness: t, color, wallKind });
    }
    return segs;
  }

  function findNearestWallSegment(wallSegs, orient, p) {
    const want = (orient === 'h' || orient === 'v') ? orient : 'h';
    let best = null;
    let bestD2 = Infinity;

    for (const s of (Array.isArray(wallSegs) ? wallSegs : [])) {
      if (!s || s.orientation !== want) continue;

      if (want === 'h') {
        const dy = Math.abs((p && p.y) - s.y);
        let dx = 0;
        if ((p && p.x) < s.x1) dx = s.x1 - (p.x);
        else if ((p && p.x) > s.x2) dx = (p.x) - s.x2;
        const d2 = dx * dx + dy * dy;
        if (d2 < bestD2) { bestD2 = d2; best = s; }
      } else {
        const dx = Math.abs((p && p.x) - s.x);
        let dy = 0;
        if ((p && p.y) < s.y1) dy = s.y1 - (p.y);
        else if ((p && p.y) > s.y2) dy = (p.y) - s.y2;
        const d2 = dx * dx + dy * dy;
        if (d2 < bestD2) { bestD2 = d2; best = s; }
      }
    }

    return best;
  }

  function quant01(v) { return Math.round(v * 100) / 100; }

  function dedupeWallSegments(segs) {
    const map = new Map();

    for (const s of (Array.isArray(segs) ? segs : [])) {
      if (!s) continue;
      const o = s.orientation;
      if (o === 'h') {
        const y = quant01(s.y);
        const x1 = quant01(Math.min(s.x1, s.x2));
        const x2 = quant01(Math.max(s.x1, s.x2));
        const key = `h|${y}|${x1}|${x2}`;
        const prev = map.get(key);
        if (!prev) map.set(key, { ...s, y, x1, x2 });
        else prev.thickness = Math.max(prev.thickness, s.thickness);
      } else {
        const x = quant01(s.x);
        const y1 = quant01(Math.min(s.y1, s.y2));
        const y2 = quant01(Math.max(s.y1, s.y2));
        const key = `v|${x}|${y1}|${y2}`;
        const prev = map.get(key);
        if (!prev) map.set(key, { ...s, x, y1, y2 });
        else prev.thickness = Math.max(prev.thickness, s.thickness);
      }
    }

    return [...map.values()];
  }

  function drawWallSegments(targetCtx, wallSegs) {
    const wantTextures = !!(elSpriteToggle && elSpriteToggle.checked);

    for (const s of (Array.isArray(wallSegs) ? wallSegs : [])) {
      if (!s || !s.thickness) continue;

      const t = s.thickness;
      const half = t / 2;

      let fill = s.color || COLORS.wall;
      if (wantTextures) {
        const def = resolveTextureDef('wall', s.wallKind);
        if (def) {
          const pat = getRepeatPatternForCtx(targetCtx, def);
          if (pat) fill = pat;
        }
      }
      targetCtx.fillStyle = fill;

      if (s.orientation === 'h') {
        const x1 = s.x1 - half;
        const x2 = s.x2 + half;
        const y1 = s.y - half;
        const y2 = s.y + half;

        const p1 = worldToScreen({ x: x1, y: y1 });
        const p2 = worldToScreen({ x: x2, y: y2 });
        const w = p2.x - p1.x;
        const h = p2.y - p1.y;
        if (w > 0 && h > 0) targetCtx.fillRect(p1.x, p1.y, w, h);
      } else {
        const x1 = s.x - half;
        const x2 = s.x + half;
        const y1 = s.y1 - half;
        const y2 = s.y2 + half;

        const p1 = worldToScreen({ x: x1, y: y1 });
        const p2 = worldToScreen({ x: x2, y: y2 });
        const w = p2.x - p1.x;
        const h = p2.y - p1.y;
        if (w > 0 && h > 0) targetCtx.fillRect(p1.x, p1.y, w, h);
      }
    }
  }

  // ===== Floor fills =====
  function floorBaseColor(kind) {
    const k = String(kind || 'wood').toLowerCase();
    if (k === 'fog') return COLORS.fogUnseen;
    if (k === 'stone') return COLORS.floorStone;
    if (k === 'cobble') return COLORS.floorCobble;
    if (k.startsWith('stairs')) return COLORS.floorWood;
    return COLORS.floorWood;
  }

  function getFloorFillStyle(kind, wantTextures, targetCtx = ctx) {
    const fk = String(kind || 'wood').toLowerCase();
    if (!wantTextures) return floorBaseColor(fk);
    const def = resolveTextureDef('floor', fk);
    if (!def) return floorBaseColor(fk);
    const pat = getRepeatPatternForCtx(targetCtx, def);
    return pat || floorBaseColor(fk);
  }

  function isFogFloorRoom(room) {
    const k = room && room.floor && room.floor.kind ? String(room.floor.kind).toLowerCase() : '';
    return k === 'fog';
  }

  function drawFloorsLayered(rooms) {
    const wantTextures = !!(elSpriteToggle && elSpriteToggle.checked);

    for (const r of (Array.isArray(rooms) ? rooms : [])) {
      const box = roomToWallBox(r);
      const f = roomFloorRectWorld(r, box);
      const p1 = worldToScreen({ x: f.x1, y: f.y1 });
      const p2 = worldToScreen({ x: f.x2, y: f.y2 });
      const w = p2.x - p1.x;
      const h = p2.y - p1.y;
      if (w <= 0 || h <= 0) continue;

      const fk = (r && r.floor && r.floor.kind) ? String(r.floor.kind).toLowerCase() : 'wood';
      ctx.fillStyle = getFloorFillStyle(fk, wantTextures, ctx);
      ctx.fillRect(p1.x, p1.y, w, h);
    }
  }

  // ===== Openings =====
  function openingOrientation(opening) {
    const o = opening && opening.orientation ? String(opening.orientation).toLowerCase() : 'h';
    if (o === 'v' || o === 'vert' || o === 'vertical') return 'v';
    return 'h';
  }

  function openingSpan(opening) {
    const s = Number(opening && opening.span != null ? opening.span : 1);
    return clamp(Number.isFinite(s) ? s : 1, 0.5, 4);
  }

  function isDoorKind(kind) {
    const k = String(kind || '').toLowerCase();
    return (k === 'door' || k.startsWith('door_') || k.startsWith('door.'));
  }

  // Pixel padding applied to wall cutouts / seam fills.
  // To avoid 1px seams at certain zoom levels, we apply a small buffer.
  // For thresholds, we ONLY buffer in the axis perpendicular to the opening orientation:
  //   - vertical threshold (orientation 'v') => widen horizontally (+4px)
  //   - horizontal threshold (orientation 'h') => widen vertically (+4px)
  // This keeps the threshold span aligned to the parent floor, while still covering subpixel seams.
  function openingPadAxes(opening) {
    const kind = String(opening && opening.kind ? opening.kind : 'door').toLowerCase();
    const orient = openingOrientation(opening);

    // No padding needed for portals (they don't cut walls/floors).
    if (kind === 'portal' || kind === 'connector') return { x: 0, y: 0 };

    // Scale padding with backing-store resolution (DPR × supersample) to prevent 1px seams
    // at high zoom levels.
    const d = Number(VIEW && VIEW.dpr) || 1;
    const pad = clamp(Math.ceil(2 * d), 4, 12);

    // Thresholds: buffer only perpendicular to the opening orientation.
    if (kind === 'threshold') {
      return (orient === 'v') ? { x: pad, y: 0 } : { x: 0, y: pad };
    }

    // Doors/windows: small buffer in both axes helps hide seams.
    return { x: pad, y: pad };
  }

  // Opening length in world-units (CSS px). For thresholds, we auto-size to the parent room's
  // interior span so the knockout matches the parent floor space exactly.
  function openingLengthWorld(opening, rooms) {
    const kind = String(opening && opening.kind ? opening.kind : 'door').toLowerCase();
    const orient = openingOrientation(opening);

    if (kind === 'threshold') {
      const parentId = (opening && opening.parent != null) ? String(opening.parent) : '';
      const parent = parentId ? roomById(rooms, parentId) : null;
      if (parent) {
        const box = roomToWallBox(parent);
        const fr = roomFloorRectWorld(parent, box);
        const worldLen = (orient === 'h') ? Math.abs(fr.x2 - fr.x1) : Math.abs(fr.y2 - fr.y1);
        // Guardrails: never return something absurdly tiny.
        return Math.max(worldLen, GRID.size * 0.6);
      }
      // If no parent is provided/found, fall back to span sizing.
    }

    const baseLen = GRID.size * 1.2;
    const span = openingSpan(opening);
    return baseLen * span;
  }

  function cutOpeningHole(targetCtx, opening, wallSegs, rooms) {
    const kind = String(opening && opening.kind ? opening.kind : 'door').toLowerCase();
    if (kind === 'portal' || kind === 'connector') return;

    const orient = openingOrientation(opening);
    const p = parseOpeningHex(opening.hex);
    if (!p) return;

    const hexWorld = hexCenterWorld(p.col, p.row);
    const seg = findNearestWallSegment(wallSegs, orient, hexWorld);

    // Important: snap the cutout centerline onto the actual wall segment axis.
    // At extreme zoom levels, tiny float/quantization differences can otherwise mean
    // the cutout misses the wall by ~<1px, making the "knockout" look like it vanished.
    let cx = hexWorld.x;
    let cy = hexWorld.y;
    if (seg) {
      if (orient === 'h' && Number.isFinite(seg.y)) cy = seg.y;
      if (orient === 'v' && Number.isFinite(seg.x)) cx = seg.x;
    }

    const len = openingLengthWorld(opening, rooms);
    const thickness = seg ? seg.thickness : 28;

    const centerS = worldToScreen({ x: cx, y: cy });
    const pad = openingPadAxes(opening);

    // Axis-aligned screen rect (no rotation) so this matches seam fills exactly.
    // Base rect dimensions depend on orientation, then we apply axis-specific padding.
    const baseW = (orient === 'v') ? thickness : len;
    const baseH = (orient === 'v') ? len : thickness;
    const w = baseW + (pad.x || 0);
    const h = baseH + (pad.y || 0);

    const rr = snappedRectFromCenter(centerS, w, h);
    if (rr.w > 0 && rr.h > 0) targetCtx.fillRect(rr.x, rr.y, rr.w, rr.h);
  }

  function drawOpeningMarker(opening, wallSegs) {
    const kind = String(opening && opening.kind ? opening.kind : 'door').toLowerCase();
    if (kind === 'threshold' || kind === 'portal' || kind === 'connector') return;

    const orient = openingOrientation(opening);
    const p = parseOpeningHex(opening.hex);
    if (!p) return;

    const hexWorld = hexCenterWorld(p.col, p.row);
    const seg = findNearestWallSegment(wallSegs, orient, hexWorld);

    // Keep the marker aligned to the wall segment axis (same reason as cutOpeningHole).
    let cx = hexWorld.x;
    let cy = hexWorld.y;
    if (seg) {
      if (orient === 'h' && Number.isFinite(seg.y)) cy = seg.y;
      if (orient === 'v' && Number.isFinite(seg.x)) cx = seg.x;
    }

    const thickness = seg ? seg.thickness : 28;

    const c = worldToScreen({ x: cx, y: cy });
    const len = (GRID.size * 1.2) * openingSpan(opening);
    const openPct = clamp(Number(opening && opening.openPct != null ? opening.openPct : 0), 0, 1);

    ctx.save();
    ctx.translate(c.x, c.y);
    if (orient === 'v') ctx.rotate(Math.PI / 2);

    if (kind === 'window') {
      ctx.strokeStyle = COLORS.window;
      ctx.globalAlpha = 0.85;
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(-len / 2, 0);
      ctx.lineTo(len / 2, 0);
      ctx.stroke();

      ctx.globalAlpha = 0.45;
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(-len / 2, -thickness * 0.25);
      ctx.lineTo(len / 2, -thickness * 0.25);
      ctx.moveTo(-len / 2, thickness * 0.25);
      ctx.lineTo(len / 2, thickness * 0.25);
      ctx.stroke();

      ctx.restore();
      return;
    }

    // Door sprites (e.g. kind: 'door_wood')
    if (isDoorKind(kind) && (elSpriteToggle && elSpriteToggle.checked)) {
      const def = getSpriteDef(kind);
      if (def) {
        const img = loadSprite(def.file);
        if (img && img.complete && img.naturalWidth && img.naturalHeight) {
          const hingeSide = String(opening && opening.hinge != null ? opening.hinge : 'left').toLowerCase();
          const hingeRight = (hingeSide === 'right' || hingeSide === 'r');

          const rawSwing = Number(opening && (opening.swing ?? opening.swingDir ?? opening.polarity));
          const swingSign = (rawSwing === 1 || rawSwing === -1) ? rawSwing : -1;

          const hingeX = hingeRight ? (len / 2) : (-len / 2);
          const hingeY = 0;

          const leafLen = len * 0.80;
          const boxW = leafLen;
          const boxH = thickness * 1.25;

          // Allow door openings to scale their sprite just like objects do.
          // (e.g. { kind:'door.wood', ..., spriteScale: 1.3 })
          let sx = 1, sy = 1;
          if (isFiniteNum(def.scale)) { sx *= Number(def.scale); sy *= Number(def.scale); }
          if (isFiniteNum(def.scaleX)) sx *= Number(def.scaleX);
          if (isFiniteNum(def.scaleY)) sy *= Number(def.scaleY);
          if (isFiniteNum(opening.spriteScale)) { sx *= Number(opening.spriteScale); sy *= Number(opening.spriteScale); }
          if (isFiniteNum(opening.spriteScaleX)) sx *= Number(opening.spriteScaleX);
          if (isFiniteNum(opening.spriteScaleY)) sy *= Number(opening.spriteScaleY);

          const ang = openPct * (Math.PI / 2);

          ctx.save();
          ctx.translate(hingeX, hingeY);
          ctx.rotate((hingeRight ? -1 : 1) * swingSign * ang);

          const ok = drawSpriteImage(img, {
            x: 0,
            y: 0,
            w: boxW * sx,
            h: boxH * sy,
            fit: 'contain',
            anchorX: hingeRight ? 1 : 0,
            anchorY: 0.5,
          });
          ctx.restore();

          if (ok) {
            ctx.restore();
            return;
          }
        }
      }
    }

    ctx.strokeStyle = COLORS.door;
    ctx.lineWidth = 4;
    ctx.globalAlpha = 0.9;

    if (openPct < 0.05) {
      ctx.beginPath();
      ctx.moveTo(-len / 2, 0);
      ctx.lineTo(len / 2, 0);
      ctx.stroke();
    } else {
      const hingeSide = String(opening && opening.hinge != null ? opening.hinge : 'left').toLowerCase();
      const hingeRight = (hingeSide === 'right' || hingeSide === 'r');

      const rawSwing = Number(opening && (opening.swing ?? opening.swingDir ?? opening.polarity));
      const swingSign = (rawSwing === 1 || rawSwing === -1) ? rawSwing : -1;

      const hingeX = hingeRight ? (len / 2) : (-len / 2);
      const hingeY = 0;

      const leafLen = len * 0.80;
      const ang = openPct * (Math.PI / 2);

      const x2 = hingeX + (hingeRight ? -1 : 1) * leafLen * Math.cos(ang);
      const y2 = hingeY + swingSign * leafLen * Math.sin(ang);

      ctx.beginPath();
      ctx.moveTo(hingeX, hingeY);
      ctx.lineTo(x2, y2);
      ctx.stroke();

      ctx.fillStyle = COLORS.door;
      ctx.globalAlpha = 0.95;
      ctx.beginPath();
      ctx.arc(hingeX, hingeY, 2.2, 0, Math.PI * 2);
      ctx.fill();
    }

    ctx.restore();
  }

  function roomById(rooms, id) {
    const target = String(id || '');
    if (!target) return null;
    return (Array.isArray(rooms) ? rooms : []).find(r => r && String(r.id) === target) || null;
  }

  function roomFloorKind(room) {
    return (room && room.floor && room.floor.kind) ? String(room.floor.kind) : 'wood';
  }


  function buildRoomMeta(rooms) {
    const meta = new Map();
    for (const r of (Array.isArray(rooms) ? rooms : [])) {
      if (!r || !r.id) continue;
      const box = roomToWallBox(r);
      const f = roomFloorRectWorld(r, box);
      meta.set(String(r.id), { room: r, floorRect: f });
    }
    // Keep a global copy for any code paths that expect `roomMetaAll` to exist.
    roomMetaAll = meta;
    return meta;
  }

  function roomContainsWorldPoint(roomRect, p) {
    if (!roomRect) return false;
    return (p.x >= roomRect.x1 && p.x <= roomRect.x2 && p.y >= roomRect.y1 && p.y <= roomRect.y2);
  }

  function pickRoomAtWorldPoint(roomMeta, p) {
    let bestId = null;
    let bestArea = Infinity;

    for (const [id, info] of roomMeta.entries()) {
      const r = info.floorRect;
      if (!roomContainsWorldPoint(r, p)) continue;
      const area = Math.abs((r.x2 - r.x1) * (r.y2 - r.y1));
      if (area < bestArea) { bestArea = area; bestId = id; }
    }

    return bestId;
  }

  function openingRoomIds(opening, roomMeta, wallSegs = null) {
    const orient = openingOrientation(opening);
    const p = parseOpeningHex(opening.hex);
    if (!p) return [];

    const hw = hexCenterWorld(p.col, p.row);

    // If we have wall segments, sample thickness from the nearest wall. Otherwise default.
    const seg = (wallSegs && Array.isArray(wallSegs))
      ? findNearestWallSegment(wallSegs, orient, hw)
      : null;

    let thickness = 28;
    if (seg && seg.thickness) thickness = seg.thickness;

    const cx = hw.x, cy = hw.y;
    const eps = Math.max(6, thickness * 0.6);
    const samples = (orient === 'h')
      ? [{ x: cx, y: cy - eps }, { x: cx, y: cy + eps }]
      : [{ x: cx - eps, y: cy }, { x: cx + eps, y: cy }];

    const ids = new Set();
    for (const s of samples) {
      const id = pickRoomAtWorldPoint(roomMeta, s);
      if (id) ids.add(id);
    }
    return [...ids];
  }

  let RENDER_FOG = null;
  // Cached per-redraw room metadata (Map roomId -> {room,floorRect}).
  // Some call-sites pass `roomMetaAll` by name; keep a global to avoid ReferenceErrors.
  var roomMetaAll = null;

  function openingPreferredRoomId(opening, roomMetaAll) {
    const parentId = opening && opening.parent ? String(opening.parent) : '';
    if (parentId) return parentId;

    const ids = openingRoomIds(opening, roomMetaAll);
    if (!ids.length) return '';

    if (RENDER_FOG && RENDER_FOG.enabled) {
      for (const id of ids) if (RENDER_FOG.visible && RENDER_FOG.visible.has(id)) return id;
      for (const id of ids) if (RENDER_FOG.explored && RENDER_FOG.explored.has(id)) return id;
    }
    return String(ids[0] || '');
  }

  function openingKnockoutFill(opening, rooms, roomMetaAll, fogEnabled, wantTextures) {
    const rid = openingPreferredRoomId(opening, roomMetaAll);
    const room = rid ? roomById(rooms, rid) : null;
    const fk = room ? roomFloorKind(room) : 'wood';

    if (!fogEnabled) return getFloorFillStyle(fk, wantTextures, ctx);

    if (RENDER_FOG && RENDER_FOG.enabled && rid && RENDER_FOG.visible && RENDER_FOG.visible.has(rid)) {
      return getFloorFillStyle(fk, wantTextures, ctx);
    }

    return floorBaseColor('fog');
  }

  function drawOpeningSeamFills(openings, rooms, roomMetaAll, wallSegs, fogEnabled) {
    const wantTextures = !!(elSpriteToggle && elSpriteToggle.checked);

    for (const o of (Array.isArray(openings) ? openings : [])) {
      const kind = String(o && o.kind ? o.kind : '').toLowerCase();
      const isDoor = isDoorKind(kind);
      if (kind !== 'threshold' && !isDoor && kind !== 'portal') continue;

      const orient = openingOrientation(o);
      const p = parseOpeningHex(o.hex);
      if (!p) continue;

      const hexWorld = hexCenterWorld(p.col, p.row);
      const seg = findNearestWallSegment(wallSegs, orient, hexWorld);

      // Snap onto the wall axis so seam fills always overlap the wall cutout.
      let cx = hexWorld.x;
      let cy = hexWorld.y;
      if (seg) {
        if (orient === 'h' && Number.isFinite(seg.y)) cy = seg.y;
        if (orient === 'v' && Number.isFinite(seg.x)) cx = seg.x;
      }

      const len = openingLengthWorld(o, rooms);
      const thickness = seg ? seg.thickness : 28;

      const centerS = worldToScreen({ x: cx, y: cy });
      const pad = openingPadAxes(o);

      // Axis-aligned screen-space rect so patterns stay aligned with the floor.
      const baseW = (orient === 'v') ? thickness : len;
      const baseH = (orient === 'v') ? len : thickness;
      const w = baseW + (pad.x || 0);
      const h = baseH + (pad.y || 0);

      ctx.save();
      ctx.fillStyle = openingKnockoutFill(o, rooms, roomMetaAll, fogEnabled, wantTextures);
      const rr = snappedRectFromCenter(centerS, w, h);
      ctx.fillRect(rr.x, rr.y, rr.w, rr.h);
      ctx.restore();
    }
  }

  // ===== Fog (room-based, per-floor) =====
  function normalizeFog(state, floorId) {
    const raw = (state && state.fog && typeof state.fog === 'object') ? state.fog : {};

    const enabled = !!raw.enabled;
    const autoCompute = raw.autoCompute !== false;
    const autoExplore = raw.autoExplore !== false;
    const maxDepth = clamp(Number.isFinite(Number(raw.maxDepth)) ? Number(raw.maxDepth) : 1, 0, 12);

    const unseenAlpha = clamp(Number.isFinite(Number(raw.unseenAlpha)) ? Number(raw.unseenAlpha) : 0.92, 0, 1);
    const exploredAlpha = clamp(Number.isFinite(Number(raw.exploredAlpha)) ? Number(raw.exploredAlpha) : 0.55, 0, 1);

    const perVis = (raw.visibleRoomIdsByFloor && typeof raw.visibleRoomIdsByFloor === 'object') ? raw.visibleRoomIdsByFloor : null;
    const perExp = (raw.exploredRoomIdsByFloor && typeof raw.exploredRoomIdsByFloor === 'object') ? raw.exploredRoomIdsByFloor : null;

    const getVis = () => {
      if (perVis) return Array.isArray(perVis[floorId]) ? perVis[floorId] : [];
      return Array.isArray(raw.visibleRoomIds) ? raw.visibleRoomIds : [];
    };

    const getExp = () => {
      if (perExp) return Array.isArray(perExp[floorId]) ? perExp[floorId] : [];
      return Array.isArray(raw.exploredRoomIds) ? raw.exploredRoomIds : [];
    };

    const setVis = (ids) => {
      if (perVis) perVis[floorId] = ids;
      else raw.visibleRoomIds = ids;
    };

    const setExp = (ids) => {
      if (perExp) perExp[floorId] = ids;
      else raw.exploredRoomIds = ids;
    };

    return {
      enabled,
      autoCompute,
      autoExplore,
      maxDepth,
      unseenAlpha,
      exploredAlpha,
      get visibleRoomIds() { return getVis(); },
      get exploredRoomIds() { return getExp(); },
      setVisibleRoomIds: setVis,
      setExploredRoomIds: setExp,
    };
  }

  function isPlayerToken(t) {
    return String(t && t.side ? t.side : '').toUpperCase() === 'PC';
  }

  function computeRenderFog(state, floorId, rooms, openings, tokens) {
    const fog = normalizeFog(state, floorId);
    if (!fog.enabled) return null;

    const roomMeta = buildRoomMeta(rooms);

    const explored = new Set((fog.exploredRoomIds || []).map(String));
    const visible = new Set((fog.visibleRoomIds || []).map(String));

    if (!fog.autoCompute) {
      return { enabled: true, explored, visible, maxDepth: fog.maxDepth, exploredAlpha: fog.exploredAlpha, unseenAlpha: fog.unseenAlpha };
    }

    const pcs = (Array.isArray(tokens) ? tokens : []).filter(isPlayerToken);
    const start = new Set();
    for (const t of pcs) {
      const hp = parseHex(t.hex);
      if (!hp) continue;
      const world = hexCenterWorld(hp.col, hp.row);
      const rid = pickRoomAtWorldPoint(roomMeta, world);
      if (rid) start.add(rid);
    }

    const adj = new Map();
    const addEdge = (a, b) => {
      if (!a || !b || a === b) return;
      if (!adj.has(a)) adj.set(a, new Set());
      if (!adj.has(b)) adj.set(b, new Set());
      adj.get(a).add(b);
      adj.get(b).add(a);
    };

    for (const o of (Array.isArray(openings) ? openings : [])) {
      const k = String(o && o.kind ? o.kind : 'door').toLowerCase();
      if (k === 'portal' || k === 'connector') continue;

      const openPct = clamp(Number(o && o.openPct != null ? o.openPct : 0), 0, 1);
      const isOpenForSight = (k === 'threshold') || (k === 'window') || (isDoorKind(k) && openPct >= 0.5);
      if (!isOpenForSight) continue;

      const ids = openingRoomIds(o, roomMeta);
      if (ids.length === 2) addEdge(ids[0], ids[1]);
    }

    const q = [];
    const dist = new Map();

    for (const rid of start) {
      q.push(rid);
      dist.set(rid, 0);
    }

    const vis = new Set();
    while (q.length) {
      const cur = q.shift();
      const d = dist.get(cur) || 0;
      vis.add(cur);
      if (d >= fog.maxDepth) continue;
      const ns = adj.get(cur);
      if (!ns) continue;
      for (const n of ns) {
        if (!dist.has(n)) {
          dist.set(n, d + 1);
          q.push(n);
        }
      }
    }

    if (fog.autoExplore) {
      for (const rid of vis) explored.add(rid);
      fog.setExploredRoomIds([...explored]);
    }

    fog.setVisibleRoomIds([...vis]);

    return { enabled: true, explored, visible: vis, maxDepth: fog.maxDepth, exploredAlpha: fog.exploredAlpha, unseenAlpha: fog.unseenAlpha };
  }

  function drawRememberedRoomOverlays(rooms) {
    if (!RENDER_FOG || !RENDER_FOG.enabled) return;

    ctx.save();
    ctx.globalAlpha = RENDER_FOG.exploredAlpha;
    ctx.fillStyle = COLORS.fogExplored;

    for (const r of (Array.isArray(rooms) ? rooms : [])) {
      if (!r || !r.id) continue;
      if (isFogFloorRoom(r)) continue;

      const id = String(r.id);
      if (!RENDER_FOG.explored.has(id)) continue;
      if (RENDER_FOG.visible.has(id)) continue;

      const box = roomToWallBox(r);
      const f = roomFloorRectWorld(r, box);
      const p1 = worldToScreen({ x: f.x1, y: f.y1 });
      const p2 = worldToScreen({ x: f.x2, y: f.y2 });
      const w = p2.x - p1.x;
      const h = p2.y - p1.y;
      if (w > 0 && h > 0) ctx.fillRect(p1.x, p1.y, w, h);
    }

    ctx.restore();
  }

  // ===== Objects / tokens orientation =====
  function degToRad(deg) { return (deg * Math.PI) / 180; }

  function objectRotationRad(o) {
    if (!o) return 0;
    const deg = Number(o.rotDeg);
    return Number.isFinite(deg) ? degToRad(deg) : 0;
  }

  function objectCenterWorld(o) {
    const p = parseObjectHex(o && o.hex);
    if (!p) return null;

    const base = hexCenterWorld(p.col, p.row);

    const ox = Number(o && o.ox);
    const oy = Number(o && o.oy);

    return {
      x: base.x + (Number.isFinite(ox) ? ox : 0) * GRID.size,
      y: base.y + (Number.isFinite(oy) ? oy : 0) * GRID.size,
    };
  }

  function objectCenterScreen(o) {
    const w = objectCenterWorld(o);
    if (!w) return null;
    return worldToScreen(w);
  }

  function objectSizePx(o) {
    const base = GRID.size * 1.15;
    return { w: base, h: base };
  }

  function objectVisible(o, roomMetaAll) {
    if (!RENDER_FOG || !RENDER_FOG.enabled) return true;

    const kind = String(o && o.kind ? o.kind : '').toLowerCase();

    const w = objectCenterWorld(o);
    if (!w) return true;

    const rid = pickRoomAtWorldPoint(roomMetaAll, w);
    if (!rid) return true;

    if (kind === 'hearth' || kind === 'cooking.hearth') return RENDER_FOG.explored.has(rid) || RENDER_FOG.visible.has(rid);

    return RENDER_FOG.visible.has(rid) || RENDER_FOG.explored.has(rid);
  }

  function roundRectPath(targetCtx, x, y, w, h, r) {
    const rr = Math.max(0, Math.min(r, Math.min(Math.abs(w), Math.abs(h)) / 2));
    targetCtx.beginPath();
    targetCtx.moveTo(x + rr, y);
    targetCtx.lineTo(x + w - rr, y);
    targetCtx.quadraticCurveTo(x + w, y, x + w, y + rr);
    targetCtx.lineTo(x + w, y + h - rr);
    targetCtx.quadraticCurveTo(x + w, y + h, x + w - rr, y + h);
    targetCtx.lineTo(x + rr, y + h);
    targetCtx.quadraticCurveTo(x, y + h, x, y + h - rr);
    targetCtx.lineTo(x, y + rr);
    targetCtx.quadraticCurveTo(x, y, x + rr, y);
    targetCtx.closePath();
  }

  function drawObject(o, roomMetaAll) {
    if (!o) return;
    if (!objectVisible(o, roomMetaAll)) return;

    const c = objectCenterScreen(o);
    if (!c) return;

    const { w, h } = objectSizePx(o);
    const rot = objectRotationRad(o);

    const kind = String(o.kind || 'object').toLowerCase();

    if (elSpriteToggle && elSpriteToggle.checked) {
      const def = getSpriteDef(kind);
      if (def) {
        const img = loadSprite(def.file);

        let sx = 1, sy = 1;
        // Sprite-def defaults are always applied first.
        if (isFiniteNum(def.scale)) { sx *= Number(def.scale); sy *= Number(def.scale); }
        if (isFiniteNum(def.scaleX)) sx *= Number(def.scaleX);
        if (isFiniteNum(def.scaleY)) sy *= Number(def.scaleY);

        // Scaling rules:
        // - spriteScale => proportional (uniform) scaling
        // - spriteScaleX / spriteScaleY => absolute per-axis scaling (non-uniform), and ignores spriteScale
        const hasAxisScale = isFiniteNum(o.spriteScaleX) || isFiniteNum(o.spriteScaleY);

        if (!hasAxisScale && isFiniteNum(o.spriteScale)) {
          sx *= Number(o.spriteScale);
          sy *= Number(o.spriteScale);
        }

        if (hasAxisScale) {
          if (isFiniteNum(o.spriteScaleX)) sx *= Number(o.spriteScaleX);
          if (isFiniteNum(o.spriteScaleY)) sy *= Number(o.spriteScaleY);
          const ok = drawSpriteImage(img, {
            x: c.x,
            y: c.y,
            w: w * sx,
            h: h * sy,
            fit: 'stretch',
            rotRad: def.rotate === 'deg' ? rot : 0,
          });
          if (ok) return;
        } else {
          const ok = drawSpriteImage(img, {
            x: c.x,
            y: c.y,
            w: w * sx,
            h: h * sy,
            fit: 'contain',
            rotRad: def.rotate === 'deg' ? rot : 0,
          });
          if (ok) return;
        }
      }
    }

    ctx.save();
    ctx.translate(c.x, c.y);
    if (rot) ctx.rotate(rot);

    ctx.fillStyle = 'rgba(255,255,255,0.08)';
    ctx.strokeStyle = 'rgba(0,0,0,0.25)';
    ctx.lineWidth = 1;

    if (kind === 'stairs') {
      const rw = w * 2;
      const rh = h * 4;
      const topW = rw * 0.4;

      ctx.fillStyle = COLORS.stairsWood;
      ctx.beginPath();
      ctx.moveTo(-rw/2,  rh/2);
      ctx.lineTo( rw/2,  rh/2);
      ctx.lineTo( topW/2, -rh/2);
      ctx.lineTo(-topW/2, -rh/2);
      ctx.closePath();
      ctx.fill();

    } else if (kind === 'bath') {
      // Simple non-sprite fallback for bath.png (top-down oval tub)
      const rw = w * 2.05;
      const rh = h * 1.20;

      // Outer tub
      ctx.fillStyle = 'rgba(90, 58, 32, 0.85)';
      ctx.strokeStyle = 'rgba(0,0,0,0.28)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.ellipse(0, 0, rw / 2, rh / 2, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.stroke();

      // Inner basin (water)
      ctx.fillStyle = 'rgba(20, 28, 40, 0.55)';
      ctx.beginPath();
      ctx.ellipse(0, 0, (rw * 0.82) / 2, (rh * 0.70) / 2, 0, 0, Math.PI * 2);
      ctx.fill();

      // Water sheen
      ctx.fillStyle = 'rgba(210, 230, 255, 0.18)';
      ctx.beginPath();
      ctx.ellipse(0, -rh * 0.06, (rw * 0.30), (rh * 0.18), 0, 0, Math.PI * 2);
      ctx.fill();

    } else if (kind === 'chest') {
      const rw = w * 0.90, rh = h * 0.70;

      ctx.fillStyle = COLORS.chestWood;
      ctx.strokeStyle = 'rgba(0,0,0,0.22)';
      ctx.lineWidth = 1;

      roundRectPath(ctx, -rw/2, -rh/2, rw, rh, Math.min(10, rh/3));
      ctx.fill();
      ctx.stroke();

      ctx.strokeStyle = 'rgba(0,0,0,0.32)';
      ctx.lineWidth = 2;
      const slats = 4;
      for (let i = 1; i < slats; i++) {
        const x = -rw/2 + (rw * i)/slats;
        ctx.beginPath();
        ctx.moveTo(x, -rh/2);
        ctx.lineTo(x, rh/2);
        ctx.stroke();
      }

    } else if (kind === 'crate') {
      // 1-hex square crate
      const s = Math.min(w, h) * 0.82;
      ctx.fillStyle = COLORS.objectWood;
      ctx.strokeStyle = 'rgba(0,0,0,0.26)';
      ctx.lineWidth = 2;
      roundRectPath(ctx, -s/2, -s/2, s, s, Math.min(10, s/5));
      ctx.fill();
      ctx.stroke();

      // simple plank/X bracing
      ctx.strokeStyle = 'rgba(0,0,0,0.28)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(-s/2, -s/2);
      ctx.lineTo(s/2, s/2);
      ctx.moveTo(-s/2, s/2);
      ctx.lineTo(s/2, -s/2);
      ctx.stroke();

      ctx.globalAlpha = 0.75;
      ctx.beginPath();
      ctx.moveTo(-s/2, 0);
      ctx.lineTo(s/2, 0);
      ctx.moveTo(0, -s/2);
      ctx.lineTo(0, s/2);
      ctx.stroke();
      ctx.globalAlpha = 1;

    } else if (kind === 'keg' || kind === 'barrel') {
      // 1-hex circular prop; barrel gets a taller oval
      const isBarrel = (kind === 'barrel');
      const rx = Math.min(w, h) * 0.42;
      const ry = Math.min(w, h) * (isBarrel ? 0.52 : 0.42);

      // body
      ctx.fillStyle = COLORS.objectWood;
      ctx.strokeStyle = 'rgba(0,0,0,0.28)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.ellipse(0, 0, rx, ry, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.stroke();

      // hoops/bands
      ctx.strokeStyle = 'rgba(0,0,0,0.34)';
      ctx.lineWidth = 3;
      const bands = isBarrel ? [-0.55, 0, 0.55] : [-0.30, 0.30];
      for (const t of bands) {
        ctx.beginPath();
        ctx.ellipse(0, ry * t, rx * 0.98, ry * 0.18, 0, 0, Math.PI * 2);
        ctx.stroke();
      }

      // staves
      ctx.strokeStyle = 'rgba(0,0,0,0.18)';
      ctx.lineWidth = 1;
      const staves = isBarrel ? 7 : 6;
      for (let i = 0; i < staves; i++) {
        const x = -rx + (2 * rx) * (i / (staves - 1));
        ctx.beginPath();
        ctx.moveTo(x, -ry * 0.85);
        ctx.lineTo(x, ry * 0.85);
        ctx.stroke();
      }

    } else if (kind === 'hearth' || kind === 'cooking.hearth') {
      const rw = w * 1.15;
      const rh = h * 0.55;
      ctx.fillStyle = COLORS.hearth;
      ctx.fillRect(-rw/2, -rh/2, rw, rh);

    } else if (kind === 'bed' || kind === 'bed.double') {
      const isDouble = (kind === 'bed.double');
      const BOOST = 2.0;
      const widthMul = isDouble ? 1.3 : 0.75;

      const rw = w * 0.70 * BOOST * widthMul;
      const rh = h * 0.95 * BOOST;

      ctx.fillStyle = COLORS.bedFabric;
      roundRectPath(ctx, -rw/2, -rh/2, rw, rh, Math.min(18, rw/3));
      ctx.fill();
      ctx.stroke();

      ctx.fillStyle = COLORS.bedPillow;
      const pad = Math.max(6, Math.min(14, Math.min(rw, rh) * 0.08));
      const pillowH = Math.max(10, rh * 0.22);
      const innerW = Math.max(0, rw - pad * 2);

      const pillowRadius = Math.min(14, pillowH * 0.5);
      const drawPillow = (x, y, pw) => {
        roundRectPath(ctx, x, y, pw, pillowH, pillowRadius);
        ctx.fill();
      };

      if (!isDouble) {
        drawPillow(-rw/2 + pad, -rh/2 + pad, innerW);
      } else {
        const gap = Math.max(6, Math.min(14, innerW * 0.06));
        const pw = Math.max(0, (innerW - gap) / 2);
        const x0 = -rw/2 + pad;
        const y0 = -rh/2 + pad;
        drawPillow(x0, y0, pw);
        drawPillow(x0 + pw + gap, y0, pw);
      }

    } else if (kind === 'table.round') {
      const r = Math.min(w, h) * 0.64;
      ctx.fillStyle = COLORS.objectWood;
      ctx.beginPath();
      ctx.arc(0, 0, r, 0, Math.PI * 2);
      ctx.fill();
      ctx.stroke();

    } else if (kind === 'table.sqr' || kind === 'table.square') {
      // Square side-table (used as a non-sprite fallback)
      const s = Math.min(w, h) * 0.75;
      ctx.fillStyle = COLORS.objectWood;
      roundRectPath(ctx, -s/2, -s/2, s, s, Math.min(10, s/5));
      ctx.fill();
      ctx.stroke();

    } else if (kind.startsWith('table')) {
      const rw = w * 0.90, rh = h * 0.55;
      ctx.fillStyle = COLORS.objectWood;
      roundRectPath(ctx, -rw/2, -rh/2, rw, rh, Math.min(10, rh/3));
      ctx.fill();
      ctx.stroke();

    } else if (kind === 'chair') {
      const rw = Math.min(w, h) * 0.65;
      const r = rw / 2;
      const rectH = rw * 0.55;
      const yShift = -(rectH - r) / 2;

      ctx.fillStyle = COLORS.objectWood;
      ctx.beginPath();
      ctx.moveTo(-rw / 2, yShift);
      ctx.arc(0, yShift, r, Math.PI, 0, false);
      ctx.lineTo(rw / 2, yShift + rectH);
      ctx.lineTo(-rw / 2, yShift + rectH);
      ctx.closePath();
      ctx.fill();

    } else {
      const rw = w * 0.80, rh = h * 0.55;
      roundRectPath(ctx, -rw/2, -rh/2, rw, rh, 10);
      ctx.fill();
      ctx.stroke();
    }



    ctx.restore();
  }

  // ===== Tokens =====
  function tokenVisible(t, roomMetaAll) {
    if (!RENDER_FOG || !RENDER_FOG.enabled) return true;
    if (isPlayerToken(t)) return true;

    const p = parseHex(t && t.hex);
    if (!p) return true;
    const w = hexCenterWorld(p.col, p.row);
    const rid = pickRoomAtWorldPoint(roomMetaAll, w);
    if (!rid) return true;

    return RENDER_FOG.visible.has(rid);
  }

  function drawTokenLabel(t, x, y, isPC) {
    const label = (t && t.label) ? String(t.label) : (t && t.name ? String(t.name).slice(0, 2) : '?');

    ctx.fillStyle = isPC ? COLORS.tokenTextDark : COLORS.tokenTextLight;
    ctx.font = 'bold 14px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(label, x, y);
  }

  function getTokenSpriteRequest(t, isPC) {
    if (!t || typeof t !== 'object') {
      return { kind: isPC ? 'token.pc' : 'token.npc', file: '', scale: 1 };
    }

    const kind = String(
      t.sprite ??
      t.spriteKind ??
      t.sprite_key ??
      t.spriteId ??
      t.sprite_id ??
      ''
    ).trim();

    const file = String(t.spriteFile ?? t.sprite_file ?? '').trim();

    let scale = 1;
    const s = Number(t.spriteScale ?? t.sprite_scale);
    if (Number.isFinite(s) && s > 0) scale *= s;

    return {
      kind: kind || (isPC ? 'token.pc' : 'token.npc'),
      file,
      scale,
    };
  }

  function drawToken(t, roomMetaAll) {
    if (!t || !t.hex) return;
    if (!tokenVisible(t, roomMetaAll)) return;

    const p = parseHexId(t.hex);
    const c = worldToScreen(hexCenterWorld(p.col, p.row));

    const r = GRID.size * 0.40;
    const isPC = isPlayerToken(t);

    if (elSpriteToggle && elSpriteToggle.checked) {
      const req = getTokenSpriteRequest(t, isPC);

      // Prefer explicit spriteFile, else sprite kind, else the default pc/npc tokens.
      let file = String(req.file || '').trim();
      if (!file) {
        const defK = getSpriteDef(req.kind);
        const defD = getSpriteDef(isPC ? 'token.pc' : 'token.npc');
        file = defK ? defK.file : (defD ? defD.file : '');
      }

      if (file) {
        const img = loadSprite(file);
        const s = (Number.isFinite(Number(req.scale)) && Number(req.scale) > 0) ? Number(req.scale) : 1;
        const ok = drawSpriteImage(img, {
          x: c.x,
          y: c.y,
          w: r * 2.2 * s,
          h: r * 2.2 * s,
          fit: 'contain',
          rotRad: 0,
        });
        if (ok) {
          drawTokenLabel(t, c.x, c.y, isPC);
          return;
        }
      }
    }

    ctx.save();
    ctx.fillStyle = isPC ? COLORS.tokenHero : COLORS.tokenEnemy;
    ctx.beginPath();
    ctx.arc(c.x, c.y, r, 0, Math.PI * 2);
    ctx.fill();

    ctx.strokeStyle = 'rgba(255,255,255,0.15)';
    ctx.lineWidth = 2;
    ctx.stroke();

    drawTokenLabel(t, c.x, c.y, isPC);

    ctx.restore();
  }

  // ===== Grid =====
  function drawHexOutline(center, size) {
    const pts = [];
    for (let i = 0; i < 6; i++) {
      const a = (Math.PI / 180) * (60 * i);
      pts.push({ x: center.x + size * Math.cos(a), y: center.y + size * Math.sin(a) });
    }

    ctx.beginPath();
    ctx.moveTo(pts[0].x, pts[0].y);
    for (let i = 1; i < pts.length; i++) ctx.lineTo(pts[i].x, pts[i].y);
    ctx.closePath();
    ctx.stroke();
  }

  function drawGrid() {
    const rect = canvas.getBoundingClientRect();
    const w = Math.max(1, rect.width);
    const h = Math.max(1, rect.height);

    const colsR = Math.ceil((w / 2) / colStep()) + 4;
    const rowsR = Math.ceil((h / 2) / rowStep()) + 4;

    const c0 = VIEW.camera.col;
    const r0 = VIEW.camera.row;

    ctx.save();
    ctx.strokeStyle = `rgba(255,255,255,${GRID.lineAlpha})`;
    ctx.lineWidth = GRID.lineWidth;

    for (let dc = -colsR; dc <= colsR; dc++) {
      for (let dr = -rowsR; dr <= rowsR; dr++) {
        const col = c0 + dc;
        const row = r0 + dr;
        const p = worldToScreen(hexCenterWorld(col, row));

        if (p.x < -100 || p.x > w + 100 || p.y < -100 || p.y > h + 100) continue;
        drawHexOutline(p, GRID.size);
      }
    }

    const bright = !!(elLabelBoldToggle && elLabelBoldToggle.checked);
    ctx.globalAlpha = bright ? 1 : GRID.labelAlpha;
    ctx.fillStyle = bright ? 'rgba(233,238,247,0.96)' : 'rgba(233,238,247,0.65)';
    ctx.font = bright
      ? '900 14px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial'
      : GRID.labelFont;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';

    if (bright) {
      ctx.lineWidth = 4;
      ctx.strokeStyle = 'rgba(0,0,0,0.70)';
      ctx.lineJoin = 'round';
    }

    for (let dc = -colsR; dc <= colsR; dc++) {
      for (let dr = -rowsR; dr <= rowsR; dr++) {
        const col = c0 + dc;
        const row = r0 + dr;
        const p = worldToScreen(hexCenterWorld(col, row));
        if (p.x < -100 || p.x > w + 100 || p.y < -100 || p.y > h + 100) continue;

        const label = hexId(col, row);
        const lx = p.x;
        const ly = p.y + 2;

        if (bright) ctx.strokeText(label, lx, ly);
        ctx.fillText(label, lx, ly);
      }
    }

    ctx.restore();
  }

  // ===== UI rendering =====
  function escapeHtml(s) {
    return String(s)
      .replaceAll('&', '&amp;')
      .replaceAll('<', '&lt;')
      .replaceAll('>', '&gt;')
      .replaceAll('"', '&quot;')
      .replaceAll("'", '&#39;');
  }

  function updateSidebar(state, floor, rooms, openings, objects, tokens) {
    const kvs = els.kvs;
    const turns = els.turns;
    if (!kvs || !turns) return;

    const meta = state && state.meta ? state.meta : {};
    const round = Number(meta.round != null ? meta.round : 1);

    const camHex = (state && state.view && state.view.camera_hex)
      ? String(state.view.camera_hex)
      : hexId(VIEW.camera.col, VIEW.camera.row);

    const fog = normalizeFog(state, VIEW.floorId);
    const fogLabel = fog.enabled
      ? ('ON (' + fog.visibleRoomIds.length + ' vis / ' + fog.exploredRoomIds.length + ' exp)')
      : 'off';

    const lines = [
      ['Version', VERSION],
      ['Battle', meta.battleId != null ? String(meta.battleId) : ''],
      ['Floor', floor && floor.name ? String(floor.name) : String(VIEW.floorId || '')],
      ['Round', String(round)],
      ['Camera', camHex],
      ['Zoom', Math.round(ZOOM * 100) + '%'],
      ['Rooms', String(rooms.length)],
      ['Openings', String(openings.length)],
      ['Objects', String(objects.length)],
      ['Tokens', String(tokens.length)],
      ['Fog', fogLabel],
      ['Fog maxDepth', String(fog.maxDepth)],
    ];

    kvs.innerHTML = lines
      .map(([k, v]) => '<div>' + escapeHtml(k) + '</div><div style="color:var(--text); text-align:right;">' + escapeHtml(v) + '</div>')
      .join('');

    const sorted = [...tokens]
      .filter(t => t && t.id)
      .sort((a, b) => (Number(b.init) || 0) - (Number(a.init) || 0));

    const activeId = (state && state.turn && state.turn.activeTokenId) ? String(state.turn.activeTokenId) : '';

    turns.innerHTML = sorted.map(t => {
      const isActive = activeId && String(t.id) === activeId;
      const name = t.name ? String(t.name) : String(t.id);
      const right = (t.hp != null) ? ('HP ' + t.hp) : '';
      return '<div class="turnRow' + (isActive ? ' active' : '') + '">' + '<div>' + escapeHtml(name) + ' <span style="opacity:0.65">(' + escapeHtml(String(t.init ?? '')) + ')</span></div>'
        + '<div style="opacity:0.85">' + escapeHtml(right) + '</div>'
        + '</div>';
    }).join('');
  }

 function populateSceneSelect(state) {
  if (!elSceneSelect) return;

  const w = (WORLD_STATE && WORLD_STATE.records && WORLD_STATE.active) ? WORLD_STATE : null;

  // Legacy mode (no world wrapper): show a single disabled option.
  if (!w) {
    const title = (state && state.meta && state.meta.title) ? String(state.meta.title) : 'Scene';
    elSceneSelect.innerHTML = '<option value="Scene">' + escapeHtml(title) + '</option>';
    elSceneSelect.value = 'Scene';
    elSceneSelect.disabled = true;
    return;
  }

  const recordIds = Object.keys(w.records || {}).sort();
  const activeRid = String((w.active && w.active.recordId) ? w.active.recordId : '');

  // Build options once per render (cheap) — but avoid stomping the dropdown while it's focused.
  if (document.activeElement !== elSceneSelect) {
    elSceneSelect.innerHTML = recordIds.map(rid => {
      const rec = w.records[rid];
      const label = (rec && rec.meta && rec.meta.title) ? String(rec.meta.title) : rid;
      return '<option value="' + escapeHtml(rid) + '">' + escapeHtml(label) + '</option>';
    }).join('');

    if (recordIds.includes(activeRid)) elSceneSelect.value = activeRid;
    else if (recordIds.length) elSceneSelect.value = recordIds[0];
  }

  elSceneSelect.disabled = recordIds.length <= 1;
}

function populateFloorSelect(floors) {
  if (!elFloorSelect) return;

  const list = Array.isArray(floors) ? floors : [];
  const current = String(VIEW.floorId || '');

  // Build options
  elFloorSelect.innerHTML = list.map(f => {
    const id = String((f && f.id) != null ? f.id : '');
    const name = (f && f.name) ? String(f.name) : id;
    return '<option value="' + escapeHtml(id) + '">' + escapeHtml(name) + '</option>';
  }).join('');

  // Pick selected value: current (if present in list) else first item's id else ''
  const hasCurrent = current && list.some(f => String((f && f.id) != null ? f.id : '') === current);
  const fallback = list.length ? String((list[0] && list[0].id) != null ? list[0].id : '') : '';

  elFloorSelect.value = hasCurrent ? current : fallback;
}

  

  function populateCenterOn(state, tokensOnThisFloor) {
    if (!elCenterOn) return;

    const tokens = Array.isArray(tokensOnThisFloor) ? tokensOnThisFloor : tokensOnFloor(state, VIEW.floorId);
    const pcs = tokens.filter(isPlayerToken);
    const wanted = VIEW.followTokenId || '';

    const opts = ['<option value="">None</option>'];
    for (const t of pcs) {
      const label = t.name ? t.name : t.id;
      opts.push('<option value="' + escapeHtml(t.id) + '">' + escapeHtml(label) + '</option>');
    }

    elCenterOn.innerHTML = opts.join('');
    elCenterOn.value = pcs.some(t => t.id === wanted) ? wanted : '';
    if (elCenterOn.value === '') VIEW.followTokenId = null;
  }

  function buildRenderState(state) {
    const floors = getFloorsFromState(state);
    const activeFloorId = VIEW.floorId || pickActiveFloorId(state, floors);
    const floor = floorById(floors, activeFloorId) || floors[0];
    const floorId = floor ? String(floor.id) : String(activeFloorId || '');

    const tokensAll = getTokensArray(state);
    const rooms = Array.isArray(floor && floor.rooms) ? floor.rooms : [];
    const openings = Array.isArray(floor && floor.openings) ? floor.openings : [];
    const objects = Array.isArray(floor && floor.objects) ? floor.objects : [];
    const tokens = tokensAll.filter(t => {
      const fid = entityFloorId(t);
      return fid ? fid === floorId : true;
    });

    return { floors, floor, floorId, rooms, openings, objects, tokensAll, tokens };
  }

  // ===== Main render =====
  function clear() {
    // Use backing-store derived CSS size so we always cover the full drawable area.
    // This prevents 1px edge seams that can appear on the right/bottom when the
    // layout produces fractional CSS pixels.
    const d = Number(VIEW && VIEW.dpr) || 1;
    const w = Math.max(1, canvas.width / d);
    const h = Math.max(1, canvas.height / d);
    ctx.fillStyle = COLORS.bg;
    ctx.fillRect(0, 0, w, h);
  }

  function renderScene(roomsAll, roomsToDraw, openingsToDraw, objects, tokens, roomMetaAll, fogEnabled) {
    clear();

    drawFloorsLayered(roomsToDraw);

    const roomsForWalls = (RENDER_FOG && RENDER_FOG.enabled)
      ? roomsToDraw.filter(r => (isFogFloorRoom(r) ? roomHasWalls(r) : true))
      : roomsToDraw;

    const wallSegsRaw = buildWallSegments(roomsForWalls);
    const wallSegs = dedupeWallSegments(wallSegsRaw);

    // Floor-aware knockout fills for doors/thresholds (so wall openings match the underlying texture)
    drawOpeningSeamFills(openingsToDraw, roomsAll, roomMetaAll, wallSegs, fogEnabled);

    wallCtx.save();
    wallCtx.setTransform(1, 0, 0, 1, 0, 0);
    wallCtx.clearRect(0, 0, wallCanvas.width, wallCanvas.height);
    wallCtx.restore();

    wallCtx.setTransform(VIEW.dpr, 0, 0, VIEW.dpr, 0, 0);

    drawWallSegments(wallCtx, wallSegs);

    wallCtx.save();
    wallCtx.globalCompositeOperation = 'destination-out';
    wallCtx.fillStyle = '#000';

    for (const o of openingsToDraw) {
      const k = String(o && o.kind ? o.kind : 'door').toLowerCase();
      wallCtx.globalAlpha = (k === 'window') ? 0.25 : 1;
      cutOpeningHole(wallCtx, o, wallSegs, roomsAll);
    }

    wallCtx.restore();

    ctx.save();
    ctx.setTransform(1, 0, 0, 1, 0, 0);
    ctx.drawImage(wallCanvas, 0, 0);
    ctx.restore();

    ctx.setTransform(VIEW.dpr, 0, 0, VIEW.dpr, 0, 0);

    for (const o of openingsToDraw) drawOpeningMarker(o, wallSegs);

    for (const o of objects) drawObject(o, roomMetaAll);

    drawRememberedRoomOverlays(roomsAll);

    for (const t of tokens) drawToken(t, roomMetaAll);

    drawGrid();
  }

  function updateUI(state, render, rooms, openings, objects, tokens) {
    populateFloorSelect(render.floors);
    populateCenterOn(state, tokens);
    updateSidebar(state, render.floor, rooms, openings, objects, tokens);
  }

  function redraw() {
    const state = getState();

    if (!canvas.width || !canvas.height || !wallCanvas.width || !wallCanvas.height) return;

    const render = buildRenderState(state);
    VIEW.floorId = render.floorId;

    populateSceneSelect(state);

    if (VIEW.followTokenId) {
      const t = render.tokensAll.find(x => x && x.id === VIEW.followTokenId);
      if (t && t.hex) {
        const fid = entityFloorId(t) || VIEW.floorId;
        if (fid && fid !== VIEW.floorId) {
          setActiveFloor(fid, { fromFollow: true });
          return;
        }

        const p = parseHexId(t.hex);
        VIEW.camera.col = p.col;
        VIEW.camera.row = p.row;
      } else {
        VIEW.followTokenId = null;
        if (elCenterOn) elCenterOn.value = '';
      }
    }

    const rooms = render.rooms;
    const openings = render.openings;
    const objects = render.objects;
    const tokens = render.tokens;

    const roomMetaAll = buildRoomMeta(rooms);

    const fogEnabled = !!elFogToggle.checked;
    const spritesEnabled = !!(elSpriteToggle && elSpriteToggle.checked);
    const labelsEnabled = !!(elLabelBoldToggle && elLabelBoldToggle.checked);
    if (state.fog && typeof state.fog === 'object') state.fog.enabled = fogEnabled;

    const renderSig = renderSignatureFor(state, {
      fogEnabled,
      spritesEnabled,
      labelsEnabled,
    });
    const shouldRender = renderSig !== LAST_RENDER_SIGNATURE;

    let roomsToDraw = rooms;
    let openingsToDraw = openings;

    if (shouldRender) {
      RENDER_FOG = computeRenderFog(state, VIEW.floorId, rooms, openings, tokens);

      if (!fogEnabled) {
        roomsToDraw = rooms.filter(r => !isFogFloorRoom(r));
      }

      if (RENDER_FOG && RENDER_FOG.enabled) {
        const baseFogRoomIds = new Set();
        for (const r of rooms) {
          if (isFogFloorRoom(r) && r && r.id) baseFogRoomIds.add(String(r.id));
        }

        const renderableRoomIds = new Set([...RENDER_FOG.explored]);
        roomsToDraw = rooms.filter(r => {
          const id = r && r.id ? String(r.id) : '';
          if (!id) return true;
          if (baseFogRoomIds.has(id)) return true;
          return renderableRoomIds.has(id);
        });

        openingsToDraw = openings.filter(o => {
          const ids = openingRoomIds(o, roomMetaAll);
          if (ids.length === 2) return (renderableRoomIds.has(ids[0]) || renderableRoomIds.has(ids[1]));
          return true;
        });
      }

      renderScene(rooms, roomsToDraw, openingsToDraw, objects, tokens, roomMetaAll, fogEnabled);
      LAST_RENDER_SIGNATURE = renderSig;
    }
    updateUI(state, render, rooms, openings, objects, tokens);

    if (state.view && typeof state.view === 'object') state.view.camera_hex = hexId(VIEW.camera.col, VIEW.camera.row);
  }

  function safeRedraw() {
    try {
      if (elError) { elError.hidden = true; elError.textContent = ''; }
      redraw();
    } catch (e) {
      console.error('[Battlemat] redraw failed:', e);
      if (elError) {
        elError.hidden = false;
        elError.textContent = String(e && e.stack ? e.stack : e);
      }
    }
  }

  // ===== Controls =====
  function pan(dc, dr) {
    if (VIEW.followTokenId) {
      VIEW.followTokenId = null;
      if (elCenterOn) elCenterOn.value = '';
    }
    VIEW.camera.col += dc;
    VIEW.camera.row += dr;
    safeRedraw();
  }

  function setCameraToHex(hex, opts = {}) {
    const manual = (opts.manual !== false);
    const p = parseHexId(hex);
    VIEW.camera.col = p.col;
    VIEW.camera.row = p.row;

    if (manual) {
      VIEW.followTokenId = null;
      if (elCenterOn) elCenterOn.value = '';
    }

    safeRedraw();
  }

  function setActiveRecord(recordId) {
  const rid = String(recordId || '').trim();
  if (!rid) return;

  const w = ensureWorldWrapper();
  if (!w || !w.records || !w.records[rid]) return;

  const rec = w.records[rid];
  const floors = Array.isArray(rec && rec.floors) ? rec.floors : [];
  const defaultFloorId = (rec && rec.view && rec.view.floorId) ? String(rec.view.floorId) : (floors[0] ? String(floors[0].id) : null);
  const defaultCameraHex = (rec && rec.view && rec.view.camera_hex) ? String(rec.view.camera_hex) : null;

  if (!w.active || typeof w.active !== 'object') w.active = { recordId: rid };
  w.active.recordId = rid;
  if (defaultFloorId) w.active.floorId = defaultFloorId;
  if (defaultCameraHex) w.active.camera_hex = defaultCameraHex;

  // Manual scene switch stops following a token.
  VIEW.followTokenId = null;
  if (elCenterOn) elCenterOn.value = '';

  refreshFromWorld();
  safeRedraw();
}

function setActiveFloor(floorId, opts = {}) {
    const state = getState();
    const floors = getFloorsFromState(state);

    const target = String(floorId || '');
    const f = floorById(floors, target);
    if (!f) return;

    // Preserve the current camera unless explicitly told to re-center.
    const prevCam = { col: VIEW.camera.col, row: VIEW.camera.row };

    // If the user manually switched floors, stop following a token.
    if (!opts.fromFollow) {
      VIEW.followTokenId = null;
      if (elCenterOn) elCenterOn.value = '';
    }

    VIEW.floorId = target;

    if (state.view && typeof state.view === 'object') state.view.floorId = target;

    const keepCamera = !!opts.keepCamera;

    // Old behavior: when not keeping camera (and not switching due to follow), snap to a PC on that floor.
    if (!opts.fromFollow && !keepCamera) {
      const pcs = tokensOnFloor(state, target).filter(isPlayerToken);
      if (pcs.length && pcs[0].hex) {
        try {
          const p = parseHexId(pcs[0].hex);
          VIEW.camera.col = p.col;
          VIEW.camera.row = p.row;
        } catch {}
      }
    } else {
      // Default requested behavior: keep the same map spot centered.
      VIEW.camera.col = prevCam.col;
      VIEW.camera.row = prevCam.row;
    }

    safeRedraw();
  }

  function wireUI() {
    const req = (id) => {
      const el = els[id];
      if (!el) console.warn('[Battlemat] missing control #' + id);
      return el;
    };

    const btnLeft = req('btnLeft');
    const btnRight = req('btnRight');
    const btnUp = req('btnUp');
    const btnDown = req('btnDown');
    const btnZoomOut = req('btnZoomOut');
    const btnZoomIn = req('btnZoomIn');
    const btnRedraw = req('btnRedraw');
    const btnJump = req('btnJump');

    if (btnLeft) btnLeft.onclick = () => pan(-PAN_STEP, 0);
    if (btnRight) btnRight.onclick = () => pan(PAN_STEP, 0);
    if (btnUp) btnUp.onclick = () => pan(0, PAN_STEP);
    if (btnDown) btnDown.onclick = () => pan(0, -PAN_STEP);

    const ZOOM_STEP = 0.10;
    if (btnZoomOut) btnZoomOut.onclick = () => setZoom(ZOOM - ZOOM_STEP);
    if (btnZoomIn) btnZoomIn.onclick = () => setZoom(ZOOM + ZOOM_STEP);

    if (btnRedraw) btnRedraw.onclick = () => safeRedraw();

    if (btnJump) btnJump.onclick = () => {
      const v = String(elJumpHex.value || '').trim();
      if (!v) return;
      try { setCameraToHex(v, { manual: true }); }
      catch (e) { console.warn('[Battlemat] Bad jump hex:', v, e); }
    };

    if (elFogToggle) elFogToggle.onchange = () => safeRedraw();
    if (elSpriteToggle) elSpriteToggle.onchange = () => safeRedraw();
    if (elLabelBoldToggle) elLabelBoldToggle.onchange = () => safeRedraw();

    if (elSceneSelect) {
      elSceneSelect.onchange = () => setActiveRecord(elSceneSelect.value);
    }

    if (elFloorSelect) {
      elFloorSelect.onchange = () => setActiveFloor(elFloorSelect.value, { fromFollow: false, keepCamera: true });
    }

    if (elCenterOn) {
      elCenterOn.onchange = () => {
        const id = String(elCenterOn.value || '');
        VIEW.followTokenId = id || null;
        safeRedraw();
      };
    }

    if (elSsSelect) {
      elSsSelect.onchange = () => setSupersample(elSsSelect.value);
    }

    window.onkeydown = (ev) => {
      if (ev.target && (ev.target.tagName === 'INPUT' || ev.target.tagName === 'SELECT' || ev.target.isContentEditable)) return;
      const k = ev.key;
      if (k === 'ArrowLeft' || k === 'a' || k === 'A') pan(-PAN_STEP, 0);
      else if (k === 'ArrowRight' || k === 'd' || k === 'D') pan(PAN_STEP, 0);
      else if (k === 'ArrowUp' || k === 'w' || k === 'W') pan(0, PAN_STEP);
      else if (k === 'ArrowDown' || k === 's' || k === 'S') pan(0, -PAN_STEP);
      else if (k === 'r' || k === 'R') safeRedraw();
      else if (k === '+' || k === '=' ) setZoom(ZOOM + 0.10);
      else if (k === '-' || k === '_' ) setZoom(ZOOM - 0.10);
    };
  }

  // ===== Resize =====
  function resize() {
    SUPERSAMPLE = readSupersample();
    ZOOM = readZoom();
    applyZoom();
    syncZoomUI();

    const wrap = els.canvasWrap;

    // Prefer integer CSS sizes (clientWidth/Height) to avoid fractional px gaps that
    // can show up as a 1px line along the right/bottom edge.
    let cssW = Math.max(1, wrap ? wrap.clientWidth : 1);
    let cssH = Math.max(1, wrap ? wrap.clientHeight : 1);

    // Fallback: if layout is mid-transition and client sizes are 0, use a rounded rect.
    if (wrap && (cssW <= 1 || cssH <= 1)) {
      const rect = wrap.getBoundingClientRect();
      cssW = Math.max(1, Math.round(rect.width));
      cssH = Math.max(1, Math.round(rect.height));
    }

    const dpr = Math.max(1, window.devicePixelRatio || 1);
    const scale = dpr * SUPERSAMPLE;

    VIEW.dpr = scale;
    VIEW.anchor.x = cssW / 2;
    VIEW.anchor.y = cssH / 2;

    if (elDpr) elDpr.textContent = dpr.toFixed(2);
    if (elSs) elSs.textContent = String(SUPERSAMPLE);

    canvas.width = Math.max(1, Math.floor(cssW * scale));
    canvas.height = Math.max(1, Math.floor(cssH * scale));

    wallCanvas.width = canvas.width;
    wallCanvas.height = canvas.height;

    ctx.setTransform(scale, 0, 0, scale, 0, 0);
    wallCtx.setTransform(scale, 0, 0, scale, 0, 0);

    ctx.imageSmoothingEnabled = true;
    try { ctx.imageSmoothingQuality = 'high'; } catch {}

    // Force a full render after any resize since the backing store changed.
    LAST_RENDER_SIGNATURE = '';
    safeRedraw();
  }

  // ===== Self-tests (tiny sanity checks) =====
  function runSelfTests() {
    const assert = (name, cond) => {
      if (!cond) throw new Error('SelfTest failed: ' + name);
    };

    // quarter-step openings (still supports .5)
    const oh = parseOpeningHexId('M12.5');
    assert('parseOpeningHexId col', oh.col === lettersToCol('M'));
    assert('parseOpeningHexId row (.5)', Math.abs(oh.row - 11.5) < 1e-9);

    const oq = parseOpeningHexId('M12.25');
    assert('parseOpeningHexId row (.25)', Math.abs(oq.row - 11.25) < 1e-9);

    // integer hex
    const hh = parseHexId('U16');
    assert('parseHexId row', hh.row === 15);

    // corner decimals
    const ch = parseCornerHexId('M21.5');
    assert('parseCornerHexId half row', Math.abs(ch.row - 20.5) < 1e-9);

    // texture alias
    const td = resolveTextureDef('floor', 'wood');
    assert('resolveTextureDef alias', !!td && td.file === 'wood_oak.png');

    // threshold auto-span sizing
    const testRooms = [{
      id: 'TestRoom',
      corners: ['A6', 'D6', 'D3', 'A3'],
      thickness: 20,
      floor: { kind: 'wood' },
      wall: { kind: 'brick' },
    }];
    const testRoom = testRooms[0];
    const box = roomToWallBox(testRoom);
    const fr = roomFloorRectWorld(testRoom, box);

    const thH = { kind: 'threshold', hex: 'B5', orientation: 'h', parent: 'TestRoom' };
    const thV = { kind: 'threshold', hex: 'D4', orientation: 'v', parent: 'TestRoom' };
    assert('openingLengthWorld threshold-h uses parent span', Math.abs(openingLengthWorld(thH, testRooms) - Math.abs(fr.x2 - fr.x1)) < 1e-6);
    assert('openingLengthWorld threshold-v uses parent span', Math.abs(openingLengthWorld(thV, testRooms) - Math.abs(fr.y2 - fr.y1)) < 1e-6);

    const noParent = { kind: 'threshold', hex: 'B5', orientation: 'h', span: 2 };
    assert('openingLengthWorld threshold fallback to span', Math.abs(openingLengthWorld(noParent, testRooms) - (GRID.size * 1.2 * 2)) < 1e-6);

    // opening padding (axis-specific)
    const pV = openingPadAxes({ kind: 'threshold', orientation: 'v' });
    const pH = openingPadAxes({ kind: 'threshold', orientation: 'h' });
    assert('openingPadAxes threshold v pads X only', pV.x === 4 && pV.y === 0);
    assert('openingPadAxes threshold h pads Y only', pH.x === 0 && pH.y === 4);
    const pD = openingPadAxes({ kind: 'door', orientation: 'v' });
    assert('openingPadAxes door pads both axes', pD.x === 4 && pD.y === 4);

    // door kind detection
    assert('isDoorKind door', isDoorKind('door') === true);
    assert('isDoorKind door_wood', isDoorKind('door_wood') === true);
    assert('isDoorKind door.wood', isDoorKind('door.wood') === true);
    assert('isDoorKind door.steel (prefix)', isDoorKind('door.steel') === true);
    assert('isDoorKind window false', isDoorKind('window') === false);

    // door sprite swing direction should match the line-based door math for both hinge sides.
    // Non-sprite math uses: y2 = swingSign * sin(ang) (independent of hinge side), while x flips for hingeRight.
    // For sprite math, we rotate about hinge. Base leaf direction is +X for hinge-left, -X for hinge-right.
    // Using rotAng = (hingeRight ? -1 : 1) * swingSign * ang preserves y2 sign across hinge sides.
    {
      const ang = 0.75; // arbitrary radians
      for (const hingeRight of [false, true]) {
        for (const swingSign of [-1, 1]) {
          const baseX = hingeRight ? -1 : 1;
          const rotAng = (hingeRight ? -1 : 1) * swingSign * ang;
          const ySprite = baseX * Math.sin(rotAng);
          const yLine = swingSign * Math.sin(ang);
          assert('door sprite swing matches line (hingeRight=' + hingeRight + ', swing=' + swingSign + ')', Math.abs(ySprite - yLine) < 1e-12);
        }
      }
    }

    // door sprite scaling (openings)
    const doorDef = getSpriteDef('door.wood');
    const sOpen = { kind: 'door.wood', spriteScale: 1.5, spriteScaleX: 2, spriteScaleY: 0.5 };
    let sx = 1, sy = 1;
    if (doorDef) {
      if (isFiniteNum(doorDef.scale)) { sx *= Number(doorDef.scale); sy *= Number(doorDef.scale); }
      if (isFiniteNum(doorDef.scaleX)) sx *= Number(doorDef.scaleX);
      if (isFiniteNum(doorDef.scaleY)) sy *= Number(doorDef.scaleY);
    }
    if (isFiniteNum(sOpen.spriteScale)) { sx *= Number(sOpen.spriteScale); sy *= Number(sOpen.spriteScale); }
    if (isFiniteNum(sOpen.spriteScaleX)) sx *= Number(sOpen.spriteScaleX);
    if (isFiniteNum(sOpen.spriteScaleY)) sy *= Number(sOpen.spriteScaleY);
    assert('door opening spriteScale combines', Math.abs(sx - (1.5 * 2)) < 1e-12 && Math.abs(sy - (1.5 * 0.5)) < 1e-12);

    // query parsing
    const qp = getQueryParams('?stateUrl=%2Fdata%2Fbattle.json&pollMs=1500');
    assert('getQueryParams stateUrl', qp.get('stateUrl') === '/data/battle.json');
    assert('getQueryParams pollMs', qp.get('pollMs') === '1500');

    // clamp zoom
    assert('clamp zoom low', clamp(0.1, 0.6, 2.25) === 0.6);
    assert('clamp zoom high', clamp(9, 0.6, 2.25) === 2.25);

    // zoom math
    const base = GRID.baseSize;
    const prev = ZOOM;
    ZOOM = 1.35;
    applyZoom();
    assert('applyZoom sets GRID.size', Math.abs(GRID.size - base * 1.35) < 1e-9);
    ZOOM = prev;
    applyZoom();

    // wall thickness scales with zoom
    const prevZ = ZOOM;
    ZOOM = 2;
    const wtRoom = { id: 'WallTest', corners: ['A6','D6','D3','A3'], thickness: 20, floor: { kind: 'wood' }, wall: { kind: 'brick' } };
    const wtBox = roomToWallBox(wtRoom);
    assert('roomToWallBox thickness scales with ZOOM', Math.abs(wtBox.thickness - 40) < 1e-9);
    ZOOM = prevZ;
    applyZoom();

    // snap to device pixels (prevents 1px seams at high zoom)
    const prevDpr = VIEW.dpr;
    VIEW.dpr = 2;
    assert('snapCss rounds to 1/dpr grid', Math.abs(snapCss(1.25) - 1.5) < 1e-12);
    const rr = snappedRectFromCenter({ x: 10.25, y: 9.75 }, 5.1, 3.1);
    // edges should land on 0.5 increments when dpr=2
    assert('snappedRectFromCenter x aligned', Math.abs((rr.x * 2) - Math.round(rr.x * 2)) < 1e-12);
    assert('snappedRectFromCenter y aligned', Math.abs((rr.y * 2) - Math.round(rr.y * 2)) < 1e-12);
    VIEW.dpr = prevDpr;

    // sqrt3 / rowStep math
    assert('sqrt3 constant', Math.abs(sqrt3 - Math.sqrt(3)) < 1e-12);
    const rs = rowStep();
    assert('rowStep uses sqrt3', Math.abs(rs - Math.sqrt(3) * GRID.size) < 1e-9);
  }

  // ===== Boot =====
  function init() {
    const state = getState();
    const floors = getFloorsFromState(state);
    VIEW.floorId = pickActiveFloorId(state, floors);

    // Persisted zoom + SS
    SUPERSAMPLE = readSupersample();
    ZOOM = readZoom();
    applyZoom();
    syncZoomUI();

    const camHex = state && state.view && state.view.camera_hex ? String(state.view.camera_hex) : null;
    if (camHex) {
      try {
        const p = parseHexId(camHex);
        VIEW.camera.col = p.col;
        VIEW.camera.row = p.row;
      } catch {}
    } else {
      const pc = (getTokensArray(state)).find(isPlayerToken);
      if (pc && pc.hex) {
        try {
          const p = parseHexId(pc.hex);
          VIEW.camera.col = p.col;
          VIEW.camera.row = p.row;
        } catch {}
      }
    }

    if (state.fog && typeof state.fog === 'object') elFogToggle.checked = !!state.fog.enabled;
    elSsSelect.value = String(readSupersample());

    // Run sanity checks early so we fail loudly with a useful message.
    try { runSelfTests(); }
    catch (e) {
      if (elError) {
        elError.hidden = false;
        elError.textContent = String(e && e.stack ? e.stack : e);
      }
      throw e;
    }

    wireUI();

    // Remote state (DB/API) hookup
    STATE_URL = resolveStateUrl();
    if (STATE_URL) startStatePolling();

    const ro = new ResizeObserver(() => resize());
    if (els.canvasWrap) ro.observe(els.canvasWrap);

    window.addEventListener('resize', resize, { passive: true });

    resize();
    requestAnimationFrame(() => {
      safeRedraw();
      requestAnimationFrame(safeRedraw);
    });
  }

  init();
  </script>
</body>
</html>
