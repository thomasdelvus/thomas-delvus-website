<!--
Battlemat
Version: set in JS (VERSION)
Changelog:
- 2026-01-28: foricing a push
- 2026-01-28: move chat bar under battlemat, widen sidebar, stretch log, move Send button left
- 2026-01-28: status turn triangle + hostility name colors; DM chat color neutral
- 2026-01-28: campaign_id resolver + active_battle_id lookup
- 2026-01-28: fix sprite base path for /play/c routes
- 2026-01-28: chat log uses campaign_id when available
- 2026-01-28: messages are campaign-scoped only (no battle_id)
- 2026-01-28: add POI selector (battle list) for current campaign
- 2026-01-28: remove unused battle/campaign input handlers
- 2026-01-28: auto-follow active token POI via campaign meta_json party_locations
- 2026-01-29: campaign meta entities + global turn active follow
-->
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Battlemat Core</title>
  <link rel="icon" href="/favicon.svg" type="image/svg+xml" />
  <style>
    :root{
      --bg:#0f1115;
      --panel:#161a22;
      --panel2:#121621;
      --text:#e9eef7;
      --muted:#9aa6bb;
      --border:rgba(255,255,255,0.12);
      --border2:rgba(255,255,255,0.08);
      --good:#43d17a;
      --bad:#ff5a5a;
      --toolbox-w:64px;
      --sidebar-w:368px;
      --layout-gap:12px;
      --layout-pad:12px;
    }
    html,body{height:100%;margin:0;}
    body{
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;
      background:var(--bg);
      color:var(--text);
      display:grid;
      grid-template-rows:auto 1fr;
    }
    #topbar{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
      padding:10px 12px;
      background:var(--panel);
      border-bottom:1px solid var(--border2);
      flex-wrap:wrap;
    }
    #status{
      display:flex;
      align-items:center;
      gap:10px;
      min-height:26px;
      flex-wrap:wrap;
      flex:1 1 auto;
      min-width:0;
    }
    .pill{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding:4px 10px;
      border-radius:999px;
      background:rgba(255,255,255,0.08);
      border:1px solid var(--border);
      font-size:12px;
      color:var(--text);
      white-space:nowrap;
    }
    .dot{width:8px;height:8px;border-radius:50%;background:var(--good);box-shadow:0 0 0 2px rgba(67,209,122,0.15);}
    .mini{font-size:12px;color:var(--muted);display:inline-flex;align-items:center;gap:6px;white-space:nowrap;}
    .mini input[type="text"]{
      width:72px;
      padding:4px 8px;
      border-radius:8px;
      border:1px solid var(--border);
      background:rgba(0,0,0,0.25);
      color:var(--text);
      outline:none;
    }
    .mini input[type="number"]{
      width:72px;
      padding:4px 8px;
      border-radius:8px;
      border:1px solid var(--border);
      background:rgba(0,0,0,0.25);
      color:var(--text);
      outline:none;
    }
    select{
      padding:4px 8px;
      border-radius:8px;
      border:1px solid var(--border);
      background:rgba(0,0,0,0.25);
      color:var(--text);
      outline:none;
      font-size:12px;
    }
    button{
      padding:6px 10px;
      border-radius:10px;
      border:1px solid var(--border);
      background:rgba(255,255,255,0.08);
      color:var(--text);
      cursor:pointer;
      font-size:12px;
    }
    button:hover{background:rgba(255,255,255,0.12);}
    .sep{width:1px;height:18px;background:var(--border2);margin:0 2px;}

    #topbar{
      display:flex;
      flex-direction:column;
      gap:8px;
    }
    #topbarMain,
    #topbarDebug{
      display:flex;
      align-items:center;
      gap:8px;
      flex-wrap:wrap;
      justify-content:space-between;
    }
    #topbarMain{justify-content:flex-end;}
    #topbarDebug{justify-content:flex-start;}

    #layout{
      display:grid;
      grid-template-columns: var(--toolbox-w) 1fr var(--sidebar-w);
      gap:var(--layout-gap);
      padding:var(--layout-pad);
      min-height:0;
    }

    #toolbox{
      background:var(--panel2);
      border:1px solid var(--border);
      border-radius:12px;
      padding:8px;
      display:flex;
      flex-direction:column;
      gap:8px;
      min-height:0;
    }

    .toolBtn{
      width:100%;
      padding:8px 6px;
      border-radius:10px;
      border:1px solid var(--border);
      background:rgba(255,255,255,0.06);
      color:var(--text);
      cursor:pointer;
      font-size:11px;
    }
    .toolBtn:hover{background:rgba(255,255,255,0.12);}
    .toolBtn.active{background:rgba(67,209,122,0.18); border-color:rgba(67,209,122,0.35);}

    .toolSep{height:1px;background:var(--border2);margin:2px 0;}
    .toolStatus{font-size:11px;color:var(--muted);text-align:center;}
    .toolStatus.ok{color:var(--good);}
    .toolStatus.error{color:var(--bad);}

    .inlineFields{display:inline-flex;gap:6px;align-items:center;}
    #editorPanel{display:flex;flex-direction:column;gap:6px;margin-bottom:12px;}
    #editorPanel .mini{justify-content:space-between;}

    #canvasWrap{
      background:#0b0d12;
      border:1px solid var(--border);
      border-radius:12px;
      box-shadow:0 10px 30px rgba(0,0,0,0.35);
      overflow:hidden;
      min-height:0;
    }

    canvas{width:100%;height:100%;display:block;background:#0b0d12;}

    #sidebar{
      background:var(--panel2);
      border:1px solid var(--border);
      border-radius:12px;
      padding:12px;
      overflow:hidden;
      display:flex;
      flex-direction:column;
      min-height:0;
    }

    #sidebar h3{
      margin:0 0 8px 0;
      font-size:13px;
      color:var(--text);
      letter-spacing:0.02em;
    }

    #statusMeta{
      display:flex;
      flex-wrap:wrap;
      gap:6px;
      font-size:12px;
      color:var(--muted);
      margin-bottom:8px;
    }
    .statusPill{
      display:inline-flex;
      align-items:center;
      gap:6px;
      padding:4px 8px;
      border-radius:999px;
      background:rgba(255,255,255,0.06);
      border:1px solid var(--border);
      color:var(--text);
      font-size:11px;
      white-space:nowrap;
    }
    .statusWrap{
      border:1px solid var(--border);
      border-radius:10px;
      overflow:auto;
      max-height:320px;
      margin-bottom:8px;
    }
    #statusTable{
      width:100%;
      border-collapse:collapse;
      font-size:12px;
      color:var(--text);
    }
    #statusTable thead th{
      position:sticky;
      top:0;
      background:rgba(255,255,255,0.06);
      font-weight:600;
      text-align:left;
      padding:6px 8px;
      border-bottom:1px solid var(--border2);
      white-space:nowrap;
    }
    #statusTable thead th:first-child{padding-left:12px;}
    #statusTable tbody td{
      padding:6px 8px;
      border-bottom:1px solid rgba(255,255,255,0.06);
      vertical-align:middle;
      white-space:nowrap;
    }
    #statusTable thead th.statusNum,
    #statusTable tbody td.statusNum{
      text-align:center;
    }
    #statusTable tbody tr:last-child td{border-bottom:none;}
    .statusNameCell{display:flex;align-items:center;gap:6px;}
    .statusTurnMarker{
      width:0;
      height:0;
      border-top:6px solid transparent;
      border-bottom:6px solid transparent;
      border-left:10px solid rgba(120,220,140,0.9);
    }
    .statusTurnMarker.inactive{border-left-color:transparent;}
    .statusName{font-weight:600;}
    .status-friendly{color:#7fd3ff;}
    .status-neutral{color:var(--muted);}
    .status-hostile{color:rgba(255,140,110,0.95);}
    .statusRow.dead{opacity:0.55;}
    .statusRow.elsewhere{opacity:0.85;}
    .statusRow.elsewhere.mob .statusName{color:#f1c08a; opacity:1; text-shadow:0 0 0.01px currentColor;}
    .statusRow.active{background:rgba(67,209,122,0.10);}
    .statusRow.clickable{cursor:pointer;}
    .statusRow.clickable:hover{background:rgba(90,170,255,0.12);}
    .statusRow.clickable:focus-visible{outline:2px solid rgba(90,170,255,0.65); outline-offset:2px;}
    .statusNum{text-align:center;font-variant-numeric:tabular-nums;}
    .statusCond{display:flex;align-items:center;gap:2px;flex-wrap:wrap;}
    .condIcon{
      display:inline-flex;
      align-items:center;
      justify-content:center;
      width:18px;
      height:18px;
      font-size:12px;
      border-radius:4px;
      background:rgba(255,255,255,0.08);
      border:1px solid rgba(255,255,255,0.10);
    }
    #statusAction{
      font-size:11px;
      color:var(--muted);
      border:1px solid var(--border);
      border-radius:10px;
      padding:6px 8px;
      background:rgba(255,255,255,0.04);
      white-space:pre-wrap;
    }

    #chatLog{
      border:1px solid var(--border);
      border-radius:10px;
      padding:8px;
      background:rgba(255,255,255,0.03);
      flex:1;
      overflow:auto;
      font-size:12px;
      color:var(--text);
      display:flex;
      flex-direction:column;
      gap:6px;
      margin-bottom:10px;
    }
    .chatEntry{
      display:flex;
      gap:8px;
      align-items:flex-start;
      line-height:1.3;
      position:relative;
      padding-left:20px;
    }
    .chatEntry.ack{
      color:rgba(190,195,205,0.85);
    }
    .chatEntry.canceled{
      color:rgba(220,120,120,0.9);
      text-decoration:line-through;
    }
    .chatEntry.processed{
      color:rgba(170,210,170,0.9);
    }
    .chatFocusArrow{
      position:absolute;
      left:4px;
      top:4px;
      display:inline-flex;
      align-items:center;
      justify-content:center;
      width:0;
      height:0;
      border-top:6px solid transparent;
      border-bottom:6px solid transparent;
      border-left:10px solid rgba(120,220,140,0.9);
    }
    .chatSpeaker{
      font-weight:600;
      color:#7fd3ff;
      margin-right:4px;
      white-space:nowrap;
    }
    .chatSpeaker.dm{color:var(--muted);}
    .chatText{white-space:pre-wrap;}
    .chatDetails{
      display:inline;
    }
    .chatDetails summary{
      cursor:pointer;
      list-style:none;
      color:var(--text);
      display:inline;
    }
    .chatDetails summary::-webkit-details-marker{display:none;}
    .chatPreview{
      color:var(--text);
    }
    .chatMore{
      color:var(--muted);
      margin-left:6px;
      font-size:11px;
    }
    .chatLess{
      color:var(--muted);
      margin-left:6px;
      font-size:11px;
      display:none;
    }
    .chatDetails[open] .chatPreview{display:none;}
    .chatDetails[open] .chatMore{display:none;}
    .chatDetails[open] .chatLess{display:inline;}
    .chatFull{
      display:block;
      margin-top:4px;
      white-space:pre-wrap;
    }
    .chatUnreadBadge{
      display:inline-flex;
      align-items:center;
      justify-content:center;
      min-width:18px;
      height:18px;
      padding:0 6px;
      border-radius:999px;
      font-size:11px;
      background:rgba(127,211,255,0.15);
      color:#bfe9ff;
      border:1px solid rgba(127,211,255,0.35);
      margin-left:6px;
    }
    .actionTick{
      display:inline-flex;
      align-items:center;
      justify-content:center;
      width:18px;
      height:18px;
      border-radius:50%;
      border:1px solid rgba(120,200,120,0.6);
      color:#9fe2a6;
      font-size:12px;
      cursor:pointer;
      background:rgba(90,160,90,0.12);
    }
    .actionTick.canceled{
      border-color:rgba(210,120,120,0.6);
      color:#e6a0a0;
      background:rgba(160,80,80,0.12);
    }

    #chatBar{
      position:fixed;
      left:calc(var(--layout-pad) + var(--toolbox-w) + var(--layout-gap));
      right:calc(var(--layout-pad) + var(--sidebar-w) + var(--layout-gap));
      bottom:0;
      display:flex;
      gap:8px;
      align-items:center;
      padding:10px 12px;
      background:rgba(10,12,18,0.92);
      border-top:1px solid var(--border);
      z-index:20;
    }
    #chatBar select,
    #chatBar input{
      background:rgba(255,255,255,0.08);
      border:1px solid var(--border);
      color:var(--text);
      border-radius:10px;
      padding:8px 10px;
      font-size:12px;
    }
    #chatSpeaker{
      min-width:160px;
    }
    #chatInput{
      flex:1;
    }
    #chatSend{
      padding:8px 14px;
      border-radius:10px;
      border:1px solid var(--border);
      background:rgba(255,255,255,0.08);
      color:var(--text);
      font-size:12px;
      cursor:pointer;
    }

    body{padding-bottom:62px;}

    #errorBox{
      border:1px solid rgba(255,90,90,0.35);
      background:rgba(255,90,90,0.08);
      border-radius:12px;
      padding:10px;
      font-size:12px;
      color:var(--text);
      white-space:pre-wrap;
    }

    .dpad{
      display:inline-flex;
      gap:6px;
      align-items:center;
      margin-left:6px;
    }
    .dpad button{padding:6px 8px; border-radius:10px; min-width:34px;}

    body.playtest #toolbox{display:none;}
    body.playtest #stateDebug{display:none;}
    body.playtest #editorPanel{display:none;}
    body.playtest #editorTitle{display:none;}
    body.playtest #errorBox{display:none;}
    body.playtest #topbarDebug{display:none;}
    body.playtest{--toolbox-w:0px;}
    body.playtest #layout{grid-template-columns:1fr var(--sidebar-w);}
    body.playtest #chatBar{left:var(--layout-pad);}

    @media (max-width: 980px){
      #layout{grid-template-columns:1fr; grid-template-rows:auto 1fr auto;}
      #toolbox{flex-direction:row; flex-wrap:wrap; justify-content:space-between;}
      .toolBtn{width:auto; flex:1 1 auto;}
      #chatBar{left:0; right:0;}
    }
  </style>
</head>
<body>
  <div id="topbar">
    <div id="topbarMain">
      <label class="mini"><input type="checkbox" id="labelBoldToggle" /> Bright Labels</label>
      <label class="mini" title="Hide editor/debug UI"><input type="checkbox" id="playtestToggle" /> Playtest</label>

      <div class="dpad" title="Pan camera">
        <button id="btnLeft">←</button>
        <button id="btnUp">↑</button>
        <button id="btnDown">↓</button>
        <button id="btnRight">→</button>
      </div>

      <div class="dpad" title="Zoom">
        <button id="btnZoomOut">−</button>
        <button id="btnZoomIn">+</button>
      </div>
      <div class="mini" title="Map zoom"><span id="zoomText">100%</span></div>
    </div>

    <div id="topbarDebug">
      <div class="pill" title="Battlemat version" id="versionPill"><span class="dot"></span><span id="versionText"></span></div>
      <div class="mini">Scene <select id="sceneSelect"></select></div>
      <div class="sep"></div>
      <div class="mini">Floor <select id="floorSelect"></select></div>
      <div class="sep"></div>
      <div class="mini">Source
        <select id="sourceSelect">
          <option value="database" selected>Database</option>
          <option value="file">File</option>
          <option value="embedded">Embedded</option>
        </select>
      </div>
      <div class="mini">POI
        <select id="poiSelect" title="Select POI (battle record)"></select>
      </div>
      <label class="mini"><input type="checkbox" id="fogToggle" checked /> Fog</label>
      <label class="mini"><input type="checkbox" id="spriteToggle" checked /> Sprites</label>
      <div class="mini">SS
        <select id="ssSelect" title="Supersample quality">
          <option value="1">1×</option>
          <option value="2">2×</option>
          <option value="3" selected>3×</option>
        </select>
      </div>
      <div class="mini">Center
        <select id="centerOn" title="Follow a PC token"></select>
      </div>
      <div class="mini">Jump
        <input id="jumpHex" type="text" value="U16" />
        <button id="btnJump">Go</button>
      </div>
      <button id="btnRedraw">Redraw</button>
      <div class="pill" title="DevicePixelRatio × Supersample">
        DPR <span id="dprText">?</span>
        &nbsp;·&nbsp; SS <span id="ssText">?</span>
      </div>
    </div>
  </div>

    <div id="layout">
      <div id="toolbox">
      <button class="toolBtn" id="toolSelect" data-tool="select">Select</button>
      <button class="toolBtn" id="toolRoom" data-tool="room">Room</button>
      <button class="toolBtn" id="toolDoor" data-tool="door">Door</button>
      <button class="toolBtn" id="toolWindow" data-tool="window">Window</button>
      <button class="toolBtn" id="toolObject" data-tool="object">Object</button>
      <button class="toolBtn" id="toolDelete" data-tool="delete">Delete</button>
      <div class="toolSep"></div>
      <button class="toolBtn" id="btnSaveDb" title="Save edits to database">Save</button>
      <button class="toolBtn" id="btnUndo" title="Undo last edit">Undo</button>
      <button class="toolBtn" id="btnScanIssues" title="Scan for orphaned or duplicate items">Scan</button>
      <button class="toolBtn" id="btnCleanOrphans" title="Remove orphan openings">Clean</button>
      <div class="toolStatus" id="toolStatus">DB: idle</div>
      </div>
      <div id="canvasWrap"><canvas id="canvas" aria-label="Battlemat canvas"></canvas></div>
      <div id="sidebar">
        <div id="stateDebug" class="mini" style="opacity:0.75;"></div>
        <h3>Status</h3>
        <div id="statusMeta"></div>
        <div class="statusWrap">
          <table id="statusTable">
            <thead>
              <tr>
                <th>Actor</th>
                <th class="statusNum" title="Initiative">Init</th>
                <th class="statusNum" title="Hit Points">HP</th>
                <th title="Conditions">Cond</th>
              </tr>
            </thead>
            <tbody id="statusBody"></tbody>
          </table>
        </div>
        <div id="statusAction" hidden></div>

        <h3>Log</h3>
        <div id="chatLog"></div>

        <h3 id="editorTitle">Editor</h3>
        <div id="editorPanel">
        <div id="editorSectionOrder" class="editorSection">
          <div class="mini">Order
            <span class="inlineFields">
              <button id="btnObjBack" title="Send selected object behind others">Send Back</button>
              <button id="btnObjFront" title="Bring selected object above others">Bring Front</button>
            </span>
          </div>
        </div>
        <div id="editorSectionObject" class="editorSection">
          <div class="mini">Object <select id="objectKindSelect"></select></div>
          <div class="mini">Rotate <input id="objectRot" type="number" step="15" value="0" /></div>
          <div class="mini">Offset
            <span class="inlineFields">
              <input id="objectOx" type="number" step="0.05" value="0" />
              <input id="objectOy" type="number" step="0.05" value="0" />
            </span>
          </div>
          <div class="mini">Scale <input id="objectScale" type="number" step="0.1" value="1" /></div>
          <div class="mini" id="objectSelected">Selected: none</div>
        </div>
        <div id="editorSectionOpening" class="editorSection">
          <div class="mini" style="opacity:0.7;">Opening</div>
          <div class="mini">Kind <input id="openingKind" type="text" list="openingKindList" placeholder="door.wood" /></div>
          <div class="mini">Hex <input id="openingHex" type="text" placeholder="M17" /></div>
          <div class="mini">Orient
            <select id="openingOrientation">
              <option value="h">h</option>
              <option value="v">v</option>
            </select>
          </div>
          <div class="mini">Open % <input id="openingOpenPct" type="number" step="0.1" min="0" max="1" value="0" /></div>
          <div class="mini">Hinge
            <select id="openingHinge">
              <option value=""></option>
              <option value="left">left</option>
              <option value="right">right</option>
            </select>
          </div>
          <div class="mini">Swing <input id="openingSwing" type="number" step="1" value="1" /></div>
          <div class="mini" id="openingSelected">Selected: none</div>
        </div>
        <div id="editorSectionRoom" class="editorSection">
          <div class="mini" style="opacity:0.7;">Room</div>
          <div class="mini">TL <input id="roomCornerTL" type="text" placeholder="AK21.5" /></div>
          <div class="mini">BR <input id="roomCornerBR" type="text" placeholder="AO18" /></div>
          <div class="mini">Floor <input id="roomFloorKind" type="text" list="floorKindList" placeholder="wood_oak" /></div>
          <div class="mini">Wall <input id="roomWallKind" type="text" list="wallKindList" placeholder="brick" /></div>
          <div class="mini">Thickness <input id="roomThickness" type="number" step="1" value="15" /></div>
          <div class="mini" id="roomSelected">Selected: none</div>
        </div>
      </div>
        <datalist id="floorKindList"></datalist>
        <datalist id="wallKindList"></datalist>
        <datalist id="openingKindList">
          <option value="door.wood"></option>
          <option value="door.stone"></option>
          <option value="door.iron"></option>
          <option value="window"></option>
          <option value="threshold"></option>
          <option value="portal"></option>
        </datalist>

        <div id="errorBox" hidden></div>
      </div>
  </div>

  <div id="chatBar">
    <select id="chatSpeaker"></select>
    <button id="chatSend">Send</button>
    <input id="chatInput" type="text" placeholder="Type message... (prefix with DM, for DM)" />
  </div>

  <script>
  // =====================================================================================
  // Battlemat Core Rewrite
  // Goals: small core renderer (hexes + camera + layers + orientation + fog) + supersample.
  // =====================================================================================

  const VERSION = 'v6.71';

  // ===== DOM =====
  const getEl = (id) => document.getElementById(id);
    const els = {
      canvas: getEl('canvas'),
      canvasWrap: getEl('canvasWrap'),
      versionText: getEl('versionText'),
    sceneSelect: getEl('sceneSelect'),
    fogToggle: getEl('fogToggle'),
    spriteToggle: getEl('spriteToggle'),
    labelBoldToggle: getEl('labelBoldToggle'),
    floorSelect: getEl('floorSelect'),
    sourceSelect: getEl('sourceSelect'),
    poiSelect: getEl('poiSelect'),
    centerOn: getEl('centerOn'),
    jumpHex: getEl('jumpHex'),
    errorBox: getEl('errorBox'),
    dprText: getEl('dprText'),
    ssText: getEl('ssText'),
      ssSelect: getEl('ssSelect'),
      zoomText: getEl('zoomText'),
    statusMeta: getEl('statusMeta'),
    statusBody: getEl('statusBody'),
    statusAction: getEl('statusAction'),
    chatLog: getEl('chatLog'),
    chatUnreadCount: getEl('chatUnreadCount'),
    chatMarkRead: getEl('chatMarkRead'),
    chatSpeaker: getEl('chatSpeaker'),
    chatInput: getEl('chatInput'),
    chatSend: getEl('chatSend'),
    stateDebug: getEl('stateDebug'),
    playtestToggle: getEl('playtestToggle'),
    toolSelect: getEl('toolSelect'),
    toolRoom: getEl('toolRoom'),
    toolDoor: getEl('toolDoor'),
    toolWindow: getEl('toolWindow'),
    toolObject: getEl('toolObject'),
    toolDelete: getEl('toolDelete'),
    btnSaveDb: getEl('btnSaveDb'),
    btnUndo: getEl('btnUndo'),
    btnScanIssues: getEl('btnScanIssues'),
    btnCleanOrphans: getEl('btnCleanOrphans'),
    toolStatus: getEl('toolStatus'),
    editorSectionOrder: getEl('editorSectionOrder'),
    editorSectionObject: getEl('editorSectionObject'),
    editorSectionOpening: getEl('editorSectionOpening'),
    editorSectionRoom: getEl('editorSectionRoom'),
    objectKindSelect: getEl('objectKindSelect'),
    objectRot: getEl('objectRot'),
    objectOx: getEl('objectOx'),
    objectOy: getEl('objectOy'),
    objectScale: getEl('objectScale'),
    objectSelected: getEl('objectSelected'),
    btnObjBack: getEl('btnObjBack'),
    btnObjFront: getEl('btnObjFront'),
    openingKind: getEl('openingKind'),
    openingHex: getEl('openingHex'),
    openingOrientation: getEl('openingOrientation'),
    openingOpenPct: getEl('openingOpenPct'),
    openingHinge: getEl('openingHinge'),
    openingSwing: getEl('openingSwing'),
    openingSelected: getEl('openingSelected'),
    roomCornerTL: getEl('roomCornerTL'),
    roomCornerBR: getEl('roomCornerBR'),
    roomFloorKind: getEl('roomFloorKind'),
    roomWallKind: getEl('roomWallKind'),
    roomThickness: getEl('roomThickness'),
    roomSelected: getEl('roomSelected'),
    floorKindList: getEl('floorKindList'),
    wallKindList: getEl('wallKindList'),
    openingKindList: getEl('openingKindList'),
    btnLeft: getEl('btnLeft'),
    btnRight: getEl('btnRight'),
    btnUp: getEl('btnUp'),
    btnDown: getEl('btnDown'),
    btnZoomOut: getEl('btnZoomOut'),
    btnZoomIn: getEl('btnZoomIn'),
    btnRedraw: getEl('btnRedraw'),
    btnJump: getEl('btnJump'),
  };

  const canvas = els.canvas;
  const ctx = canvas.getContext('2d', { alpha: false, desynchronized: true });

  // Offscreen wall layer (we punch openings out of walls here, then composite onto main canvas)
  const wallCanvas = document.createElement('canvas');
  const wallCtx = wallCanvas.getContext('2d', { alpha: true, desynchronized: true });

  const elVersion = els.versionText;
  const elSceneSelect = els.sceneSelect;
  const elFogToggle = els.fogToggle;
  const elSpriteToggle = els.spriteToggle;
  const elLabelBoldToggle = els.labelBoldToggle;
  const elFloorSelect = els.floorSelect;
  const elSourceSelect = els.sourceSelect;
  const elPoiSelect = els.poiSelect;
  const elCenterOn = els.centerOn;
  const elJumpHex = els.jumpHex;
  const elError = els.errorBox;
  const elDpr = els.dprText;
  const elSs = els.ssText;
  const elSsSelect = els.ssSelect;
  const elToolSelect = els.toolSelect;
  const elToolRoom = els.toolRoom;
  const elToolDoor = els.toolDoor;
  const elToolWindow = els.toolWindow;
  const elToolObject = els.toolObject;
  const elToolDelete = els.toolDelete;
  const elSaveDb = els.btnSaveDb;
  const elUndo = els.btnUndo;
  const elToolStatus = els.toolStatus;
  const elPlaytestToggle = els.playtestToggle;
  const elChatLog = els.chatLog;
  const elChatUnreadCount = els.chatUnreadCount;
  const elChatMarkRead = els.chatMarkRead;
  const elChatSpeaker = els.chatSpeaker;
  const elChatInput = els.chatInput;
  const elChatSend = els.chatSend;
  const elStateDebug = els.stateDebug;
  const elEditorSectionOrder = els.editorSectionOrder;
  const elEditorSectionObject = els.editorSectionObject;
  const elEditorSectionOpening = els.editorSectionOpening;
  const elEditorSectionRoom = els.editorSectionRoom;
  const elObjectKindSelect = els.objectKindSelect;
  const elObjectRot = els.objectRot;
  const elObjectOx = els.objectOx;
  const elObjectOy = els.objectOy;
  const elObjectScale = els.objectScale;
  const elObjectSelected = els.objectSelected;
  const elObjBack = els.btnObjBack;
  const elObjFront = els.btnObjFront;
  const elOpeningKind = els.openingKind;
  const elOpeningHex = els.openingHex;
  const elOpeningOrientation = els.openingOrientation;
  const elOpeningOpenPct = els.openingOpenPct;
  const elOpeningHinge = els.openingHinge;
  const elOpeningSwing = els.openingSwing;
  const elOpeningSelected = els.openingSelected;
  const elRoomCornerTL = els.roomCornerTL;
  const elRoomCornerBR = els.roomCornerBR;
  const elRoomFloorKind = els.roomFloorKind;
  const elRoomWallKind = els.roomWallKind;
  const elRoomThickness = els.roomThickness;
  const elRoomSelected = els.roomSelected;
  const elFloorKindList = els.floorKindList;
  const elWallKindList = els.wallKindList;
  const elOpeningKindList = els.openingKindList;

  if (elVersion) elVersion.textContent = VERSION;
  document.title = 'Battlemat Core ' + VERSION;

  // ===== Constants =====
  const sqrt3 = Math.sqrt(3);

  const GRID = {
    // Flat-top hex geometry: size is center-to-vertex.
    baseSize: 42,
    size: 42,
    lineWidth: 2,
    lineAlpha: 0.10,
    labelAlpha: 0.18,
    labelFont: 'bold 12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial',
  };

  const COLORS = {
    bg: '#0b0d12',
    wall: '#666',
    door: '#b67a2c',
    window: '#bfe2ff',

    floorStone: 'rgb(223, 208, 165)',
    floorWood:  'rgb(213, 181, 140)',

    // Placeholder prop colors (used when sprites are off or missing)
    objectWood: 'rgb(173, 131, 89)',
    chestWood:  'rgb(110, 72, 40)',
    stairsWood: 'rgb(140, 98, 64)',

    // Beds (placeholder colors)
    bedFabric: 'rgb(173, 131, 89)', // match table color
    bedPillow: 'rgb(175, 159, 141)',

    // Hearth (placeholder color)
    hearth: 'rgb(147, 53, 53)',
    floorCobble: 'rgb(154, 160, 166)',

    tokenHero: '#4aa3ff',
    tokenEnemy: '#111',
    tokenTextDark: 'rgba(0,0,0,0.72)',
    tokenTextLight: 'rgba(255,255,255,0.88)',

    fogUnseen: 'rgb(128,128,128)',
    fogExplored: 'rgb(170,170,170)',
  };

  const TOKEN_DEFAULT_SCALE = 2.4;

  const VIEW = {
    // Camera is in hex coords (col,row), row 0 is "row 1" at the bottom.
    camera: { col: 6, row: 6 },
    anchor: { x: 0, y: 0 },

    // Active floor id (single-floor states still work)
    floorId: null,

    // If set, camera will automatically follow that token id (and flip floors when needed)
    followTokenId: null,

    // DevicePixelRatio × supersample scale (set in resize())
    dpr: 1,
  };

  const PAN_STEP = 2;
  const FILE_STATE_URL = '/app/data.json';
  const STORAGE_PREFIX = (() => {
    const bid = resolveBattleIdFromUrl();
    return bid ? ('battlemat.' + bid + '.') : 'battlemat.';
  })();
  const STORAGE_SS = STORAGE_PREFIX + 'supersample';
  const STORAGE_ZOOM = STORAGE_PREFIX + 'zoom';
  const STORAGE_PLAYTEST = STORAGE_PREFIX + 'playtest';

  // ===== Remote state (DB/API) =====
  const DEFAULT_POLL_MS = 0;
  let CURRENT_STATE = null;
  let STATE_URL = null;
  let STATE_POLL_TIMER = null;
  let LAST_STATE_JSON = '';
  const BATTLE_STATE_CACHE = new Map();
  const BATTLE_STATE_FETCHING = new Set();
  const BATTLE_STATE_TTL_MS = 8000;
  let LAST_RENDER_SIGNATURE = '';
  let LAST_EDITOR_SIGNATURE = '';
  let SPRITE_LOAD_TICK = 0;
  let SPRITES_ENABLED = true;
  let STATE_SOURCE = 'embedded';
  let LAST_FETCH_URL = '';
  let LAST_FETCH_STATUS = null;
  let LAST_FETCH_ERROR = '';
  let LAST_FETCH_AT = 0;
  let CHAT_LOG = [];
  let CHAT_ID_SET = new Set();
  let LAST_CHAT_TS = 0;
  let CURRENT_BATTLE_ID = null;
  let CURRENT_CAMPAIGN_ID = null;
  let CURRENT_CAMPAIGN_META = null;
  let FOLLOW_ACTIVE_LOCATION = true;
  let FOLLOW_LOCATION_MANUAL_OVERRIDE = false;
  let LAST_META_FETCH_AT = 0;
  const META_FETCH_INTERVAL_MS = 15000;
  const STORAGE_CHAT_READ_PREFIX = 'battlemat.chat.read.';
  let CHAT_SAVE_TIMER = null;

  const EDITOR = {
    tool: 'select',
    preview: null,
    objectPreview: null,
    roomStart: null,
    roomPreview: null,
    selectedId: null,
    selectedFloorId: null,
    selectedObjectId: null,
    selectedObjectFloorId: null,
    selectedRoomId: null,
    selectedRoomFloorId: null,
    lastOpenings: null,
    lastObjects: null,
    issueMarkers: [],
    deletedOpeningsByFloor: {},
    deletedObjectsByFloor: {},
    deletedRoomsByFloor: {},
    deletedTokens: {},
    undoSnapshot: null,
    undoLock: false,
    objectKind: 'chair',
    objectRotDeg: 0,
    objectOx: 0,
    objectOy: 0,
    objectScale: 1,
    objectUiLock: false,
    openingUiLock: false,
    roomUiLock: false,
    saveTimer: null,
    saving: false,
  };

  function getQueryParams(search = window.location.search) {
    const s = String(search || '').trim();
    const out = new Map();
    if (!s || s === '?' || s === '#') return out;
    const q = (s[0] === '?' || s[0] === '#') ? s.slice(1) : s;
    for (const part of q.split('&')) {
      if (!part) continue;
      const [kRaw, vRaw] = part.split('=');
      const k = decodeURIComponent((kRaw || '').replaceAll('+', ' ')).trim();
      const v = decodeURIComponent((vRaw || '').replaceAll('+', ' ')).trim();
      if (k) out.set(k, v);
    }
    return out;
  }

  function getQueryParamsCached() {
    if (!getQueryParamsCached._cached) {
      getQueryParamsCached._cached = getQueryParams();
    }
    return getQueryParamsCached._cached;
  }

  function getAuthToken() {
    const qp = getQueryParamsCached();
    const token = (
      qp.get('token') ||
      qp.get('auth') ||
      qp.get('bearer') ||
      ''
    ).trim();
    if (token) return token;
    if (window && window.BATTLE_API_TOKEN) {
      const w = String(window.BATTLE_API_TOKEN).trim();
      if (w) return w;
    }
    return '';
  }

  function getAuthHeaders() {
    const token = getAuthToken();
    if (!token) return {};
    return { Authorization: 'Bearer ' + token };
  }

  function parseBattleIdFromUrlString(rawUrl) {
    const base = (window && window.location && window.location.href)
      ? window.location.href
      : 'http://localhost/';
    const s = String(rawUrl || '').trim();
    if (!s) return null;

    let u = null;
    try { u = new URL(s, base); } catch { u = null; }

    const search = u ? u.search : '';
    const hash = u ? u.hash : '';
    const path = u ? u.pathname : s;

    let bid = (
      getQueryParams(search).get('battle_id') ||
      getQueryParams(search).get('battleId') ||
      getQueryParams(search).get('battle') ||
      getQueryParams(search).get('id') ||
      ''
    ).trim();
    if (bid) return bid;

    bid = (
      getQueryParams(hash).get('battle_id') ||
      getQueryParams(hash).get('battleId') ||
      getQueryParams(hash).get('battle') ||
      getQueryParams(hash).get('id') ||
      ''
    ).trim();
    if (bid) return bid;

    const playMatch = String(path || '').match(/\/play\/([^\/?#]+)/i);
    if (playMatch && playMatch[1] && String(playMatch[1]).toLowerCase() !== 'c') {
      try { return decodeURIComponent(playMatch[1]); } catch { return playMatch[1]; }
    }

    const matMatch = String(path || '').match(/\/battlemat\/([^\/?#]+)/i);
    if (matMatch && matMatch[1]) {
      try { return decodeURIComponent(matMatch[1]); } catch { return matMatch[1]; }
    }

    return null;
  }

  function parseCampaignIdFromUrlString(rawUrl) {
    const base = (window && window.location && window.location.href)
      ? window.location.href
      : 'http://localhost/';
    const s = String(rawUrl || '').trim();
    if (!s) return null;

    let u = null;
    try { u = new URL(s, base); } catch { u = null; }

    const search = u ? u.search : '';
    const hash = u ? u.hash : '';
    const path = u ? u.pathname : s;

    let cid = (
      getQueryParams(search).get('campaign_id') ||
      getQueryParams(search).get('campaignId') ||
      getQueryParams(search).get('campaign') ||
      ''
    ).trim();
    if (cid) return cid;

    cid = (
      getQueryParams(hash).get('campaign_id') ||
      getQueryParams(hash).get('campaignId') ||
      getQueryParams(hash).get('campaign') ||
      ''
    ).trim();
    if (cid) return cid;

    const playMatch = String(path || '').match(/\/play\/c\/([^\/?#]+)/i);
    if (playMatch && playMatch[1]) {
      try { return decodeURIComponent(playMatch[1]); } catch { return playMatch[1]; }
    }

    const campMatch = String(path || '').match(/\/campaign\/([^\/?#]+)/i);
    if (campMatch && campMatch[1]) {
      try { return decodeURIComponent(campMatch[1]); } catch { return campMatch[1]; }
    }

    return null;
  }

  function resolveBattleIdHintFromUrl() {
    const qp = getQueryParamsCached();
    let bid = (
      qp.get('battle_id') ||
      qp.get('battleId') ||
      qp.get('battle') ||
      qp.get('id') ||
      ''
    ).trim();
    if (bid) return bid;

    const hp = getQueryParams(window.location.hash);
    bid = (
      hp.get('battle_id') ||
      hp.get('battleId') ||
      hp.get('battle') ||
      hp.get('id') ||
      ''
    ).trim();
    if (bid) return bid;

    // Support pretty URLs like /play/28 (rewrites may keep the path in the address bar).
    const path = (window && window.location && window.location.pathname)
      ? String(window.location.pathname)
      : '';
    const playMatch = path.match(/\/play\/([^\/?#]+)/i);
    if (playMatch && playMatch[1] && String(playMatch[1]).toLowerCase() !== 'c') {
      try { return decodeURIComponent(playMatch[1]); } catch { return playMatch[1]; }
    }

    const matMatch = path.match(/\/battlemat\/([^\/?#]+)/i);
    if (matMatch && matMatch[1]) {
      try { return decodeURIComponent(matMatch[1]); } catch { return matMatch[1]; }
    }

    const href = (window && window.location && window.location.href)
      ? String(window.location.href)
      : '';
    const hrefPlayMatch = href.match(/\/play\/([^\/?#]+)/i);
    if (hrefPlayMatch && hrefPlayMatch[1] && String(hrefPlayMatch[1]).toLowerCase() !== 'c') {
      try { return decodeURIComponent(hrefPlayMatch[1]); } catch { return hrefPlayMatch[1]; }
    }
    const hrefMatMatch = href.match(/\/battlemat\/([^\/?#]+)/i);
    if (hrefMatMatch && hrefMatMatch[1]) {
      try { return decodeURIComponent(hrefMatMatch[1]); } catch { return hrefMatMatch[1]; }
    }

    const ref = (document && document.referrer) ? String(document.referrer) : '';
    if (ref) {
      const refBid = parseBattleIdFromUrlString(ref);
      if (refBid) return refBid;
    }

    return null;
  }

  function resolveCampaignIdHintFromUrl() {
    const qp = getQueryParamsCached();
    let cid = (
      qp.get('campaign_id') ||
      qp.get('campaignId') ||
      qp.get('campaign') ||
      ''
    ).trim();
    if (cid) return cid;

    const hp = getQueryParams(window.location.hash);
    cid = (
      hp.get('campaign_id') ||
      hp.get('campaignId') ||
      hp.get('campaign') ||
      ''
    ).trim();
    if (cid) return cid;

    const path = (window && window.location && window.location.pathname)
      ? String(window.location.pathname)
      : '';
    const playMatch = path.match(/\/play\/c\/([^\/?#]+)/i);
    if (playMatch && playMatch[1]) {
      try { return decodeURIComponent(playMatch[1]); } catch { return playMatch[1]; }
    }

    const campMatch = path.match(/\/campaign\/([^\/?#]+)/i);
    if (campMatch && campMatch[1]) {
      try { return decodeURIComponent(campMatch[1]); } catch { return campMatch[1]; }
    }

    const href = (window && window.location && window.location.href)
      ? String(window.location.href)
      : '';
    const refCid = parseCampaignIdFromUrlString(href);
    if (refCid) return refCid;

    const ref = (document && document.referrer) ? String(document.referrer) : '';
    if (ref) {
      const refCid2 = parseCampaignIdFromUrlString(ref);
      if (refCid2) return refCid2;
    }

    return null;
  }

  function shouldRunSelfTests() {
    const qp = getQueryParamsCached();
    if (qp.get('selftest') === '1' || qp.get('selftests') === '1') return true;
    return !!(window && window.BATTLEMAT_SELFTESTS);
  }

  function resolveBattleIdFromUrl() {
    return resolveBattleIdHintFromUrl();
  }

  function resolveCampaignIdFromUrl() {
    return resolveCampaignIdHintFromUrl();
  }

  function resolveStateUrl() {
    const qp = getQueryParamsCached();
    const fromQuery = qp.get('stateUrl') || qp.get('state_url') || qp.get('state') || '';
    const fromWindow = (window && window.BATTLE_STATE_URL) ? String(window.BATTLE_STATE_URL) : '';
    const url = (fromQuery || fromWindow || '').trim();
    if (url) return url;

    // Canonical site routing: /play/27 -> /app/battlemat?battle_id=27
    // We can auto-derive the API URL from battle_id.
    const battleId = resolveBattleIdFromUrl();
    if (battleId) return `/api/battles/${encodeURIComponent(battleId)}`;

    return null;
  }

  function resolvePollMs() {
    const qp = getQueryParamsCached();
    const qv = qp.get('pollMs') || qp.get('poll_ms') || '';
    const wv = (window && window.BATTLE_STATE_POLL_MS != null) ? String(window.BATTLE_STATE_POLL_MS) : '';
    const raw = (qv || wv || '').trim();
    if (raw === '') return DEFAULT_POLL_MS;
    const n = Number(raw);
    if (!Number.isFinite(n)) return DEFAULT_POLL_MS;
    return Math.max(0, Math.floor(n));
  }

  async function fetchStateOnce(url) {
    const u = String(url || '').trim();
    if (!u) return null;

    // Cache-bust so you can serve plain JSON from static hosting or through proxies.
    const sep = u.includes('?') ? '&' : '?';
    const fetchUrl = u + sep + '_ts=' + Date.now();
    LAST_FETCH_URL = fetchUrl;
    LAST_FETCH_ERROR = '';

    const res = await fetch(fetchUrl, {
      method: 'GET',
      cache: 'no-store',
      headers: { 'Accept': 'application/json', ...getAuthHeaders() },
    });

    LAST_FETCH_STATUS = res.status;
    LAST_FETCH_AT = Date.now();
    if (!res.ok) {
      LAST_FETCH_ERROR = 'HTTP ' + res.status + ' ' + res.statusText;
      throw new Error('State fetch failed: ' + res.status + ' ' + res.statusText);
    }

    const txt = await res.text();
    const jsonText = txt.trim();
    if (!jsonText) throw new Error('State fetch returned empty body');

    let parsedOuter;
    try { parsedOuter = JSON.parse(jsonText); }
    catch (e) {
      LAST_FETCH_ERROR = 'non-JSON response';
      throw new Error('State fetch returned non-JSON: ' + (e && e.message ? e.message : String(e)));
    }

      // Common DB shape: { ..., state_json: "{...}", chat_json: "...", battle_id, campaign_id }
      if (parsedOuter && typeof parsedOuter === 'object' && parsedOuter.state_json != null) {
        const sj = parsedOuter.state_json;
        const chatJson = parsedOuter.chat_json;
        const battleId = parsedOuter.battle_id != null ? String(parsedOuter.battle_id) : null;
        const campaignId = parsedOuter.campaign_id != null ? String(parsedOuter.campaign_id) : null;

        if (typeof sj === 'string') {
          const sjText = sj.trim();
          if (!sjText) throw new Error('Battle record has empty state_json');

        let parsedState;
        try { parsedState = JSON.parse(sjText); }
        catch (e) {
          LAST_FETCH_ERROR = 'invalid state_json';
          throw new Error('Battle record has invalid state_json JSON: ' + (e && e.message ? e.message : String(e)));
        }

        // Use state_json text for change detection (avoids redrawing if other DB fields change).
          return { parsed: parsedState, jsonText: sjText, chatJson, battleId, campaignId };
        }

        // state_json provided as object already
        try {
          const stable = JSON.stringify(sj);
          return { parsed: sj, jsonText: stable, chatJson, battleId, campaignId };
        } catch {
          // Fallback: if it can't stringify, still apply it
          return { parsed: sj, jsonText: '[[state_json_object]]', chatJson, battleId, campaignId };
        }
      }

    // If the endpoint returns the scene JSON directly.
    return { parsed: parsedOuter, jsonText };
  }

  let CURRENT_RAW_STATE = null; // last raw payload from DB/API (world wrapper OR legacy)

  function stableJsonTextFor(raw) {
    try { return JSON.stringify(raw); } catch { return '[[unstringifiable_state]]'; }
  }

  function applyViewFromState(state) {
    // If the state specifies a floor/camera, apply it.
    try {
      const st = state;
      const floors = getFloorsFromState(st);
      const fid = pickActiveFloorId(st, floors);
      VIEW.floorId = fid;

      const camHex = st && st.view && st.view.camera_hex ? String(st.view.camera_hex) : null;
      if (camHex) {
        const p = parseHexId(camHex);
        VIEW.camera.col = p.col;
        VIEW.camera.row = p.row;
      }
    } catch {}
  }

  function setCanonicalStateFromRaw(raw, jsonTextHint) {
    clearEditorPendingDeletes();
    CURRENT_RAW_STATE = raw;
    LAST_STATE_JSON = String(jsonTextHint != null ? jsonTextHint : stableJsonTextFor(raw));

    // Normalize (world wrapper -> active record scene; legacy scene -> scene)
    const scene = normalizeStateForRenderer(raw) || FALLBACK_STATE_MIN;
    CURRENT_STATE = scene;

    // Keep VIEW synced to the scene.
    applyViewFromState(scene);
  }

  function applyFetchedState(parsed, jsonText, chatJson, battleId, campaignId) {
    setCanonicalStateFromRaw(parsed, jsonText);
    if (battleId) CURRENT_BATTLE_ID = battleId;
    if (campaignId) {
      const nextCampaignId = String(campaignId);
      if (CURRENT_CAMPAIGN_ID && String(CURRENT_CAMPAIGN_ID) !== nextCampaignId) {
        CURRENT_CAMPAIGN_META = null;
      }
      CURRENT_CAMPAIGN_ID = nextCampaignId;
    }
    STATE_SOURCE = stateSourceFromUrl(STATE_URL);
  }

  function stateSourceFromUrl(url) {
    const u = String(url || '').toLowerCase();
    if (!u) return 'database';
    if (u.includes('/api/battles/') || u.includes('/battles/')) return 'database';
    if (u.endsWith('.json') || u.includes('/data/')) return 'file';
    return 'database';
  }

  function stopStatePolling() {
    if (STATE_POLL_TIMER) clearInterval(STATE_POLL_TIMER);
    STATE_POLL_TIMER = null;
  }

  function resolveFileUrl() {
    const qp = getQueryParamsCached();
    const fromQuery = qp.get('stateUrl') || qp.get('state_url') || qp.get('state') || '';
    if (fromQuery && stateSourceFromUrl(fromQuery) === 'file') return fromQuery;

    const fromWindow = (window && window.BATTLE_STATE_URL) ? String(window.BATTLE_STATE_URL) : '';
    if (fromWindow && stateSourceFromUrl(fromWindow) === 'file') return fromWindow;

    return FILE_STATE_URL;
  }

  function resolveDatabaseUrl() {
    const resolved = resolveStateUrl();
    if (stateSourceFromUrl(resolved) === 'database') return resolved;

    const battleId = resolveBattleIdFromUrl();
    if (battleId) return `/api/battles/${encodeURIComponent(battleId)}`;

    return null;
  }

  function parseCampaignMeta(raw) {
    if (!raw) return null;
    if (typeof raw === 'object') return raw;
    if (typeof raw === 'string') {
      try { return JSON.parse(raw); } catch { return null; }
    }
    return null;
  }

  async function fetchCampaignInfo(campaignId) {
    const cid = String(campaignId || '').trim();
    if (!cid) return null;
    const bases = [];
    if (window && window.BATTLE_API_BASE) bases.push(String(window.BATTLE_API_BASE));
    if (STATE_URL && STATE_URL.includes('/battles/')) {
      const base = STATE_URL.split('/battles/')[0];
      if (base) bases.push(base);
    }
    bases.push('/api');
    bases.push('https://dungeon.delvus.net');

    const seen = new Set();
    for (const base0 of bases) {
      const base = String(base0 || '').trim().replace(/\/+$/, '');
      if (!base || seen.has(base)) continue;
      seen.add(base);
      const url = base + '/campaigns/' + encodeURIComponent(cid);
      try {
        const res = await fetch(url, { headers: getAuthHeaders() });
        if (!res.ok) continue;
        const data = await res.json().catch(() => null);
        if (!data || typeof data !== 'object') continue;
        const bid = data.active_battle_id || data.activeBattleId || data.battle_id || data.battleId || null;
        const meta = parseCampaignMeta(data.meta_json || data.metaJson || null);
        return { battleId: bid != null ? String(bid) : null, meta };
      } catch {}
    }
    return null;
  }

  async function fetchCampaignBattleId(campaignId) {
    const info = await fetchCampaignInfo(campaignId);
    return info && info.battleId ? info.battleId : null;
  }

  async function ensureCampaignMeta(campaignId, force = false) {
    const cid = String(campaignId || '').trim();
    if (!cid) return null;
    if (!force && CURRENT_CAMPAIGN_META && CURRENT_CAMPAIGN_ID === cid) return CURRENT_CAMPAIGN_META;
    if (!force && LAST_META_FETCH_AT && (Date.now() - LAST_META_FETCH_AT) < META_FETCH_INTERVAL_MS) {
      return CURRENT_CAMPAIGN_META;
    }
    LAST_META_FETCH_AT = Date.now();
    const info = await fetchCampaignInfo(cid);
    if (!info) return CURRENT_CAMPAIGN_META;
    if (info.meta != null) CURRENT_CAMPAIGN_META = info.meta;
    if (info.battleId && !CURRENT_BATTLE_ID) CURRENT_BATTLE_ID = info.battleId;
    if (!FOLLOW_LOCATION_MANUAL_OVERRIDE && CURRENT_CAMPAIGN_META && typeof CURRENT_CAMPAIGN_META === 'object') {
      const mode = String(CURRENT_CAMPAIGN_META.follow_mode || CURRENT_CAMPAIGN_META.followMode || '').trim().toLowerCase();
      if (mode) FOLLOW_ACTIVE_LOCATION = (mode === 'active_turn' || mode === 'active');
    }
    return CURRENT_CAMPAIGN_META;
  }

  async function fetchCampaignBattles(campaignId) {
    const cid = String(campaignId || '').trim();
    if (!cid) return [];
    const url = '/api/battles?campaign_id=' + encodeURIComponent(cid);
    try {
      const res = await fetch(url, { method: 'GET', cache: 'no-store', headers: { 'accept': 'application/json', ...getAuthHeaders() } });
      if (!res.ok) return [];
      const data = await res.json().catch(() => null);
      const rows = data && Array.isArray(data.rows) ? data.rows : [];
      return rows;
    } catch {
      return [];
    }
  }

  function renderPoiSelectOptions(rows, activeBattleId) {
    if (!elPoiSelect) return;
    const list = Array.isArray(rows) ? rows : [];
    const activeId = activeBattleId ? String(activeBattleId) : '';
    const options = ['<option value="">Select POI</option>'];
    for (const row of list) {
      if (!row || !row.battle_id) continue;
      const id = String(row.battle_id);
      const label = String(row.name || row.slug || row.title || id);
      const selected = activeId && id === activeId ? ' selected' : '';
      options.push('<option value="' + escapeHtml(id) + '"' + selected + '>' + escapeHtml(label) + '</option>');
    }
    elPoiSelect.innerHTML = options.join('');
    elPoiSelect.disabled = options.length <= 1;
  }

  async function refreshPoiSelect(campaignId) {
    if (!elPoiSelect) return;
    if (!campaignId) {
      elPoiSelect.innerHTML = '<option value="">Select POI</option>';
      elPoiSelect.disabled = true;
      return;
    }
    const rows = await fetchCampaignBattles(campaignId);
    renderPoiSelectOptions(rows, CURRENT_BATTLE_ID || resolveBattleIdFromUrl());
  }

  function getActiveTokenIdFromState(state) {
    if (!state || typeof state !== 'object') return null;
    const t = state.turn && typeof state.turn === 'object' ? state.turn : null;
    if (!t) return null;
    const id = t.activeTokenId || t.active_token_id || t.tokenId || t.token_id || t.actorId || t.actor_id;
    return id != null ? String(id) : null;
  }

  function getCampaignTurnActiveId() {
    if (!CURRENT_CAMPAIGN_META || typeof CURRENT_CAMPAIGN_META !== 'object') return null;
    const world = CURRENT_CAMPAIGN_META.world && typeof CURRENT_CAMPAIGN_META.world === 'object'
      ? CURRENT_CAMPAIGN_META.world
      : null;
    const battle = world && typeof world.battle === 'object' ? world.battle : null;
    if (battle) {
      const id = battle.active || battle.active_id || battle.activeId || battle.active_entity || battle.activeEntity;
      if (id != null) return String(id);
    }
    const t = CURRENT_CAMPAIGN_META.turn && typeof CURRENT_CAMPAIGN_META.turn === 'object'
      ? CURRENT_CAMPAIGN_META.turn
      : null;
    if (!t) return null;
    const id = t.active || t.active_id || t.activeId || t.active_entity || t.activeEntity;
    return id != null ? String(id) : null;
  }

  function getCampaignEntities() {
    if (!CURRENT_CAMPAIGN_META || typeof CURRENT_CAMPAIGN_META !== 'object') return null;
    const world = CURRENT_CAMPAIGN_META.world && typeof CURRENT_CAMPAIGN_META.world === 'object'
      ? CURRENT_CAMPAIGN_META.world
      : null;
    const ents = (world && (world.entities || world.creatures))
      || CURRENT_CAMPAIGN_META.entities
      || CURRENT_CAMPAIGN_META.creatures
      || null;
    if (!ents) return null;
    if (Array.isArray(ents)) return ents.slice();
    if (typeof ents === 'object') {
      return Object.entries(ents).map(([id, data]) => ({ id, ...(data || {}) }));
    }
    return null;
  }

  function getCampaignPartyLocations() {
    if (!CURRENT_CAMPAIGN_META || typeof CURRENT_CAMPAIGN_META !== 'object') return null;
    return CURRENT_CAMPAIGN_META.party_locations || CURRENT_CAMPAIGN_META.partyLocations || null;
  }

  function getBattleStateCached(battleId) {
    const id = String(battleId || '').trim();
    if (!id) return null;
    const entry = BATTLE_STATE_CACHE.get(id);
    if (!entry) return null;
    if ((Date.now() - entry.ts) > BATTLE_STATE_TTL_MS) return null;
    return entry;
  }

  async function fetchBattleStateForId(battleId) {
    const id = String(battleId || '').trim();
    if (!id || BATTLE_STATE_FETCHING.has(id)) return;
    BATTLE_STATE_FETCHING.add(id);
    try {
      const url = '/api/battles/' + encodeURIComponent(id);
      const res = await fetch(url, { method: 'GET', cache: 'no-store', headers: { 'accept': 'application/json', ...getAuthHeaders() } });
      if (!res.ok) return;
      const data = await res.json().catch(() => null);
      if (!data) return;
      let state = null;
      if (data.state_json) {
        if (typeof data.state_json === 'string') {
          try { state = JSON.parse(data.state_json); } catch { state = null; }
        } else if (typeof data.state_json === 'object') {
          state = data.state_json;
        }
      }
      if (!state || typeof state !== 'object') return;
      const render = buildRenderState(state);
      const tokens = normalizeTokenCharacterIds((render && Array.isArray(render.tokensAll)) ? render.tokensAll : getTokensArray(state));
      BATTLE_STATE_CACHE.set(id, { ts: Date.now(), state, tokens, render });
      if (CURRENT_STATE) {
        const render = buildRenderState(CURRENT_STATE);
        updateSidebar(CURRENT_STATE, render.floor, render.rooms, render.openings, render.objects, render.tokensAll || render.tokens);
      }
    } finally {
      BATTLE_STATE_FETCHING.delete(id);
    }
  }

  function ensureBattleStateCached(battleId) {
    const entry = getBattleStateCached(battleId);
    if (entry) return entry;
    fetchBattleStateForId(battleId);
    return null;
  }

  function findEntityById(entityId) {
    const id = String(entityId || '').trim();
    if (!id) return null;
    const ents = getCampaignEntities();
    if (!Array.isArray(ents)) return null;
    return ents.find(e => e && String(e.id || '') === id) || null;
  }

  function findEntityByCharacterId(characterId) {
    const cid = String(characterId || '').trim();
    if (!cid) return null;
    const ents = getCampaignEntities();
    if (!Array.isArray(ents)) return null;
    return ents.find(e => {
      if (!e) return false;
      const eCid = e.character_id != null ? String(e.character_id) : '';
      const eCId = e.characterId != null ? String(e.characterId) : '';
      return eCid === cid || eCId === cid;
    }) || null;
  }

  function getPoiBattleMap() {
    if (!CURRENT_CAMPAIGN_META || typeof CURRENT_CAMPAIGN_META !== 'object') return null;
    return (
      (CURRENT_CAMPAIGN_META.world && CURRENT_CAMPAIGN_META.world.poi_index) ||
      (CURRENT_CAMPAIGN_META.world && CURRENT_CAMPAIGN_META.world.poiIndex) ||
      CURRENT_CAMPAIGN_META.poi_index ||
      CURRENT_CAMPAIGN_META.poiIndex ||
      CURRENT_CAMPAIGN_META.poi_to_battle ||
      CURRENT_CAMPAIGN_META.poiToBattle ||
      CURRENT_CAMPAIGN_META.pois ||
      null
    );
  }

  function getPoiLabel(poiId) {
    const pid = String(poiId || '').trim();
    if (!pid) return '';
    const map = getPoiBattleMap();
    if (!map || typeof map !== 'object') return pid;
    const entry = map[pid];
    if (!entry || typeof entry !== 'object') return pid;
    const label = entry.title || entry.name || entry.label || entry.poi_name || entry.poiName || '';
    return label ? String(label) : pid;
  }

  function resolvePoiForBattle(battleId) {
    const bid = String(battleId || '').trim();
    if (!bid) return null;
    const map = getPoiBattleMap();
    if (!map || typeof map !== 'object') return null;
    for (const [poiId, entry] of Object.entries(map)) {
      if (typeof entry === 'string' && String(entry) === bid) return poiId;
      if (entry && typeof entry === 'object') {
        const id = entry.battle_id || entry.battleId || entry.battle || entry.id;
        if (id && String(id) === bid) return poiId;
      }
    }
    return null;
  }

  function isPcEntity(entity) {
    if (!entity || typeof entity !== 'object') return false;
    const kind = String(entity.kind || entity.type || '').trim().toLowerCase();
    if (kind === 'npc' || kind === 'monster' || kind === 'creature') return false;
    if (kind === 'pc') return true;
    return !!(entity.character_id || entity.characterId);
  }

  function isEntityListed(entity) {
    if (!entity || typeof entity !== 'object') return false;
    if (isPcEntity(entity)) return true;
    const flag = entity.listed ?? entity.in_battle ?? entity.inBattle ?? entity.show_in_hud ?? entity.showInHud;
    if (typeof flag === 'boolean') return flag;
    const hostility = String(entity.hostility || entity.attitude || entity.alignment || '').trim().toLowerCase();
    if (hostility === 'hostile') return true;
    return false;
  }

  function resolveBattleFromPoi(poiId) {
    const map = getPoiBattleMap();
    if (!map || typeof map !== 'object') return null;
    const pid = String(poiId || '').trim();
    if (!pid) return null;
    const entry = map[pid];
    if (typeof entry === 'string' && entry.trim()) return String(entry);
    if (entry && typeof entry === 'object') {
      const bid = entry.battle_id || entry.battleId || entry.battle || entry.id;
      if (bid) return String(bid);
    }
    return null;
  }

  function resolveBattleForEntity(entityId) {
    if (!FOLLOW_ACTIVE_LOCATION) return null;
    if (!CURRENT_CAMPAIGN_META || typeof CURRENT_CAMPAIGN_META !== 'object') return null;

    const id = String(entityId || '').trim();
    if (!id) return null;

    const map = CURRENT_CAMPAIGN_META.party_locations || CURRENT_CAMPAIGN_META.partyLocations || null;
    const entity = findEntityById(id) || findEntityByCharacterId(id);

    if (entity) {
      const loc = entity.location && typeof entity.location === 'object' ? entity.location : null;
      const battleDirect =
        entity.current_battle_id || entity.currentBattleId ||
        entity.battle_id || entity.battleId || (loc && (loc.battle_id || loc.battleId || loc.battle));
      if (battleDirect) return String(battleDirect);

      const poi = entity.current_poi || entity.currentPoi || entity.poi || (loc && (loc.poi_id || loc.poiId || loc.poi)) || null;
      const fromPoi = poi ? resolveBattleFromPoi(poi) : null;
      if (fromPoi) return fromPoi;
    }

    if (map && typeof map === 'object') {
      const entry = map[id];
      if (typeof entry === 'string' && entry.trim()) return String(entry);
      if (entry && typeof entry === 'object') {
        const bid = entry.battle_id || entry.battleId || entry.battle;
        if (bid) return String(bid);
      }
    }

    return null;
  }

  function findTokenById(state, tokenId) {
    if (!tokenId) return null;
    const tokens = normalizeTokenCharacterIds(getTokensArray(state));
    return tokens.find(t => {
      if (!t) return false;
      const id = t.id != null ? String(t.id) : '';
      const cid = t.character_id != null ? String(t.character_id) : '';
      const cId = t.characterId != null ? String(t.characterId) : '';
      const tid = String(tokenId);
      return id === tid || cid === tid || cId === tid;
    }) || null;
  }

  function resolveBattleForActiveToken(state) {
    if (!FOLLOW_ACTIVE_LOCATION) return null;
    if (!CURRENT_CAMPAIGN_META || typeof CURRENT_CAMPAIGN_META !== 'object') return null;
    const campaignActiveId = getCampaignTurnActiveId();
    if (campaignActiveId) {
      const fromCampaign = resolveBattleForEntity(campaignActiveId);
      if (fromCampaign) return fromCampaign;
    }

    const activeTokenId = getActiveTokenIdFromState(state);
    if (!activeTokenId) return null;
    const token = findTokenById(state, activeTokenId);
    const keys = [];
    if (token && token.character_id) keys.push(String(token.character_id));
    if (token && token.characterId) keys.push(String(token.characterId));
    keys.push(String(activeTokenId));

    for (const key of keys) {
      const resolved = resolveBattleForEntity(key);
      if (resolved) return resolved;
    }

    return null;
  }

  function switchBattleTo(battleId, campaignId) {
    const id = String(battleId || '').trim();
    if (!id) return;
    if (CURRENT_BATTLE_ID && String(CURRENT_BATTLE_ID) === id) return;
    const encId = encodeURIComponent(id);
    const cid = String(campaignId || CURRENT_CAMPAIGN_ID || '').trim();
    if (cid) {
      try { history.replaceState(null, '', '/play/c/' + encodeURIComponent(cid) + '?battle_id=' + encId); } catch {}
    } else {
      try { history.replaceState(null, '', '/play/' + encId); } catch {}
    }
    CURRENT_BATTLE_ID = id;
    STATE_URL = '/api/battles/' + encId;
    STATE_SOURCE = 'database';
    stopStatePolling();
    startStatePolling();
  }

  async function loadStateFromUrl(url, sourceLabel) {
    const u = String(url || '').trim();
    if (!u) throw new Error('Missing state URL');

    const got = await fetchStateOnce(u);
    if (!got) throw new Error('State fetch returned empty body');

      setCanonicalStateFromRaw(got.parsed, got.jsonText);
      if (got.battleId) CURRENT_BATTLE_ID = got.battleId;
      if (got.campaignId) CURRENT_CAMPAIGN_ID = got.campaignId;
      STATE_SOURCE = sourceLabel || stateSourceFromUrl(u);
    }

  function syncSourceSelect() {
    if (!elSourceSelect) return;
    const v = (STATE_SOURCE === 'embedded' || STATE_SOURCE === 'file' || STATE_SOURCE === 'database')
      ? STATE_SOURCE
      : 'database';
    if (document.activeElement !== elSourceSelect) elSourceSelect.value = v;
  }

  function resetPoiSelect() {
    if (!elPoiSelect) return;
    elPoiSelect.innerHTML = '<option value="">Select POI</option>';
    elPoiSelect.disabled = true;
  }

  async function applySourceSelection(source) {
    const s = String(source || '').toLowerCase();
    if (elError) { elError.hidden = true; elError.textContent = ''; }
    stopStatePolling();

    if (s === 'embedded') {
      STATE_URL = null;
      const raw = readEmbeddedWorld();
      if (!raw) {
        if (elError) {
          elError.hidden = false;
          elError.textContent = 'Embedded state not available.';
        }
        return;
      }
      setCanonicalStateFromRaw(raw, stableJsonTextFor(raw));
      STATE_SOURCE = 'embedded';
      setToolStatus('DB: not active');
      safeRedraw();
      syncSourceSelect();
      return;
    }

    if (s === 'file') {
      STATE_URL = null;
      try {
        const url = resolveFileUrl();
        await loadStateFromUrl(url, 'file');
        safeRedraw();
        setToolStatus('DB: not active');
      } catch (e) {
        if (elError) {
          elError.hidden = false;
          elError.textContent = 'File state error:' + String.fromCharCode(10) + String(e && e.message ? e.message : e);
        }
      }
      syncSourceSelect();
      return;
    }

    const dbUrl = resolveDatabaseUrl();
    if (!dbUrl) {
      if (elError) {
        elError.hidden = false;
        elError.textContent = 'Database state URL not available.';
      }
      return;
    }

    STATE_URL = dbUrl;
    STATE_SOURCE = 'database';
    startStatePolling();
    setToolStatus('DB: idle');
    syncSourceSelect();
  }

  async function pollStateLoop() {
    if (!STATE_URL) return;

    try {
      const got = await fetchStateOnce(STATE_URL);
      if (!got) return;

      // Only apply when the server payload changes.
        if (got.jsonText !== LAST_STATE_JSON) {
          applyFetchedState(got.parsed, got.jsonText, got.chatJson, got.battleId, got.campaignId);
          if (got.campaignId) await ensureCampaignMeta(got.campaignId);
          const targetBattle = resolveBattleForActiveToken(CURRENT_STATE);
          if (targetBattle && (!CURRENT_BATTLE_ID || String(CURRENT_BATTLE_ID) !== String(targetBattle))) {
            switchBattleTo(targetBattle, got.campaignId || CURRENT_CAMPAIGN_ID);
            return;
          }
          safeRedraw();
        }
        await pollMessagesOnce();
        updateStateDebug();
    } catch (e) {
      console.warn('[Battlemat] state poll error:', e);
      LAST_FETCH_ERROR = LAST_FETCH_ERROR || (e && e.message ? String(e.message) : 'fetch error');
      updateStateDebug();
      // Show last error in UI, but don't spam.
      if (elError) {
        elError.hidden = false;
        elError.textContent = 'State fetch error (polling paused):' + String.fromCharCode(10) + String(e && e.stack ? e.stack : e);
      }
      setToolStatus('DB: paused (error)', 'error');
      stopStatePolling();
    }
  }

  function startStatePolling() {
    const pollMs = resolvePollMs();
    if (!STATE_URL) return;

    // Always do one immediate fetch.
    pollStateLoop();

    if (pollMs <= 0) return;
    if (STATE_POLL_TIMER) clearInterval(STATE_POLL_TIMER);
    STATE_POLL_TIMER = setInterval(pollStateLoop, pollMs);
  }

  // ===== Editor helpers =====
  function setToolStatus(text, kind) {
    if (!elToolStatus) return;
    elToolStatus.textContent = String(text || '');
    elToolStatus.classList.remove('ok', 'error');
    if (kind === 'ok') elToolStatus.classList.add('ok');
    if (kind === 'error') elToolStatus.classList.add('error');
  }

  function updateStateDebug() {
    if (!elStateDebug) return;
    const source = STATE_SOURCE || 'n/a';
    const url = STATE_URL || LAST_FETCH_URL || 'n/a';
    const status = (LAST_FETCH_STATUS != null) ? String(LAST_FETCH_STATUS) : 'n/a';
    const err = LAST_FETCH_ERROR ? (' - ' + LAST_FETCH_ERROR) : '';
    elStateDebug.textContent = 'State: ' + source + ' | URL: ' + url + ' | Last: ' + status + err;
  }

  function setPlaytestMode(enabled) {
    const on = !!enabled;
    document.body.classList.toggle('playtest', on);
    if (elPlaytestToggle) elPlaytestToggle.checked = on;
    try { localStorage.setItem(STORAGE_PLAYTEST, on ? '1' : '0'); } catch {}
  }

  function readPlaytestMode() {
    try { return localStorage.getItem(STORAGE_PLAYTEST) === '1'; } catch { return false; }
  }

  function normalizeChatEntry(entry) {
      if (!entry || typeof entry !== 'object') return null;
      const speaker = entry.speaker != null ? String(entry.speaker) : '';
      const text = entry.text != null ? String(entry.text) : '';
      const id = entry.chat_id || entry.id || entry.chatId || entry.message_id || entry.messageId || null;
      let createdAt = Number(entry.created_at ?? entry.ts ?? entry.time ?? 0);
      if (!Number.isFinite(createdAt) || createdAt <= 0) createdAt = Math.floor(Date.now() / 1000);
      if (createdAt > 1e12) createdAt = Math.floor(createdAt / 1000);
      const ts = createdAt * 1000;
      if (!speaker && !text) return null;
      return {
        id: id ? String(id) : null,
        speaker,
        speaker_id: entry.speaker_id != null ? String(entry.speaker_id) : null,
        text,
        type: entry.type ? String(entry.type) : '',
        status: entry.status ? String(entry.status) : '',
        battle_id: entry.battle_id != null ? String(entry.battle_id) : null,
        campaign_id: entry.campaign_id != null ? String(entry.campaign_id) : null,
        created_at: createdAt,
        ts
      };
    }

    function normalizeSpeakerKey(name) {
      return String(name || '').trim().toLowerCase();
    }

    function getLatestActionBySpeaker() {
      const map = new Map();
      for (const entry of CHAT_LOG) {
        if (!entry || entry.type !== 'action') continue;
        const key = normalizeSpeakerKey(entry.speaker);
        if (!key) continue;
        const prev = map.get(key);
        if (!prev || (entry.created_at || 0) >= (prev.created_at || 0)) {
          map.set(key, entry);
        }
      }
      return map;
    }

    function mergeChatEntries(list, append) {
      const normalized = [];
      for (const entry of list) {
        const clean = normalizeChatEntry(entry);
        if (!clean) continue;
        if (append && clean.id && CHAT_ID_SET.has(clean.id)) continue;
        normalized.push(clean);
      }
      if (!append) {
        CHAT_LOG = [];
        CHAT_ID_SET = new Set();
      }
      for (const entry of normalized) {
        if (entry.id) CHAT_ID_SET.add(entry.id);
        CHAT_LOG.push(entry);
        if (entry.created_at > LAST_CHAT_TS) LAST_CHAT_TS = entry.created_at;
      }
      if (CHAT_LOG.length > 500) CHAT_LOG = CHAT_LOG.slice(-500);
      renderChatLog();
    }

    function getChatReadKey() {
      const bid = CURRENT_BATTLE_ID || resolveBattleIdFromUrl() || 'none';
      return STORAGE_CHAT_READ_PREFIX + bid;
    }

    function readChatReadTs() {
      try {
        const v = localStorage.getItem(getChatReadKey());
        const n = v ? Number(v) : 0;
        return Number.isFinite(n) ? n : 0;
      } catch {
        return 0;
      }
    }

    function setChatReadTs(tsSeconds) {
      const v = Math.max(0, Number(tsSeconds) || 0);
      try { localStorage.setItem(getChatReadKey(), String(v)); } catch {}
      updateChatUnreadIndicator();
    }

    function updateChatUnreadIndicator() {
      if (!elChatUnreadCount) return;
      const readTs = readChatReadTs();
      const unread = CHAT_LOG.filter(m => (m.created_at || 0) > readTs).length;
      if (unread > 0) {
        elChatUnreadCount.hidden = false;
        elChatUnreadCount.textContent = String(unread);
      } else {
        elChatUnreadCount.hidden = true;
        elChatUnreadCount.textContent = '0';
      }
    }

    function setChatLogFromMessages(list) {
      if (!Array.isArray(list)) {
        CHAT_LOG = [];
        CHAT_ID_SET = new Set();
        LAST_CHAT_TS = 0;
        renderChatLog();
        return;
      }
      mergeChatEntries(list, false);
    }

  function formatChatTime(ts) {
    const d = new Date(ts || Date.now());
    const hh = String(d.getHours()).padStart(2, '0');
    const mm = String(d.getMinutes()).padStart(2, '0');
    return `${hh}:${mm}`;
  }

  function summarizeChatText(text, limit = 140) {
    const raw = String(text || '');
    const firstLine = raw.split('\n')[0];
    if (raw.length <= limit && firstLine.length <= limit) return { preview: raw, collapsed: false };
    const preview = (firstLine.length > limit)
      ? firstLine.slice(0, limit - 1) + '…'
      : firstLine + (raw.length > firstLine.length ? '…' : '');
    return { preview, collapsed: true };
  }

  function renderChatLog() {
      if (!elChatLog) return;
      if (!CHAT_LOG.length) {
        elChatLog.innerHTML = '<div class="mini" style="opacity:0.7;">No chat yet.</div>';
        updateChatUnreadIndicator();
        return;
      }
      const readTs = readChatReadTs();
      elChatLog.innerHTML = CHAT_LOG.map(e => {
        const speakerKey = normalizeSpeakerKey(e.speaker || '');
        const speaker = escapeHtml(e.speaker || 'Unknown');
        const speakerClass = 'chatSpeaker' + (speakerKey === 'dm' ? ' dm' : '');
        const rawText = String(e.text || '');
        const safeText = escapeHtml(rawText);
        const summary = summarizeChatText(rawText, 180);
        const safePreview = escapeHtml(summary.preview || '');
        const unreadClass = (e.created_at || 0) > readTs ? ' unread' : '';
        const statusRaw = String(e.status || '').toLowerCase().replace(/[^a-z0-9_-]+/g, '');
        const statusClass = statusRaw ? (' ' + statusRaw) : '';
        const focusArrow = (statusRaw === 'processing') ? '<span class="chatFocusArrow" aria-hidden="true"></span>' : '';
        return '<div class="chatEntry' + unreadClass + statusClass + '">'
          + focusArrow
          + '<span class="' + speakerClass + '">' + speaker + ':</span>'
          + (summary.collapsed
            ? '<details class="chatDetails"><summary>'
                + '<span class="chatPreview">' + safePreview + '</span>'
                + '<span class="chatMore">(more)</span>'
              + '<span class="chatLess">(less)</span>'
            + '</summary>'
            + '<div class="chatFull">' + safeText + '</div>'
            + '</details>'
          : '<span class="chatText">' + safeText + '</span>')
          + '</div>';
      }).join('');
      elChatLog.scrollTop = elChatLog.scrollHeight;
      updateChatUnreadIndicator();
      if (CURRENT_STATE) {
        try {
          const render = buildRenderState(CURRENT_STATE);
          updateSidebar(CURRENT_STATE, render.floor, render.rooms, render.openings, render.objects, render.tokensAll || render.tokens);
        } catch {}
      }
    }

    function appendChatEntry(entry) {
      const clean = normalizeChatEntry(entry);
      if (!clean) return false;
      mergeChatEntries([clean], true);
      return true;
    }

    function upsertChatEntry(entry) {
      const clean = normalizeChatEntry(entry);
      if (!clean) return false;
      if (clean.id) {
        const idx = CHAT_LOG.findIndex(e => e && e.id && e.id === clean.id);
        if (idx !== -1) {
          CHAT_LOG[idx] = clean;
          renderChatLog();
          return true;
        }
      }
      return appendChatEntry(clean);
    }

    function resolveMessagesUrl(params = {}) {
      const campaignId = params.campaign_id || params.campaignId || CURRENT_CAMPAIGN_ID;
      const qs = [];
      if (campaignId) qs.push('campaign_id=' + encodeURIComponent(campaignId));
      if (params.since_ts) qs.push('since_ts=' + encodeURIComponent(params.since_ts));
      if (params.limit) qs.push('limit=' + encodeURIComponent(params.limit));
      if (!qs.length) return null;
      return '/api/messages?' + qs.join('&');
    }

    async function pollMessagesOnce() {
      if (STATE_SOURCE !== 'database') return false;
      const url = resolveMessagesUrl({ since_ts: LAST_CHAT_TS || null, limit: 200 });
      if (!url) return false;
      try {
        const res = await fetch(url, {
          method: 'GET',
          cache: 'no-store',
          headers: { 'accept': 'application/json', ...getAuthHeaders() },
        });
        if (!res.ok) throw new Error('Chat fetch failed: ' + res.status + ' ' + res.statusText);
        const data = await res.json().catch(() => null);
        const rows = (data && Array.isArray(data.rows)) ? data.rows
          : (Array.isArray(data) ? data : []);
        if (rows.length) mergeChatEntries(rows, true);
        return true;
      } catch (e) {
        console.warn('[Battlemat] chat fetch failed:', e);
        return false;
      }
    }

    async function sendChatMessage(entry) {
      if (STATE_SOURCE !== 'database') return false;
      const campaignId = CURRENT_CAMPAIGN_ID;
      if (!campaignId) return false;
      const textRaw = String(entry.text || '');
      const isAction = /^\s*dm\s*,/i.test(textRaw);
      const payload = {
        campaign_id: campaignId || null,
        speaker: entry.speaker || 'Player',
        speaker_id: entry.speaker_id || null,
        text: textRaw,
        type: entry.type || (entry.speaker === 'DM' ? 'dm' : (isAction ? 'action' : 'player')),
        status: entry.status || 'new',
      };
      try {
        const res = await fetch('/api/messages', {
          method: 'POST',
          headers: { 'content-type': 'application/json', 'accept': 'application/json', ...getAuthHeaders() },
          body: JSON.stringify(payload),
        });
        if (!res.ok) throw new Error('Chat send failed: ' + res.status + ' ' + res.statusText);
        const data = await res.json().catch(() => null);
        const row = data && (data.row || data.message || data);
        if (row && typeof row === 'object') appendChatEntry(row);
        return true;
      } catch (e) {
        console.warn('[Battlemat] chat send failed:', e);
        return false;
      }
    }

    async function updateMessageStatus(chatId, status) {
      if (!chatId) return false;
      try {
        const res = await fetch('/api/messages/' + encodeURIComponent(chatId), {
          method: 'PATCH',
          headers: { 'content-type': 'application/json', 'accept': 'application/json', ...getAuthHeaders() },
          body: JSON.stringify({ status }),
        });
        if (!res.ok) throw new Error('Chat update failed: ' + res.status + ' ' + res.statusText);
        const data = await res.json().catch(() => null);
        const row = data && (data.row || data.message || data);
        if (row && typeof row === 'object') upsertChatEntry(row);
        return true;
      } catch (e) {
        console.warn('[Battlemat] chat update failed:', e);
        return false;
      }
    }

  function getTokenDisplayName(token) {
    if (!token || typeof token !== 'object') return '';
    const meta = token.meta && typeof token.meta === 'object' ? token.meta : null;
    const sheet = token.sheet && typeof token.sheet === 'object' ? token.sheet : null;
    const identity = sheet && sheet.identity && typeof sheet.identity === 'object' ? sheet.identity : null;
    const nickname = normStr(token.nickname || (meta && meta.nickname) || (identity && identity.nickname) || '');
    const name = normStr(token.name || token.label || token.id || '');
    return nickname || name;
  }

  function populateChatSpeakerSelect(state) {
    if (!elChatSpeaker) return;
    const tokens = normalizeTokenCharacterIds(getTokensArray(state)).filter(t => t && t.id);
    const names = [];
    for (const t of tokens) {
      const name = getTokenDisplayName(t);
      if (name && !names.includes(name)) names.push(name);
    }
    if (!names.includes('DM')) names.unshift('DM');
    if (!names.includes('Player')) names.push('Player');

    const active = document.activeElement === elChatSpeaker;
    if (!active) {
      elChatSpeaker.innerHTML = names.map(n => '<option value="' + escapeHtml(n) + '">' + escapeHtml(n) + '</option>').join('');
    }
  }

  function syncEditorButtons() {
    if (elToolSelect) elToolSelect.classList.toggle('active', EDITOR.tool === 'select');
    if (elToolRoom) elToolRoom.classList.toggle('active', EDITOR.tool === 'room');
    if (elToolDoor) elToolDoor.classList.toggle('active', EDITOR.tool === 'door');
    if (elToolWindow) elToolWindow.classList.toggle('active', EDITOR.tool === 'window');
    if (elToolObject) elToolObject.classList.toggle('active', EDITOR.tool === 'object');
    if (elToolDelete) elToolDelete.classList.toggle('active', EDITOR.tool === 'delete');
  }

  function resolveEditorFocus() {
    if (EDITOR.selectedObjectId) return 'object';
    if (EDITOR.selectedRoomId) return 'room';
    if (EDITOR.selectedId) return 'opening';
    if (EDITOR.tool === 'object') return 'object';
    if (EDITOR.tool === 'room') return 'room';
    if (EDITOR.tool === 'door' || EDITOR.tool === 'window') return 'opening';
    return null;
  }

  function updateEditorPanelVisibility() {
    const focus = resolveEditorFocus();
    if (elEditorSectionObject) elEditorSectionObject.hidden = focus !== 'object';
    if (elEditorSectionOpening) elEditorSectionOpening.hidden = focus !== 'opening';
    if (elEditorSectionRoom) elEditorSectionRoom.hidden = focus !== 'room';
    if (elEditorSectionOrder) elEditorSectionOrder.hidden = false;
  }

  function setEditorTool(tool) {
    const t = (tool === 'door' || tool === 'window' || tool === 'room' || tool === 'object' || tool === 'delete' || tool === 'select') ? tool : 'select';
    EDITOR.tool = t;
    EDITOR.preview = null;
    EDITOR.objectPreview = null;
    EDITOR.roomStart = null;
    EDITOR.roomPreview = null;
    syncEditorButtons();
    updateEditorPanelVisibility();
    safeRedraw();
  }

  function sanitizeSceneForUndo(scene) {
    const out = cloneDeepSafe(scene);
    delete out.__hydratedObjectsFlat;
    delete out.__activeRecordId;
    delete out.__worldName;
    delete out.objects;
    delete out.rooms;
    delete out.openings;
    return out;
  }

  function captureUndoSnapshot(reason) {
    if (EDITOR.undoLock) return;
    const state = getState();
    if (!state || typeof state !== 'object') return;
    const recordId = state.__activeRecordId ? String(state.__activeRecordId) : '';
    EDITOR.undoSnapshot = {
      recordId,
      scene: sanitizeSceneForUndo(state),
      reason: String(reason || ''),
      ts: Date.now(),
    };
  }

  function beginUndoBatch(reason) {
    if (!EDITOR.undoLock) captureUndoSnapshot(reason);
    EDITOR.undoLock = true;
  }

  function endUndoBatch() {
    EDITOR.undoLock = false;
  }

  function applyUndoSnapshot() {
    const snap = EDITOR.undoSnapshot;
    if (!snap || !snap.scene) {
      setToolStatus('Undo: none', 'error');
      return false;
    }
    const scene = sanitizeSceneForUndo(snap.scene);
    if (snap.recordId && WORLD_STATE && WORLD_STATE.records) {
      WORLD_STATE.records[snap.recordId] = scene;
      if (!WORLD_STATE.active || typeof WORLD_STATE.active !== 'object') WORLD_STATE.active = {};
      WORLD_STATE.active.recordId = snap.recordId;
      if (scene.view && scene.view.floorId) WORLD_STATE.active.floorId = String(scene.view.floorId);
      if (scene.view && scene.view.camera_hex) WORLD_STATE.active.camera_hex = String(scene.view.camera_hex);
      setCanonicalStateFromRaw(WORLD_STATE, stableJsonTextFor(WORLD_STATE));
    } else {
      setCanonicalStateFromRaw(scene, stableJsonTextFor(scene));
    }
    EDITOR.undoSnapshot = null;
    setToolStatus('Undo: ok', 'ok');
    safeRedraw();
    if (STATE_SOURCE === 'database') scheduleDatabaseSave();
    return true;
  }

  function screenToWorld(p) {
    const cam = cameraWorld();
    return { x: cam.x + (p.x - VIEW.anchor.x), y: cam.y + (p.y - VIEW.anchor.y) };
  }

  function eventToWorld(ev) {
    const rect = canvas.getBoundingClientRect();
    const x = ev.clientX - rect.left;
    const y = ev.clientY - rect.top;
    return screenToWorld({ x, y });
  }

  function roundStep(v, step) {
    const s = Number(step);
    if (!Number.isFinite(s) || s <= 0) return v;
    return Math.round(v / s) * s;
  }

  function roundQuarter(v) { return Math.round(v * 4) / 4; }

  function formatStep(v) {
    const s = roundQuarter(v).toFixed(2);
    return s.replace(/\.00$/, '').replace(/(\.\d)0$/, '$1');
  }

  function formatCornerStep(v) {
    const s = Number(v).toFixed(2);
    return s.replace(/\.00$/, '').replace(/(\.\d)0$/, '$1');
  }

  function openingHexFromWorld(world) {
    const size = GRID.size || 1;
    const qf = (2 / 3) * (world.x / size);
    const rf = ((-world.y) / size) / sqrt3 - (qf / 2);
    const q = Math.round(qf);
    const rowf = rf + (q - (q & 1)) / 2;
    const row = roundQuarter(rowf);
    return { col: q, row };
  }

  function openingHexLabelFromCoords(col, row) {
    if (!Number.isFinite(col) || !Number.isFinite(row)) return null;
    const rowNum = row + 1;
    return colToLetters(col) + formatStep(rowNum);
  }

  function cornerHexLabelFromCoords(col, row) {
    if (!Number.isFinite(col) || !Number.isFinite(row)) return null;
    const rowNum = row + 1;
    return colToLetters(col) + formatCornerStep(rowNum);
  }

  function wallSegDistance2(seg, p) {
    if (!seg) return Infinity;
    if (seg.orientation === 'h') {
      const dy = Math.abs((p && p.y) - seg.y);
      let dx = 0;
      if ((p && p.x) < seg.x1) dx = seg.x1 - (p.x);
      else if ((p && p.x) > seg.x2) dx = (p.x) - seg.x2;
      return dx * dx + dy * dy;
    }
    const dx = Math.abs((p && p.x) - seg.x);
    let dy = 0;
    if ((p && p.y) < seg.y1) dy = seg.y1 - (p.y);
    else if ((p && p.y) > seg.y2) dy = (p.y) - seg.y2;
    return dx * dx + dy * dy;
  }

  function projectToWall(seg, p) {
    if (!seg) return null;
    if (seg.orientation === 'h') {
      return { x: clamp(p.x, seg.x1, seg.x2), y: seg.y };
    }
    return { x: seg.x, y: clamp(p.y, seg.y1, seg.y2) };
  }

  function pickBestWallSegment(wallSegs, p) {
    const h = findNearestWallSegment(wallSegs, 'h', p);
    const v = findNearestWallSegment(wallSegs, 'v', p);
    const dh = wallSegDistance2(h, p);
    const dv = wallSegDistance2(v, p);
    if (!h && !v) return null;
    return (dh <= dv) ? h : v;
  }

  function getEditorContext() {
    const state = getState();
    const render = buildRenderState(state);
    const rooms = Array.isArray(render.rooms) ? render.rooms : [];
    let openings = Array.isArray(render.floor && render.floor.openings) ? render.floor.openings : [];
    if (render.floor && render.floor.openings !== openings) render.floor.openings = openings;
    const wallSegs = dedupeWallSegments(buildWallSegments(rooms));
    return { state, ...render, openings, wallSegs };
  }

  function computeDoorPlacement(world, ctx) {
    if (!ctx || !ctx.wallSegs || !ctx.wallSegs.length) return null;
    const seg = pickBestWallSegment(ctx.wallSegs, world);
    if (!seg) return null;
    const maxDist = GRID.size * 1.5;
    if (wallSegDistance2(seg, world) > (maxDist * maxDist)) return null;
    const proj = projectToWall(seg, world);
    if (!proj) return null;
    const hex = openingHexFromWorld(proj);
    const label = openingHexLabelFromCoords(hex.col, hex.row);
    if (!label) return null;
    return { hex: label, orientation: seg.orientation };
  }

  function openingWorldCenter(opening, wallSegs) {
    const p = parseOpeningHex(opening && opening.hex);
    if (!p) return null;
    const hexWorld = hexCenterWorld(p.col, p.row);
    const orient = openingOrientation(opening);
    const seg = findNearestWallSegment(wallSegs, orient, hexWorld);
    let cx = hexWorld.x;
    let cy = hexWorld.y;
    if (seg) {
      if (orient === 'h') cy = seg.y;
      else cx = seg.x;
    }
    return { x: cx, y: cy };
  }

  function ensureOpeningId(opening) {
    if (!opening || opening.id) return opening && opening.id;
    opening.id = 'opening_' + Date.now().toString(36) + '_' + Math.floor(Math.random() * 1e4).toString(36);
    return opening.id;
  }

  function findOpeningNear(world, ctx, maxDist) {
    const openings = Array.isArray(ctx && ctx.openings) ? ctx.openings : [];
    const wallSegs = ctx && ctx.wallSegs ? ctx.wallSegs : [];
    const limit = Number.isFinite(maxDist) ? maxDist : (GRID.size * 0.85);
    const limit2 = limit * limit;
    let best = null;
    let bestD2 = Infinity;
    for (const o of openings) {
      const c = openingWorldCenter(o, wallSegs);
      if (!c) continue;
      const dx = c.x - world.x;
      const dy = c.y - world.y;
      const d2 = dx * dx + dy * dy;
      if (d2 <= limit2 && d2 < bestD2) {
        best = o;
        bestD2 = d2;
      }
    }
    return best;
  }

  function findObjectNear(world, ctx, maxDist) {
    const objects = Array.isArray(ctx && ctx.objects) ? ctx.objects : [];
    const limit = Number.isFinite(maxDist) ? maxDist : (GRID.size * 0.9);
    const limit2 = limit * limit;
    let best = null;
    let bestD2 = Infinity;
    for (const o of objects) {
      const c = objectCenterWorld(o);
      if (!c) continue;
      const dx = c.x - world.x;
      const dy = c.y - world.y;
      const d2 = dx * dx + dy * dy;
      if (d2 <= limit2 && d2 < bestD2) {
        best = o;
        bestD2 = d2;
      }
    }
    return best;
  }

  function findTokenNear(world, ctx, maxDist) {
    const tokens = Array.isArray(ctx && ctx.tokens) ? ctx.tokens : [];
    const limit = Number.isFinite(maxDist) ? maxDist : (GRID.size * 0.9);
    const limit2 = limit * limit;
    let best = null;
    let bestD2 = Infinity;
    for (const t of tokens) {
      if (!t || !t.hex) continue;
      const p = parseHexId(t.hex);
      if (!p) continue;
      const c = hexCenterWorld(p.col, p.row);
      const dx = c.x - world.x;
      const dy = c.y - world.y;
      const d2 = dx * dx + dy * dy;
      if (d2 <= limit2 && d2 < bestD2) {
        best = t;
        bestD2 = d2;
      }
    }
    return best;
  }

  function findRoomAtWorld(world, ctx) {
    const rooms = Array.isArray(ctx && ctx.rooms) ? ctx.rooms : [];
    if (!rooms.length) return null;
    let meta = null;
    try {
      meta = buildRoomMeta(rooms);
    } catch {
      meta = null;
    }
    if (!meta) return null;
    const rid = pickRoomAtWorldPoint(meta, world);
    if (!rid) return null;
    return rooms.find(r => r && String(r.id) === String(rid)) || null;
  }

  function roomHexFromWorld(world) {
    const hex = openingHexFromWorld(world);
    if (!hex || !Number.isFinite(hex.col) || !Number.isFinite(hex.row)) return null;
    return { col: hex.col, row: roundQuarter(hex.row) };
  }

  function objectHexFromWorld(world) {
    const hex = openingHexFromWorld(world);
    if (!hex || !Number.isFinite(hex.col) || !Number.isFinite(hex.row)) return null;
    const label = openingHexLabelFromCoords(hex.col, hex.row);
    if (!label) return null;
    return { col: hex.col, row: roundQuarter(hex.row), label };
  }

  function roomCornersFromHexes(a, b) {
    if (!a || !b) return null;
    const minCol = Math.min(a.col, b.col);
    const maxCol = Math.max(a.col, b.col);
    const minRow = Math.min(a.row, b.row);
    const maxRow = Math.max(a.row, b.row);
    if (!Number.isFinite(minCol) || !Number.isFinite(maxCol) || !Number.isFinite(minRow) || !Number.isFinite(maxRow)) return null;
    if (Math.abs(maxCol - minCol) < 1e-6 || Math.abs(maxRow - minRow) < 1e-6) return null;
    const tl = openingHexLabelFromCoords(minCol, maxRow);
    const tr = openingHexLabelFromCoords(maxCol, maxRow);
    const br = openingHexLabelFromCoords(maxCol, minRow);
    const bl = openingHexLabelFromCoords(minCol, minRow);
    if (!tl || !tr || !br || !bl) return null;
    return [tl, tr, br, bl];
  }

  function roomDefaultsFor(ctx) {
    const rooms = Array.isArray(ctx && ctx.rooms) ? ctx.rooms : [];
    const last = rooms.length ? rooms[rooms.length - 1] : null;
    const thickness = numOr(last && last.thickness, 15);
    const floorKind = (last && last.floor && last.floor.kind) ? String(last.floor.kind) : 'wood';
    const wallKind = (last && last.wall && last.wall.kind) ? String(last.wall.kind) : 'brick';
    return { thickness, floorKind, wallKind };
  }

  function buildRoomPreview(ctx, startHex, endHex) {
    const corners = roomCornersFromHexes(startHex, endHex);
    if (!corners) return null;
    const defaults = roomDefaultsFor(ctx);
    return {
      id: '__preview_room',
      corners,
      thickness: defaults.thickness,
      floor: { kind: defaults.floorKind },
      wall: { kind: defaults.wallKind },
    };
  }

  function addRoomAtCorners(ctx, corners) {
    if (!ctx || !ctx.floor || !Array.isArray(corners) || corners.length !== 4) return null;
    if (!Array.isArray(ctx.floor.rooms)) ctx.floor.rooms = [];
    const rooms = ctx.floor.rooms;
    const defaults = roomDefaultsFor(ctx);
    const room = {
      id: 'room_' + Date.now().toString(36) + '_' + Math.floor(Math.random() * 1e4).toString(36),
      corners: corners.slice(),
      thickness: defaults.thickness,
      floor: { kind: defaults.floorKind },
      wall: { kind: defaults.wallKind },
      z: nextRoomZ(rooms),
    };
    rooms.push(room);
    return room;
  }

  function clearEditorPendingDeletes() {
    EDITOR.deletedOpeningsByFloor = {};
    EDITOR.deletedObjectsByFloor = {};
    EDITOR.deletedRoomsByFloor = {};
    EDITOR.deletedTokens = {};
  }

  function trackOpeningDelete(ctx, opening) {
    const floorId = ctx && ctx.floorId ? String(ctx.floorId) : '';
    const openingId = opening && opening.id ? String(opening.id) : '';
    if (!floorId || !openingId) return;
    if (!EDITOR.deletedOpeningsByFloor || typeof EDITOR.deletedOpeningsByFloor !== 'object') {
      EDITOR.deletedOpeningsByFloor = {};
    }
    const bucket = EDITOR.deletedOpeningsByFloor;
    if (!bucket[floorId]) bucket[floorId] = {};
    bucket[floorId][openingId] = true;
  }

  function trackObjectDelete(ctx, object) {
    const floorId = ctx && ctx.floorId ? String(ctx.floorId) : '';
    const objectId = object && object.id ? String(object.id) : '';
    if (!floorId || !objectId) return;
    if (!EDITOR.deletedObjectsByFloor || typeof EDITOR.deletedObjectsByFloor !== 'object') {
      EDITOR.deletedObjectsByFloor = {};
    }
    const bucket = EDITOR.deletedObjectsByFloor;
    if (!bucket[floorId]) bucket[floorId] = {};
    bucket[floorId][objectId] = true;
  }

  function trackRoomDelete(ctx, room) {
    const floorId = ctx && ctx.floorId ? String(ctx.floorId) : '';
    const roomId = room && room.id ? String(room.id) : '';
    if (!floorId || !roomId) return;
    if (!EDITOR.deletedRoomsByFloor || typeof EDITOR.deletedRoomsByFloor !== 'object') {
      EDITOR.deletedRoomsByFloor = {};
    }
    const bucket = EDITOR.deletedRoomsByFloor;
    if (!bucket[floorId]) bucket[floorId] = {};
    bucket[floorId][roomId] = true;
  }

  function trackTokenDelete(token) {
    const tokenId = token && token.id ? String(token.id) : '';
    if (!tokenId) return;
    if (!EDITOR.deletedTokens || typeof EDITOR.deletedTokens !== 'object') {
      EDITOR.deletedTokens = {};
    }
    EDITOR.deletedTokens[tokenId] = true;
  }

  function syncOpeningSelectedLabel(opening) {
    if (!elOpeningSelected) return;
    if (!opening) {
      elOpeningSelected.textContent = 'Selected: none';
      return;
    }
    const kind = opening.kind ? String(opening.kind) : 'opening';
    const id = opening.id ? String(opening.id) : 'opening';
    elOpeningSelected.textContent = 'Selected: ' + kind + ' (' + id + ')';
  }

  function clearSelectedOpening() {
    EDITOR.selectedId = null;
    EDITOR.selectedFloorId = null;
    syncOpeningSelectedLabel(null);
    syncOpeningControlsFromOpening(null);
    updateEditorPanelVisibility();
  }

  function setSelectedOpening(opening, floorId) {
    if (!opening) {
      clearSelectedOpening();
      return;
    }
    EDITOR.selectedObjectId = null;
    EDITOR.selectedObjectFloorId = null;
    EDITOR.selectedRoomId = null;
    EDITOR.selectedRoomFloorId = null;
    syncObjectSelectedLabel(null);
    syncRoomSelectedLabel(null);
    EDITOR.selectedId = ensureOpeningId(opening);
    EDITOR.selectedFloorId = floorId || null;
    syncOpeningSelectedLabel(opening);
    syncOpeningControlsFromOpening(opening);
    updateEditorPanelVisibility();
  }

  function getSelectedOpening(ctx) {
    if (!ctx || !ctx.openings || !EDITOR.selectedId) return null;
    if (EDITOR.selectedFloorId && ctx.floorId && EDITOR.selectedFloorId !== ctx.floorId) return null;
    return ctx.openings.find(o => o && o.id === EDITOR.selectedId) || null;
  }

  function ensureObjectId(object) {
    if (!object) return '';
    if (object.id) return object.id;
    object.id = 'object_' + Date.now().toString(36) + '_' + Math.floor(Math.random() * 1e4).toString(36);
    return object.id;
  }

  function objectZValue(object) {
    const z = object && object.z;
    return Number.isFinite(Number(z)) ? Number(z) : null;
  }

  function assignSequentialObjectZ(objects) {
    for (let i = 0; i < objects.length; i++) {
      const o = objects[i];
      if (!o || typeof o !== 'object') continue;
      o.z = i;
    }
  }

  function nextObjectZ(objects) {
    let maxZ = -Infinity;
    let hasZ = false;
    for (const o of objects) {
      const z = objectZValue(o);
      if (z == null) continue;
      hasZ = true;
      if (z > maxZ) maxZ = z;
    }
    if (!hasZ) return objects.length;
    return maxZ + 1;
  }

  function sortObjectsForRender(objects) {
    const list = Array.isArray(objects) ? objects.slice() : [];
    if (!list.length) return list;
    let hasZ = false;
    for (const o of list) {
      if (objectZValue(o) != null) { hasZ = true; break; }
    }
    if (!hasZ) return list;
    return list
      .map((o, idx) => ({ o, idx, z: objectZValue(o) }))
      .sort((a, b) => {
        const az = (a.z != null) ? a.z : a.idx;
        const bz = (b.z != null) ? b.z : b.idx;
        if (az !== bz) return az - bz;
        return a.idx - b.idx;
      })
      .map(entry => entry.o);
  }

  function roomZValue(room) {
    const z = room && room.z;
    return Number.isFinite(Number(z)) ? Number(z) : null;
  }

  function assignSequentialRoomZ(rooms) {
    for (let i = 0; i < rooms.length; i++) {
      const r = rooms[i];
      if (!r || typeof r !== 'object') continue;
      r.z = i;
    }
  }

  function nextRoomZ(rooms) {
    let maxZ = -Infinity;
    let hasZ = false;
    for (const r of rooms) {
      const z = roomZValue(r);
      if (z == null) continue;
      hasZ = true;
      if (z > maxZ) maxZ = z;
    }
    if (!hasZ) return rooms.length;
    return maxZ + 1;
  }

  function sortRoomsForRender(rooms) {
    const list = Array.isArray(rooms) ? rooms.slice() : [];
    if (!list.length) return list;
    let hasZ = false;
    for (const r of list) {
      if (roomZValue(r) != null) { hasZ = true; break; }
    }
    if (!hasZ) return list;
    return list
      .map((r, idx) => ({ r, idx, z: roomZValue(r) }))
      .sort((a, b) => {
        const az = (a.z != null) ? a.z : a.idx;
        const bz = (b.z != null) ? b.z : b.idx;
        if (az !== bz) return az - bz;
        return a.idx - b.idx;
      })
      .map(entry => entry.r);
  }

  function syncObjectSelectedLabel(object) {
    if (!elObjectSelected) return;
    if (!object) {
      elObjectSelected.textContent = 'Selected: none';
      return;
    }
    const kind = object.kind ? String(object.kind) : 'object';
    const id = object.id ? String(object.id) : 'object';
    elObjectSelected.textContent = 'Selected: ' + kind + ' (' + id + ')';
  }

  function clearSelectedObject() {
    EDITOR.selectedObjectId = null;
    EDITOR.selectedObjectFloorId = null;
    syncObjectSelectedLabel(null);
    updateEditorPanelVisibility();
  }

  function setSelectedObject(object, floorId) {
    if (!object) {
      clearSelectedObject();
      return;
    }
    EDITOR.selectedId = null;
    EDITOR.selectedFloorId = null;
    EDITOR.selectedRoomId = null;
    EDITOR.selectedRoomFloorId = null;
    syncOpeningSelectedLabel(null);
    syncOpeningControlsFromOpening(null);
    EDITOR.selectedObjectId = ensureObjectId(object);
    EDITOR.selectedObjectFloorId = floorId || null;
    syncObjectSelectedLabel(object);
    syncObjectControlsFromObject(object);
    updateEditorPanelVisibility();
  }

  function syncRoomSelectedLabel(room) {
    if (!elRoomSelected) return;
    if (!room) {
      elRoomSelected.textContent = 'Selected: none';
      return;
    }
    const id = room.id ? String(room.id) : 'room';
    elRoomSelected.textContent = 'Selected: ' + id;
  }

  function clearSelectedRoom() {
    EDITOR.selectedRoomId = null;
    EDITOR.selectedRoomFloorId = null;
    syncRoomSelectedLabel(null);
    updateEditorPanelVisibility();
  }

  function setSelectedRoom(room, floorId) {
    if (!room) {
      clearSelectedRoom();
      return;
    }
    EDITOR.selectedId = null;
    EDITOR.selectedFloorId = null;
    EDITOR.selectedObjectId = null;
    EDITOR.selectedObjectFloorId = null;
    syncObjectSelectedLabel(null);
    syncOpeningSelectedLabel(null);
    syncOpeningControlsFromOpening(null);
    EDITOR.selectedRoomId = String(room.id || '');
    EDITOR.selectedRoomFloorId = floorId || null;
    syncRoomSelectedLabel(room);
    syncRoomControlsFromRoom(room);
    updateEditorPanelVisibility();
  }

  function getSelectedRoom(ctx) {
    if (!ctx || !ctx.rooms || !EDITOR.selectedRoomId) return null;
    if (EDITOR.selectedRoomFloorId && ctx.floorId && EDITOR.selectedRoomFloorId !== ctx.floorId) return null;
    return ctx.rooms.find(r => r && String(r.id) === String(EDITOR.selectedRoomId)) || null;
  }

  function getSelectedObject(ctx) {
    if (!ctx || !ctx.objects || !EDITOR.selectedObjectId) return null;
    if (EDITOR.selectedObjectFloorId && ctx.floorId && EDITOR.selectedObjectFloorId !== ctx.floorId) return null;
    return ctx.objects.find(o => o && o.id === EDITOR.selectedObjectId) || null;
  }

  function normalizeObjectControlValues(values) {
    const v = values || {};
    const kind = String(v.kind != null ? v.kind : (EDITOR.objectKind || 'object')).trim().toLowerCase() || 'object';
    const rotDeg = Number.isFinite(Number(v.rotDeg)) ? Number(v.rotDeg) : (Number.isFinite(EDITOR.objectRotDeg) ? EDITOR.objectRotDeg : 0);
    const oxRaw = Number.isFinite(Number(v.ox)) ? Number(v.ox) : (Number.isFinite(EDITOR.objectOx) ? EDITOR.objectOx : 0);
    const oyRaw = Number.isFinite(Number(v.oy)) ? Number(v.oy) : (Number.isFinite(EDITOR.objectOy) ? EDITOR.objectOy : 0);
    const scaleRaw = Number.isFinite(Number(v.scale)) ? Number(v.scale) : (Number.isFinite(EDITOR.objectScale) ? EDITOR.objectScale : 1);
    return {
      kind,
      rotDeg,
      ox: roundStep(oxRaw, 0.05),
      oy: roundStep(oyRaw, 0.05),
      scale: scaleRaw,
    };
  }

  function normalizeOpeningKindValue(kind) {
    const k = normKind(kind, '');
    if (!k) return '';
    if (k === 'door' || k.startsWith('door') || k.startsWith('door_') || k.startsWith('door.')) return normDoorKind(k);
    return k;
  }

  function setOpeningControls(values) {
    const v = values || {};
    EDITOR.openingUiLock = true;
    if (elOpeningKind) elOpeningKind.value = v.kind != null ? String(v.kind) : '';
    if (elOpeningHex) elOpeningHex.value = v.hex != null ? String(v.hex) : '';
    if (elOpeningOrientation) elOpeningOrientation.value = v.orientation != null ? String(v.orientation) : 'h';
    if (elOpeningOpenPct) elOpeningOpenPct.value = v.openPct != null ? String(v.openPct) : '';
    if (elOpeningHinge) elOpeningHinge.value = v.hinge != null ? String(v.hinge) : '';
    if (elOpeningSwing) elOpeningSwing.value = v.swing != null ? String(v.swing) : '';
    EDITOR.openingUiLock = false;
  }

  function readOpeningControls() {
    return {
      kind: elOpeningKind ? String(elOpeningKind.value || '').trim() : '',
      hex: elOpeningHex ? String(elOpeningHex.value || '').trim() : '',
      orientation: elOpeningOrientation ? String(elOpeningOrientation.value || '').trim() : '',
      openPct: elOpeningOpenPct ? String(elOpeningOpenPct.value || '').trim() : '',
      hinge: elOpeningHinge ? String(elOpeningHinge.value || '').trim() : '',
      swing: elOpeningSwing ? String(elOpeningSwing.value || '').trim() : '',
    };
  }

  function syncOpeningControlsFromOpening(opening) {
    if (!opening) {
      setOpeningControls({ kind: '', hex: '', orientation: 'h', openPct: '', hinge: '', swing: '' });
      return;
    }
    const kind = normalizeOpeningKindValue(opening.kind || 'door.wood') || 'door.wood';
    const hex = opening.hex != null ? String(opening.hex) : '';
    const orientation = openingOrientation(opening);
    const openPct = Number.isFinite(Number(opening.openPct)) ? Number(opening.openPct) : 0;
    const hinge = opening.hinge != null ? String(opening.hinge) : '';
    const swing = opening.swing != null ? String(opening.swing) : '';
    setOpeningControls({
      kind,
      hex,
      orientation,
      openPct,
      hinge,
      swing,
    });
  }

  function applyOpeningControlsToSelection(ctx, values) {
    const sel = ctx ? getSelectedOpening(ctx) : null;
    if (!sel) return false;

    const kindRaw = String(values.kind || '').trim();
    const hexRaw = String(values.hex || '').trim();
    const orientRaw = String(values.orientation || '').trim();
    const openPctRaw = String(values.openPct != null ? values.openPct : '').trim();
    const hingeRaw = String(values.hinge || '').trim();
    const swingRaw = String(values.swing != null ? values.swing : '').trim();

    let changed = false;

    if (kindRaw) {
      const nextKind = normalizeOpeningKindValue(kindRaw);
      if (nextKind && nextKind !== sel.kind) {
        sel.kind = nextKind;
        changed = true;
      }
    }

    if (hexRaw) {
      try {
        parseOpeningHex(hexRaw);
        const nextHex = hexRaw.toUpperCase();
        if (sel.hex !== nextHex) {
          sel.hex = nextHex;
          changed = true;
        }
      } catch {
        syncOpeningControlsFromOpening(sel);
        return false;
      }
    }

    if (orientRaw) {
      const nextOrient = normOrient(orientRaw);
      if (nextOrient !== sel.orientation) {
        sel.orientation = nextOrient;
        changed = true;
      }
    }

    if (openPctRaw !== '') {
      const nextOpen = clamp(Number(openPctRaw), 0, 1);
      if (Number.isFinite(nextOpen) && Number(nextOpen) !== Number(sel.openPct)) {
        sel.openPct = nextOpen;
        changed = true;
      }
    }

    if (hingeRaw !== '') {
      const nextHinge = hingeRaw.toLowerCase();
      if (nextHinge !== sel.hinge) {
        sel.hinge = nextHinge;
        changed = true;
      }
    } else if (sel.hinge != null && sel.hinge !== '') {
      delete sel.hinge;
      changed = true;
    }

    if (swingRaw !== '') {
      const nextSwing = Number(swingRaw);
      if (Number.isFinite(nextSwing) && Number(nextSwing) !== Number(sel.swing)) {
        sel.swing = nextSwing;
        changed = true;
      }
    } else if (sel.swing != null && sel.swing !== '') {
      delete sel.swing;
      changed = true;
    }

    if (!changed) {
      syncOpeningControlsFromOpening(sel);
      return false;
    }

    captureUndoSnapshot('edit opening');
    syncOpeningSelectedLabel(sel);
    scheduleDatabaseSave();
    safeRedraw();
    return true;
  }

  function updateOpeningControlsFromInputs() {
    if (EDITOR.openingUiLock) return;
    const ctx = getEditorContext();
    const sel = getSelectedOpening(ctx);
    if (!sel) return;
    const values = readOpeningControls();
    applyOpeningControlsToSelection(ctx, values);
  }

  function syncRoomControlsFromRoom(room) {
    if (!room) return;
    const corners = Array.isArray(room.corners) ? room.corners : [];
    let tl = '';
    let br = '';
    if (corners.length >= 4) {
      tl = String(corners[0] ?? '');
      br = String(corners[2] ?? '');
    } else if (corners.length >= 2) {
      tl = String(corners[0] ?? '');
      br = String(corners[corners.length - 1] ?? '');
    }
    if (!tl || !br) {
      let minCol = Infinity, maxCol = -Infinity, minRow = Infinity, maxRow = -Infinity;
      for (const c of corners) {
        try {
          const p = parseCornerHexId(c);
          minCol = Math.min(minCol, p.col);
          maxCol = Math.max(maxCol, p.col);
          minRow = Math.min(minRow, p.row);
          maxRow = Math.max(maxRow, p.row);
        } catch {}
      }
      if (Number.isFinite(minCol) && Number.isFinite(maxCol) && Number.isFinite(minRow) && Number.isFinite(maxRow)) {
        tl = cornerHexLabelFromCoords(minCol, maxRow) || '';
        br = cornerHexLabelFromCoords(maxCol, minRow) || '';
      }
    }

    const floorKind = room && room.floor && room.floor.kind ? String(room.floor.kind) : '';
    const wallKind = room && room.wall && room.wall.kind ? String(room.wall.kind) : '';
    const thickness = Number.isFinite(Number(room && room.thickness)) ? Number(room.thickness) : 0;

    EDITOR.roomUiLock = true;
    if (elRoomCornerTL) elRoomCornerTL.value = tl;
    if (elRoomCornerBR) elRoomCornerBR.value = br;
    if (elRoomFloorKind) elRoomFloorKind.value = floorKind;
    if (elRoomWallKind) elRoomWallKind.value = wallKind;
    if (elRoomThickness) elRoomThickness.value = String(thickness);
    EDITOR.roomUiLock = false;
  }

  function readRoomControls() {
    return {
      tl: elRoomCornerTL ? String(elRoomCornerTL.value || '').trim() : '',
      br: elRoomCornerBR ? String(elRoomCornerBR.value || '').trim() : '',
      floorKind: elRoomFloorKind ? String(elRoomFloorKind.value || '').trim() : '',
      wallKind: elRoomWallKind ? String(elRoomWallKind.value || '').trim() : '',
      thickness: elRoomThickness ? elRoomThickness.value : '',
    };
  }

  function computeRoomCornersFromTwoPoints(tlStr, brStr) {
    if (!tlStr || !brStr) return null;
    let tl = null;
    let br = null;
    try { tl = parseCornerHexId(tlStr); } catch {}
    try { br = parseCornerHexId(brStr); } catch {}
    if (!tl || !br) return null;
    const minCol = Math.min(tl.col, br.col);
    const maxCol = Math.max(tl.col, br.col);
    const minRow = Math.min(tl.row, br.row);
    const maxRow = Math.max(tl.row, br.row);
    const c0 = cornerHexLabelFromCoords(minCol, maxRow);
    const c1 = cornerHexLabelFromCoords(maxCol, maxRow);
    const c2 = cornerHexLabelFromCoords(maxCol, minRow);
    const c3 = cornerHexLabelFromCoords(minCol, minRow);
    if (!c0 || !c1 || !c2 || !c3) return null;
    return [c0, c1, c2, c3];
  }

  function applyRoomControlsToSelection(ctx, values) {
    const sel = ctx ? getSelectedRoom(ctx) : null;
    if (!sel) return false;
    const tl = String(values.tl || '').trim();
    const br = String(values.br || '').trim();
    const corners = computeRoomCornersFromTwoPoints(tl, br) || (Array.isArray(sel.corners) ? sel.corners.slice() : null);
    const floorKind = values.floorKind ? String(values.floorKind).toLowerCase() : (sel.floor && sel.floor.kind ? String(sel.floor.kind) : '');
    const wallKind = values.wallKind ? String(values.wallKind).toLowerCase() : (sel.wall && sel.wall.kind ? String(sel.wall.kind) : '');
    const thicknessRaw = Number(values.thickness);
    const thickness = Number.isFinite(thicknessRaw) ? thicknessRaw : Number(sel.thickness) || 0;

    captureUndoSnapshot('edit room');
    if (corners) sel.corners = corners;
    if (!sel.floor || typeof sel.floor !== 'object') sel.floor = {};
    if (!sel.wall || typeof sel.wall !== 'object') sel.wall = {};
    if (floorKind) sel.floor.kind = floorKind;
    if (wallKind) sel.wall.kind = wallKind;
    sel.thickness = thickness;

    scheduleDatabaseSave();
    safeRedraw();
    return true;
  }

  function updateRoomControlsFromInputs() {
    if (EDITOR.roomUiLock) return;
    const ctx = getEditorContext();
    const sel = getSelectedRoom(ctx);
    if (!sel) return;
    const values = readRoomControls();
    applyRoomControlsToSelection(ctx, values);
  }

  function setObjectControls(values) {
    const v = normalizeObjectControlValues(values);
    EDITOR.objectUiLock = true;
    EDITOR.objectKind = v.kind;
    EDITOR.objectRotDeg = v.rotDeg;
    EDITOR.objectOx = v.ox;
    EDITOR.objectOy = v.oy;
    EDITOR.objectScale = v.scale;
    if (elObjectKindSelect) elObjectKindSelect.value = v.kind;
    if (elObjectRot) elObjectRot.value = String(v.rotDeg);
    if (elObjectOx) elObjectOx.value = String(v.ox);
    if (elObjectOy) elObjectOy.value = String(v.oy);
    if (elObjectScale) elObjectScale.value = String(v.scale);
    EDITOR.objectUiLock = false;
  }

  function readObjectControls() {
    return normalizeObjectControlValues({
      kind: elObjectKindSelect ? elObjectKindSelect.value : EDITOR.objectKind,
      rotDeg: elObjectRot ? elObjectRot.value : EDITOR.objectRotDeg,
      ox: elObjectOx ? elObjectOx.value : EDITOR.objectOx,
      oy: elObjectOy ? elObjectOy.value : EDITOR.objectOy,
      scale: elObjectScale ? elObjectScale.value : EDITOR.objectScale,
    });
  }

  function syncObjectControlsFromObject(object) {
    if (!object) return;
    const rotDeg = Number.isFinite(Number(object.rotDeg)) ? Number(object.rotDeg) : 0;
    const ox = Number.isFinite(Number(object.ox)) ? Number(object.ox) : 0;
    const oy = Number.isFinite(Number(object.oy)) ? Number(object.oy) : 0;
    const scale = Number.isFinite(Number(object.spriteScale)) ? Number(object.spriteScale) : 1;
    setObjectControls({
      kind: object.kind || 'object',
      rotDeg,
      ox,
      oy,
      scale,
    });
  }

  function applyObjectControlsToSelection(ctx, values, reason) {
    const sel = ctx ? getSelectedObject(ctx) : null;
    if (!sel) return false;
    captureUndoSnapshot(reason || 'edit object');
    sel.kind = values.kind;
    sel.rotDeg = values.rotDeg;
    sel.ox = values.ox;
    sel.oy = values.oy;
    sel.spriteScale = values.scale;
    syncObjectSelectedLabel(sel);
    scheduleDatabaseSave();
    safeRedraw();
    return true;
  }

  function populateRoomKindDatalists() {
    if (!elFloorKindList || !elWallKindList) return;
    if (populateRoomKindDatalists._done) return;
    const baseKinds = Object.keys(TEXTURES.files || {}).map(k => String(k));
    const floorExtra = ['wood', 'stone', 'cobble', 'gravel', 'brick', 'fog'];
    const wallExtra = ['wood', 'stone', 'cobble', 'gravel', 'brick', 'none'];
    const floorKinds = Array.from(new Set([...baseKinds, ...floorExtra])).sort();
    const wallKinds = Array.from(new Set([...baseKinds, ...wallExtra])).sort();
    elFloorKindList.innerHTML = floorKinds.map(k => '<option value="' + escapeHtml(k) + '"></option>').join('');
    elWallKindList.innerHTML = wallKinds.map(k => '<option value="' + escapeHtml(k) + '"></option>').join('');
    populateRoomKindDatalists._done = true;
  }

  function moveSelectedObjectZ(ctx, direction) {
    const sel = ctx ? getSelectedObject(ctx) : null;
    if (!sel) return false;
    const objects = Array.isArray(ctx.objects) ? ctx.objects : [];
    let idx = objects.indexOf(sel);
    if (idx < 0 && sel.id) idx = objects.findIndex(o => o && o.id === sel.id);
    if (idx < 0) return false;

    if (direction === 'front') {
      if (idx === objects.length - 1) return false;
      captureUndoSnapshot('object order');
      objects.splice(idx, 1);
      objects.push(sel);
    } else if (direction === 'back') {
      if (idx === 0) return false;
      captureUndoSnapshot('object order');
      objects.splice(idx, 1);
      objects.unshift(sel);
    } else {
      return false;
    }

    assignSequentialObjectZ(objects);
    scheduleDatabaseSave();
    safeRedraw();
    return true;
  }

  function moveSelectedRoomZ(ctx, direction) {
    const sel = ctx ? getSelectedRoom(ctx) : null;
    if (!sel) return false;
    const rooms = Array.isArray(ctx.rooms) ? ctx.rooms : [];
    let idx = rooms.indexOf(sel);
    if (idx < 0 && sel.id) idx = rooms.findIndex(r => r && r.id === sel.id);
    if (idx < 0) return false;

    if (direction === 'front') {
      if (idx === rooms.length - 1) return false;
      captureUndoSnapshot('room order');
      rooms.splice(idx, 1);
      rooms.push(sel);
    } else if (direction === 'back') {
      if (idx === 0) return false;
      captureUndoSnapshot('room order');
      rooms.splice(idx, 1);
      rooms.unshift(sel);
    } else {
      return false;
    }

    assignSequentialRoomZ(rooms);
    scheduleDatabaseSave();
    safeRedraw();
    return true;
  }

  function updateObjectControlsFromInputs(opts = {}) {
    if (EDITOR.objectUiLock) return;
    const values = readObjectControls();
    EDITOR.objectKind = values.kind;
    EDITOR.objectRotDeg = values.rotDeg;
    EDITOR.objectOx = values.ox;
    EDITOR.objectOy = values.oy;
    EDITOR.objectScale = values.scale;

    if (EDITOR.objectPreview && EDITOR.objectPreview.object) {
      const hex = EDITOR.objectPreview.object.hex;
      EDITOR.objectPreview.object = {
        kind: values.kind,
        hex,
        ox: values.ox,
        oy: values.oy,
        rotDeg: values.rotDeg,
        spriteScale: values.scale,
        __forceVisible: true,
      };
    }

    const ctx = opts.ctx || getEditorContext();
    const applied = opts.applyToSelection ? applyObjectControlsToSelection(ctx, values, 'edit object') : false;
    if (!applied && EDITOR.tool === 'object') safeRedraw();
  }

  function getObjectToolValues() {
    return normalizeObjectControlValues({
      kind: EDITOR.objectKind,
      rotDeg: EDITOR.objectRotDeg,
      ox: EDITOR.objectOx,
      oy: EDITOR.objectOy,
      scale: EDITOR.objectScale,
    });
  }

  function addDoorAtPlacement(ctx, placement) {
    if (!ctx || !ctx.floor || !placement) return null;
    if (!Array.isArray(ctx.floor.openings)) ctx.floor.openings = [];
    const openings = ctx.floor.openings;
    const existing = openings.find(o => o && o.hex === placement.hex && openingOrientation(o) === placement.orientation);
    if (existing) return existing;
    const opening = {
      id: 'door_' + Date.now().toString(36) + '_' + Math.floor(Math.random() * 1e4).toString(36),
      kind: 'door.wood',
      hex: placement.hex,
      orientation: placement.orientation,
      openPct: 0.0,
    };
    openings.push(opening);
    return opening;
  }

  function addWindowAtPlacement(ctx, placement) {
    if (!ctx || !ctx.floor || !placement) return null;
    if (!Array.isArray(ctx.floor.openings)) ctx.floor.openings = [];
    const openings = ctx.floor.openings;
    const existing = openings.find(o => o && o.hex === placement.hex && openingOrientation(o) === placement.orientation);
    if (existing) return existing;
    const opening = {
      id: 'window_' + Date.now().toString(36) + '_' + Math.floor(Math.random() * 1e4).toString(36),
      kind: 'window',
      hex: placement.hex,
      orientation: placement.orientation,
      openPct: 0.0,
    };
    openings.push(opening);
    return opening;
  }

  function addObjectAtHex(ctx, hexLabel, opts) {
    if (!ctx || !ctx.floor || !hexLabel) return null;
    if (!Array.isArray(ctx.floor.objects)) ctx.floor.objects = [];
    const objects = ctx.floor.objects;
    const values = normalizeObjectControlValues(opts || {});
    const object = {
      id: 'object_' + Date.now().toString(36) + '_' + Math.floor(Math.random() * 1e4).toString(36),
      kind: values.kind,
      hex: hexLabel,
      ox: values.ox,
      oy: values.oy,
      rotDeg: values.rotDeg,
      spriteScale: values.scale,
      floorId: ctx.floorId || null,
      z: nextObjectZ(objects),
    };
    objects.push(object);
    return object;
  }

  function updateObjectHex(object, colDelta, rowDelta) {
    const p = parseObjectHex(object && object.hex);
    if (!p) return false;
    const col = p.col + colDelta;
    const row = roundQuarter(p.row + rowDelta);
    const label = openingHexLabelFromCoords(col, row);
    if (!label) return false;
    object.hex = label;
    return true;
  }

  function updateOpeningHex(opening, colDelta, rowDelta) {
    const p = parseOpeningHex(opening && opening.hex);
    if (!p) return false;
    const col = p.col + colDelta;
    const row = roundQuarter(p.row + rowDelta);
    const label = openingHexLabelFromCoords(col, row);
    if (!label) return false;
    opening.hex = label;
    return true;
  }

  function removeOpening(ctx, opening) {
    if (!ctx || !opening) return false;
    const openings = Array.isArray(ctx.openings) ? ctx.openings : [];
    const idx = openings.indexOf(opening);
    if (idx < 0) return false;
    captureUndoSnapshot('delete opening');
    openings.splice(idx, 1);
    trackOpeningDelete(ctx, opening);
    if (EDITOR.selectedId === opening.id) {
      setSelectedOpening(null);
    }
    return true;
  }

  function removeObject(ctx, object) {
    if (!ctx || !object) return false;
    const objects = Array.isArray(ctx.objects) ? ctx.objects : [];
    let idx = objects.indexOf(object);
    if (idx < 0 && object.id) {
      idx = objects.findIndex(o => o && o.id === object.id);
    }
    if (idx < 0) return false;
    captureUndoSnapshot('delete object');
    objects.splice(idx, 1);
    trackObjectDelete(ctx, object);
    if (EDITOR.selectedObjectId && object.id && EDITOR.selectedObjectId === object.id) {
      clearSelectedObject();
    }
    return true;
  }

  function removeToken(ctx, token) {
    if (!token) return false;
    const state = ctx && ctx.state ? ctx.state : getState();
    const tokens = Array.isArray(state && state.tokens)
      ? state.tokens
      : (Array.isArray(state && state.actors) ? state.actors : null);
    if (!tokens) return false;
    let idx = tokens.indexOf(token);
    if (idx < 0 && token.id) {
      idx = tokens.findIndex(t => t && t.id === token.id);
    }
    if (idx < 0) return false;
    captureUndoSnapshot('delete token');
    tokens.splice(idx, 1);
    trackTokenDelete(token);
    if (token.id && VIEW.followTokenId === token.id) {
      VIEW.followTokenId = null;
      if (elCenterOn) elCenterOn.value = '';
    }
    return true;
  }

  function removeRoom(ctx, room) {
    if (!ctx || !room) return false;
    const rooms = Array.isArray(ctx.rooms) ? ctx.rooms : [];
    let idx = rooms.indexOf(room);
    if (idx < 0 && room.id) {
      idx = rooms.findIndex(r => r && r.id === room.id);
    }
    if (idx < 0) return false;
    captureUndoSnapshot('delete room');
    rooms.splice(idx, 1);
    trackRoomDelete(ctx, room);
    if (EDITOR.selectedRoomId && room.id && EDITOR.selectedRoomId === String(room.id)) {
      clearSelectedRoom();
    }
    return true;
  }

  function handleEditorKey(ev) {
    if (ev.target && (ev.target.tagName === 'INPUT' || ev.target.tagName === 'SELECT' || ev.target.isContentEditable)) return false;
    const key = ev.key;
    const ctx = getEditorContext();

    if (key === 'Escape') {
      if (EDITOR.tool === 'room' && EDITOR.roomStart) {
        EDITOR.roomStart = null;
        EDITOR.roomPreview = null;
        safeRedraw();
        return true;
      }
      if (EDITOR.tool !== 'select') {
        setEditorTool('select');
        return true;
      }
    }

    const selObj = ctx ? getSelectedObject(ctx) : null;
    if (selObj) {
      if (key === 'Delete' || key === 'Backspace') {
        if (removeObject(ctx, selObj)) {
          scheduleDatabaseSave();
          safeRedraw();
        }
        return true;
      }

      if (key === 'r' || key === 'R') {
        captureUndoSnapshot('rotate object');
        const cur = Number(selObj.rotDeg) || 0;
        selObj.rotDeg = cur + (ev.shiftKey ? -15 : 15);
        syncObjectControlsFromObject(selObj);
        scheduleDatabaseSave();
        safeRedraw();
        return true;
      }

      if (key === 'ArrowLeft') {
        captureUndoSnapshot('move object');
        if (updateObjectHex(selObj, -1, 0)) {
          scheduleDatabaseSave();
          safeRedraw();
        }
        return true;
      }
      if (key === 'ArrowRight') {
        captureUndoSnapshot('move object');
        if (updateObjectHex(selObj, 1, 0)) {
          scheduleDatabaseSave();
          safeRedraw();
        }
        return true;
      }
      if (key === 'ArrowUp') {
        captureUndoSnapshot('move object');
        if (updateObjectHex(selObj, 0, 1)) {
          scheduleDatabaseSave();
          safeRedraw();
        }
        return true;
      }
      if (key === 'ArrowDown') {
        captureUndoSnapshot('move object');
        if (updateObjectHex(selObj, 0, -1)) {
          scheduleDatabaseSave();
          safeRedraw();
        }
        return true;
      }
    }

    const sel = ctx ? getSelectedOpening(ctx) : null;
    if (!sel) return false;

      if (key === 'Delete' || key === 'Backspace') {
        if (removeOpening(ctx, sel)) {
          scheduleDatabaseSave();
          safeRedraw();
        }
        return true;
      }

      if (key === 'r' || key === 'R') {
        captureUndoSnapshot('rotate opening');
        sel.orientation = (openingOrientation(sel) === 'h') ? 'v' : 'h';
        scheduleDatabaseSave();
        safeRedraw();
        return true;
      }

      if (key === 'ArrowLeft') {
        captureUndoSnapshot('move opening');
        if (updateOpeningHex(sel, -1, 0)) {
          scheduleDatabaseSave();
          safeRedraw();
        }
        return true;
      }
      if (key === 'ArrowRight') {
        captureUndoSnapshot('move opening');
        if (updateOpeningHex(sel, 1, 0)) {
          scheduleDatabaseSave();
          safeRedraw();
        }
        return true;
      }
      if (key === 'ArrowUp') {
        captureUndoSnapshot('move opening');
        if (updateOpeningHex(sel, 0, 1)) {
          scheduleDatabaseSave();
          safeRedraw();
        }
        return true;
      }
      if (key === 'ArrowDown') {
        captureUndoSnapshot('move opening');
        if (updateOpeningHex(sel, 0, -1)) {
          scheduleDatabaseSave();
          safeRedraw();
        }
        return true;
      }

    return false;
  }

  function applyPendingOpeningDeletes(out) {
    const pending = EDITOR.deletedOpeningsByFloor;
    if (!pending || !out || !Array.isArray(out.floors)) return;
    for (const floor of out.floors) {
      if (!floor || !floor.id) continue;
      const byId = pending[floor.id];
      if (!byId) continue;
      const ids = Object.keys(byId);
      if (!ids.length) continue;
      const existing = Array.isArray(floor.openings) ? floor.openings : [];
      const filtered = existing.filter(o => !(o && o.id && byId[o.id]));
      for (const id of ids) {
        filtered.push({ id, deleted: true });
      }
      floor.openings = filtered;
    }
  }

  function applyPendingObjectDeletes(out) {
    const pending = EDITOR.deletedObjectsByFloor;
    if (!pending || !out || !Array.isArray(out.floors)) return;
    for (const floor of out.floors) {
      if (!floor || !floor.id) continue;
      const byId = pending[floor.id];
      if (!byId) continue;
      const ids = Object.keys(byId);
      if (!ids.length) continue;
      const existing = Array.isArray(floor.objects) ? floor.objects : [];
      const filtered = existing.filter(o => !(o && o.id && byId[o.id]));
      for (const id of ids) {
        filtered.push({ id, deleted: true });
      }
      floor.objects = filtered;
    }
  }

  function applyPendingRoomDeletes(out) {
    const pending = EDITOR.deletedRoomsByFloor;
    if (!pending || !out || !Array.isArray(out.floors)) return;
    for (const floor of out.floors) {
      if (!floor || !floor.id) continue;
      const byId = pending[floor.id];
      if (!byId) continue;
      const ids = Object.keys(byId);
      if (!ids.length) continue;
      const existing = Array.isArray(floor.rooms) ? floor.rooms : [];
      const filtered = existing.filter(r => !(r && r.id && byId[r.id]));
      for (const id of ids) {
        filtered.push({ id, deleted: true });
      }
      floor.rooms = filtered;
    }
  }

  function applyPendingTokenDeletes(out) {
    const pending = EDITOR.deletedTokens;
    if (!pending || !out) return;
    const ids = Object.keys(pending);
    if (!ids.length) return;
    const existing = Array.isArray(out.tokens) ? out.tokens : [];
    const filtered = existing.filter(t => !(t && t.id && pending[t.id]));
    for (const id of ids) {
      filtered.push({ id, deleted: true });
    }
    out.tokens = filtered;
  }

  function applyPendingDeletes(out) {
    applyPendingOpeningDeletes(out);
    applyPendingObjectDeletes(out);
    applyPendingRoomDeletes(out);
    applyPendingTokenDeletes(out);
  }

  function buildRecordPatchForSave() {
    const state = getState();
    if (!state || typeof state !== 'object') return null;

    const recordId = (state && state.__activeRecordId) ? String(state.__activeRecordId) : '';
    const out = cloneDeepSafe(state);
    applyPendingDeletes(out);
    delete out.__hydratedObjectsFlat;
    delete out.__activeRecordId;
    delete out.__worldName;
    delete out.objects;  // derived flattening (avoid cross-floor pollution)
    delete out.rooms;    // legacy top-level floor mirrors
    delete out.openings; // legacy top-level floor mirrors
    if (recordId) {
      return { records: { [recordId]: out } };
    }
    return out;
  }

  async function saveStateToDatabase() {
    if (STATE_SOURCE !== 'database') {
      setToolStatus('DB: not active', 'error');
      return false;
    }
    const url = resolveDatabaseUrl() || STATE_URL;
    if (!url) {
      setToolStatus('DB: missing battle id', 'error');
      return false;
    }
    const raw = buildRecordPatchForSave();
    if (!raw) {
      setToolStatus('DB: no state', 'error');
      return false;
    }
    EDITOR.saving = true;
    setToolStatus('DB: saving...', null);
    try {
      const res = await fetch(url, {
        method: 'PUT',
        headers: { 'content-type': 'application/json', 'accept': 'application/json', ...getAuthHeaders() },
        body: JSON.stringify({ state_json: raw }),
      });
      if (!res.ok) throw new Error('DB save failed: ' + res.status + ' ' + res.statusText);
      EDITOR.saving = false;
      clearEditorPendingDeletes();
      setToolStatus('DB: saved', 'ok');
      return true;
    } catch (e) {
      EDITOR.saving = false;
      setToolStatus('DB: save error', 'error');
      if (elError) {
        elError.hidden = false;
        elError.textContent = 'Database save error:' + String.fromCharCode(10) + String(e && e.message ? e.message : e);
      }
      return false;
    }
  }

  function scheduleDatabaseSave() {
    if (STATE_SOURCE !== 'database') {
      setToolStatus('DB: not active', 'error');
      return;
    }
    if (EDITOR.saveTimer) clearTimeout(EDITOR.saveTimer);
    EDITOR.saveTimer = setTimeout(() => {
      EDITOR.saveTimer = null;
      saveStateToDatabase();
    }, 400);
  }

  function resolveSpriteBasePath() {
    const origin = (window && window.location && window.location.origin)
      ? window.location.origin
      : '';
    if (origin) return origin.replace(/\/+$/, '') + '/assets/sprites/';
    return '/assets/sprites/';
  }

  // ===== Sprites (core, optional) =====
  const SPRITES = {
    basePath: resolveSpriteBasePath(),
    cache: new Map(),
    defs: {
      // Objects
      'bed':         { file: 'bed.png', rotate: 'deg' },
      'bed.double':  { file: 'bed_double.png', rotate: 'deg' },
      'chair':       { file: 'chair.png', rotate: 'deg' },
      'table.round': { file: 'table_round.png', rotate: 'deg' },
      'table.rect':  { file: 'table_rectangle.png', rotate: 'deg' },
      'table.sqr':   { file: 'table_square.png', rotate: 'deg' },
      'table.prep':  { file: 'table_prep.png', rotate: 'deg' },
      'table.plate': { file: 'table_plate.png', rotate: 'deg' },
      'table.hot':   { file: 'table_hot.png', rotate: 'deg' },
      'table.cold':  { file: 'table_cold.png', rotate: 'deg' },
      'chest':       { file: 'chest_closed.png', rotate: 'deg' },
      'hearth':      { file: 'hearth.png', rotate: 'deg' },
      'cooking.hearth': { file: 'cooking_hearth.png', rotate: 'deg' },
      'stairs':      { file: 'stairs.png', rotate: 'deg' },

      // New 1-hex props
      'keg':         { file: 'keg.png', rotate: 'deg' },
      'barrel':      { file: 'barrel.png', rotate: 'deg' },
      'crate':       { file: 'crate.png', rotate: 'deg' },

      // Doors (prefer dot-style kinds, but keep aliases for convenience/compat)
      'door':         { file: 'door_wood.png', rotate: 'none' },
      'door.wood':    { file: 'door_wood.png', rotate: 'none' },
      'door_wood':    { file: 'door_wood.png', rotate: 'none' },
      'bath':        { file: 'bath.png', rotate: 'deg' },

      // Tokens (optional)
      'token.pc':    { file: 'token_pc.png', rotate: 'none' },
      'token.npc':   { file: 'token_npc.png', rotate: 'none' },
    }
  };

  function getSpriteDef(kind) {
    const k = String(kind || '').toLowerCase();
    return SPRITES.defs[k] || null;
  }

  function scheduleSpriteRedraw() {
    // Debounce redraws when multiple images finish loading at once.
    if (scheduleSpriteRedraw._pending) return;
    scheduleSpriteRedraw._pending = true;
    requestAnimationFrame(() => {
      scheduleSpriteRedraw._pending = false;
      SPRITE_LOAD_TICK++;
      if (SPRITES_ENABLED) safeRedraw();
    });
  }

  function loadSprite(file) {
    const f = String(file || '').trim();
    if (!f) return null;

    if (SPRITES.cache.has(f)) return SPRITES.cache.get(f);

    const img = new Image();
    img.decoding = 'async';
    img.addEventListener('load', () => scheduleSpriteRedraw(), { once: true });
    img.addEventListener('error', () => scheduleSpriteRedraw(), { once: true });
    img.src = SPRITES.basePath + f;

    SPRITES.cache.set(f, img);
    return img;
  }

  function drawSpriteImage(img, opts = {}) {
    // Unified sprite draw: fit=contain or stretch, optional anchor and rotation.
    if (!img || !img.complete || !img.naturalWidth || !img.naturalHeight) return false;

    const x = Number(opts.x || 0);
    const y = Number(opts.y || 0);
    const w = Number(opts.w || 0);
    const h = Number(opts.h || 0);
    const fit = String(opts.fit || 'contain').toLowerCase();
    const rotRad = Number(opts.rotRad || 0);
    const ax = clamp(Number(opts.anchorX != null ? opts.anchorX : 0.5), 0, 1);
    const ay = clamp(Number(opts.anchorY != null ? opts.anchorY : 0.5), 0, 1);

    let dw = w;
    let dh = h;

    if (fit === 'contain') {
      const iw = img.naturalWidth;
      const ih = img.naturalHeight;
      const s = Math.min(w / iw, h / ih);
      dw = iw * s;
      dh = ih * s;
    }

    ctx.save();
    ctx.translate(x, y);
    if (rotRad) ctx.rotate(rotRad);
    ctx.drawImage(img, -dw * ax, -dh * ay, dw, dh);
    ctx.restore();
    return true;
  }

  // ===== Repeat textures (optional) =====
  // One texture catalog; per-category scales + aliases.
  const TEXTURES = {
    files: {
      wood_oak:     'wood_oak.png',
      wood_elm:     'wood_elm.png',
      wood_dark:    'wood_dark.png',

      stone:        'stone.png',
      stone_cobble: 'stone_cobble.png',
      stone_gravel: 'stone_gravel.png',

      brick_gray:   'brick_gray.png',
      brick_red:    'brick_red.png',
      brick_dark:   'brick_dark.png',
    },

    scales: {
      wall: {
        wood_oak:     0.50,
        wood_elm:     0.50,
        wood_dark:    0.50,

        stone:        0.50,
        stone_cobble: 0.45,
        stone_gravel: 0.55,

        brick_gray:   0.15,
        brick_red:    0.15,
        brick_dark:   0.15,
      },
      floor: {
        wood_oak:     0.50,
        wood_elm:     0.50,
        wood_dark:    0.50,

        stone_cobble: 0.45,
        stone_gravel: 0.55,
        stone: 0.25,

        brick_gray:   0.15,
        brick_red:    0.15,
        brick_dark:   0.15,
      },
    },

    aliases: {
      wall: {
        brick:  'brick_gray',
        wood:   'wood_oak',
        cobble: 'stone_cobble',
        stone:  'stone_cobble',
        gravel: 'stone_gravel',
      },
      floor: {
        wood:   'wood_oak',
        stone:  'stone',
        cobble: 'stone_cobble',
        gravel: 'stone_gravel',
        brick:  'brick_gray',
      },
    },
  };

  function resolveTextureDef(category, kind) {
    const cat = String(category || '').toLowerCase();
    const k0 = String(kind || '').toLowerCase();
    if (!cat || !k0) return null;

    const files = TEXTURES && TEXTURES.files ? TEXTURES.files : null;
    const scales = (TEXTURES && TEXTURES.scales && TEXTURES.scales[cat]) ? TEXTURES.scales[cat] : null;
    const aliases = (TEXTURES && TEXTURES.aliases && TEXTURES.aliases[cat]) ? TEXTURES.aliases[cat] : null;
    if (!files || !scales) return null;

    const key = (k0 in files) ? k0 : (aliases && aliases[k0] ? String(aliases[k0]).toLowerCase() : '');
    if (!key || !(key in files)) return null;

    return { file: files[key], scale: (key in scales) ? Number(scales[key]) : 1 };
  }

  const PATTERN_CACHE = new Map();

  const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v));
  const isFiniteNum = (v) => Number.isFinite(Number(v));

  // Snap CSS-space coords to the device-pixel grid to avoid 1px seams at high zoom.
  // VIEW.dpr is devicePixelRatio × supersample, so snapping to 1/VIEW.dpr lines up with the backing store.
  function snapCss(v) {
    const d = Number(VIEW && VIEW.dpr) || 1;
    return Math.round(Number(v) * d) / d;
  }

  function snappedRectFromCenter(centerS, w, h) {
    const x1 = snapCss(centerS.x - w / 2);
    const y1 = snapCss(centerS.y - h / 2);
    const x2 = snapCss(centerS.x + w / 2);
    const y2 = snapCss(centerS.y + h / 2);
    return { x: x1, y: y1, w: Math.max(0, x2 - x1), h: Math.max(0, y2 - y1) };
  }

  // ===== Supersample + Zoom =====
  let SUPERSAMPLE = 3;
  let ZOOM = 1;

  function effectivePatternScale(defScale) {
    // Patterns should zoom with the map so tiles stay visually consistent.
    return clamp((Number(defScale) || 1) * (Number(ZOOM) || 1), 0.02, 10);
  }

  function getRepeatPatternForCtx(targetCtx, tex) {
    const file = (typeof tex === 'string') ? tex : (tex && tex.file);
    const defScale = (tex && typeof tex === 'object' && isFiniteNum(tex.scale)) ? Number(tex.scale) : 1;

    const f = String(file || '').trim();
    if (!f) return null;

    const ctxKey = (targetCtx === wallCtx) ? 'wall' : 'main';
    const effScale = effectivePatternScale(defScale);
    const key = ctxKey + '|' + f + '|s=' + String(effScale.toFixed(4));

    const cached = PATTERN_CACHE.get(key);
    if (cached && cached.pattern) return cached.pattern;

    const img = loadSprite(f);
    if (!img || !img.complete || !img.naturalWidth || !img.naturalHeight) return null;

    const pat = targetCtx.createPattern(img, 'repeat');
    if (!pat) return null;

    if (typeof pat.setTransform === 'function') {
      pat.setTransform(new DOMMatrix([effScale, 0, 0, effScale, 0, 0]));
      PATTERN_CACHE.set(key, { pattern: pat });
      return pat;
    }

    // Fallback: pre-scale into an offscreen tile canvas, then pattern that.
    const tw = Math.max(1, Math.round(img.naturalWidth * effScale));
    const th = Math.max(1, Math.round(img.naturalHeight * effScale));
    const tile = document.createElement('canvas');
    tile.width = tw;
    tile.height = th;
    const tctx = tile.getContext('2d');
    tctx.imageSmoothingEnabled = true;
    try { tctx.imageSmoothingQuality = 'high'; } catch {}
    tctx.drawImage(img, 0, 0, tw, th);

    const pat2 = targetCtx.createPattern(tile, 'repeat');
    if (!pat2) return null;

    PATTERN_CACHE.set(key, { pattern: pat2 });
    return pat2;
  }

  function readSupersample() {
    const raw = localStorage.getItem(STORAGE_SS);
    const v = parseFloat(raw != null ? raw : '3');
    if (!Number.isFinite(v)) return 3;
    return clamp(v, 1, 3);
  }

  function setSupersample(v) {
    const n = clamp(parseFloat(String(v)), 1, 3);
    localStorage.setItem(STORAGE_SS, String(n));
    SUPERSAMPLE = n;
    PATTERN_CACHE.clear();
    if (elSsSelect) elSsSelect.value = String(n);
    resize();
  }

  function readZoom() {
    const raw = localStorage.getItem(STORAGE_ZOOM);
    const v = parseFloat(raw != null ? raw : '1');
    if (!Number.isFinite(v)) return 1;
    return clamp(v, 0.60, 2.25);
  }

  function applyZoom() {
    GRID.size = GRID.baseSize * ZOOM;
  }

  function syncZoomUI() {
    const el = els.zoomText;
    if (el) el.textContent = Math.round(ZOOM * 100) + '%';
  }

  function setZoom(v, opts = {}) {
    const n = clamp(parseFloat(String(v)), 0.60, 2.25);
    ZOOM = n;
    applyZoom();
    PATTERN_CACHE.clear();
    if (opts.persist !== false) localStorage.setItem(STORAGE_ZOOM, String(n));
    syncZoomUI();
    safeRedraw();
  }

  // ===== Canonical state (demo) =====
  // PHASE 1 of "World Record" support:
  // - We now support *either* a legacy battlemat state OR a world-record wrapper.
  // - World-record wrapper format:
  //     { world, version, meta, active:{recordId,floorId,camera_hex}, records:{[recordId]:<sceneState>}, links:[] }
  // - The renderer continues to run on a *sceneState* (floors/openings/objects/tokens).
  // - normalizeStateForRenderer() extracts the active scene and hydrates it for the current renderer.
  //
  // NOTE: Embedded data is intentionally JSON (not JS object-literal) so you can copy/paste into state_json.
  // Keep it JSON-valid: double quotes only, no comments, no trailing commas.

const EMBEDDED_WORLD_JSON = `{
  "world": "Saffrondale",
  "version": 1,
  "meta": { "scale": "1 hex = 5 ft", "fogMode": "room" },
  "active": { "recordId": "CrossKeysInn", "floorId": "ground", "camera_hex": "U16" },
  "records": {
    "CrossKeysInn": {
      "meta": { "title": "Cross Keys Inn - Base", "battleId": "local", "round": 1 },
      "view": { "camera_hex": "U16", "floorId": "ground" },
      "fog": {
        "enabled": true,
        "mode": "room",
        "visibleRoomIdsByFloor": { "upper": [], "ground": [], "basement": [] },
        "exploredRoomIdsByFloor": { "upper": [], "ground": [], "basement": [] },
        "autoCompute": true,
        "autoExplore": true,
        "maxDepth": 1,
        "unseenAlpha": 0.92,
        "exploredAlpha": 0.55
      },
      "floors": [
        {
          "id": "upper",
          "name": "Upper",
          "rooms": [
            { "id": "CrossKeysUpperFloor", "buildingId": "CrossKeysInn", "corners": ["L21", "AJ21", "AJ12", "L12"], "thickness": 15, "floor": { "kind": "fog" }, "wall": { "kind": "wood_dark" } }
          ],
          "openings": [],
          "objects": []
        },
        {
          "id": "ground",
          "name": "Ground",
          "rooms": [
            { "id": "CrossKeysGroundFloor", "buildingId": "CrossKeysInn", "corners": ["M21.5", "AJ21", "AJ12.5", "M13"], "thickness": 15, "floor": { "kind": "fog" }, "wall": { "kind": "brick" } }
          ],
          "openings": [
            { "id": "door_front", "kind": "door.wood", "hex": "M17", "orientation": "v", "openPct": 0.0 }
          ],
          "objects": []
        },
        {
          "id": "basement",
          "name": "Basement",
          "rooms": [
            { "id": "BasementRoom", "buildingId": "CrossKeysInn", "corners": ["P18", "W18", "W14", "P14"], "thickness": 15, "floor": { "kind": "stone" }, "wall": { "kind": "brick" } }
          ],
          "openings": [],
          "objects": []
        }
      ],
      "tokens": []
    }
  },
  "links": []
}`;

  let WORLD_STATE = null; // holds the last parsed *world record* (if provided)

  const FALLBACK_STATE_MIN = {
    meta: { title: 'Fallback', battleId: 'local', round: 1 },
    floors: [],
    tokens: []
  };

  function cloneDeepSafe(obj) {
    if (obj == null) return obj;
    if (typeof structuredClone === 'function') return structuredClone(obj);
    return JSON.parse(JSON.stringify(obj));
  }

  // ===== Data normalization =====
  function numOr(v, d = 0) {
    const n = Number(v);
    return Number.isFinite(n) ? n : d;
  }

  function normStr(v, d = '') {
    const s = (v == null) ? '' : String(v);
    return s.trim() || d;
  }

  function normKind(v, d = '') {
    return normStr(v, d).toLowerCase();
  }

  function normOrient(v) {
    const o = normKind(v, 'h');
    return (o === 'v' || o === 'vert' || o === 'vertical') ? 'v' : 'h';
  }

  function normDoorKind(kind) {
    const k = normKind(kind, 'door');
    // Unify common door aliases.
    if (k === 'door_wood' || k === 'doorwood' || k === 'door.wood' || k === 'door-wood') return 'door.wood';
    if (k === 'door_stone' || k === 'doorstone' || k === 'door.stone' || k === 'door-stone') return 'door.stone';
    if (k.startsWith('door.') || k.startsWith('door_') || k === 'door') return k;
    return k;
  }

  function normalizeRooms(list) {
    const rooms = Array.isArray(list) ? list : [];
    for (const r of rooms) {
      if (!r || typeof r !== 'object') continue;
      if (r.id != null) r.id = String(r.id);
      if (Array.isArray(r.corners)) r.corners = r.corners.map(c => String(c));
      r.thickness = numOr(r.thickness, numOr(r.wallThickness, 15));
      if (!r.floor || typeof r.floor !== 'object') r.floor = {};
      if (!r.wall || typeof r.wall !== 'object') r.wall = {};
      r.floor.kind = normKind(r.floor.kind, normKind(r.floor.type, 'wood'));
      r.wall.kind = normKind(r.wall.kind, normKind(r.wall.type, 'brick'));
    }
    return rooms;
  }

  function normalizeOpenings(list) {
    const openings = Array.isArray(list) ? list : [];
    for (const o of openings) {
      if (!o || typeof o !== 'object') continue;
      if (o.id != null) o.id = String(o.id);
      o.hex = normStr(o.hex);
      o.orientation = normOrient(o.orientation);

      const k0 = normKind(o.kind, 'door');
      o.kind = (k0 === 'door' || k0.startsWith('door') || k0.startsWith('door_') || k0.startsWith('door.'))
        ? normDoorKind(k0)
        : k0;

      if (o.openPct == null && o.open != null) o.openPct = o.open;
      if (o.openPct == null && o.open_pct != null) o.openPct = o.open_pct;
      o.openPct = clamp(numOr(o.openPct, 0), 0, 1);

      if (o.span != null) o.span = clamp(numOr(o.span, 1), 0.5, 4);
      if (o.spriteScale != null) o.spriteScale = numOr(o.spriteScale, 1);
      if (o.spriteScaleX != null) o.spriteScaleX = numOr(o.spriteScaleX, 1);
      if (o.spriteScaleY != null) o.spriteScaleY = numOr(o.spriteScaleY, 1);

      if (o.parent != null) o.parent = String(o.parent);
      if (o.hinge != null) o.hinge = String(o.hinge);
      if (o.swing != null) o.swing = numOr(o.swing, o.swing);
    }
    return openings;
  }

  function normalizeObjects(list, floorIdFallback = null) {
    const objects = Array.isArray(list) ? list : [];
    for (const o of objects) {
      if (!o || typeof o !== 'object') continue;
      if (o.id != null) o.id = String(o.id);
      o.kind = normKind(o.kind, 'object');
      o.hex = normStr(o.hex);

      if (o.floorId == null && o.floor_id != null) o.floorId = o.floor_id;
      if (o.floorId == null && floorIdFallback != null) o.floorId = String(floorIdFallback);
      if (o.floorId != null) o.floorId = String(o.floorId);

      if (o.ox != null) o.ox = numOr(o.ox, 0);
      if (o.oy != null) o.oy = numOr(o.oy, 0);
      if (o.rotDeg != null) o.rotDeg = numOr(o.rotDeg, 0);

      if (o.spriteScale != null) o.spriteScale = numOr(o.spriteScale, 1);
      if (o.spriteScaleX != null) o.spriteScaleX = numOr(o.spriteScaleX, 1);
      if (o.spriteScaleY != null) o.spriteScaleY = numOr(o.spriteScaleY, 1);
    }
    return objects;
  }

  function normalizeTokens(list, floorIdFallback = null) {
    const tokens = Array.isArray(list) ? list : [];
    for (const t of tokens) {
      if (!t || typeof t !== 'object') continue;
      if (t.id != null) t.id = String(t.id);
      t.hex = normStr(t.hex);

      const side = normStr(t.side ?? t.team ?? t.faction, 'NPC').toUpperCase();
      t.side = (side === 'PC' || side === 'NPC') ? side : 'NPC';

      if (t.floorId == null && t.floor_id != null) t.floorId = t.floor_id;
      if (t.floorId == null && floorIdFallback != null) t.floorId = String(floorIdFallback);
      if (t.floorId != null) t.floorId = String(t.floorId);

      if (t.init != null) t.init = numOr(t.init, 0);
      if (t.hp != null) t.hp = numOr(t.hp, t.hp);

      if (t.label != null) t.label = String(t.label);
      if (t.name != null) t.name = String(t.name);
    }
    return tokens;
  }

  function normalizeSceneShape(scene) {
    if (!scene || typeof scene !== 'object') return null;

    if (!scene.meta || typeof scene.meta !== 'object') scene.meta = {};
    if (!scene.view || typeof scene.view !== 'object') scene.view = {};

    // Normalize floors into an array. If we only have legacy top-level rooms/openings/objects,
    // fold them into a single floor.
    let floors = null;

    if (Array.isArray(scene.floors)) {
      floors = scene.floors;
    } else if (scene.floors && typeof scene.floors === 'object') {
      floors = Object.entries(scene.floors).map(([id, data]) => ({ id, ...(data || {}) }));
      scene.floors = floors;
    } else {
      const fid = String(scene.view.floorId || scene.view.floor_id || scene.view.floor || 'floor1');
      floors = [{
        id: fid,
        name: 'Floor',
        rooms: Array.isArray(scene.rooms) ? scene.rooms : [],
        openings: Array.isArray(scene.openings) ? scene.openings : [],
        objects: Array.isArray(scene.objects) ? scene.objects : [],
      }];
      scene.floors = floors;
    }

    // Ensure view.floorId is set to a valid floor id.
    const firstId = floors && floors.length ? String(floors[0].id ?? 'floor1') : 'floor1';
    const wanted = String(scene.view.floorId || scene.view.floor_id || scene.view.floor || '') || '';
    const ok = wanted && floors.some(f => String(f && f.id) === wanted);
    scene.view.floorId = ok ? wanted : firstId;

    // Normalize per-floor arrays.
    for (const f of floors) {
      if (!f || typeof f !== 'object') continue;
      if (f.id == null) f.id = firstId;
      f.id = String(f.id);
      if (f.name != null) f.name = String(f.name);

      f.rooms = normalizeRooms(f.rooms);
      f.openings = normalizeOpenings(f.openings);
      f.objects = normalizeObjects(f.objects, f.id);
    }

    // Normalize tokens.
    const tok = (scene.tokens != null) ? scene.tokens : (scene.actors != null ? scene.actors : []);
    scene.tokens = normalizeTokens(tok, scene.view.floorId);

    // Keep legacy top-level lists present but consistent (for compatibility).
    scene.rooms = floors[0] ? floors[0].rooms : [];
    scene.openings = floors[0] ? floors[0].openings : [];

    return scene;
  }

  function hydrateSceneForRenderer(scene) {
    if (!scene || typeof scene !== 'object') return null;

    // Prevent double-hydration if we normalize the same object more than once.
    // We keep this marker internal; it's only used in-memory.
    if (scene.__hydratedObjectsFlat) return scene;

    // Normalize shape + fields before we derive any compatibility views.
    normalizeSceneShape(scene);

    // If objects are stored per-floor, also expose a top-level flattened list so older rendering paths continue to work.
    // Always rebuild the flattened list so we never accidentally duplicate entries.
    scene.objects = [];

    if (Array.isArray(scene.floors)) {
      for (const f of scene.floors) {
        if (!f || typeof f !== 'object') continue;
        const fid = f.id;
        if (Array.isArray(f.objects) && f.objects.length) {
          for (const o of f.objects) {
            if (!o || typeof o !== 'object') continue;
            if (!('floorId' in o) && fid) o.floorId = fid;
            scene.objects.push(o);
          }
        }
      }
    }

    scene.__hydratedObjectsFlat = true;
    return scene;
  }

  function normalizeStateForRenderer(rawState) {
    if (!rawState || typeof rawState !== 'object') return null;

    // World-record wrapper
    if (rawState.records && rawState.active && rawState.active.recordId) {
      WORLD_STATE = rawState;
      const recordId = rawState.active.recordId;
      const rec = rawState.records ? rawState.records[recordId] : null;
      if (!rec) {
        console.warn('[Battlemat] World record missing active record:', recordId);
        return null;
      }

      const scene = cloneDeepSafe(rec);
      if (!scene.view || typeof scene.view !== 'object') scene.view = {};

      // Active pointer overrides scene view (camera/floor)
      if (rawState.active.camera_hex) scene.view.camera_hex = rawState.active.camera_hex;
      if (rawState.active.floorId) scene.view.floorId = rawState.active.floorId;

      // Carry through helpful context for UI/debugging (non-canonical for now)
      scene.__activeRecordId = recordId;
      scene.__worldName = rawState.world || null;

      return hydrateSceneForRenderer(scene);
    }

    // Legacy battlemat state
    WORLD_STATE = null;
    return hydrateSceneForRenderer(cloneDeepSafe(rawState));
  }

  function readEmbeddedWorld() {
    try {
      const parsed = JSON.parse(EMBEDDED_WORLD_JSON);
      STATE_SOURCE = 'embedded';
      return parsed;
    } catch (e) {
      console.warn('[Battlemat] Embedded world JSON parse failed:', e);
      return null;
    }
  }

  // PHASE 2: Allow the host page (or a future DB bootstrap) to provide state_json up-front.
  // If present, it should be either:
  //   - a JSON string (world-record wrapper OR legacy scene state), OR
  //   - a parsed object (same)
  // We intentionally support multiple variable names to make integration easy.
  function readBootstrapState() {
    const injected =
      (typeof window !== 'undefined' && (window.__BATTLEMAT_BOOTSTRAP_STATE_JSON ?? window.BATTLEMAT_BOOTSTRAP_STATE_JSON)) ||
      null;

    if (!injected) return readEmbeddedWorld();

    try {
      if (typeof injected === 'string') {
        STATE_SOURCE = 'file';
        return JSON.parse(injected);
      }
      if (typeof injected === 'object') {
        STATE_SOURCE = 'file';
        return injected;
      }
    } catch (e) {
      console.warn('[Battlemat] Bootstrap state parse failed; falling back to embedded demo:', e);
      return readEmbeddedWorld();
    }

    console.warn('[Battlemat] Bootstrap state was neither string nor object; falling back to embedded demo.');
    return readEmbeddedWorld();
  }

  // This is the in-page demo default. It is parsed from JSON so it matches state_json storage.
  const DEFAULT_STATE = normalizeStateForRenderer(readBootstrapState()) || FALLBACK_STATE_MIN;

  // Debug helper: lets you easily copy the canonical "raw" JSON (world wrapper if present).
  // Note: This returns the last parsed WORLD_STATE if you loaded a world wrapper; otherwise it returns DEFAULT_STATE.
  if (typeof window !== 'undefined') {
  window.BattlematExportRawState = function () {
    const raw = WORLD_STATE || DEFAULT_STATE;
    return JSON.stringify(raw, null, 2);
  };

  function scanCollectionIds(items, label, recordId, floorId, issues) {
    const counts = new Map();
    for (const item of (Array.isArray(items) ? items : [])) {
      const id = item && item.id != null ? String(item.id) : '';
      if (!id) {
        issues.push({ type: 'missing_id', label, recordId, floorId, id: '', detail: '' });
        continue;
      }
      counts.set(id, (counts.get(id) || 0) + 1);
    }
    for (const [id, count] of counts.entries()) {
      if (count > 1) {
        issues.push({ type: 'duplicate_id', label, recordId, floorId, id, detail: 'count=' + count });
      }
    }
  }

  function scanSceneIssues(scene, recordId) {
    const issues = [];
    const floors = getFloorsFromState(scene);
    const floorIds = floors.map(f => (f && f.id != null) ? String(f.id) : '');
    const floorSet = new Set(floorIds.filter(Boolean));

    const tokens = getTokensArray(scene);
    scanCollectionIds(tokens, 'token', recordId, '', issues);
    for (const t of tokens) {
      if (!t || !t.hex) continue;
      const p = parseHex(t.hex);
      if (!p) {
        issues.push({ type: 'bad_hex', label: 'token', recordId, floorId: entityFloorId(t), id: String(t.id || ''), detail: String(t.hex || '') });
      }
      const fid = entityFloorId(t);
      if (fid && !floorSet.has(String(fid))) {
        issues.push({ type: 'unknown_floor', label: 'token', recordId, floorId: String(fid), id: String(t.id || ''), detail: 'floorId not found' });
      }
    }

    for (const floor of floors) {
      const floorId = floor && floor.id != null ? String(floor.id) : '';
      const rooms = Array.isArray(floor && floor.rooms) ? floor.rooms : [];
      const openings = Array.isArray(floor && floor.openings) ? floor.openings : [];
      const objects = Array.isArray(floor && floor.objects) ? floor.objects : [];

      scanCollectionIds(rooms, 'room', recordId, floorId, issues);
      scanCollectionIds(openings, 'opening', recordId, floorId, issues);
      scanCollectionIds(objects, 'object', recordId, floorId, issues);

      for (const r of rooms) {
        const corners = Array.isArray(r && r.corners) ? r.corners : null;
        if (!corners || corners.length !== 4) {
          issues.push({ type: 'bad_corners', label: 'room', recordId, floorId, id: String(r && r.id || ''), detail: 'corners=' + (corners ? corners.length : 0) });
          continue;
        }
        for (const c of corners) {
          try { parseCornerHexId(c); } catch (e) {
            issues.push({ type: 'bad_corner_hex', label: 'room', recordId, floorId, id: String(r && r.id || ''), detail: String(c) });
          }
        }
      }

      const roomMeta = buildRoomMeta(rooms);
      for (const o of openings) {
        const p = parseOpeningHex(o && o.hex);
        if (!p) {
          issues.push({ type: 'bad_hex', label: 'opening', recordId, floorId, id: String(o && o.id || ''), detail: String(o && o.hex || '') });
          continue;
        }
        const ids = openingRoomIds(o, roomMeta);
        if (!ids.length) {
          issues.push({ type: 'orphan_opening', label: 'opening', recordId, floorId, id: String(o && o.id || ''), detail: String(o && o.hex || '') });
        }
      }

      for (const o of objects) {
        const p = parseObjectHex(o && o.hex);
        if (!p) {
          issues.push({ type: 'bad_hex', label: 'object', recordId, floorId, id: String(o && o.id || ''), detail: String(o && o.hex || '') });
        }
      }
    }

    return { recordId, issues };
  }

  function scanRawStateIssues(raw) {
    const report = { issues: [], records: [] };
    const w = (raw && raw.records && raw.active) ? raw : null;
    if (w) {
      const recordIds = Object.keys(w.records || {});
      for (const rid of recordIds) {
        const rec = w.records[rid];
        const res = scanSceneIssues(rec, String(rid));
        report.records.push(res);
        report.issues.push(...res.issues);
      }
    } else {
      const res = scanSceneIssues(raw, 'Scene');
      report.records.push(res);
      report.issues.push(...res.issues);
    }
    report.summary = {
      total: report.issues.length,
      duplicate_id: report.issues.filter(i => i.type === 'duplicate_id').length,
      missing_id: report.issues.filter(i => i.type === 'missing_id').length,
      bad_hex: report.issues.filter(i => i.type === 'bad_hex').length,
      orphan_opening: report.issues.filter(i => i.type === 'orphan_opening').length,
      bad_corners: report.issues.filter(i => i.type === 'bad_corners').length,
      bad_corner_hex: report.issues.filter(i => i.type === 'bad_corner_hex').length,
      unknown_floor: report.issues.filter(i => i.type === 'unknown_floor').length,
    };
    return report;
  }

  function cleanOrphanOpeningsInScene(scene) {
    const removed = [];
    const floors = getFloorsFromState(scene);
    beginUndoBatch('clean orphans');
    for (const floor of floors) {
      const floorId = floor && floor.id != null ? String(floor.id) : '';
      const rooms = Array.isArray(floor && floor.rooms) ? floor.rooms : [];
      const openings = Array.isArray(floor && floor.openings) ? floor.openings : [];
      if (!openings.length) continue;
      const roomMeta = buildRoomMeta(rooms);
      for (let i = openings.length - 1; i >= 0; i -= 1) {
        const o = openings[i];
        const ids = openingRoomIds(o, roomMeta);
        if (!ids.length) {
          const ctx = { openings, floorId };
          if (removeOpening(ctx, o)) {
            removed.push({ floorId, id: String(o && o.id || ''), hex: String(o && o.hex || '') });
          }
        }
      }
    }
    endUndoBatch();
    return removed;
  }

  function findDuplicateIds(items) {
    const counts = new Map();
    for (const item of (Array.isArray(items) ? items : [])) {
      const id = item && item.id != null ? String(item.id) : '';
      if (!id) continue;
      counts.set(id, (counts.get(id) || 0) + 1);
    }
    const dups = new Set();
    for (const [id, count] of counts.entries()) {
      if (count > 1) dups.add(id);
    }
    return dups;
  }

  function buildIssueMarkersForContext(ctx) {
    const markers = [];
    const seen = new Set();
    if (!ctx) return markers;
    const floorId = ctx.floorId;
    const rooms = Array.isArray(ctx.rooms) ? ctx.rooms : [];
    const openings = Array.isArray(ctx.openings) ? ctx.openings : [];
    const objects = Array.isArray(ctx.objects) ? ctx.objects : [];
    const tokens = Array.isArray(ctx.tokens) ? ctx.tokens : [];

    const dupRooms = findDuplicateIds(rooms);
    const dupOpenings = findDuplicateIds(openings);
    const dupObjects = findDuplicateIds(objects);
    const dupTokens = findDuplicateIds(tokens);

    const addMarker = (m) => {
      const key = [
        m.kind || '',
        m.floorId || '',
        m.id || '',
        m.hex || '',
        Array.isArray(m.corners) ? m.corners.join(',') : ''
      ].join('|');
      if (seen.has(key)) return;
      m.key = key;
      markers.push(m);
      seen.add(key);
    };

    const roomMeta = buildRoomMeta(rooms);

    for (let i = 0; i < rooms.length; i++) {
      const r = rooms[i];
      const id = r && r.id != null ? String(r.id) : '';
      if (!id) {
        addMarker({ kind: 'room', floorId, id: '__missing_' + i, corners: r && r.corners ? r.corners.slice() : null, thickness: r && r.thickness, reason: 'missing_id' });
      } else if (dupRooms.has(id)) {
        addMarker({ kind: 'room', floorId, id, corners: r && r.corners ? r.corners.slice() : null, thickness: r && r.thickness, reason: 'duplicate_id' });
      }
    }

    for (let i = 0; i < openings.length; i++) {
      const o = openings[i];
      const id = o && o.id != null ? String(o.id) : '';
      const hex = o && o.hex ? String(o.hex) : '';
      const orient = o && o.orientation ? String(o.orientation) : 'h';
      const ids = openingRoomIds(o, roomMeta);
      if (!id) {
        addMarker({ kind: 'opening', floorId, id: '__missing_' + i, hex, orientation: orient, reason: 'missing_id' });
      } else if (dupOpenings.has(id)) {
        addMarker({ kind: 'opening', floorId, id, hex, orientation: orient, reason: 'duplicate_id' });
      }
      if (!ids.length) {
        addMarker({ kind: 'opening', floorId, id: id || ('__orphan_' + i), hex, orientation: orient, reason: 'orphan' });
      }
    }

    for (let i = 0; i < objects.length; i++) {
      const o = objects[i];
      const id = o && o.id != null ? String(o.id) : '';
      const hex = o && o.hex ? String(o.hex) : '';
      const ox = o && o.ox != null ? Number(o.ox) : undefined;
      const oy = o && o.oy != null ? Number(o.oy) : undefined;
      if (!id) {
        addMarker({ kind: 'object', floorId, id: '__missing_' + i, hex, ox, oy, reason: 'missing_id' });
      } else if (dupObjects.has(id)) {
        addMarker({ kind: 'object', floorId, id, hex, ox, oy, reason: 'duplicate_id' });
      }
    }

    for (let i = 0; i < tokens.length; i++) {
      const t = tokens[i];
      const id = t && t.id != null ? String(t.id) : '';
      const hex = t && t.hex ? String(t.hex) : '';
      if (!id) {
        addMarker({ kind: 'token', floorId, id: '__missing_' + i, hex, reason: 'missing_id' });
      } else if (dupTokens.has(id)) {
        addMarker({ kind: 'token', floorId, id, hex, reason: 'duplicate_id' });
      }
    }

    return markers;
  }

  function setIssueMarkers(markers) {
    EDITOR.issueMarkers = Array.isArray(markers) ? markers : [];
    safeRedraw();
  }

  window.BattlematScanIssues = function (opts = {}) {
    const raw = CURRENT_RAW_STATE || WORLD_STATE || DEFAULT_STATE;
    const report = scanRawStateIssues(raw);
    const ctx = getEditorContext();
    const markers = buildIssueMarkersForContext(ctx);
    setIssueMarkers(markers);
    if (!opts || !opts.silent) {
      const label = report.summary ? ('Issues: ' + report.summary.total) : 'Issues: ?';
      setToolStatus(label, report.summary && report.summary.total ? 'error' : 'ok');
    }
    if (!opts || !opts.silent) {
      console.group('[Battlemat] scan issues');
      console.log('Summary:', report.summary);
      if (report.issues.length) console.table(report.issues);
      console.groupEnd();
    }
    return report;
  };

  window.BattlematClearIssues = function () {
    setIssueMarkers([]);
    setToolStatus('Issues: 0', 'ok');
  };

  window.BattlematCleanOrphanOpenings = function () {
    const scene = getState();
    const removed = cleanOrphanOpeningsInScene(scene);
    if (removed.length) {
      scheduleDatabaseSave();
    }
    console.log('[Battlemat] orphan openings removed:', removed.length);
    if (removed.length) console.table(removed);
    window.BattlematScanIssues({ silent: true });
    return removed;
  };
  }
  function parseMaybeJson(rawOrJson) {
    if (rawOrJson == null) return null;
    if (typeof rawOrJson === 'string') {
      try { return JSON.parse(rawOrJson); } catch { return null; }
    }
    if (typeof rawOrJson === 'object') return rawOrJson;
    return null;
  }

  function cameraHexFromView() {
    try {
      return colToLetters(VIEW.camera.col) + String((Math.round(VIEW.camera.row) + 1));
    } catch {
      return null;
    }
  }

  function ensureWorldWrapper(recordId) {
    const rid = String(recordId || 'Scene').trim() || 'Scene';
    if (WORLD_STATE && WORLD_STATE.records && WORLD_STATE.active) return WORLD_STATE;

    const scene = cloneDeepSafe(CURRENT_STATE || DEFAULT_STATE || FALLBACK_STATE_MIN);
    const floorId =
      VIEW.floorId ||
      (scene.view && scene.view.floorId) ||
      (Array.isArray(scene.floors) && scene.floors[0] ? scene.floors[0].id : null) ||
      null;

    const camHex = cameraHexFromView() || (scene.view && scene.view.camera_hex) || null;

    WORLD_STATE = {
      world: (scene.__worldName || 'World'),
      version: 1,
      meta: { scale: '1 hex = 5 ft' },
      active: { recordId: rid, floorId, camera_hex: camHex },
      records: { [rid]: scene },
      links: []
    };

    return WORLD_STATE;
  }

  function parsePathParts(path) {
    if (Array.isArray(path)) return path.slice();
    const s = String(path || '').trim();
    if (!s) return [];

    const out = [];
    let i = 0;

    while (i < s.length) {
      const ch = s[i];

      if (ch === '.') { i++; continue; }

      if (ch === '[') {
        i++;
        let numStr = '';
        while (i < s.length && s[i] !== ']') {
          numStr += s[i];
          i++;
        }
        i++; // skip ]
        const n = Number(numStr);
        if (!Number.isFinite(n)) throw new Error('Bad array index in path: ' + numStr);
        out.push(n);
        continue;
      }

      // plain token
      let tok = '';
      while (i < s.length) {
        const c = s[i];
        if (c === '.' || c === '[') break;
        tok += c;
        i++;
      }
      tok = tok.trim();
      if (tok) out.push(tok);
    }

    return out;
  }

  function getContainerForSet(root, parts) {
    let cur = root;

    for (let i = 0; i < parts.length - 1; i++) {
      const k = parts[i];
      const nextK = parts[i + 1];
      const nextIsIndex = typeof nextK === 'number';

      if (typeof k === 'number') {
        if (!Array.isArray(cur)) throw new Error('Path expects array at segment ' + i);
        if (cur[k] == null) cur[k] = nextIsIndex ? [] : {};
        cur = cur[k];
      } else {
        if (cur[k] == null) cur[k] = nextIsIndex ? [] : {};
        cur = cur[k];
      }
    }

    return cur;
  }

  function applyOnePatch(root, patch) {
    const op = String(patch && (patch.op || 'set')).toLowerCase();
    const parts = parsePathParts(patch && (patch.pathParts || patch.path));
    if (!parts.length) throw new Error('Patch missing path');

    const parent = getContainerForSet(root, parts);
    const key = parts[parts.length - 1];

    if (op === 'delete' || op === 'del' || op === 'remove') {
      if (typeof key === 'number') {
        if (!Array.isArray(parent)) throw new Error('Delete expects array at leaf');
        parent.splice(key, 1);
      } else {
        delete parent[key];
      }
      return;
    }

    if (op === 'merge') {
      const val = patch && patch.value;
      const curVal = (typeof key === 'number') ? parent[key] : parent[key];

      if (val && typeof val === 'object' && !Array.isArray(val) &&
          curVal && typeof curVal === 'object' && !Array.isArray(curVal)) {
        Object.assign(curVal, val);
      } else {
        if (typeof key === 'number') {
          if (!Array.isArray(parent)) throw new Error('Set expects array at leaf');
          parent[key] = val;
        } else {
          parent[key] = val;
        }
      }
      return;
    }

    // default: set
    if (typeof key === 'number') {
      if (!Array.isArray(parent)) throw new Error('Set expects array at leaf');
      parent[key] = patch.value;
    } else {
      parent[key] = patch.value;
    }
  }

  function refreshFromWorld() {
    if (WORLD_STATE && WORLD_STATE.records && WORLD_STATE.active && WORLD_STATE.active.recordId) {
      setCanonicalStateFromRaw(WORLD_STATE, stableJsonTextFor(WORLD_STATE));
      return;
    }
    if (CURRENT_RAW_STATE) {
      setCanonicalStateFromRaw(CURRENT_RAW_STATE, LAST_STATE_JSON);
      return;
    }
    CURRENT_STATE = DEFAULT_STATE;
    applyViewFromState(CURRENT_STATE);
  }

  window.BattlematGetWorld = function () {
    return WORLD_STATE ? cloneDeepSafe(WORLD_STATE) : null;
  };

  window.BattlematGetWorldJson = function () {
    return WORLD_STATE ? JSON.stringify(WORLD_STATE, null, 2) : null;
  };

  window.BattlematSetWorldState = function (rawOrJson) {
    const parsed = parseMaybeJson(rawOrJson);
    if (!parsed) throw new Error('BattlematSetWorldState: invalid JSON');
    setCanonicalStateFromRaw(parsed, (typeof rawOrJson === 'string') ? rawOrJson : null);
    safeRedraw();
    return true;
  };

  window.BattlematEnsureWorld = function (recordId) {
    ensureWorldWrapper(recordId || 'Scene');
    refreshFromWorld();
    safeRedraw();
    return true;
  };

  window.BattlematSetActive = function (recordId, floorId, camera_hex) {
    const w = ensureWorldWrapper();
    const rid = String(recordId || '').trim();
    if (!rid) throw new Error('BattlematSetActive: recordId required');
    if (!w.records || !w.records[rid]) throw new Error('BattlematSetActive: unknown recordId ' + rid);

    if (!w.active || typeof w.active !== 'object') w.active = { recordId: rid };
    w.active.recordId = rid;
    if (floorId != null) w.active.floorId = String(floorId);
    if (camera_hex != null) w.active.camera_hex = String(camera_hex);

    refreshFromWorld();
    safeRedraw();
    return true;
  };

  window.BattlematApplyPatches = function (patches) {
    const w = ensureWorldWrapper();
    const list = Array.isArray(patches) ? patches : [patches];
    for (const p of list) applyOnePatch(w, p);
    refreshFromWorld();
    safeRedraw();
    return true;
  };

  // ===== State access =====
  function getState() {
    // 1) If we have a fetched state, use it.
    if (CURRENT_STATE && typeof CURRENT_STATE === 'object') return CURRENT_STATE;

    // 2) Otherwise fall back to injected state.
    const injected = (window && window.BATTLE_STATE != null) ? window.BATTLE_STATE : null;
    const raw = injected != null ? injected : DEFAULT_STATE;
    if (injected != null) STATE_SOURCE = 'file';
    if (typeof raw === 'string') {
      try { return JSON.parse(raw); } catch { return DEFAULT_STATE; }
    }
    return raw;
  }


  // ===== State compatibility helpers =====
  // v6.20+: tolerate older schema variants while keeping the renderer deterministic.
  function getTokensArray(state) {
    const s = (state && typeof state === 'object') ? state : null;
    const recordId = s && s.active && s.active.recordId ? String(s.active.recordId) : '';
    const poiId = recordId || (CURRENT_BATTLE_ID ? resolvePoiForBattle(CURRENT_BATTLE_ID) : '');
    const worldTokens = buildTokensFromWorldEntities(poiId);
    if (Array.isArray(worldTokens) && worldTokens.length) return worldTokens;
    if (s && s.records && typeof s.records === 'object') {
      const rid = (s.active && s.active.recordId) ? String(s.active.recordId) : null;
      const record = rid && s.records[rid] ? s.records[rid] : (Object.values(s.records)[0] || null);
      const arr = record && (record.tokens != null ? record.tokens : record.actors);
      return Array.isArray(arr) ? arr : [];
    }
    const arr = s && (s.tokens != null ? s.tokens : s.actors);
    return Array.isArray(arr) ? arr : [];
  }

  function normalizeTokenName(value) {
    return String(value || '').trim().toLowerCase().replace(/\s+/g, ' ');
  }

  function normalizeTokenCharacterIds(tokens) {
    if (!Array.isArray(tokens)) return tokens;
    const ents = getCampaignEntities();
    if (!Array.isArray(ents) || !ents.length) return tokens;
    const byName = new Map();
    for (const ent of ents) {
      if (!ent) continue;
      const cid = ent.character_id != null ? String(ent.character_id)
        : (ent.characterId != null ? String(ent.characterId) : '');
      if (!cid) continue;
      const name = normalizeTokenName(ent.name || ent.label || ent.title || ent.id || cid);
      if (name && !byName.has(name)) byName.set(name, cid);
    }
    for (const token of tokens) {
      if (!token || token.character_id || token.characterId) continue;
      const name = normalizeTokenName(token.name || token.label);
      if (!name) continue;
      const cid = byName.get(name);
      if (cid) token.character_id = cid;
    }
    for (const token of tokens) {
      if (!token) continue;
      const cid = token.character_id != null ? String(token.character_id)
        : (token.characterId != null ? String(token.characterId) : '');
      if (!cid) continue;
      const side = String(token.side || token.team || '').trim().toLowerCase();
      if (side && side !== 'pc' && side !== 'player') continue;
      if (!token.id || String(token.id) !== cid) token.id = cid;
    }
    return tokens;
  }

  function normalizeTokenSideFromKind(kind) {
    const k = String(kind || '').trim().toLowerCase();
    if (k === 'pc' || k === 'player') return 'PC';
    if (k === 'npc' || k === 'monster' || k === 'creature') return 'NPC';
    return '';
  }

  function buildTokensFromWorldEntities(poiId) {
    const ents = getCampaignEntities();
    if (!Array.isArray(ents) || !ents.length) return null;
    const pid = String(poiId || '').trim();
    if (!pid) return null;

    const out = [];
    for (const ent of ents) {
      if (!ent) continue;
      const loc = ent.location && typeof ent.location === 'object' ? ent.location : null;
      const entPoi = ent.current_poi || ent.currentPoi || ent.poi_id || ent.poiId || ent.poi || (loc && (loc.poi_id || loc.poiId || loc.poi)) || null;
      if (!entPoi || String(entPoi) !== pid) continue;

      const stats = ent.stats && typeof ent.stats === 'object' ? ent.stats : null;
      const appearance = ent.appearance && typeof ent.appearance === 'object' ? ent.appearance : null;
      const normalizedSide = normalizeTokenSideFromKind(ent.kind);
      const side = ent.side || normalizedSide || (ent.hostility === 'hostile' ? 'ENEMY' : '');
      const token = {
        id: ent.id || ent.character_id || ent.characterId || ent.name,
        character_id: ent.character_id || ent.characterId || null,
        name: ent.name || ent.label || ent.id || '',
        side,
        kind: ent.kind || null,
        hex: (loc && loc.hex) || ent.hex || ent.tile || '',
        floorId: (loc && (loc.floorId || loc.floor_id)) || ent.floorId || ent.floor_id || '',
        init: (stats && stats.init != null) ? stats.init : (ent.init != null ? ent.init : null),
        hp: (stats && stats.hp != null) ? stats.hp : (ent.hp != null ? ent.hp : null),
        maxHp: (stats && (stats.maxHp != null || stats.max_hp != null)) ? (stats.maxHp != null ? stats.maxHp : stats.max_hp)
          : (ent.maxHp != null ? ent.maxHp : ent.max_hp),
        conditions: (stats && stats.conditions) ? stats.conditions : ent.conditions,
        spriteFile: ent.spriteFile || (appearance && (appearance.spriteFile || appearance.sprite_file || appearance.sprite)) || ent.sprite || null,
        hostility: ent.hostility || ent.attitude || null
      };
      out.push(token);
    }
    return out;
  }

  function getMeta(state) {
    const s = (state && typeof state === 'object') ? state : null;
    return (s && s.meta && typeof s.meta === 'object') ? s.meta : {};
  }

  function getLastAction(state) {
    const s = (state && typeof state === 'object') ? state : null;
    if (!s) return '';
    if (s.last_action != null && s.last_action !== '') return String(s.last_action);
    if (s.lastAction != null && s.lastAction !== '') {
      const v = String(s.lastAction);
      s.last_action = v;
      return v;
    }
    return '';
  }

  function getNarration(state) {
    const s = (state && typeof state === 'object') ? state : null;
    if (!s) return '';
    if (s.narration != null && s.narration !== '') return String(s.narration);
    if (s.narrative != null && s.narrative !== '') {
      const v = String(s.narrative);
      s.narration = v;
      return v;
    }
    return '';
  }

  function renderSignatureFor(state, opts = {}) {
    const s = (state && typeof state === 'object') ? state : {};
    const {
      narration,
      narrative,
      narrationText,
      last_action,
      lastAction,
      lastActionText,
      ...rest
    } = s;

    const sig = {
      ...rest,
      __render: {
        view: { floorId: VIEW.floorId, camera: VIEW.camera },
        zoom: ZOOM,
        supersample: SUPERSAMPLE,
        ui: {
          fog: !!opts.fogEnabled,
          sprites: !!opts.spritesEnabled,
          labels: !!opts.labelsEnabled,
        },
        spritesLoaded: SPRITE_LOAD_TICK,
      },
    };

    return stableJsonTextFor(sig);
  }

  function editorSignatureFor() {
    const preview = (EDITOR.preview && EDITOR.preview.opening)
      ? { floorId: EDITOR.preview.floorId || null, hex: EDITOR.preview.opening.hex, orientation: EDITOR.preview.opening.orientation }
      : null;
    const objectPreview = (EDITOR.objectPreview && EDITOR.objectPreview.object)
      ? {
          floorId: EDITOR.objectPreview.floorId || null,
          hex: EDITOR.objectPreview.object.hex,
          kind: EDITOR.objectPreview.object.kind,
          rotDeg: EDITOR.objectPreview.object.rotDeg,
          ox: EDITOR.objectPreview.object.ox,
          oy: EDITOR.objectPreview.object.oy,
          spriteScale: EDITOR.objectPreview.object.spriteScale,
        }
      : null;
    const roomPreview = (EDITOR.roomPreview && EDITOR.roomPreview.room && Array.isArray(EDITOR.roomPreview.room.corners))
      ? { floorId: EDITOR.roomPreview.floorId || null, corners: EDITOR.roomPreview.room.corners }
      : null;
    const roomStart = EDITOR.roomStart
      ? { floorId: EDITOR.roomStart.floorId || null, col: EDITOR.roomStart.col, row: EDITOR.roomStart.row }
      : null;
    const selected = (EDITOR.selectedId && EDITOR.selectedFloorId)
      ? { id: EDITOR.selectedId, floorId: EDITOR.selectedFloorId }
      : null;
    const selectedObject = (EDITOR.selectedObjectId && EDITOR.selectedObjectFloorId)
      ? { id: EDITOR.selectedObjectId, floorId: EDITOR.selectedObjectFloorId }
      : null;
    const selectedRoom = (EDITOR.selectedRoomId && EDITOR.selectedRoomFloorId)
      ? { id: EDITOR.selectedRoomId, floorId: EDITOR.selectedRoomFloorId }
      : null;
    const issues = Array.isArray(EDITOR.issueMarkers)
      ? EDITOR.issueMarkers.map(m => String(m && m.key != null ? m.key : '')).filter(Boolean)
      : [];
    return stableJsonTextFor({
      tool: EDITOR.tool,
      preview,
      objectPreview,
      roomPreview,
      roomStart,
      selected,
      selectedObject,
      selectedRoom,
      issues,
    });
  }

  // ===== Hex id helpers =====
  function colToLetters(col) {
    let n = col + 1;
    let s = '';
    while (n > 0) {
      const r = (n - 1) % 26;
      s = String.fromCharCode(65 + r) + s;
      n = Math.floor((n - 1) / 26);
    }
    return s;
  }

  function lettersToCol(letters) {
    const u = String(letters).toUpperCase();
    let n = 0;
    for (let i = 0; i < u.length; i++) {
      const c = u.charCodeAt(i);
      if (c < 65 || c > 90) throw new Error('Bad column letters');
      n = n * 26 + (c - 64);
    }
    return n - 1;
  }

  function parseHexId(hex) {
    const m = String(hex).trim().toUpperCase().match(/^([A-Z]+)([0-9]+)$/);
    if (!m) throw new Error('Bad hex: ' + hex);
    return { col: lettersToCol(m[1]), row: parseInt(m[2], 10) - 1 };
  }

  function parseHex(hex) {
    try { return parseHexId(hex); } catch { return null; }
  }


  // Openings (doors/windows/thresholds) may use quarter-step rows (e.g. AD20.25)
  // to support odd hall geometries. Corners already allow arbitrary decimals.
  function isQuarterStep(n) {
    const v = Number(n);
    if (!Number.isFinite(v)) return false;
    return Math.abs(v * 4 - Math.round(v * 4)) < 1e-6;
  }

  function parseOpeningHexId(hex) {
    const m = String(hex).trim().toUpperCase().match(/^([A-Z]+)([0-9]+(?:\.[0-9]+)?)$/);
    if (!m) throw new Error('Bad opening hex: ' + hex);

    const col = lettersToCol(m[1]);
    const rowNum = parseFloat(m[2]);
    if (!isQuarterStep(rowNum)) throw new Error('Opening hex must be in 0.25 steps (e.g. 20, 20.25, 20.5, 20.75): ' + hex);

    return { col, row: rowNum - 1 };
  }

  function parseOpeningHex(hex) {
    try { return parseOpeningHexId(hex); } catch { return null; }
  }

  // Objects can optionally sit on half/quarter rows too (e.g. O20.5), which is handy for
  // 1/2-hex placement without needing ox/oy micro-adjustments.
  function parseObjectHexId(hex) {
    const m = String(hex).trim().toUpperCase().match(/^([A-Z]+)([0-9]+(?:\.[0-9]+)?)$/);
    if (!m) throw new Error('Bad object hex: ' + hex);

    const col = lettersToCol(m[1]);
    const rowNum = parseFloat(m[2]);
    if (!isQuarterStep(rowNum)) throw new Error('Object hex must be in 0.25 steps (e.g. 20, 20.25, 20.5, 20.75): ' + hex);

    return { col, row: rowNum - 1 };
  }

  function parseObjectHex(hex) {
    try { return parseObjectHexId(hex); } catch { return null; }
  }

  function parseCornerHexId(hex) {
    const m = String(hex).trim().toUpperCase().match(/^([A-Z]+)([0-9]+(?:\.[0-9]+)?)$/);
    if (!m) throw new Error('Bad corner hex: ' + hex);

    const col = lettersToCol(m[1]);
    const rowNum = parseFloat(m[2]);
    if (!Number.isFinite(rowNum)) throw new Error('Bad corner row: ' + hex);

    return { col, row: rowNum - 1 };
  }

  function hexId(col, row) {
    return colToLetters(col) + String(row + 1);
  }

  // ===== World geometry (flat-top) =====
  function colStep() { return 1.5 * GRID.size; }
  function rowStep() { return sqrt3 * GRID.size; }

  // Row 0 is bottom row ("1"), row increases upward.
  function hexCenterWorld(col, row) {
    const x = col * colStep();
    const y = -(row * rowStep() + (col & 1) * (rowStep() / 2));
    return { x, y };
  }

  // ===== Camera transform =====
  function cameraWorld() { return hexCenterWorld(VIEW.camera.col, VIEW.camera.row); }

  function worldToScreen(p) {
    const cam = cameraWorld();
    return { x: VIEW.anchor.x + (p.x - cam.x), y: VIEW.anchor.y + (p.y - cam.y) };
  }

  // ===== Floors (multi-floor) =====
  function getFloorsFromState(state) {
    const f = state && state.floors;
    if (Array.isArray(f)) return f;

    if (f && typeof f === 'object') {
      return Object.entries(f).map(([id, data]) => ({ id, ...(data || {}) }));
    }

    return [{
      id: (state && state.view && (state.view.floorId || state.view.floor_id || state.view.floor)) ? String(state.view.floorId || state.view.floor_id || state.view.floor) : 'floor1',
      name: 'Floor',
      rooms: Array.isArray(state && state.rooms) ? state.rooms : [],
      openings: Array.isArray(state && state.openings) ? state.openings : [],
      objects: Array.isArray(state && state.objects) ? state.objects : [],
    }];
  }

  function pickActiveFloorId(state, floors) {
    const wanted = state && state.view ? (state.view.floorId || state.view.floor_id || state.view.floor || state.view.level) : null;
    const w = wanted != null ? String(wanted) : '';
    if (w && floors.some(f => String(f.id) === w)) return w;
    return floors.length ? String(floors[0].id) : 'floor1';
  }

  function floorById(floors, id) {
    const target = String(id || '');
    return floors.find(f => String(f.id) === target) || null;
  }

  function entityFloorId(e) {
    if (!e || typeof e !== 'object') return '';
    return String(e.floorId || e.floor_id || e.floor || e.level || e.z || '');
  }

  function tokensOnFloor(state, floorId) {
    const all = normalizeTokenCharacterIds(getTokensArray(state));
    return all.filter(t => {
      const fid = entityFloorId(t);
      return fid ? fid === String(floorId) : true;
    });
  }

  // ===== Rooms / walls geometry =====
  function roomWallKind(room) {
    const w = (room && room.wall && typeof room.wall === 'object') ? room.wall : null;
    const k = (w && w.kind != null) ? String(w.kind) : '';
    const t = (w && w.type != null) ? String(w.type) : '';
    return String((k || t || 'brick')).toLowerCase();
  }

  function roomHasWalls(room) {
    const thick = Number(room && room.thickness != null ? room.thickness : 0);
    const wk = roomWallKind(room);
    return thick > 0 && wk !== 'none';
  }

  function roomToWallBox(room) {
    const corners = Array.isArray(room && room.corners) ? room.corners : [];
    if (corners.length !== 4) throw new Error('Room corners must be [TL, TR, BR, BL]');

    const tl = parseCornerHexId(corners[0]);
    const tr = parseCornerHexId(corners[1]);
    const br = parseCornerHexId(corners[2]);
    const bl = parseCornerHexId(corners[3]);

    const pTL = hexCenterWorld(tl.col, tl.row);
    const pTR = hexCenterWorld(tr.col, tr.row);
    const pBR = hexCenterWorld(br.col, br.row);
    const pBL = hexCenterWorld(bl.col, bl.row);

    const xL = (pTL.x + pBL.x) / 2;
    const xR = (pTR.x + pBR.x) / 2;
    const yTop = (pTL.y + pTR.y) / 2;
    const yBot = (pBL.y + pBR.y) / 2;

    const thicknessBase = Number(room && room.thickness != null ? room.thickness : 20);
    // room.thickness is specified at 100% zoom; scale by ZOOM so walls stay proportional.
    const thickness = thicknessBase * (Number(ZOOM) || 1);

    const t = roomHasWalls(room) ? thickness : 0;

    const half = t / 2;

    const mid = { x1: xL, y1: yTop, x2: xR, y2: yBot };
    const floor = { x1: xL + half, y1: yTop + half, x2: xR - half, y2: yBot - half };

    return { xL, xR, yTop, yBot, thickness: t, mid, floor };
  }

  function roomFloorRectWorld(room, box) {
    const src = (roomHasWalls(room) ? box.floor : box.mid);
    return { x1: src.x1, y1: src.y1, x2: src.x2, y2: src.y2 };
  }

  function buildWallSegments(rooms) {
    const segs = [];
    for (const r of (Array.isArray(rooms) ? rooms : [])) {
      if (!r || !roomHasWalls(r)) continue;
      const box = roomToWallBox(r);
      const t = box.thickness;

      const color = (r && r.color) ? String(r.color) : COLORS.wall;
      const wallKind = roomWallKind(r);

      segs.push({ orientation: 'h', y: box.yTop, x1: box.xL, x2: box.xR, thickness: t, color, wallKind });
      segs.push({ orientation: 'h', y: box.yBot, x1: box.xL, x2: box.xR, thickness: t, color, wallKind });
      segs.push({ orientation: 'v', x: box.xL, y1: box.yTop, y2: box.yBot, thickness: t, color, wallKind });
      segs.push({ orientation: 'v', x: box.xR, y1: box.yTop, y2: box.yBot, thickness: t, color, wallKind });
    }
    return segs;
  }

  function findNearestWallSegment(wallSegs, orient, p) {
    const want = (orient === 'h' || orient === 'v') ? orient : 'h';
    let best = null;
    let bestD2 = Infinity;

    for (const s of (Array.isArray(wallSegs) ? wallSegs : [])) {
      if (!s || s.orientation !== want) continue;

      if (want === 'h') {
        const dy = Math.abs((p && p.y) - s.y);
        let dx = 0;
        if ((p && p.x) < s.x1) dx = s.x1 - (p.x);
        else if ((p && p.x) > s.x2) dx = (p.x) - s.x2;
        const d2 = dx * dx + dy * dy;
        if (d2 < bestD2) { bestD2 = d2; best = s; }
      } else {
        const dx = Math.abs((p && p.x) - s.x);
        let dy = 0;
        if ((p && p.y) < s.y1) dy = s.y1 - (p.y);
        else if ((p && p.y) > s.y2) dy = (p.y) - s.y2;
        const d2 = dx * dx + dy * dy;
        if (d2 < bestD2) { bestD2 = d2; best = s; }
      }
    }

    return best;
  }

  function quant01(v) { return Math.round(v * 100) / 100; }

  function dedupeWallSegments(segs) {
    const map = new Map();

    for (const s of (Array.isArray(segs) ? segs : [])) {
      if (!s) continue;
      const o = s.orientation;
      if (o === 'h') {
        const y = quant01(s.y);
        const x1 = quant01(Math.min(s.x1, s.x2));
        const x2 = quant01(Math.max(s.x1, s.x2));
        const key = `h|${y}|${x1}|${x2}`;
        const prev = map.get(key);
        if (!prev) map.set(key, { ...s, y, x1, x2 });
        else prev.thickness = Math.max(prev.thickness, s.thickness);
      } else {
        const x = quant01(s.x);
        const y1 = quant01(Math.min(s.y1, s.y2));
        const y2 = quant01(Math.max(s.y1, s.y2));
        const key = `v|${x}|${y1}|${y2}`;
        const prev = map.get(key);
        if (!prev) map.set(key, { ...s, x, y1, y2 });
        else prev.thickness = Math.max(prev.thickness, s.thickness);
      }
    }

    return [...map.values()];
  }

  function drawWallSegments(targetCtx, wallSegs) {
    const wantTextures = !!(elSpriteToggle && elSpriteToggle.checked);

    for (const s of (Array.isArray(wallSegs) ? wallSegs : [])) {
      if (!s || !s.thickness) continue;

      const t = s.thickness;
      const half = t / 2;

      let fill = s.color || COLORS.wall;
      if (wantTextures) {
        const def = resolveTextureDef('wall', s.wallKind);
        if (def) {
          const pat = getRepeatPatternForCtx(targetCtx, def);
          if (pat) fill = pat;
        }
      }
      targetCtx.fillStyle = fill;

        if (s.orientation === 'h') {
          const x1 = s.x1 - half;
          const x2 = s.x2 + half;
          const y1 = s.y - half;
          const y2 = s.y + half;

          const p1 = worldToScreen({ x: x1, y: y1 });
          const p2 = worldToScreen({ x: x2, y: y2 });
          const sx1 = snapCss(Math.min(p1.x, p2.x));
          const sx2 = snapCss(Math.max(p1.x, p2.x));
          const sy1 = snapCss(Math.min(p1.y, p2.y));
          const sy2 = snapCss(Math.max(p1.y, p2.y));
          const w = sx2 - sx1;
          const h = sy2 - sy1;
          if (w > 0 && h > 0) targetCtx.fillRect(sx1, sy1, w, h);
        } else {
          const x1 = s.x - half;
          const x2 = s.x + half;
          const y1 = s.y1 - half;
          const y2 = s.y2 + half;

          const p1 = worldToScreen({ x: x1, y: y1 });
          const p2 = worldToScreen({ x: x2, y: y2 });
          const sx1 = snapCss(Math.min(p1.x, p2.x));
          const sx2 = snapCss(Math.max(p1.x, p2.x));
          const sy1 = snapCss(Math.min(p1.y, p2.y));
          const sy2 = snapCss(Math.max(p1.y, p2.y));
          const w = sx2 - sx1;
          const h = sy2 - sy1;
          if (w > 0 && h > 0) targetCtx.fillRect(sx1, sy1, w, h);
        }
      }
    }

  // ===== Floor fills =====
  function floorBaseColor(kind) {
    const k = String(kind || 'wood').toLowerCase();
    if (k === 'fog') return COLORS.fogUnseen;
    if (k === 'stone') return COLORS.floorStone;
    if (k === 'cobble') return COLORS.floorCobble;
    if (k.startsWith('stairs')) return COLORS.floorWood;
    return COLORS.floorWood;
  }

  function getFloorFillStyle(kind, wantTextures, targetCtx = ctx) {
    const fk = String(kind || 'wood').toLowerCase();
    if (!wantTextures) return floorBaseColor(fk);
    const def = resolveTextureDef('floor', fk);
    if (!def) return floorBaseColor(fk);
    const pat = getRepeatPatternForCtx(targetCtx, def);
    return pat || floorBaseColor(fk);
  }

  function isFogFloorRoom(room) {
    const k = room && room.floor && room.floor.kind ? String(room.floor.kind).toLowerCase() : '';
    return k === 'fog';
  }

    function drawFloorsLayered(rooms) {
      const wantTextures = !!(elSpriteToggle && elSpriteToggle.checked);

      for (const r of (Array.isArray(rooms) ? rooms : [])) {
        const box = roomToWallBox(r);
        const f = roomFloorRectWorld(r, box);
        const p1 = worldToScreen({ x: f.x1, y: f.y1 });
        const p2 = worldToScreen({ x: f.x2, y: f.y2 });
        const x1 = snapCss(Math.min(p1.x, p2.x));
        const x2 = snapCss(Math.max(p1.x, p2.x));
        const y1 = snapCss(Math.min(p1.y, p2.y));
        const y2 = snapCss(Math.max(p1.y, p2.y));
        const w = x2 - x1;
        const h = y2 - y1;
        if (w <= 0 || h <= 0) continue;

        const fk = (r && r.floor && r.floor.kind) ? String(r.floor.kind).toLowerCase() : 'wood';
        ctx.fillStyle = getFloorFillStyle(fk, wantTextures, ctx);
        ctx.fillRect(x1, y1, w, h);
      }
    }

  // ===== Openings =====
  function openingOrientation(opening) {
    const o = opening && opening.orientation ? String(opening.orientation).toLowerCase() : 'h';
    if (o === 'v' || o === 'vert' || o === 'vertical') return 'v';
    return 'h';
  }

  function openingSpan(opening) {
    const s = Number(opening && opening.span != null ? opening.span : 1);
    return clamp(Number.isFinite(s) ? s : 1, 0.5, 4);
  }

  function isDoorKind(kind) {
    const k = String(kind || '').toLowerCase();
    return (k === 'door' || k.startsWith('door_') || k.startsWith('door.'));
  }

  // Pixel padding applied to wall cutouts / seam fills.
  // To avoid 1px seams at certain zoom levels, we apply a small buffer.
  // For thresholds, we ONLY buffer in the axis perpendicular to the opening orientation:
  //   - vertical threshold (orientation 'v') => widen horizontally (+4px)
  //   - horizontal threshold (orientation 'h') => widen vertically (+4px)
  // This keeps the threshold span aligned to the parent floor, while still covering subpixel seams.
  function openingPadAxes(opening, thickness) {
    const kind = String(opening && opening.kind ? opening.kind : 'door').toLowerCase();
    const orient = openingOrientation(opening);

    // No padding needed for portals (they don't cut walls/floors).
    if (kind === 'portal' || kind === 'connector') return { x: 0, y: 0 };

    // Scale padding with backing-store resolution (DPR × supersample) to prevent 1px seams
    // at high zoom levels.
    const d = Number(VIEW && VIEW.dpr) || 1;
    const t = Number.isFinite(thickness) && thickness > 0 ? thickness : (GRID.size * 0.6);
    const maxPad = Math.max(2, Math.round(t * 0.12));
    const pad = clamp(Math.ceil(1 * d), 1, maxPad);

    // Thresholds: buffer only perpendicular to the opening orientation.
    if (kind === 'threshold') {
      return (orient === 'v') ? { x: pad, y: 0 } : { x: 0, y: pad };
    }

    // Doors/windows: small buffer in both axes helps hide seams.
    return { x: pad, y: pad };
  }

  // Opening length in world-units (CSS px). For thresholds, we auto-size to the parent room's
  // interior span so the knockout matches the parent floor space exactly.
  function openingLengthWorld(opening, rooms) {
    const kind = String(opening && opening.kind ? opening.kind : 'door').toLowerCase();
    const orient = openingOrientation(opening);

    if (kind === 'threshold') {
      const parentId = (opening && opening.parent != null) ? String(opening.parent) : '';
      const parent = parentId ? roomById(rooms, parentId) : null;
      if (parent) {
        const box = roomToWallBox(parent);
        const fr = roomFloorRectWorld(parent, box);
        const worldLen = (orient === 'h') ? Math.abs(fr.x2 - fr.x1) : Math.abs(fr.y2 - fr.y1);
        // Guardrails: never return something absurdly tiny.
        return Math.max(worldLen, GRID.size * 0.6);
      }
      // If no parent is provided/found, fall back to span sizing.
    }

    const baseLen = GRID.size * 1.2;
    const span = openingSpan(opening);
    return baseLen * span;
  }

  function openingWallThickness(opening, wallSegs, rooms, roomMetaAll) {
    const orient = openingOrientation(opening);
    const p = parseOpeningHex(opening && opening.hex);
    if (p && Array.isArray(wallSegs)) {
      const hexWorld = hexCenterWorld(p.col, p.row);
      const seg = findNearestWallSegment(wallSegs, orient, hexWorld);
      if (seg && Number.isFinite(seg.thickness) && seg.thickness > 0) return seg.thickness;
    }

    const parentId = (opening && opening.parent != null) ? String(opening.parent) : '';
    if (parentId) {
      const parent = roomById(rooms, parentId);
      if (parent && roomHasWalls(parent)) {
        const base = Number(parent.thickness);
        if (Number.isFinite(base) && base > 0) return base * (Number(ZOOM) || 1);
      }
    }

    if (roomMetaAll) {
      const ids = openingRoomIds(opening, roomMetaAll, wallSegs);
      for (const id of ids) {
        const room = roomById(rooms, id);
        if (room && roomHasWalls(room)) {
          const base = Number(room.thickness);
          if (Number.isFinite(base) && base > 0) return base * (Number(ZOOM) || 1);
        }
      }
    }

    const defaults = roomDefaultsFor({ rooms: Array.isArray(rooms) ? rooms : [] });
    const base = Number(defaults && defaults.thickness);
    const fallback = (Number.isFinite(base) && base > 0) ? base : 15;
    return fallback * (Number(ZOOM) || 1);
  }

  function cutOpeningHole(targetCtx, opening, wallSegs, rooms, roomMetaAll) {
    const kind = String(opening && opening.kind ? opening.kind : 'door').toLowerCase();
    if (kind === 'portal' || kind === 'connector') return;

    const orient = openingOrientation(opening);
    const p = parseOpeningHex(opening.hex);
    if (!p) return;

    const hexWorld = hexCenterWorld(p.col, p.row);
    const seg = findNearestWallSegment(wallSegs, orient, hexWorld);

    // Important: snap the cutout centerline onto the actual wall segment axis.
    // At extreme zoom levels, tiny float/quantization differences can otherwise mean
    // the cutout misses the wall by ~<1px, making the "knockout" look like it vanished.
    let cx = hexWorld.x;
    let cy = hexWorld.y;
    if (seg) {
      if (orient === 'h' && Number.isFinite(seg.y)) cy = seg.y;
      if (orient === 'v' && Number.isFinite(seg.x)) cx = seg.x;
    }

    const len = openingLengthWorld(opening, rooms);
    const thickness = openingWallThickness(opening, wallSegs, rooms, roomMetaAll);

    const centerS = worldToScreen({ x: cx, y: cy });
    const pad = openingPadAxes(opening, thickness);

    // Axis-aligned screen rect (no rotation) so this matches seam fills exactly.
    // Base rect dimensions depend on orientation, then we apply axis-specific padding.
    const baseW = (orient === 'v') ? thickness : len;
    const baseH = (orient === 'v') ? len : thickness;
    const w = baseW + (pad.x || 0);
    const h = baseH + (pad.y || 0);

    const rr = snappedRectFromCenter(centerS, w, h);
    if (rr.w > 0 && rr.h > 0) targetCtx.fillRect(rr.x, rr.y, rr.w, rr.h);
  }

  function drawOpeningMarker(opening, wallSegs, rooms, roomMetaAll) {
    const kind = String(opening && opening.kind ? opening.kind : 'door').toLowerCase();
    if (kind === 'threshold' || kind === 'portal' || kind === 'connector') return;

    const orient = openingOrientation(opening);
    const p = parseOpeningHex(opening.hex);
    if (!p) return;

    const hexWorld = hexCenterWorld(p.col, p.row);
    const seg = findNearestWallSegment(wallSegs, orient, hexWorld);

    // Keep the marker aligned to the wall segment axis (same reason as cutOpeningHole).
    let cx = hexWorld.x;
    let cy = hexWorld.y;
    if (seg) {
      if (orient === 'h' && Number.isFinite(seg.y)) cy = seg.y;
      if (orient === 'v' && Number.isFinite(seg.x)) cx = seg.x;
    }

    const thickness = openingWallThickness(opening, wallSegs, rooms, roomMetaAll);

    const c = worldToScreen({ x: cx, y: cy });
    const len = (GRID.size * 1.2) * openingSpan(opening);
    const openPct = clamp(Number(opening && opening.openPct != null ? opening.openPct : 0), 0, 1);

    ctx.save();
    ctx.translate(c.x, c.y);
    if (orient === 'v') ctx.rotate(Math.PI / 2);

    if (kind === 'window') {
      ctx.strokeStyle = COLORS.window;
      ctx.globalAlpha = 0.85;
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(-len / 2, 0);
      ctx.lineTo(len / 2, 0);
      ctx.stroke();

      ctx.globalAlpha = 0.45;
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(-len / 2, -thickness * 0.25);
      ctx.lineTo(len / 2, -thickness * 0.25);
      ctx.moveTo(-len / 2, thickness * 0.25);
      ctx.lineTo(len / 2, thickness * 0.25);
      ctx.stroke();

      ctx.restore();
      return;
    }

    // Door sprites (e.g. kind: 'door_wood')
    if (isDoorKind(kind) && SPRITES_ENABLED) {
      const def = getSpriteDef(kind);
      if (def) {
        const img = loadSprite(def.file);
        if (img && img.complete && img.naturalWidth && img.naturalHeight) {
          const hingeSide = String(opening && opening.hinge != null ? opening.hinge : 'left').toLowerCase();
          const hingeRight = (hingeSide === 'right' || hingeSide === 'r');

          const rawSwing = Number(opening && (opening.swing ?? opening.swingDir ?? opening.polarity));
          const swingSign = (rawSwing === 1 || rawSwing === -1) ? rawSwing : -1;

          const hingeX = hingeRight ? (len / 2) : (-len / 2);
          const hingeY = 0;

          const leafLen = len * 0.80;
          const boxW = leafLen;
          const boxH = thickness * 1.25;

          // Allow door openings to scale their sprite just like objects do.
          // (e.g. { kind:'door.wood', ..., spriteScale: 1.3 })
          let sx = 1, sy = 1;
          if (isFiniteNum(def.scale)) { sx *= Number(def.scale); sy *= Number(def.scale); }
          if (isFiniteNum(def.scaleX)) sx *= Number(def.scaleX);
          if (isFiniteNum(def.scaleY)) sy *= Number(def.scaleY);
          if (isFiniteNum(opening.spriteScale)) { sx *= Number(opening.spriteScale); sy *= Number(opening.spriteScale); }
          if (isFiniteNum(opening.spriteScaleX)) sx *= Number(opening.spriteScaleX);
          if (isFiniteNum(opening.spriteScaleY)) sy *= Number(opening.spriteScaleY);

          const ang = openPct * (Math.PI / 2);

          ctx.save();
          ctx.translate(hingeX, hingeY);
          ctx.rotate((hingeRight ? -1 : 1) * swingSign * ang);

          const ok = drawSpriteImage(img, {
            x: 0,
            y: 0,
            w: boxW * sx,
            h: boxH * sy,
            fit: 'contain',
            anchorX: hingeRight ? 1 : 0,
            anchorY: 0.5,
          });
          ctx.restore();

          if (ok) {
            ctx.restore();
            return;
          }
        }
      }
    }

    ctx.strokeStyle = COLORS.door;
    ctx.lineWidth = 4;
    ctx.globalAlpha = 0.9;

    if (openPct < 0.05) {
      ctx.beginPath();
      ctx.moveTo(-len / 2, 0);
      ctx.lineTo(len / 2, 0);
      ctx.stroke();
    } else {
      const hingeSide = String(opening && opening.hinge != null ? opening.hinge : 'left').toLowerCase();
      const hingeRight = (hingeSide === 'right' || hingeSide === 'r');

      const rawSwing = Number(opening && (opening.swing ?? opening.swingDir ?? opening.polarity));
      const swingSign = (rawSwing === 1 || rawSwing === -1) ? rawSwing : -1;

      const hingeX = hingeRight ? (len / 2) : (-len / 2);
      const hingeY = 0;

      const leafLen = len * 0.80;
      const ang = openPct * (Math.PI / 2);

      const x2 = hingeX + (hingeRight ? -1 : 1) * leafLen * Math.cos(ang);
      const y2 = hingeY + swingSign * leafLen * Math.sin(ang);

      ctx.beginPath();
      ctx.moveTo(hingeX, hingeY);
      ctx.lineTo(x2, y2);
      ctx.stroke();

      ctx.fillStyle = COLORS.door;
      ctx.globalAlpha = 0.95;
      ctx.beginPath();
      ctx.arc(hingeX, hingeY, 2.2, 0, Math.PI * 2);
      ctx.fill();
    }

    ctx.restore();
  }

  function drawOpeningOverlay(opening, wallSegs, opts = {}) {
    const o = opening || {};
    const orient = openingOrientation(o);
    const p = parseOpeningHex(o.hex);
    if (!p) return;

    const hexWorld = hexCenterWorld(p.col, p.row);
    const seg = findNearestWallSegment(wallSegs, orient, hexWorld);
    let cx = hexWorld.x;
    let cy = hexWorld.y;
    if (seg) {
      if (orient === 'h') cy = seg.y;
      else cx = seg.x;
    }

    const len = (GRID.size * 1.2) * openingSpan(o);
    const half = len / 2;
    const centerS = worldToScreen({ x: cx, y: cy });

    ctx.save();
    ctx.globalAlpha = 0.85;
    ctx.strokeStyle = opts.strokeStyle || 'rgba(67,209,122,0.9)';
    ctx.lineWidth = Number.isFinite(opts.lineWidth) ? opts.lineWidth : 3;
    if (opts.dash) ctx.setLineDash(opts.dash);
    ctx.beginPath();
    if (orient === 'h') {
      ctx.moveTo(centerS.x - half, centerS.y);
      ctx.lineTo(centerS.x + half, centerS.y);
    } else {
      ctx.moveTo(centerS.x, centerS.y - half);
      ctx.lineTo(centerS.x, centerS.y + half);
    }
    ctx.stroke();
    ctx.restore();
  }

  function drawRoomOverlay(room, opts = {}) {
    if (!room || !room.corners) return;
    let box = null;
    try {
      box = roomToWallBox(room);
    } catch {
      return;
    }
    const rect = roomFloorRectWorld(room, box);
    const p1 = worldToScreen({ x: rect.x1, y: rect.y1 });
    const p2 = worldToScreen({ x: rect.x2, y: rect.y2 });
    const x = Math.min(p1.x, p2.x);
    const y = Math.min(p1.y, p2.y);
    const w = Math.abs(p2.x - p1.x);
    const h = Math.abs(p2.y - p1.y);
    ctx.save();
    ctx.globalAlpha = 0.85;
    ctx.strokeStyle = opts.strokeStyle || 'rgba(67,209,122,0.9)';
    ctx.lineWidth = Number.isFinite(opts.lineWidth) ? opts.lineWidth : 3;
    if (opts.dash) ctx.setLineDash(opts.dash);
    ctx.strokeRect(x, y, w, h);
    ctx.restore();
  }

  function drawIssueRing(world, radius, opts = {}) {
    if (!world) return;
    const center = worldToScreen(world);
    const r = Number.isFinite(radius) ? radius : (GRID.size * 0.5);
    ctx.save();
    ctx.globalAlpha = Number.isFinite(opts.alpha) ? opts.alpha : 0.9;
    ctx.strokeStyle = opts.strokeStyle || 'rgba(255,80,80,0.95)';
    ctx.lineWidth = Number.isFinite(opts.lineWidth) ? opts.lineWidth : 3;
    if (opts.dash) ctx.setLineDash(opts.dash);
    ctx.beginPath();
    ctx.arc(center.x, center.y, r, 0, Math.PI * 2);
    ctx.stroke();
    ctx.restore();
  }

  function drawIssueMarker(marker, wallSegs) {
    if (!marker) return;
    const kind = String(marker.kind || '').toLowerCase();
    if (kind === 'opening') {
      const p = parseOpeningHex(marker.hex);
      if (!p) return;
      const hexWorld = hexCenterWorld(p.col, p.row);
      const orient = marker.orientation || 'h';
      const seg = findNearestWallSegment(wallSegs, orient, hexWorld);
      let cx = hexWorld.x;
      let cy = hexWorld.y;
      if (seg) {
        if (orient === 'h' && Number.isFinite(seg.y)) cy = seg.y;
        if (orient === 'v' && Number.isFinite(seg.x)) cx = seg.x;
      }
      drawIssueRing({ x: cx, y: cy }, GRID.size * 0.45);
      return;
    }
    if (kind === 'object') {
      const p = parseObjectHex(marker.hex);
      if (!p) return;
      const world = objectCenterWorld({ hex: marker.hex, ox: marker.ox, oy: marker.oy });
      if (!world) return;
      drawIssueRing(world, GRID.size * 0.45);
      return;
    }
    if (kind === 'token') {
      const p = parseHex(marker.hex);
      if (!p) return;
      drawIssueRing(hexCenterWorld(p.col, p.row), GRID.size * 0.5);
      return;
    }
    if (kind === 'room') {
      if (!Array.isArray(marker.corners)) return;
      const room = { corners: marker.corners, thickness: marker.thickness || 0, wall: { kind: 'none' } };
      let box = null;
      try { box = roomToWallBox(room); } catch { box = null; }
      if (!box) return;
      const rect = roomFloorRectWorld(room, box);
      const cx = (rect.x1 + rect.x2) / 2;
      const cy = (rect.y1 + rect.y2) / 2;
      const radius = Math.max(GRID.size * 0.6, Math.min(Math.abs(rect.x2 - rect.x1), Math.abs(rect.y2 - rect.y1)) * 0.35);
      drawIssueRing({ x: cx, y: cy }, radius, { dash: [6, 4], lineWidth: 2.5 });
    }
  }

  function drawHexHighlight(col, row, opts = {}) {
    if (!Number.isFinite(col) || !Number.isFinite(row)) return;
    const center = worldToScreen(hexCenterWorld(col, row));
    const r = GRID.size;
    const h = (Math.sqrt(3) / 2) * r;
    const points = [
      { x: center.x + r, y: center.y },
      { x: center.x + r / 2, y: center.y + h },
      { x: center.x - r / 2, y: center.y + h },
      { x: center.x - r, y: center.y },
      { x: center.x - r / 2, y: center.y - h },
      { x: center.x + r / 2, y: center.y - h },
    ];
    ctx.save();
    ctx.globalAlpha = Number.isFinite(opts.alpha) ? opts.alpha : 0.5;
    ctx.strokeStyle = opts.strokeStyle || 'rgba(67,209,122,0.9)';
    ctx.fillStyle = opts.fillStyle || 'rgba(67,209,122,0.12)';
    ctx.lineWidth = Number.isFinite(opts.lineWidth) ? opts.lineWidth : 2.5;
    if (opts.dash) ctx.setLineDash(opts.dash);
    ctx.beginPath();
    ctx.moveTo(points[0].x, points[0].y);
    for (let i = 1; i < points.length; i++) ctx.lineTo(points[i].x, points[i].y);
    ctx.closePath();
    if (opts.fill !== false) ctx.fill();
    ctx.stroke();
    ctx.restore();
  }

  function drawEditorOverlays(wallSegs, roomMetaAll) {
    if (EDITOR.preview && EDITOR.preview.floorId === VIEW.floorId && (EDITOR.tool === 'door' || EDITOR.tool === 'window')) {
      drawOpeningOverlay(EDITOR.preview.opening, wallSegs, { dash: [6, 4] });
    }

    if (EDITOR.roomPreview && EDITOR.roomPreview.floorId === VIEW.floorId && EDITOR.tool === 'room') {
      drawRoomOverlay(EDITOR.roomPreview.room, { dash: [6, 4] });
    }
    if (EDITOR.tool === 'room' && EDITOR.roomStart && EDITOR.roomStart.floorId === VIEW.floorId) {
      drawHexHighlight(EDITOR.roomStart.col, EDITOR.roomStart.row, { fill: true, alpha: 0.55 });
    }

    if (EDITOR.objectPreview && EDITOR.objectPreview.floorId === VIEW.floorId && EDITOR.tool === 'object') {
      drawObjectGhost(EDITOR.objectPreview.object, roomMetaAll);
      const w = objectCenterWorld(EDITOR.objectPreview.object);
      if (w) drawIssueRing(w, GRID.size * 0.5, { strokeStyle: 'rgba(67,209,122,0.9)', dash: [6, 4], lineWidth: 2.5 });
    }

    const markers = Array.isArray(EDITOR.issueMarkers) ? EDITOR.issueMarkers : [];
    for (const m of markers) {
      if (!m || (m.floorId && String(m.floorId) !== String(VIEW.floorId))) continue;
      drawIssueMarker(m, wallSegs);
    }

    const openings = Array.isArray(EDITOR.lastOpenings) ? EDITOR.lastOpenings : [];
    if (EDITOR.selectedId && EDITOR.selectedFloorId === VIEW.floorId) {
      const sel = openings.find(o => o && o.id === EDITOR.selectedId);
      if (sel) drawOpeningOverlay(sel, wallSegs, { lineWidth: 4 });
    }

    const objects = Array.isArray(EDITOR.lastObjects) ? EDITOR.lastObjects : [];
    if (EDITOR.selectedObjectId && EDITOR.selectedObjectFloorId === VIEW.floorId) {
      const selObj = objects.find(o => o && o.id === EDITOR.selectedObjectId);
      if (selObj) {
        const w = objectCenterWorld(selObj);
        if (w) drawIssueRing(w, GRID.size * 0.55, { strokeStyle: 'rgba(67,209,122,0.9)', lineWidth: 3 });
      }
    }

    if (EDITOR.selectedRoomId && EDITOR.selectedRoomFloorId === VIEW.floorId) {
      const info = roomMetaAll && roomMetaAll.get ? roomMetaAll.get(String(EDITOR.selectedRoomId)) : null;
      const room = info ? info.room : null;
      if (room) drawRoomOverlay(room, { lineWidth: 4 });
    }
  }

  function roomById(rooms, id) {
    const target = String(id || '');
    if (!target) return null;
    return (Array.isArray(rooms) ? rooms : []).find(r => r && String(r.id) === target) || null;
  }

  function roomFloorKind(room) {
    return (room && room.floor && room.floor.kind) ? String(room.floor.kind) : 'wood';
  }


  function buildRoomMeta(rooms) {
    const meta = new Map();
    for (const r of (Array.isArray(rooms) ? rooms : [])) {
      if (!r || !r.id) continue;
      const box = roomToWallBox(r);
      const f = roomFloorRectWorld(r, box);
      meta.set(String(r.id), { room: r, floorRect: f });
    }
    // Keep a global copy for any code paths that expect `roomMetaAll` to exist.
    roomMetaAll = meta;
    return meta;
  }

  function roomContainsWorldPoint(roomRect, p) {
    if (!roomRect) return false;
    return (p.x >= roomRect.x1 && p.x <= roomRect.x2 && p.y >= roomRect.y1 && p.y <= roomRect.y2);
  }

  function pickRoomAtWorldPoint(roomMeta, p) {
    let bestId = null;
    let bestArea = Infinity;

    for (const [id, info] of roomMeta.entries()) {
      const r = info.floorRect;
      if (!roomContainsWorldPoint(r, p)) continue;
      const area = Math.abs((r.x2 - r.x1) * (r.y2 - r.y1));
      if (area < bestArea) { bestArea = area; bestId = id; }
    }

    return bestId;
  }

  function openingRoomIds(opening, roomMeta, wallSegs = null) {
    const orient = openingOrientation(opening);
    const p = parseOpeningHex(opening.hex);
    if (!p) return [];

    const hw = hexCenterWorld(p.col, p.row);

    // If we have wall segments, sample thickness from the nearest wall. Otherwise default.
    const seg = (wallSegs && Array.isArray(wallSegs))
      ? findNearestWallSegment(wallSegs, orient, hw)
      : null;

    let thickness = 28;
    if (seg && seg.thickness) thickness = seg.thickness;

    const cx = hw.x, cy = hw.y;
    const eps = Math.max(6, thickness * 0.6);
    const samples = (orient === 'h')
      ? [{ x: cx, y: cy - eps }, { x: cx, y: cy + eps }]
      : [{ x: cx - eps, y: cy }, { x: cx + eps, y: cy }];

    const ids = new Set();
    for (const s of samples) {
      const id = pickRoomAtWorldPoint(roomMeta, s);
      if (id) ids.add(id);
    }
    return [...ids];
  }

  let RENDER_FOG = null;
  // Cached per-redraw room metadata (Map roomId -> {room,floorRect}).
  // Some call-sites pass `roomMetaAll` by name; keep a global to avoid ReferenceErrors.
  var roomMetaAll = null;

  function openingPreferredRoomId(opening, roomMetaAll) {
    const parentId = opening && opening.parent ? String(opening.parent) : '';
    if (parentId) return parentId;

    const ids = openingRoomIds(opening, roomMetaAll);
    if (!ids.length) return '';

    if (RENDER_FOG && RENDER_FOG.enabled) {
      for (const id of ids) if (RENDER_FOG.visible && RENDER_FOG.visible.has(id)) return id;
      for (const id of ids) if (RENDER_FOG.explored && RENDER_FOG.explored.has(id)) return id;
    }
    return String(ids[0] || '');
  }

  function openingKnockoutFill(opening, rooms, roomMetaAll, fogEnabled, wantTextures) {
    const rid = openingPreferredRoomId(opening, roomMetaAll);
    const room = rid ? roomById(rooms, rid) : null;
    const fk = room ? roomFloorKind(room) : 'wood';

    if (!fogEnabled) return getFloorFillStyle(fk, wantTextures, ctx);

    if (RENDER_FOG && RENDER_FOG.enabled && rid && RENDER_FOG.visible && RENDER_FOG.visible.has(rid)) {
      return getFloorFillStyle(fk, wantTextures, ctx);
    }

    return floorBaseColor('fog');
  }

  function drawOpeningSeamFills(openings, rooms, roomMetaAll, wallSegs, fogEnabled) {
    const wantTextures = !!(elSpriteToggle && elSpriteToggle.checked);

    for (const o of (Array.isArray(openings) ? openings : [])) {
      const kind = String(o && o.kind ? o.kind : '').toLowerCase();
      const isDoor = isDoorKind(kind);
      if (kind !== 'threshold' && !isDoor && kind !== 'portal') continue;

      const orient = openingOrientation(o);
      const p = parseOpeningHex(o.hex);
      if (!p) continue;

      const hexWorld = hexCenterWorld(p.col, p.row);
      const seg = findNearestWallSegment(wallSegs, orient, hexWorld);

      // Snap onto the wall axis so seam fills always overlap the wall cutout.
      let cx = hexWorld.x;
      let cy = hexWorld.y;
      if (seg) {
        if (orient === 'h' && Number.isFinite(seg.y)) cy = seg.y;
        if (orient === 'v' && Number.isFinite(seg.x)) cx = seg.x;
      }

      const len = openingLengthWorld(o, rooms);
      const thickness = openingWallThickness(o, wallSegs, rooms, roomMetaAll);

      const centerS = worldToScreen({ x: cx, y: cy });
      const pad = openingPadAxes(o, thickness);

      // Axis-aligned screen-space rect so patterns stay aligned with the floor.
      const baseW = (orient === 'v') ? thickness : len;
      const baseH = (orient === 'v') ? len : thickness;
      const w = baseW + (pad.x || 0);
      const h = baseH + (pad.y || 0);

      ctx.save();
      ctx.fillStyle = openingKnockoutFill(o, rooms, roomMetaAll, fogEnabled, wantTextures);
      const rr = snappedRectFromCenter(centerS, w, h);
      ctx.fillRect(rr.x, rr.y, rr.w, rr.h);
      ctx.restore();
    }
  }

  // ===== Fog (room-based, per-floor) =====
  function normalizeFog(state, floorId) {
    const raw = (state && state.fog && typeof state.fog === 'object') ? state.fog : {};

    const enabled = !!raw.enabled;
    const autoCompute = raw.autoCompute !== false;
    const autoExplore = raw.autoExplore !== false;
    const maxDepth = clamp(Number.isFinite(Number(raw.maxDepth)) ? Number(raw.maxDepth) : 1, 0, 12);

    const unseenAlpha = clamp(Number.isFinite(Number(raw.unseenAlpha)) ? Number(raw.unseenAlpha) : 0.92, 0, 1);
    const exploredAlpha = clamp(Number.isFinite(Number(raw.exploredAlpha)) ? Number(raw.exploredAlpha) : 0.55, 0, 1);

    const perVis = (raw.visibleRoomIdsByFloor && typeof raw.visibleRoomIdsByFloor === 'object') ? raw.visibleRoomIdsByFloor : null;
    const perExp = (raw.exploredRoomIdsByFloor && typeof raw.exploredRoomIdsByFloor === 'object') ? raw.exploredRoomIdsByFloor : null;

    const getVis = () => {
      if (perVis) return Array.isArray(perVis[floorId]) ? perVis[floorId] : [];
      return Array.isArray(raw.visibleRoomIds) ? raw.visibleRoomIds : [];
    };

    const getExp = () => {
      if (perExp) return Array.isArray(perExp[floorId]) ? perExp[floorId] : [];
      return Array.isArray(raw.exploredRoomIds) ? raw.exploredRoomIds : [];
    };

    const setVis = (ids) => {
      if (perVis) perVis[floorId] = ids;
      else raw.visibleRoomIds = ids;
    };

    const setExp = (ids) => {
      if (perExp) perExp[floorId] = ids;
      else raw.exploredRoomIds = ids;
    };

    return {
      enabled,
      autoCompute,
      autoExplore,
      maxDepth,
      unseenAlpha,
      exploredAlpha,
      get visibleRoomIds() { return getVis(); },
      get exploredRoomIds() { return getExp(); },
      setVisibleRoomIds: setVis,
      setExploredRoomIds: setExp,
    };
  }

  function isPlayerToken(t) {
    return String(t && t.side ? t.side : '').toUpperCase() === 'PC';
  }

  function computeRenderFog(state, floorId, rooms, openings, tokens) {
    const fog = normalizeFog(state, floorId);
    if (!fog.enabled) return null;

    const roomMeta = buildRoomMeta(rooms);

    const explored = new Set((fog.exploredRoomIds || []).map(String));
    const visible = new Set((fog.visibleRoomIds || []).map(String));

    if (!fog.autoCompute) {
      return { enabled: true, explored, visible, maxDepth: fog.maxDepth, exploredAlpha: fog.exploredAlpha, unseenAlpha: fog.unseenAlpha };
    }

    const pcs = (Array.isArray(tokens) ? tokens : []).filter(isPlayerToken);
    const start = new Set();
    for (const t of pcs) {
      const hp = parseHex(t.hex);
      if (!hp) continue;
      const world = hexCenterWorld(hp.col, hp.row);
      const rid = pickRoomAtWorldPoint(roomMeta, world);
      if (rid) start.add(rid);
    }

    const adj = new Map();
    const addEdge = (a, b) => {
      if (!a || !b || a === b) return;
      if (!adj.has(a)) adj.set(a, new Set());
      if (!adj.has(b)) adj.set(b, new Set());
      adj.get(a).add(b);
      adj.get(b).add(a);
    };

    for (const o of (Array.isArray(openings) ? openings : [])) {
      const k = String(o && o.kind ? o.kind : 'door').toLowerCase();
      if (k === 'portal' || k === 'connector') continue;

      const openPct = clamp(Number(o && o.openPct != null ? o.openPct : 0), 0, 1);
      const isOpenForSight = (k === 'threshold') || (k === 'window') || (isDoorKind(k) && openPct >= 0.5);
      if (!isOpenForSight) continue;

      const ids = openingRoomIds(o, roomMeta);
      if (ids.length === 2) addEdge(ids[0], ids[1]);
    }

    const q = [];
    const dist = new Map();

    for (const rid of start) {
      q.push(rid);
      dist.set(rid, 0);
    }

    const vis = new Set();
    while (q.length) {
      const cur = q.shift();
      const d = dist.get(cur) || 0;
      vis.add(cur);
      if (d >= fog.maxDepth) continue;
      const ns = adj.get(cur);
      if (!ns) continue;
      for (const n of ns) {
        if (!dist.has(n)) {
          dist.set(n, d + 1);
          q.push(n);
        }
      }
    }

    if (fog.autoExplore) {
      for (const rid of vis) explored.add(rid);
      fog.setExploredRoomIds([...explored]);
    }

    fog.setVisibleRoomIds([...vis]);

    return { enabled: true, explored, visible: vis, maxDepth: fog.maxDepth, exploredAlpha: fog.exploredAlpha, unseenAlpha: fog.unseenAlpha };
  }

  function drawRememberedRoomOverlays(rooms) {
    if (!RENDER_FOG || !RENDER_FOG.enabled) return;

    ctx.save();
    ctx.globalAlpha = RENDER_FOG.exploredAlpha;
    ctx.fillStyle = COLORS.fogExplored;

    for (const r of (Array.isArray(rooms) ? rooms : [])) {
      if (!r || !r.id) continue;
      if (isFogFloorRoom(r)) continue;

      const id = String(r.id);
      if (!RENDER_FOG.explored.has(id)) continue;
      if (RENDER_FOG.visible.has(id)) continue;

      const box = roomToWallBox(r);
      const f = roomFloorRectWorld(r, box);
      const p1 = worldToScreen({ x: f.x1, y: f.y1 });
      const p2 = worldToScreen({ x: f.x2, y: f.y2 });
      const w = p2.x - p1.x;
      const h = p2.y - p1.y;
      if (w > 0 && h > 0) ctx.fillRect(p1.x, p1.y, w, h);
    }

    ctx.restore();
  }

  // ===== Objects / tokens orientation =====
  function degToRad(deg) { return (deg * Math.PI) / 180; }

  function objectRotationRad(o) {
    if (!o) return 0;
    const deg = Number(o.rotDeg);
    return Number.isFinite(deg) ? degToRad(deg) : 0;
  }

  function objectCenterWorld(o) {
    const p = parseObjectHex(o && o.hex);
    if (!p) return null;

    const base = hexCenterWorld(p.col, p.row);

    const ox = Number(o && o.ox);
    const oy = Number(o && o.oy);

    return {
      x: base.x + (Number.isFinite(ox) ? ox : 0) * GRID.size,
      y: base.y + (Number.isFinite(oy) ? oy : 0) * GRID.size,
    };
  }

  function objectCenterScreen(o) {
    const w = objectCenterWorld(o);
    if (!w) return null;
    return worldToScreen(w);
  }

  function objectSizePx(o) {
    const base = GRID.size * 1.15;
    return { w: base, h: base };
  }

  function drawObjectGhost(o, roomMetaAll) {
    if (!o) return;
    const ghost = { ...o, __forceVisible: true };
    ctx.save();
    ctx.globalAlpha = 0.6;
    drawObject(ghost, roomMetaAll);
    ctx.restore();
  }

  function objectVisible(o, roomMetaAll) {
    if (o && o.__forceVisible) return true;
    if (EDITOR && EDITOR.tool === 'object') return true;
    if (!RENDER_FOG || !RENDER_FOG.enabled) return true;

    const kind = String(o && o.kind ? o.kind : '').toLowerCase();

    const w = objectCenterWorld(o);
    if (!w) return true;

    const rid = pickRoomAtWorldPoint(roomMetaAll, w);
    if (!rid) return true;

    if (kind === 'hearth' || kind === 'cooking.hearth') return RENDER_FOG.explored.has(rid) || RENDER_FOG.visible.has(rid);

    return RENDER_FOG.visible.has(rid) || RENDER_FOG.explored.has(rid);
  }

  function roundRectPath(targetCtx, x, y, w, h, r) {
    const rr = Math.max(0, Math.min(r, Math.min(Math.abs(w), Math.abs(h)) / 2));
    targetCtx.beginPath();
    targetCtx.moveTo(x + rr, y);
    targetCtx.lineTo(x + w - rr, y);
    targetCtx.quadraticCurveTo(x + w, y, x + w, y + rr);
    targetCtx.lineTo(x + w, y + h - rr);
    targetCtx.quadraticCurveTo(x + w, y + h, x + w - rr, y + h);
    targetCtx.lineTo(x + rr, y + h);
    targetCtx.quadraticCurveTo(x, y + h, x, y + h - rr);
    targetCtx.lineTo(x, y + rr);
    targetCtx.quadraticCurveTo(x, y, x + rr, y);
    targetCtx.closePath();
  }

  function drawObject(o, roomMetaAll) {
    if (!o) return;
    if (!objectVisible(o, roomMetaAll)) return;

    const c = objectCenterScreen(o);
    if (!c) return;

    const { w, h } = objectSizePx(o);
    const rot = objectRotationRad(o);

    const kind = String(o.kind || 'object').toLowerCase();

    if (SPRITES_ENABLED) {
      const def = getSpriteDef(kind);
      if (def) {
        const img = loadSprite(def.file);

        let sx = 1, sy = 1;
        // Sprite-def defaults are always applied first.
        if (isFiniteNum(def.scale)) { sx *= Number(def.scale); sy *= Number(def.scale); }
        if (isFiniteNum(def.scaleX)) sx *= Number(def.scaleX);
        if (isFiniteNum(def.scaleY)) sy *= Number(def.scaleY);

        // Scaling rules:
        // - spriteScale => proportional (uniform) scaling
        // - spriteScaleX / spriteScaleY => absolute per-axis scaling (non-uniform), and ignores spriteScale
        const hasAxisScale = isFiniteNum(o.spriteScaleX) || isFiniteNum(o.spriteScaleY);

        if (!hasAxisScale && isFiniteNum(o.spriteScale)) {
          sx *= Number(o.spriteScale);
          sy *= Number(o.spriteScale);
        }

        if (hasAxisScale) {
          if (isFiniteNum(o.spriteScaleX)) sx *= Number(o.spriteScaleX);
          if (isFiniteNum(o.spriteScaleY)) sy *= Number(o.spriteScaleY);
          const ok = drawSpriteImage(img, {
            x: c.x,
            y: c.y,
            w: w * sx,
            h: h * sy,
            fit: 'stretch',
            rotRad: def.rotate === 'deg' ? rot : 0,
          });
          if (ok) return;
        } else {
          const ok = drawSpriteImage(img, {
            x: c.x,
            y: c.y,
            w: w * sx,
            h: h * sy,
            fit: 'contain',
            rotRad: def.rotate === 'deg' ? rot : 0,
          });
          if (ok) return;
        }
      }
    }

    ctx.save();
    ctx.translate(c.x, c.y);
    if (rot) ctx.rotate(rot);

    ctx.fillStyle = 'rgba(255,255,255,0.08)';
    ctx.strokeStyle = 'rgba(0,0,0,0.25)';
    ctx.lineWidth = 1;

    if (kind === 'stairs') {
      const rw = w * 2;
      const rh = h * 4;
      const topW = rw * 0.4;

      ctx.fillStyle = COLORS.stairsWood;
      ctx.beginPath();
      ctx.moveTo(-rw/2,  rh/2);
      ctx.lineTo( rw/2,  rh/2);
      ctx.lineTo( topW/2, -rh/2);
      ctx.lineTo(-topW/2, -rh/2);
      ctx.closePath();
      ctx.fill();

    } else if (kind === 'bath') {
      // Simple non-sprite fallback for bath.png (top-down oval tub)
      const rw = w * 2.05;
      const rh = h * 1.20;

      // Outer tub
      ctx.fillStyle = 'rgba(90, 58, 32, 0.85)';
      ctx.strokeStyle = 'rgba(0,0,0,0.28)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.ellipse(0, 0, rw / 2, rh / 2, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.stroke();

      // Inner basin (water)
      ctx.fillStyle = 'rgba(20, 28, 40, 0.55)';
      ctx.beginPath();
      ctx.ellipse(0, 0, (rw * 0.82) / 2, (rh * 0.70) / 2, 0, 0, Math.PI * 2);
      ctx.fill();

      // Water sheen
      ctx.fillStyle = 'rgba(210, 230, 255, 0.18)';
      ctx.beginPath();
      ctx.ellipse(0, -rh * 0.06, (rw * 0.30), (rh * 0.18), 0, 0, Math.PI * 2);
      ctx.fill();

    } else if (kind === 'chest') {
      const rw = w * 0.90, rh = h * 0.70;

      ctx.fillStyle = COLORS.chestWood;
      ctx.strokeStyle = 'rgba(0,0,0,0.22)';
      ctx.lineWidth = 1;

      roundRectPath(ctx, -rw/2, -rh/2, rw, rh, Math.min(10, rh/3));
      ctx.fill();
      ctx.stroke();

      ctx.strokeStyle = 'rgba(0,0,0,0.32)';
      ctx.lineWidth = 2;
      const slats = 4;
      for (let i = 1; i < slats; i++) {
        const x = -rw/2 + (rw * i)/slats;
        ctx.beginPath();
        ctx.moveTo(x, -rh/2);
        ctx.lineTo(x, rh/2);
        ctx.stroke();
      }

    } else if (kind === 'crate') {
      // 1-hex square crate
      const s = Math.min(w, h) * 0.82;
      ctx.fillStyle = COLORS.objectWood;
      ctx.strokeStyle = 'rgba(0,0,0,0.26)';
      ctx.lineWidth = 2;
      roundRectPath(ctx, -s/2, -s/2, s, s, Math.min(10, s/5));
      ctx.fill();
      ctx.stroke();

      // simple plank/X bracing
      ctx.strokeStyle = 'rgba(0,0,0,0.28)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(-s/2, -s/2);
      ctx.lineTo(s/2, s/2);
      ctx.moveTo(-s/2, s/2);
      ctx.lineTo(s/2, -s/2);
      ctx.stroke();

      ctx.globalAlpha = 0.75;
      ctx.beginPath();
      ctx.moveTo(-s/2, 0);
      ctx.lineTo(s/2, 0);
      ctx.moveTo(0, -s/2);
      ctx.lineTo(0, s/2);
      ctx.stroke();
      ctx.globalAlpha = 1;

    } else if (kind === 'keg' || kind === 'barrel') {
      // 1-hex circular prop; barrel gets a taller oval
      const isBarrel = (kind === 'barrel');
      const rx = Math.min(w, h) * 0.42;
      const ry = Math.min(w, h) * (isBarrel ? 0.52 : 0.42);

      // body
      ctx.fillStyle = COLORS.objectWood;
      ctx.strokeStyle = 'rgba(0,0,0,0.28)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.ellipse(0, 0, rx, ry, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.stroke();

      // hoops/bands
      ctx.strokeStyle = 'rgba(0,0,0,0.34)';
      ctx.lineWidth = 3;
      const bands = isBarrel ? [-0.55, 0, 0.55] : [-0.30, 0.30];
      for (const t of bands) {
        ctx.beginPath();
        ctx.ellipse(0, ry * t, rx * 0.98, ry * 0.18, 0, 0, Math.PI * 2);
        ctx.stroke();
      }

      // staves
      ctx.strokeStyle = 'rgba(0,0,0,0.18)';
      ctx.lineWidth = 1;
      const staves = isBarrel ? 7 : 6;
      for (let i = 0; i < staves; i++) {
        const x = -rx + (2 * rx) * (i / (staves - 1));
        ctx.beginPath();
        ctx.moveTo(x, -ry * 0.85);
        ctx.lineTo(x, ry * 0.85);
        ctx.stroke();
      }

    } else if (kind === 'hearth' || kind === 'cooking.hearth') {
      const rw = w * 1.15;
      const rh = h * 0.55;
      ctx.fillStyle = COLORS.hearth;
      ctx.fillRect(-rw/2, -rh/2, rw, rh);

    } else if (kind === 'bed' || kind === 'bed.double') {
      const isDouble = (kind === 'bed.double');
      const BOOST = 2.0;
      const widthMul = isDouble ? 1.3 : 0.75;

      const rw = w * 0.70 * BOOST * widthMul;
      const rh = h * 0.95 * BOOST;

      ctx.fillStyle = COLORS.bedFabric;
      roundRectPath(ctx, -rw/2, -rh/2, rw, rh, Math.min(18, rw/3));
      ctx.fill();
      ctx.stroke();

      ctx.fillStyle = COLORS.bedPillow;
      const pad = Math.max(6, Math.min(14, Math.min(rw, rh) * 0.08));
      const pillowH = Math.max(10, rh * 0.22);
      const innerW = Math.max(0, rw - pad * 2);

      const pillowRadius = Math.min(14, pillowH * 0.5);
      const drawPillow = (x, y, pw) => {
        roundRectPath(ctx, x, y, pw, pillowH, pillowRadius);
        ctx.fill();
      };

      if (!isDouble) {
        drawPillow(-rw/2 + pad, -rh/2 + pad, innerW);
      } else {
        const gap = Math.max(6, Math.min(14, innerW * 0.06));
        const pw = Math.max(0, (innerW - gap) / 2);
        const x0 = -rw/2 + pad;
        const y0 = -rh/2 + pad;
        drawPillow(x0, y0, pw);
        drawPillow(x0 + pw + gap, y0, pw);
      }

    } else if (kind === 'table.round') {
      const r = Math.min(w, h) * 0.64;
      ctx.fillStyle = COLORS.objectWood;
      ctx.beginPath();
      ctx.arc(0, 0, r, 0, Math.PI * 2);
      ctx.fill();
      ctx.stroke();

    } else if (kind === 'table.sqr' || kind === 'table.square') {
      // Square side-table (used as a non-sprite fallback)
      const s = Math.min(w, h) * 0.75;
      ctx.fillStyle = COLORS.objectWood;
      roundRectPath(ctx, -s/2, -s/2, s, s, Math.min(10, s/5));
      ctx.fill();
      ctx.stroke();

    } else if (kind.startsWith('table')) {
      const rw = w * 0.90, rh = h * 0.55;
      ctx.fillStyle = COLORS.objectWood;
      roundRectPath(ctx, -rw/2, -rh/2, rw, rh, Math.min(10, rh/3));
      ctx.fill();
      ctx.stroke();

    } else if (kind === 'chair') {
      const rw = Math.min(w, h) * 0.65;
      const r = rw / 2;
      const rectH = rw * 0.55;
      const yShift = -(rectH - r) / 2;

      ctx.fillStyle = COLORS.objectWood;
      ctx.beginPath();
      ctx.moveTo(-rw / 2, yShift);
      ctx.arc(0, yShift, r, Math.PI, 0, false);
      ctx.lineTo(rw / 2, yShift + rectH);
      ctx.lineTo(-rw / 2, yShift + rectH);
      ctx.closePath();
      ctx.fill();

    } else {
      const rw = w * 0.80, rh = h * 0.55;
      roundRectPath(ctx, -rw/2, -rh/2, rw, rh, 10);
      ctx.fill();
      ctx.stroke();
    }



    ctx.restore();
  }

  // ===== Tokens =====
  function tokenVisible(t, roomMetaAll) {
    if (!RENDER_FOG || !RENDER_FOG.enabled) return true;
    if (isPlayerToken(t)) return true;

    const p = parseHex(t && t.hex);
    if (!p) return true;
    const w = hexCenterWorld(p.col, p.row);
    const rid = pickRoomAtWorldPoint(roomMetaAll, w);
    if (!rid) return true;

    return RENDER_FOG.visible.has(rid);
  }

  function drawTokenLabel(t, x, y, isPC) {
    const label = (t && t.label) ? String(t.label) : (t && t.name ? String(t.name).slice(0, 2) : '?');

    ctx.fillStyle = isPC ? COLORS.tokenTextDark : COLORS.tokenTextLight;
    ctx.font = 'bold 14px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(label, x, y);
  }

  function getTokenSpriteRequest(t, isPC) {
    if (!t || typeof t !== 'object') {
      return { kind: isPC ? 'token.pc' : 'token.npc', file: '', scale: TOKEN_DEFAULT_SCALE };
    }

    const kind = String(
      t.sprite ??
      t.spriteKind ??
      t.sprite_key ??
      t.spriteId ??
      t.sprite_id ??
      ''
    ).trim();

    const file = String(t.spriteFile ?? t.sprite_file ?? '').trim();

    let scale = TOKEN_DEFAULT_SCALE;
    const s = Number(t.spriteScale ?? t.sprite_scale);
    if (Number.isFinite(s) && s > 0) scale = s;

    return {
      kind: kind || (isPC ? 'token.pc' : 'token.npc'),
      file,
      scale,
    };
  }

  function drawToken(t, roomMetaAll) {
    if (!t || !t.hex) return;
    if (!tokenVisible(t, roomMetaAll)) return;

    const p = parseHexId(t.hex);
    const c = worldToScreen(hexCenterWorld(p.col, p.row));

    const r = GRID.size * 0.40;
    const isPC = isPlayerToken(t);

    if (SPRITES_ENABLED) {
      const req = getTokenSpriteRequest(t, isPC);

      // Prefer explicit spriteFile, else sprite kind, else the default pc/npc tokens.
      let file = String(req.file || '').trim();
      if (!file) {
        const defK = getSpriteDef(req.kind);
        const defD = getSpriteDef(isPC ? 'token.pc' : 'token.npc');
        file = defK ? defK.file : (defD ? defD.file : '');
      }

      if (file) {
        const img = loadSprite(file);
        const s = (Number.isFinite(Number(req.scale)) && Number(req.scale) > 0) ? Number(req.scale) : TOKEN_DEFAULT_SCALE;
        const ok = drawSpriteImage(img, {
          x: c.x,
          y: c.y,
          w: r * 2.2 * s,
          h: r * 2.2 * s,
          fit: 'contain',
          rotRad: 0,
        });
        if (ok) {
          drawTokenLabel(t, c.x, c.y, isPC);
          return;
        }
      }
    }

    ctx.save();
    ctx.fillStyle = isPC ? COLORS.tokenHero : COLORS.tokenEnemy;
    ctx.beginPath();
    ctx.arc(c.x, c.y, r, 0, Math.PI * 2);
    ctx.fill();

    ctx.strokeStyle = 'rgba(255,255,255,0.15)';
    ctx.lineWidth = 2;
    ctx.stroke();

    drawTokenLabel(t, c.x, c.y, isPC);

    ctx.restore();
  }

  // ===== Grid =====
  function drawHexOutline(center, size) {
    const pts = [];
    for (let i = 0; i < 6; i++) {
      const a = (Math.PI / 180) * (60 * i);
      pts.push({ x: center.x + size * Math.cos(a), y: center.y + size * Math.sin(a) });
    }

    ctx.beginPath();
    ctx.moveTo(pts[0].x, pts[0].y);
    for (let i = 1; i < pts.length; i++) ctx.lineTo(pts[i].x, pts[i].y);
    ctx.closePath();
    ctx.stroke();
  }

  function drawGrid() {
    const rect = canvas.getBoundingClientRect();
    const w = Math.max(1, rect.width);
    const h = Math.max(1, rect.height);

    const colsR = Math.ceil((w / 2) / colStep()) + 4;
    const rowsR = Math.ceil((h / 2) / rowStep()) + 4;

    const c0 = VIEW.camera.col;
    const r0 = VIEW.camera.row;

    ctx.save();
    ctx.strokeStyle = `rgba(255,255,255,${GRID.lineAlpha})`;
    ctx.lineWidth = GRID.lineWidth;

    for (let dc = -colsR; dc <= colsR; dc++) {
      for (let dr = -rowsR; dr <= rowsR; dr++) {
        const col = c0 + dc;
        const row = r0 + dr;
        const p = worldToScreen(hexCenterWorld(col, row));

        if (p.x < -100 || p.x > w + 100 || p.y < -100 || p.y > h + 100) continue;
        drawHexOutline(p, GRID.size);
      }
    }

    const bright = !!(elLabelBoldToggle && elLabelBoldToggle.checked);
    ctx.globalAlpha = bright ? 1 : GRID.labelAlpha;
    ctx.fillStyle = bright ? 'rgba(233,238,247,0.96)' : 'rgba(233,238,247,0.65)';
    ctx.font = bright
      ? '900 14px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial'
      : GRID.labelFont;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';

    if (bright) {
      ctx.lineWidth = 4;
      ctx.strokeStyle = 'rgba(0,0,0,0.70)';
      ctx.lineJoin = 'round';
    }

    for (let dc = -colsR; dc <= colsR; dc++) {
      for (let dr = -rowsR; dr <= rowsR; dr++) {
        const col = c0 + dc;
        const row = r0 + dr;
        const p = worldToScreen(hexCenterWorld(col, row));
        if (p.x < -100 || p.x > w + 100 || p.y < -100 || p.y > h + 100) continue;

        const label = hexId(col, row);
        const lx = p.x;
        const ly = p.y + 2;

        if (bright) ctx.strokeText(label, lx, ly);
        ctx.fillText(label, lx, ly);
      }
    }

    ctx.restore();
  }

  // ===== UI rendering =====
  function escapeHtml(s) {
    return String(s)
      .replaceAll('&', '&amp;')
      .replaceAll('<', '&lt;')
      .replaceAll('>', '&gt;')
      .replaceAll('"', '&quot;')
      .replaceAll("'", '&#39;');
  }

  function openCharacterSheet(characterId) {
    const id = String(characterId || '').trim();
    if (!id) return;
    const battleId = resolveBattleIdHintFromUrl();
    let url = '/app/character.html?character_id=' + encodeURIComponent(id);
    if (battleId) url += '&battle_id=' + encodeURIComponent(battleId);
    const win = window.open(url, '_blank', 'noopener');
    if (!win) window.location.href = url;
  }

  const CONDITION_MAP = {
    poisoned: { emoji: '☠️', label: 'Poisoned' },
    burning: { emoji: '🔥', label: 'Burning' },
    on_fire: { emoji: '🔥', label: 'Burning' },
    stunned: { emoji: '😵', label: 'Stunned' },
    blinded: { emoji: '🙈', label: 'Blinded' },
    frightened: { emoji: '😱', label: 'Frightened' },
    charmed: { emoji: '💘', label: 'Charmed' },
    grappled: { emoji: '🧲', label: 'Grappled' },
    restrained: { emoji: '🪢', label: 'Restrained' },
    prone: { emoji: '🧎', label: 'Prone' },
    slowed: { emoji: '🧊', label: 'Slowed' },
    frozen: { emoji: '🧊', label: 'Frozen' },
    paralyzed: { emoji: '🪫', label: 'Paralyzed' },
    unconscious: { emoji: '💤', label: 'Unconscious' },
    invisible: { emoji: '🫥', label: 'Invisible' },
    buffed: { emoji: '✨', label: 'Buffed' },
    debuffed: { emoji: '⚠️', label: 'Debuffed' },
    concentrating: { emoji: '🧠', label: 'Concentrating' },
    down: { emoji: '💀', label: 'Downed' },
    dead: { emoji: '💀', label: 'Dead' },
  };

  function conditionLabel(cond) {
    if (cond == null) return '';
    if (typeof cond === 'string' || typeof cond === 'number') return String(cond);
    if (typeof cond === 'object') {
      return String(cond.name || cond.label || cond.id || cond.type || '').trim();
    }
    return String(cond);
  }

  function conditionKey(label) {
    const key = String(label || '').toLowerCase().replace(/[^a-z0-9]+/g, '_').replace(/^_+|_+$/g, '');
    if (!key) return '';
    if (key.includes('poison')) return 'poisoned';
    if (key.includes('burn')) return 'burning';
    if (key.includes('stun')) return 'stunned';
    if (key.includes('blind')) return 'blinded';
    if (key.includes('fright')) return 'frightened';
    if (key.includes('charm')) return 'charmed';
    if (key.includes('grappl')) return 'grappled';
    if (key.includes('restrain')) return 'restrained';
    if (key.includes('prone')) return 'prone';
    if (key.includes('slow')) return 'slowed';
    if (key.includes('freeze')) return 'frozen';
    if (key.includes('paraly')) return 'paralyzed';
    if (key.includes('unconscious')) return 'unconscious';
    if (key.includes('invis')) return 'invisible';
    if (key.includes('concentrat')) return 'concentrating';
    if (key.includes('buff')) return 'buffed';
    if (key.includes('debuff')) return 'debuffed';
    if (key.includes('dead')) return 'dead';
    if (key.includes('down')) return 'down';
    return key;
  }

  function getTokenConditions(token) {
    const raw = [];
    if (token && Array.isArray(token.conditions)) raw.push(...token.conditions);
    if (token && Array.isArray(token.effects)) raw.push(...token.effects);
    if (token && Array.isArray(token.status)) raw.push(...token.status);
    if (token && Array.isArray(token.tags)) raw.push(...token.tags);
    if (token && (token.concentration || token.concentrating)) raw.push('concentrating');
    const out = [];
    const seen = new Set();
    for (const item of raw) {
      const label = conditionLabel(item);
      if (!label) continue;
      const key = conditionKey(label) || label;
      if (seen.has(key)) continue;
      seen.add(key);
      const mapped = CONDITION_MAP[key];
      out.push(mapped || { emoji: '•', label });
    }
    return out;
  }

  function pickNumber(...values) {
    for (const v of values) {
      const num = Number(v);
      if (Number.isFinite(num)) return num;
    }
    return null;
  }

  function tokenHpText(token) {
    if (!token) return '';
    const cur = token.hp ?? token.hp_current ?? token.current_hp;
    const max = token.maxHp ?? token.max_hp ?? token.hpMax ?? token.hp_max;
    if (cur == null && max == null) return '';
    const curText = cur != null ? String(cur) : '?';
    if (max == null) return curText + '/' + curText;
    const maxText = max != null ? String(max) : '?';
    return curText + '/' + maxText;
  }

  function tokenSideClass(token) {
    const sideRaw = token && token.side != null ? String(token.side) : '';
    const side = sideRaw.trim().toUpperCase();
    if (side === 'PC' || side === 'PLAYER') return 'side-pc';
    if (side === 'EN' || side === 'ENEMY') return 'side-en';
    if (side === 'NPC') return 'side-npc';
    return 'side-npc';
  }

  function tokenHostility(token) {
    const raw = token && token.hostility != null ? String(token.hostility).trim().toLowerCase() : '';
    if (raw === 'friendly' || raw === 'neutral' || raw === 'hostile') return raw;
    const kind = token && token.kind != null ? String(token.kind).trim().toLowerCase() : '';
    if (kind === 'monster' || kind === 'creature') return 'hostile';
    const sideRaw = token && token.side != null ? String(token.side) : '';
    const side = sideRaw.trim().toUpperCase();
    if (side === 'PC' || side === 'PLAYER') return 'friendly';
    if (side === 'EN' || side === 'ENEMY') return 'hostile';
    return 'neutral';
  }

  function updateSidebar(state, floor, rooms, openings, objects, tokens) {
    const statusMeta = els.statusMeta;
    const statusBody = els.statusBody;
    const statusAction = els.statusAction;
    if (!statusMeta || !statusBody) return;

    const meta = state && state.meta ? state.meta : {};
    const roundRaw = (state && state.turn && state.turn.round != null) ? state.turn.round : meta.round;
    const round = Number.isFinite(Number(roundRaw)) ? Number(roundRaw) : null;

    const campaignActiveId = getCampaignTurnActiveId();
    const activeId = campaignActiveId || ((state && state.turn && state.turn.activeTokenId)
      ? String(state.turn.activeTokenId)
      : (state && state.turn && state.turn.active_actor_id ? String(state.turn.active_actor_id)
        : (state && (state.activeActorId || state.active_actor_id) ? String(state.activeActorId || state.active_actor_id) : '')));
    let baseTokens = null;
    if (state && typeof state === 'object' && state.records) {
      const renderAll = buildRenderState(state);
      baseTokens = (renderAll && Array.isArray(renderAll.tokensAll)) ? renderAll.tokensAll : null;
    }
    if (!baseTokens || !baseTokens.length) {
      baseTokens = Array.isArray(tokens) && tokens.length ? tokens : getTokensArray(state);
    }
    const allTokens = normalizeTokenCharacterIds(baseTokens).filter(t => t && t.id);
    const activeToken = activeId ? allTokens.find(t => String(t.id) === activeId) : null;
    const activeEntity = !activeToken && activeId ? findEntityById(activeId) || findEntityByCharacterId(activeId) : null;
    const activeName = activeToken
      ? String(activeToken.name || activeToken.id || '')
      : (activeEntity ? String(activeEntity.name || activeEntity.id || '') : '');

    const battlePoiId = (state && state.active && state.active.recordId)
      ? String(state.active.recordId)
      : (CURRENT_BATTLE_ID ? resolvePoiForBattle(CURRENT_BATTLE_ID) : null);
    const localBattleId = CURRENT_BATTLE_ID ? String(CURRENT_BATTLE_ID) : '';
    const currentFloorId = floor && (floor.id || floor.floorId) ? String(floor.id || floor.floorId) : '';
    const localCharacterIds = new Set();
    for (const t of allTokens) {
      if (!t) continue;
      if (t.character_id) localCharacterIds.add(String(t.character_id));
      if (t.characterId) localCharacterIds.add(String(t.characterId));
    }

    for (const t of allTokens) {
      if (!t) continue;
      const tfloor = t.floorId || t.floor_id || (t.view && t.view.floorId);
      if (tfloor && currentFloorId && String(tfloor) !== currentFloorId) {
        t._elsewhere = true;
        if (!t._locationLabel) t._locationLabel = currentFloorId ? ('Floor: ' + String(tfloor)) : '';
      }
    }

    const campaignEntities = getCampaignEntities() || [];
    const partyLocations = getCampaignPartyLocations() || {};
    const entityByCharacterId = new Map();
    const findTokenInList = (tokens, characterId, entityId) => {
      if (!Array.isArray(tokens)) return null;
      const cid = characterId ? String(characterId) : '';
      const eid = entityId ? String(entityId) : '';
      return tokens.find(t => {
        if (!t) return false;
        const tid = t.id != null ? String(t.id) : '';
        const tcid = t.character_id != null ? String(t.character_id) : '';
        const tCid = t.characterId != null ? String(t.characterId) : '';
        return (cid && (tcid === cid || tCid === cid)) || (eid && tid === eid);
      }) || null;
    };
    const resolveBattleIdMaybe = (value) => {
      if (!value) return null;
      const v = String(value);
      const poi = resolvePoiForBattle(v);
      if (poi) return v;
      return resolveBattleFromPoi(v);
    };
    const getFloorLabelFromRender = (render, token) => {
      if (!render || !token) return '';
      const floors = Array.isArray(render.floors) ? render.floors : [];
      const fid = token.floorId || token.floor_id || (token.view && token.view.floorId);
      if (!fid) return '';
      const match = floors.find(f => f && (f.id === fid || f.floorId === fid));
      return match && match.name ? String(match.name) : String(fid);
    };
    for (const ent of campaignEntities) {
      if (!ent) continue;
      const entCharId = ent.character_id != null ? String(ent.character_id)
        : (ent.characterId != null ? String(ent.characterId) : '');
      if (entCharId) entityByCharacterId.set(entCharId, ent);
    }
    const extraEntityTokens = [];
    for (const ent of campaignEntities) {
      if (!ent || !isEntityListed(ent)) continue;
      const entId = ent.id != null ? String(ent.id) : '';
      const entCharId = ent.character_id != null ? String(ent.character_id)
        : (ent.characterId != null ? String(ent.characterId) : '');
      if (entCharId && localCharacterIds.has(entCharId)) continue;
      if (!entCharId && entId && allTokens.some(t => t && String(t.id) === entId)) continue;

      const loc = ent.location && typeof ent.location === 'object' ? ent.location : null;
      let poiId = ent.current_poi || ent.currentPoi || ent.poi_id || ent.poiId || ent.poi
        || (loc && (loc.poi_id || loc.poiId || loc.poi))
        || null;
      if (!poiId && entCharId && partyLocations[entCharId]) poiId = partyLocations[entCharId];
      if (!poiId && entId && partyLocations[entId]) poiId = partyLocations[entId];
      let poiLabel = poiId ? getPoiLabel(poiId) : '';
      if (poiId && !poiLabel) {
        const resolvedPoi = resolvePoiForBattle(poiId);
        if (resolvedPoi) {
          poiId = resolvedPoi;
          poiLabel = getPoiLabel(resolvedPoi);
        }
      }
      const stats = ent.stats && typeof ent.stats === 'object' ? ent.stats : null;
      const initValue = ent.init != null ? ent.init : (stats && stats.init != null ? stats.init : -1);
      const hpValue = ent.hp != null ? ent.hp : (stats && stats.hp != null ? stats.hp : null);
      const maxHpValue = (ent.maxHp != null ? ent.maxHp : (ent.max_hp != null ? ent.max_hp : (stats && (stats.maxHp != null ? stats.maxHp : stats.max_hp))));
      const entFloorId = (loc && (loc.floorId || loc.floor_id)) || ent.floorId || ent.floor_id || '';
      const floorLabel = entFloorId ? ('Floor: ' + String(entFloorId)) : '';
      const locationLabel = poiLabel ? (poiLabel + (floorLabel ? ' / ' + floorLabel : '')) : floorLabel;
      const elsewhereByPoi = (poiId && (battlePoiId || localBattleId))
        ? (String(poiId) !== String(battlePoiId || '') && String(poiId) !== localBattleId)
        : false;
      const elsewhereByFloor = entFloorId && currentFloorId ? String(entFloorId) !== String(currentFloorId) : false;
      extraEntityTokens.push({
        id: entId || ('entity_' + entCharId),
        character_id: entCharId || null,
        name: ent.name || ent.label || entCharId || entId,
        side: ent.side || normalizeTokenSideFromKind(ent.kind),
        init: initValue,
        hp: hpValue,
        maxHp: maxHpValue,
        _globalOnly: true,
        _locationLabel: locationLabel,
        _elsewhere: elsewhereByPoi || elsewhereByFloor
      });
    }

    const combinedTokens = allTokens.concat(extraEntityTokens);

    statusMeta.innerHTML = [
      '<div class="statusPill">Round <strong>' + escapeHtml(round != null ? String(round) : '–') + '</strong></div>',
      '<div class="statusPill">Active <strong>' + escapeHtml(activeName || '–') + '</strong></div>',
    ].join('');

    const lastAction = getLastAction(state);
    if (statusAction) {
      if (lastAction) {
        statusAction.hidden = false;
        statusAction.textContent = lastAction;
      } else {
        statusAction.hidden = true;
        statusAction.textContent = '';
      }
    }

    const sorted = [...combinedTokens]
      .sort((a, b) => {
        const aiRaw = Number(a.init);
        const biRaw = Number(b.init);
        const ai = Number.isFinite(aiRaw) ? aiRaw : (a._globalOnly ? -1 : 0);
        const bi = Number.isFinite(biRaw) ? biRaw : (b._globalOnly ? -1 : 0);
        if (bi !== ai) return bi - ai;
        const an = String(a.name || a.id || '');
        const bn = String(b.name || b.id || '');
        return an.localeCompare(bn);
      });

    const actionMap = getLatestActionBySpeaker();

    statusBody.innerHTML = sorted.map(t => {
      const tid = t && t.id != null ? String(t.id) : '';
      const tcid = t && t.character_id != null ? String(t.character_id) : '';
      const tcId = t && t.characterId != null ? String(t.characterId) : '';
      const isActive = activeId && (tid === activeId || tcid === activeId || tcId === activeId);
      const name = t.name ? String(t.name) : String(t.id);
      const speakerKey = normalizeSpeakerKey(name);
      const actionEntry = actionMap.get(speakerKey) || null;
      const actionStatus = actionEntry ? String(actionEntry.status || '') : '';
      const hasActiveAction = actionEntry && (actionStatus === 'new' || actionStatus === 'ack');
      const actionTitle = actionEntry
        ? ('Action (' + (actionStatus || 'new') + '): ' + String(actionEntry.text || ''))
        : '';
      const actionTickHtml = hasActiveAction
        ? ('<span class="actionTick" role="button" tabindex="0"'
          + ' data-chat-id="' + escapeHtml(actionEntry.id || '') + '"'
          + ' data-action-status="' + escapeHtml(actionStatus || 'new') + '"'
          + ' title="' + escapeHtml(actionTitle) + '">✓</span>')
        : '';
      const hpText = tokenHpText(t);
      const ac = pickNumber(t.ac, t.AC, t.armorClass, t.armor_class);
      const init = pickNumber(t.init, t.initiative);
      const speed = pickNumber(t.speedHex, t.speed_hex, t.speed, t.move, t.movement, t.speed_tiles, t.speedTiles);
      const range = pickNumber(t.rangeHex, t.range_hex, t.range, t.weaponRange, t.weapon_range, t.range_max, t.rangeMax);
      const conditions = getTokenConditions(t);
      const conditionsHtml = conditions.length
        ? conditions.map(c => '<span class="condIcon" title="' + escapeHtml(c.label) + '">' + escapeHtml(c.emoji) + '</span>').join('')
        : '';
      const characterId = (t.character_id != null) ? String(t.character_id)
        : (t.characterId != null ? String(t.characterId) : '');
      const hpNum = Number(t.hp);
      const hpDead = Number.isFinite(hpNum) ? hpNum <= 0 : false;
      const isDead = hpDead || conditions.some(c => c.label.toLowerCase().includes('dead') || c.label.toLowerCase().includes('down'));
      const hostility = tokenHostility(t);
      const isMob = hostility === 'hostile';
      const elsewhere = !!t._elsewhere;
      const rowClass = 'statusRow' + (isDead ? ' dead' : '') + (elsewhere ? ' elsewhere' : '') + (isMob ? ' mob' : '') + (isActive ? ' active' : '') + (characterId ? ' clickable' : '');
      const turnMarkerClass = 'statusTurnMarker' + (isActive ? '' : ' inactive');
      const nameClass = 'statusName status-' + hostility;
      const rowAttrs = characterId
        ? (' data-character-id="' + escapeHtml(characterId) + '" role="button" tabindex="0" title="Open character sheet"')
        : '';
      const hoverDetails = [
        'AC: ' + (ac != null ? String(ac) : '–'),
        'Speed: ' + (speed != null ? String(speed) : '–'),
        'Range: ' + (range != null ? String(range) : '–'),
      ].concat(t._locationLabel ? ['Location: ' + String(t._locationLabel)] : []).join('\n');
      return '<tr class="' + rowClass + '"' + rowAttrs + '>'
        + '<td class="statusNameCell" title="' + escapeHtml(hoverDetails) + '">'
          + '<span class="' + turnMarkerClass + '" aria-hidden="' + (isActive ? 'false' : 'true') + '"></span>'
          + '<span class="' + nameClass + '">' + escapeHtml(name) + '</span>'
        + '</td>'
        + '<td class="statusNum">' + escapeHtml(init != null ? String(init) : '–') + '</td>'
        + '<td class="statusNum">' + escapeHtml(hpText || '–') + '</td>'
        + '<td><div class="statusCond">' + conditionsHtml + actionTickHtml + '</div></td>'
        + '</tr>';
    }).join('');
  }

 function populateSceneSelect(state) {
  if (!elSceneSelect) return;

  const w = (WORLD_STATE && WORLD_STATE.records && WORLD_STATE.active) ? WORLD_STATE : null;

  // Legacy mode (no world wrapper): show a single disabled option.
  if (!w) {
    const title = (state && state.meta && state.meta.title) ? String(state.meta.title) : 'Scene';
    elSceneSelect.innerHTML = '<option value="Scene">' + escapeHtml(title) + '</option>';
    elSceneSelect.value = 'Scene';
    elSceneSelect.disabled = true;
    return;
  }

  const recordIds = Object.keys(w.records || {}).sort();
  const activeRid = String((w.active && w.active.recordId) ? w.active.recordId : '');

  // Build options once per render (cheap) — but avoid stomping the dropdown while it's focused.
  if (document.activeElement !== elSceneSelect) {
    elSceneSelect.innerHTML = recordIds.map(rid => {
      const rec = w.records[rid];
      const label = (rec && rec.meta && rec.meta.title) ? String(rec.meta.title) : rid;
      return '<option value="' + escapeHtml(rid) + '">' + escapeHtml(label) + '</option>';
    }).join('');

    if (recordIds.includes(activeRid)) elSceneSelect.value = activeRid;
    else if (recordIds.length) elSceneSelect.value = recordIds[0];
  }

  elSceneSelect.disabled = recordIds.length <= 1;
}

function populateFloorSelect(floors) {
  if (!elFloorSelect) return;

  const list = Array.isArray(floors) ? floors : [];
  const current = String(VIEW.floorId || '');

  // Build options
  elFloorSelect.innerHTML = list.map(f => {
    const id = String((f && f.id) != null ? f.id : '');
    const name = (f && f.name) ? String(f.name) : id;
    return '<option value="' + escapeHtml(id) + '">' + escapeHtml(name) + '</option>';
  }).join('');

  // Pick selected value: current (if present in list) else first item's id else ''
  const hasCurrent = current && list.some(f => String((f && f.id) != null ? f.id : '') === current);
  const fallback = list.length ? String((list[0] && list[0].id) != null ? list[0].id : '') : '';

  elFloorSelect.value = hasCurrent ? current : fallback;
}

  function isSelectableObjectKind(kind) {
    const k = String(kind || '').toLowerCase();
    if (!k) return false;
    if (k.startsWith('token')) return false;
    if (k === 'window' || k === 'portal' || k === 'threshold') return false;
    if (isDoorKind(k)) return false;
    return true;
  }

  function collectObjectKinds(state) {
    const kinds = new Set();

    for (const key of Object.keys(SPRITES.defs || {})) {
      if (isSelectableObjectKind(key)) kinds.add(String(key).toLowerCase());
    }

    const floors = getFloorsFromState(state);
    for (const f of floors) {
      const objs = Array.isArray(f && f.objects) ? f.objects : [];
      for (const o of objs) {
        const kind = o && o.kind ? String(o.kind).toLowerCase() : '';
        if (isSelectableObjectKind(kind)) kinds.add(kind);
      }
    }

    if (!kinds.size) kinds.add('object');
    return Array.from(kinds).sort();
  }

  function populateObjectKindSelect(state) {
    if (!elObjectKindSelect) return;
    const kinds = collectObjectKinds(state);
    const active = (document.activeElement === elObjectKindSelect);

    if (!active) {
      elObjectKindSelect.innerHTML = kinds
        .map(k => '<option value="' + escapeHtml(k) + '">' + escapeHtml(k) + '</option>')
        .join('');
    }

    if (!kinds.includes(EDITOR.objectKind)) EDITOR.objectKind = kinds[0] || 'object';
    if (!active) elObjectKindSelect.value = EDITOR.objectKind;
  }

  

  function populateCenterOn(state, tokensOnThisFloor) {
    if (!elCenterOn) return;

    const tokens = Array.isArray(tokensOnThisFloor) ? tokensOnThisFloor : tokensOnFloor(state, VIEW.floorId);
    const pcs = tokens.filter(isPlayerToken);
    const wanted = VIEW.followTokenId || '';

    const opts = ['<option value="">None</option>'];
    for (const t of pcs) {
      const label = t.name ? t.name : t.id;
      opts.push('<option value="' + escapeHtml(t.id) + '">' + escapeHtml(label) + '</option>');
    }

    elCenterOn.innerHTML = opts.join('');
    elCenterOn.value = pcs.some(t => t.id === wanted) ? wanted : '';
    if (elCenterOn.value === '') VIEW.followTokenId = null;
  }

  function buildRenderState(state) {
    const floors = getFloorsFromState(state);
    const activeFloorId = VIEW.floorId || pickActiveFloorId(state, floors);
    const floor = floorById(floors, activeFloorId) || floors[0];
    const floorId = floor ? String(floor.id) : String(activeFloorId || '');

    const recordId = (state && state.active && state.active.recordId) ? String(state.active.recordId) : '';
    const poiId = recordId || resolvePoiForBattle(CURRENT_BATTLE_ID);
    const worldTokens = buildTokensFromWorldEntities(poiId);
    const tokensAll = normalizeTokenCharacterIds(worldTokens && worldTokens.length ? worldTokens : getTokensArray(state));
    const rooms = Array.isArray(floor && floor.rooms) ? floor.rooms : [];
    const openings = Array.isArray(floor && floor.openings) ? floor.openings : [];
    const objects = Array.isArray(floor && floor.objects) ? floor.objects : [];
    const tokens = tokensAll.filter(t => {
      const fid = entityFloorId(t);
      return fid ? fid === floorId : true;
    });

    return { floors, floor, floorId, rooms, openings, objects, tokensAll, tokens };
  }

  // ===== Main render =====
  function clear() {
    // Use backing-store derived CSS size so we always cover the full drawable area.
    // This prevents 1px edge seams that can appear on the right/bottom when the
    // layout produces fractional CSS pixels.
    const d = Number(VIEW && VIEW.dpr) || 1;
    const w = Math.max(1, canvas.width / d);
    const h = Math.max(1, canvas.height / d);
    ctx.fillStyle = COLORS.bg;
    ctx.fillRect(0, 0, w, h);
  }

  function renderScene(roomsAll, roomsToDraw, openingsToDraw, objects, tokens, roomMetaAll, fogEnabled) {
    clear();

    const roomsToDrawSorted = sortRoomsForRender(roomsToDraw);
    drawFloorsLayered(roomsToDrawSorted);

    const roomsForWalls = (RENDER_FOG && RENDER_FOG.enabled)
      ? roomsToDrawSorted.filter(r => (isFogFloorRoom(r) ? roomHasWalls(r) : true))
      : roomsToDrawSorted;

    const wallSegsRaw = buildWallSegments(roomsForWalls);
    const wallSegs = dedupeWallSegments(wallSegsRaw);

    // Floor-aware knockout fills for doors/thresholds (so wall openings match the underlying texture)
    drawOpeningSeamFills(openingsToDraw, roomsAll, roomMetaAll, wallSegs, fogEnabled);

    wallCtx.save();
    wallCtx.setTransform(1, 0, 0, 1, 0, 0);
    wallCtx.clearRect(0, 0, wallCanvas.width, wallCanvas.height);
    wallCtx.restore();

    wallCtx.setTransform(VIEW.dpr, 0, 0, VIEW.dpr, 0, 0);

    drawWallSegments(wallCtx, wallSegs);

    wallCtx.save();
    wallCtx.globalCompositeOperation = 'destination-out';
    wallCtx.fillStyle = '#000';

    for (const o of openingsToDraw) {
      const k = String(o && o.kind ? o.kind : 'door').toLowerCase();
      wallCtx.globalAlpha = (k === 'window') ? 0.25 : 1;
      cutOpeningHole(wallCtx, o, wallSegs, roomsAll, roomMetaAll);
    }

    wallCtx.restore();

    ctx.save();
    ctx.setTransform(1, 0, 0, 1, 0, 0);
    ctx.drawImage(wallCanvas, 0, 0);
    ctx.restore();

    ctx.setTransform(VIEW.dpr, 0, 0, VIEW.dpr, 0, 0);

    for (const o of openingsToDraw) drawOpeningMarker(o, wallSegs, roomsAll, roomMetaAll);
    drawEditorOverlays(wallSegs, roomMetaAll);

    const objectsToDraw = sortObjectsForRender(objects);
    for (const o of objectsToDraw) drawObject(o, roomMetaAll);

    drawRememberedRoomOverlays(roomsAll);

    for (const t of tokens) drawToken(t, roomMetaAll);

    drawGrid();
  }

  function updateUI(state, render, rooms, openings, objects, tokens) {
    populateFloorSelect(render.floors);
    populateCenterOn(state, tokens);
    updateSidebar(state, render.floor, rooms, openings, objects, tokens);
    updateStateDebug();
    populateChatSpeakerSelect(state);
    populateObjectKindSelect(state);
    populateRoomKindDatalists();
    syncSourceSelect();
    if (!CURRENT_CAMPAIGN_ID) resetPoiSelect();
  }

  function redraw() {
    const state = getState();

    if (!canvas.width || !canvas.height || !wallCanvas.width || !wallCanvas.height) return;

    const render = buildRenderState(state);
    VIEW.floorId = render.floorId;

    populateSceneSelect(state);

    if (VIEW.followTokenId) {
      const t = render.tokensAll.find(x => x && x.id === VIEW.followTokenId);
      if (t && t.hex) {
        const fid = entityFloorId(t) || VIEW.floorId;
        if (fid && fid !== VIEW.floorId) {
          setActiveFloor(fid, { fromFollow: true });
          return;
        }

        const p = parseHexId(t.hex);
        VIEW.camera.col = p.col;
        VIEW.camera.row = p.row;
      } else {
        VIEW.followTokenId = null;
        if (elCenterOn) elCenterOn.value = '';
      }
    }

    const rooms = render.rooms;
    const openings = render.openings;
    const objects = render.objects;
    const tokens = render.tokens;
    EDITOR.lastOpenings = openings;
    EDITOR.lastObjects = objects;

    const roomMetaAll = buildRoomMeta(rooms);

    const fogEnabled = !!elFogToggle.checked;
    const spritesEnabled = !!(elSpriteToggle && elSpriteToggle.checked);
    SPRITES_ENABLED = spritesEnabled;
    const labelsEnabled = !!(elLabelBoldToggle && elLabelBoldToggle.checked);
    if (state.fog && typeof state.fog === 'object') state.fog.enabled = fogEnabled;

    const renderSig = renderSignatureFor(state, {
      fogEnabled,
      spritesEnabled,
      labelsEnabled,
    });
    const editorSig = editorSignatureFor();
    const shouldRender = (renderSig !== LAST_RENDER_SIGNATURE) || (editorSig !== LAST_EDITOR_SIGNATURE);

    let roomsToDraw = rooms;
    let openingsToDraw = openings;

    if (shouldRender) {
      RENDER_FOG = computeRenderFog(state, VIEW.floorId, rooms, openings, tokens);

      if (!fogEnabled) {
        roomsToDraw = rooms.filter(r => !isFogFloorRoom(r));
      }

      if (RENDER_FOG && RENDER_FOG.enabled) {
        const baseFogRoomIds = new Set();
        for (const r of rooms) {
          if (isFogFloorRoom(r) && r && r.id) baseFogRoomIds.add(String(r.id));
        }

        const renderableRoomIds = new Set([...RENDER_FOG.explored]);
        roomsToDraw = rooms.filter(r => {
          const id = r && r.id ? String(r.id) : '';
          if (!id) return true;
          if (baseFogRoomIds.has(id)) return true;
          return renderableRoomIds.has(id);
        });

        openingsToDraw = openings.filter(o => {
          const ids = openingRoomIds(o, roomMetaAll);
          if (!ids.length) return false;
          const isRenderable = (id) => renderableRoomIds.has(id) || baseFogRoomIds.has(id);
          if (ids.length === 1) return isRenderable(ids[0]);
          return (isRenderable(ids[0]) || isRenderable(ids[1]));
        });
      }

      renderScene(rooms, roomsToDraw, openingsToDraw, objects, tokens, roomMetaAll, fogEnabled);
      LAST_RENDER_SIGNATURE = renderSig;
      LAST_EDITOR_SIGNATURE = editorSig;
    }
    updateUI(state, render, rooms, openings, objects, tokens);

    if (state.view && typeof state.view === 'object') state.view.camera_hex = hexId(VIEW.camera.col, VIEW.camera.row);
  }

  function safeRedraw() {
    try {
      if (elError) { elError.hidden = true; elError.textContent = ''; }
      redraw();
    } catch (e) {
      console.error('[Battlemat] redraw failed:', e);
      if (elError) {
        elError.hidden = false;
        elError.textContent = String(e && e.stack ? e.stack : e);
      }
    }
  }

  // ===== Controls =====
  function pan(dc, dr) {
    if (VIEW.followTokenId) {
      VIEW.followTokenId = null;
      if (elCenterOn) elCenterOn.value = '';
    }
    VIEW.camera.col += dc;
    VIEW.camera.row += dr;
    safeRedraw();
  }

  function setCameraToHex(hex, opts = {}) {
    const manual = (opts.manual !== false);
    const p = parseHexId(hex);
    VIEW.camera.col = p.col;
    VIEW.camera.row = p.row;

    if (manual) {
      VIEW.followTokenId = null;
      if (elCenterOn) elCenterOn.value = '';
    }

    safeRedraw();
  }

  function setActiveRecord(recordId) {
  const rid = String(recordId || '').trim();
  if (!rid) return;

  const w = ensureWorldWrapper();
  if (!w || !w.records || !w.records[rid]) return;

  const rec = w.records[rid];
  const floors = Array.isArray(rec && rec.floors) ? rec.floors : [];
  const defaultFloorId = (rec && rec.view && rec.view.floorId) ? String(rec.view.floorId) : (floors[0] ? String(floors[0].id) : null);
  const defaultCameraHex = (rec && rec.view && rec.view.camera_hex) ? String(rec.view.camera_hex) : null;

  if (!w.active || typeof w.active !== 'object') w.active = { recordId: rid };
  w.active.recordId = rid;
  if (defaultFloorId) w.active.floorId = defaultFloorId;
  if (defaultCameraHex) w.active.camera_hex = defaultCameraHex;

  // Manual scene switch stops following a token.
  VIEW.followTokenId = null;
  if (elCenterOn) elCenterOn.value = '';

  refreshFromWorld();
  safeRedraw();
}

function setActiveFloor(floorId, opts = {}) {
    const state = getState();
    const floors = getFloorsFromState(state);

    const target = String(floorId || '');
    const f = floorById(floors, target);
    if (!f) return;

    // Preserve the current camera unless explicitly told to re-center.
    const prevCam = { col: VIEW.camera.col, row: VIEW.camera.row };

    // If the user manually switched floors, stop following a token.
    if (!opts.fromFollow) {
      VIEW.followTokenId = null;
      if (elCenterOn) elCenterOn.value = '';
    }

    VIEW.floorId = target;

    if (state.view && typeof state.view === 'object') state.view.floorId = target;

    const keepCamera = !!opts.keepCamera;

    // Old behavior: when not keeping camera (and not switching due to follow), snap to a PC on that floor.
    if (!opts.fromFollow && !keepCamera) {
      const pcs = tokensOnFloor(state, target).filter(isPlayerToken);
      if (pcs.length && pcs[0].hex) {
        try {
          const p = parseHexId(pcs[0].hex);
          VIEW.camera.col = p.col;
          VIEW.camera.row = p.row;
        } catch {}
      }
    } else {
      // Default requested behavior: keep the same map spot centered.
      VIEW.camera.col = prevCam.col;
      VIEW.camera.row = prevCam.row;
    }

    safeRedraw();
  }

  function wireUI() {
    const req = (id) => {
      const el = els[id];
      if (!el) console.warn('[Battlemat] missing control #' + id);
      return el;
    };

    const btnLeft = req('btnLeft');
    const btnRight = req('btnRight');
    const btnUp = req('btnUp');
    const btnDown = req('btnDown');
    const btnZoomOut = req('btnZoomOut');
    const btnZoomIn = req('btnZoomIn');
    const btnRedraw = req('btnRedraw');
    const btnJump = req('btnJump');
    const toolSelect = req('toolSelect');
    const toolRoom = req('toolRoom');
    const toolDoor = req('toolDoor');
    const toolWindow = req('toolWindow');
    const toolObject = req('toolObject');
    const toolDelete = req('toolDelete');
    const btnSaveDb = req('btnSaveDb');
    const btnUndo = req('btnUndo');
    const btnScanIssues = req('btnScanIssues');
    const btnCleanOrphans = req('btnCleanOrphans');
    const objectKindSelect = req('objectKindSelect');
    const objectRot = req('objectRot');
    const objectOx = req('objectOx');
    const objectOy = req('objectOy');
    const objectScale = req('objectScale');
    const btnObjBack = req('btnObjBack');
    const btnObjFront = req('btnObjFront');
    const openingKind = req('openingKind');
    const openingHex = req('openingHex');
    const openingOrientation = req('openingOrientation');
    const openingOpenPct = req('openingOpenPct');
    const openingHinge = req('openingHinge');
    const openingSwing = req('openingSwing');
    const roomCornerTL = req('roomCornerTL');
    const roomCornerBR = req('roomCornerBR');
    const roomFloorKind = req('roomFloorKind');
    const roomWallKind = req('roomWallKind');
    const roomThickness = req('roomThickness');
    const sourceSelect = req('sourceSelect');
    const statusBody = req('statusBody');
    const chatSpeaker = req('chatSpeaker');
    const chatInput = req('chatInput');
    const chatSend = req('chatSend');
    const playtestToggle = req('playtestToggle');

    if (btnLeft) btnLeft.onclick = () => pan(-PAN_STEP, 0);
    if (btnRight) btnRight.onclick = () => pan(PAN_STEP, 0);
    if (btnUp) btnUp.onclick = () => pan(0, PAN_STEP);
    if (btnDown) btnDown.onclick = () => pan(0, -PAN_STEP);

    const ZOOM_STEP = 0.10;
    if (btnZoomOut) btnZoomOut.onclick = () => setZoom(ZOOM - ZOOM_STEP);
    if (btnZoomIn) btnZoomIn.onclick = () => setZoom(ZOOM + ZOOM_STEP);

    if (btnRedraw) btnRedraw.onclick = () => safeRedraw();

    if (btnJump) btnJump.onclick = () => {
      const v = String(elJumpHex.value || '').trim();
      if (!v) return;
      try { setCameraToHex(v, { manual: true }); }
      catch (e) { console.warn('[Battlemat] Bad jump hex:', v, e); }
    };

    if (toolSelect) toolSelect.onclick = () => setEditorTool('select');
    if (toolRoom) toolRoom.onclick = () => setEditorTool('room');
    if (toolDoor) toolDoor.onclick = () => setEditorTool('door');
    if (toolWindow) toolWindow.onclick = () => setEditorTool('window');
    if (toolObject) toolObject.onclick = () => setEditorTool('object');
    if (toolDelete) toolDelete.onclick = () => setEditorTool('delete');
    if (btnSaveDb) btnSaveDb.onclick = () => saveStateToDatabase();
    if (btnUndo) btnUndo.onclick = () => applyUndoSnapshot();
    if (btnScanIssues) btnScanIssues.onclick = () => window.BattlematScanIssues();
    if (btnCleanOrphans) btnCleanOrphans.onclick = () => window.BattlematCleanOrphanOpenings();
    if (playtestToggle) playtestToggle.onchange = () => setPlaytestMode(playtestToggle.checked);

    const onObjectControlChange = () => updateObjectControlsFromInputs({ applyToSelection: true });
    if (objectKindSelect) objectKindSelect.onchange = () => onObjectControlChange();
    if (objectRot) objectRot.oninput = () => onObjectControlChange();
    if (objectOx) objectOx.oninput = () => onObjectControlChange();
    if (objectOy) objectOy.oninput = () => onObjectControlChange();
    if (objectScale) objectScale.oninput = () => onObjectControlChange();
    if (btnObjBack) btnObjBack.onclick = () => {
      const ctx = getEditorContext();
      if (!moveSelectedRoomZ(ctx, 'back')) moveSelectedObjectZ(ctx, 'back');
    };
    if (btnObjFront) btnObjFront.onclick = () => {
      const ctx = getEditorContext();
      if (!moveSelectedRoomZ(ctx, 'front')) moveSelectedObjectZ(ctx, 'front');
    };

    const onOpeningControlChange = () => updateOpeningControlsFromInputs();
    if (openingKind) {
      openingKind.onchange = () => onOpeningControlChange();
      openingKind.onkeydown = (ev) => { if (ev.key === 'Enter') onOpeningControlChange(); };
    }
    if (openingHex) {
      openingHex.onchange = () => onOpeningControlChange();
      openingHex.onkeydown = (ev) => { if (ev.key === 'Enter') onOpeningControlChange(); };
    }
    if (openingOrientation) openingOrientation.onchange = () => onOpeningControlChange();
    if (openingOpenPct) openingOpenPct.oninput = () => onOpeningControlChange();
    if (openingHinge) openingHinge.onchange = () => onOpeningControlChange();
    if (openingSwing) openingSwing.oninput = () => onOpeningControlChange();

    const onRoomControlChange = () => updateRoomControlsFromInputs();
    if (roomCornerTL) {
      roomCornerTL.onchange = () => onRoomControlChange();
      roomCornerTL.onkeydown = (ev) => { if (ev.key === 'Enter') onRoomControlChange(); };
    }
    if (roomCornerBR) {
      roomCornerBR.onchange = () => onRoomControlChange();
      roomCornerBR.onkeydown = (ev) => { if (ev.key === 'Enter') onRoomControlChange(); };
    }
    if (roomFloorKind) {
      roomFloorKind.onchange = () => onRoomControlChange();
      roomFloorKind.onkeydown = (ev) => { if (ev.key === 'Enter') onRoomControlChange(); };
    }
    if (roomWallKind) {
      roomWallKind.onchange = () => onRoomControlChange();
      roomWallKind.onkeydown = (ev) => { if (ev.key === 'Enter') onRoomControlChange(); };
    }
    if (roomThickness) roomThickness.oninput = () => onRoomControlChange();

    if (statusBody) {
      const tryCancelAction = async (target) => {
        const tick = target && target.closest ? target.closest('.actionTick') : null;
        if (!tick || !tick.dataset) return false;
        const chatId = tick.dataset.chatId;
        if (!chatId) return false;
        await updateMessageStatus(chatId, 'canceled');
        return true;
      };
      const tryOpenSheet = (target) => {
        const row = target && target.closest ? target.closest('.statusRow') : null;
        if (!row || !row.dataset) return false;
        const cid = row.dataset.characterId;
        if (!cid) return false;
        openCharacterSheet(cid);
        return true;
      };
      statusBody.addEventListener('click', (ev) => {
        if (tryCancelAction(ev.target)) { ev.preventDefault(); return; }
        if (tryOpenSheet(ev.target)) ev.preventDefault();
      });
      statusBody.addEventListener('keydown', (ev) => {
        if (ev.key !== 'Enter' && ev.key !== ' ') return;
        if (tryCancelAction(ev.target)) { ev.preventDefault(); return; }
        if (tryOpenSheet(ev.target)) ev.preventDefault();
      });
    }

    const submitChat = async () => {
      if (!chatInput) return;
      const text = String(chatInput.value || '').trim();
      if (!text) return;
      const speaker = chatSpeaker ? String(chatSpeaker.value || '').trim() : 'Player';
      const ok = await sendChatMessage({ speaker, text });
      if (ok) chatInput.value = '';
    };
    if (chatSend) chatSend.onclick = () => submitChat();
    if (chatInput) chatInput.onkeydown = (ev) => {
      if (ev.key === 'Enter') {
        ev.preventDefault();
        submitChat();
      }
    };
    if (elChatMarkRead) {
      elChatMarkRead.onclick = () => {
        setChatReadTs(LAST_CHAT_TS || 0);
      };
    }

    if (canvas) {
      canvas.addEventListener('mousemove', (ev) => {
        const tool = EDITOR.tool;
        if (tool !== 'door' && tool !== 'window' && tool !== 'room' && tool !== 'object') {
          let changed = false;
          if (EDITOR.preview) { EDITOR.preview = null; changed = true; }
          if (EDITOR.roomPreview) { EDITOR.roomPreview = null; changed = true; }
          if (EDITOR.objectPreview) { EDITOR.objectPreview = null; changed = true; }
          if (changed) safeRedraw();
          return;
        }

        const ctx = getEditorContext();
        if (!ctx) return;
        const world = eventToWorld(ev);

        if (tool === 'door' || tool === 'window') {
          const placement = computeDoorPlacement(world, ctx);
          if (!placement) {
            if (EDITOR.preview) {
              EDITOR.preview = null;
              safeRedraw();
            }
            return;
          }
          const prev = EDITOR.preview && EDITOR.preview.opening
            ? EDITOR.preview.opening
            : null;
          if (prev && prev.hex === placement.hex && prev.orientation === placement.orientation && EDITOR.preview.floorId === ctx.floorId) {
            return;
          }
          EDITOR.preview = {
            floorId: ctx.floorId,
            opening: { kind: (tool === 'window' ? 'window' : 'door.wood'), hex: placement.hex, orientation: placement.orientation }
          };
          safeRedraw();
          return;
        }

        if (tool === 'object') {
          const placement = objectHexFromWorld(world);
          if (!placement) {
            if (EDITOR.objectPreview) {
              EDITOR.objectPreview = null;
              safeRedraw();
            }
            return;
          }
          const values = getObjectToolValues();
          const prev = EDITOR.objectPreview && EDITOR.objectPreview.object ? EDITOR.objectPreview.object : null;
          if (prev &&
              prev.hex === placement.label &&
              prev.kind === values.kind &&
              prev.rotDeg === values.rotDeg &&
              prev.ox === values.ox &&
              prev.oy === values.oy &&
              prev.spriteScale === values.scale &&
              EDITOR.objectPreview.floorId === ctx.floorId) {
            return;
          }
          EDITOR.objectPreview = {
            floorId: ctx.floorId,
            object: {
              kind: values.kind,
              hex: placement.label,
              ox: values.ox,
              oy: values.oy,
              rotDeg: values.rotDeg,
              spriteScale: values.scale,
              __forceVisible: true,
            }
          };
          safeRedraw();
          return;
        }

        if (EDITOR.preview) {
          EDITOR.preview = null;
        }
        if (EDITOR.objectPreview) {
          EDITOR.objectPreview = null;
        }

        if (EDITOR.roomStart && EDITOR.roomStart.floorId && EDITOR.roomStart.floorId !== ctx.floorId) {
          EDITOR.roomStart = null;
          EDITOR.roomPreview = null;
        }

        if (!EDITOR.roomStart) {
          if (EDITOR.roomPreview) {
            EDITOR.roomPreview = null;
            safeRedraw();
          }
          return;
        }

        const endHex = roomHexFromWorld(world);
        const roomPreview = endHex ? buildRoomPreview(ctx, EDITOR.roomStart, endHex) : null;
        if (!roomPreview) {
          if (EDITOR.roomPreview) {
            EDITOR.roomPreview = null;
            safeRedraw();
          }
          return;
        }

        const nextKey = Array.isArray(roomPreview.corners) ? roomPreview.corners.join('|') : '';
        const prevKey = (EDITOR.roomPreview && EDITOR.roomPreview.room && Array.isArray(EDITOR.roomPreview.room.corners))
          ? EDITOR.roomPreview.room.corners.join('|')
          : '';
        if (nextKey && nextKey === prevKey && EDITOR.roomPreview.floorId === ctx.floorId) return;

        EDITOR.roomPreview = { floorId: ctx.floorId, room: roomPreview };
        safeRedraw();
      }, { passive: true });

      canvas.addEventListener('mouseleave', () => {
        let changed = false;
        if (EDITOR.preview) { EDITOR.preview = null; changed = true; }
        if (EDITOR.roomPreview) { EDITOR.roomPreview = null; changed = true; }
        if (EDITOR.objectPreview) { EDITOR.objectPreview = null; changed = true; }
        if (changed) safeRedraw();
      }, { passive: true });

      canvas.addEventListener('mousedown', (ev) => {
        if (ev.button !== 0) return;
        const ctx = getEditorContext();
        if (!ctx) return;
        const world = eventToWorld(ev);

        if (EDITOR.tool === 'door') {
          const hit = findOpeningNear(world, ctx);
          if (hit) {
            setSelectedOpening(hit, ctx.floorId);
            safeRedraw();
            return;
          }
          const placement = computeDoorPlacement(world, ctx);
          if (!placement) return;
          captureUndoSnapshot('add door');
          const opening = addDoorAtPlacement(ctx, placement);
          if (!opening) return;
          setSelectedOpening(opening, ctx.floorId);
          scheduleDatabaseSave();
          safeRedraw();
          return;
        }

        if (EDITOR.tool === 'window') {
          const hit = findOpeningNear(world, ctx);
          if (hit) {
            setSelectedOpening(hit, ctx.floorId);
            safeRedraw();
            return;
          }
          const placement = computeDoorPlacement(world, ctx);
          if (!placement) return;
          captureUndoSnapshot('add window');
          const opening = addWindowAtPlacement(ctx, placement);
          if (!opening) return;
          setSelectedOpening(opening, ctx.floorId);
          scheduleDatabaseSave();
          safeRedraw();
          return;
        }

        if (EDITOR.tool === 'object') {
          const hitObject = findObjectNear(world, ctx);
          if (hitObject) {
            setSelectedObject(hitObject, ctx.floorId);
            safeRedraw();
            return;
          }
          const placement = objectHexFromWorld(world);
          if (!placement) return;
          captureUndoSnapshot('add object');
          const object = addObjectAtHex(ctx, placement.label, getObjectToolValues());
          if (!object) return;
          setSelectedObject(object, ctx.floorId);
          scheduleDatabaseSave();
          safeRedraw();
          return;
        }

        if (EDITOR.tool === 'room') {
          if (EDITOR.roomStart && EDITOR.roomStart.floorId && EDITOR.roomStart.floorId !== ctx.floorId) {
            EDITOR.roomStart = null;
            EDITOR.roomPreview = null;
          }

          const hex = roomHexFromWorld(world);
          if (!hex) return;

          if (!EDITOR.roomStart) {
            const start = { col: hex.col, row: hex.row, floorId: ctx.floorId };
            EDITOR.roomStart = start;
            const preview = buildRoomPreview(ctx, start, start);
            EDITOR.roomPreview = preview ? { floorId: ctx.floorId, room: preview } : null;
            safeRedraw();
            return;
          }

          const corners = roomCornersFromHexes(EDITOR.roomStart, hex);
          if (!corners) {
            EDITOR.roomPreview = null;
            safeRedraw();
            return;
          }

          captureUndoSnapshot('add room');
          const room = addRoomAtCorners(ctx, corners);
          EDITOR.roomStart = null;
          EDITOR.roomPreview = null;
          if (room) scheduleDatabaseSave();
          safeRedraw();
          return;
        }

        if (EDITOR.tool === 'delete') {
          const hitOpening = findOpeningNear(world, ctx);
          if (hitOpening && removeOpening(ctx, hitOpening)) {
            scheduleDatabaseSave();
          } else {
            const hitObject = findObjectNear(world, ctx);
            if (hitObject && removeObject(ctx, hitObject)) {
              scheduleDatabaseSave();
            } else {
              const hitToken = findTokenNear(world, ctx);
              if (hitToken && removeToken(ctx, hitToken)) {
                scheduleDatabaseSave();
              } else {
                const hitRoom = findRoomAtWorld(world, ctx);
                if (hitRoom && removeRoom(ctx, hitRoom)) {
                  scheduleDatabaseSave();
                } else {
                  setSelectedOpening(null);
                  clearSelectedObject();
                  clearSelectedRoom();
                }
              }
            }
          }
          safeRedraw();
          return;
        }

        const hit = findOpeningNear(world, ctx);
        if (hit) {
          setSelectedOpening(hit, ctx.floorId);
        } else {
          const hitObject = findObjectNear(world, ctx);
          if (hitObject) {
            setSelectedObject(hitObject, ctx.floorId);
          } else {
            const hitRoom = findRoomAtWorld(world, ctx);
            if (hitRoom) setSelectedRoom(hitRoom, ctx.floorId);
            else {
              setSelectedOpening(null);
              clearSelectedObject();
              clearSelectedRoom();
            }
          }
        }
        safeRedraw();
      });
    }

    if (elPoiSelect) {
      elPoiSelect.onchange = () => {
        const v = String(elPoiSelect.value || '').trim();
        if (!v) return;
        FOLLOW_LOCATION_MANUAL_OVERRIDE = true;
        FOLLOW_ACTIVE_LOCATION = false;
        CURRENT_BATTLE_ID = v;
        const cid = CURRENT_CAMPAIGN_ID || resolveCampaignIdFromUrl() || '';
        const id = encodeURIComponent(v);
        if (cid) {
          try { history.replaceState(null, '', '/play/c/' + encodeURIComponent(cid) + '?battle_id=' + id); } catch {}
        } else {
          try { history.replaceState(null, '', '/play/' + id); } catch {}
        }
        STATE_URL = '/api/battles/' + id;
        STATE_SOURCE = 'database';
        stopStatePolling();
        startStatePolling();
      };
    }

    if (elFogToggle) elFogToggle.onchange = () => safeRedraw();
    if (elSpriteToggle) {
      elSpriteToggle.onchange = () => {
        SPRITES_ENABLED = !!elSpriteToggle.checked;
        safeRedraw();
      };
    }
    if (elLabelBoldToggle) elLabelBoldToggle.onchange = () => safeRedraw();

    if (elSceneSelect) {
      elSceneSelect.onchange = () => setActiveRecord(elSceneSelect.value);
    }

    if (elFloorSelect) {
      elFloorSelect.onchange = () => setActiveFloor(elFloorSelect.value, { fromFollow: false, keepCamera: true });
    }

    if (elCenterOn) {
      elCenterOn.onchange = () => {
        const id = String(elCenterOn.value || '');
        VIEW.followTokenId = id || null;
        safeRedraw();
      };
    }

    if (elSsSelect) {
      elSsSelect.onchange = () => setSupersample(elSsSelect.value);
    }

    if (sourceSelect) {
      sourceSelect.onchange = () => applySourceSelection(sourceSelect.value);
    }

    window.onkeydown = (ev) => {
      if (ev.target && (ev.target.tagName === 'INPUT' || ev.target.tagName === 'SELECT' || ev.target.isContentEditable)) return;
      if ((ev.ctrlKey || ev.metaKey) && (ev.key === 'z' || ev.key === 'Z')) {
        applyUndoSnapshot();
        ev.preventDefault();
        return;
      }
      if (handleEditorKey(ev)) {
        ev.preventDefault();
        return;
      }
      const k = ev.key;
      if (k === 'ArrowLeft' || k === 'a' || k === 'A') pan(-PAN_STEP, 0);
      else if (k === 'ArrowRight' || k === 'd' || k === 'D') pan(PAN_STEP, 0);
      else if (k === 'ArrowUp' || k === 'w' || k === 'W') pan(0, PAN_STEP);
      else if (k === 'ArrowDown' || k === 's' || k === 'S') pan(0, -PAN_STEP);
      else if (k === 'r' || k === 'R') safeRedraw();
      else if (k === '+' || k === '=' ) setZoom(ZOOM + 0.10);
      else if (k === '-' || k === '_' ) setZoom(ZOOM - 0.10);
    };
  }

  // ===== Resize =====
  function resize() {
    SUPERSAMPLE = readSupersample();
    ZOOM = readZoom();
    applyZoom();
    syncZoomUI();

    const wrap = els.canvasWrap;

    // Prefer integer CSS sizes (clientWidth/Height) to avoid fractional px gaps that
    // can show up as a 1px line along the right/bottom edge.
    let cssW = Math.max(1, wrap ? wrap.clientWidth : 1);
    let cssH = Math.max(1, wrap ? wrap.clientHeight : 1);

    // Fallback: if layout is mid-transition and client sizes are 0, use a rounded rect.
    if (wrap && (cssW <= 1 || cssH <= 1)) {
      const rect = wrap.getBoundingClientRect();
      cssW = Math.max(1, Math.round(rect.width));
      cssH = Math.max(1, Math.round(rect.height));
    }

    const dpr = Math.max(1, window.devicePixelRatio || 1);
    const scale = dpr * SUPERSAMPLE;

    VIEW.dpr = scale;
    VIEW.anchor.x = cssW / 2;
    VIEW.anchor.y = cssH / 2;

    if (elDpr) elDpr.textContent = dpr.toFixed(2);
    if (elSs) elSs.textContent = String(SUPERSAMPLE);

    canvas.width = Math.max(1, Math.floor(cssW * scale));
    canvas.height = Math.max(1, Math.floor(cssH * scale));

    wallCanvas.width = canvas.width;
    wallCanvas.height = canvas.height;

    ctx.setTransform(scale, 0, 0, scale, 0, 0);
    wallCtx.setTransform(scale, 0, 0, scale, 0, 0);

    ctx.imageSmoothingEnabled = true;
    try { ctx.imageSmoothingQuality = 'high'; } catch {}

    // Force a full render after any resize since the backing store changed.
    LAST_RENDER_SIGNATURE = '';
    safeRedraw();
  }

  // ===== Self-tests (tiny sanity checks) =====
  function runSelfTests() {
    const assert = (name, cond) => {
      if (!cond) throw new Error('SelfTest failed: ' + name);
    };

    // quarter-step openings (still supports .5)
    const oh = parseOpeningHexId('M12.5');
    assert('parseOpeningHexId col', oh.col === lettersToCol('M'));
    assert('parseOpeningHexId row (.5)', Math.abs(oh.row - 11.5) < 1e-9);

    const oq = parseOpeningHexId('M12.25');
    assert('parseOpeningHexId row (.25)', Math.abs(oq.row - 11.25) < 1e-9);

    // integer hex
    const hh = parseHexId('U16');
    assert('parseHexId row', hh.row === 15);

    // corner decimals
    const ch = parseCornerHexId('M21.5');
    assert('parseCornerHexId half row', Math.abs(ch.row - 20.5) < 1e-9);

    // texture alias
    const td = resolveTextureDef('floor', 'wood');
    assert('resolveTextureDef alias', !!td && td.file === 'wood_oak.png');

    // threshold auto-span sizing
    const testRooms = [{
      id: 'TestRoom',
      corners: ['A6', 'D6', 'D3', 'A3'],
      thickness: 20,
      floor: { kind: 'wood' },
      wall: { kind: 'brick' },
    }];
    const testRoom = testRooms[0];
    const box = roomToWallBox(testRoom);
    const fr = roomFloorRectWorld(testRoom, box);

    const thH = { kind: 'threshold', hex: 'B5', orientation: 'h', parent: 'TestRoom' };
    const thV = { kind: 'threshold', hex: 'D4', orientation: 'v', parent: 'TestRoom' };
    assert('openingLengthWorld threshold-h uses parent span', Math.abs(openingLengthWorld(thH, testRooms) - Math.abs(fr.x2 - fr.x1)) < 1e-6);
    assert('openingLengthWorld threshold-v uses parent span', Math.abs(openingLengthWorld(thV, testRooms) - Math.abs(fr.y2 - fr.y1)) < 1e-6);

    const noParent = { kind: 'threshold', hex: 'B5', orientation: 'h', span: 2 };
    assert('openingLengthWorld threshold fallback to span', Math.abs(openingLengthWorld(noParent, testRooms) - (GRID.size * 1.2 * 2)) < 1e-6);

    // opening padding (axis-specific)
    const pV = openingPadAxes({ kind: 'threshold', orientation: 'v' }, 20);
    const pH = openingPadAxes({ kind: 'threshold', orientation: 'h' }, 20);
    assert('openingPadAxes threshold v pads X only', pV.x === 1 && pV.y === 0);
    assert('openingPadAxes threshold h pads Y only', pH.x === 0 && pH.y === 1);
    const pD = openingPadAxes({ kind: 'door', orientation: 'v' }, 20);
    assert('openingPadAxes door pads both axes', pD.x === 1 && pD.y === 1);

    // door kind detection
    assert('isDoorKind door', isDoorKind('door') === true);
    assert('isDoorKind door_wood', isDoorKind('door_wood') === true);
    assert('isDoorKind door.wood', isDoorKind('door.wood') === true);
    assert('isDoorKind door.steel (prefix)', isDoorKind('door.steel') === true);
    assert('isDoorKind window false', isDoorKind('window') === false);

    // door sprite swing direction should match the line-based door math for both hinge sides.
    // Non-sprite math uses: y2 = swingSign * sin(ang) (independent of hinge side), while x flips for hingeRight.
    // For sprite math, we rotate about hinge. Base leaf direction is +X for hinge-left, -X for hinge-right.
    // Using rotAng = (hingeRight ? -1 : 1) * swingSign * ang preserves y2 sign across hinge sides.
    {
      const ang = 0.75; // arbitrary radians
      for (const hingeRight of [false, true]) {
        for (const swingSign of [-1, 1]) {
          const baseX = hingeRight ? -1 : 1;
          const rotAng = (hingeRight ? -1 : 1) * swingSign * ang;
          const ySprite = baseX * Math.sin(rotAng);
          const yLine = swingSign * Math.sin(ang);
          assert('door sprite swing matches line (hingeRight=' + hingeRight + ', swing=' + swingSign + ')', Math.abs(ySprite - yLine) < 1e-12);
        }
      }
    }

    // door sprite scaling (openings)
    const doorDef = getSpriteDef('door.wood');
    const sOpen = { kind: 'door.wood', spriteScale: 1.5, spriteScaleX: 2, spriteScaleY: 0.5 };
    let sx = 1, sy = 1;
    if (doorDef) {
      if (isFiniteNum(doorDef.scale)) { sx *= Number(doorDef.scale); sy *= Number(doorDef.scale); }
      if (isFiniteNum(doorDef.scaleX)) sx *= Number(doorDef.scaleX);
      if (isFiniteNum(doorDef.scaleY)) sy *= Number(doorDef.scaleY);
    }
    if (isFiniteNum(sOpen.spriteScale)) { sx *= Number(sOpen.spriteScale); sy *= Number(sOpen.spriteScale); }
    if (isFiniteNum(sOpen.spriteScaleX)) sx *= Number(sOpen.spriteScaleX);
    if (isFiniteNum(sOpen.spriteScaleY)) sy *= Number(sOpen.spriteScaleY);
    assert('door opening spriteScale combines', Math.abs(sx - (1.5 * 2)) < 1e-12 && Math.abs(sy - (1.5 * 0.5)) < 1e-12);

    // query parsing
    const qp = getQueryParams('?stateUrl=%2Fdata%2Fbattle.json&pollMs=1500');
    assert('getQueryParams stateUrl', qp.get('stateUrl') === '/data/battle.json');
    assert('getQueryParams pollMs', qp.get('pollMs') === '1500');

    // clamp zoom
    assert('clamp zoom low', clamp(0.1, 0.6, 2.25) === 0.6);
    assert('clamp zoom high', clamp(9, 0.6, 2.25) === 2.25);

    // zoom math
    const base = GRID.baseSize;
    const prev = ZOOM;
    ZOOM = 1.35;
    applyZoom();
    assert('applyZoom sets GRID.size', Math.abs(GRID.size - base * 1.35) < 1e-9);
    ZOOM = prev;
    applyZoom();

    // wall thickness scales with zoom
    const prevZ = ZOOM;
    ZOOM = 2;
    const wtRoom = { id: 'WallTest', corners: ['A6','D6','D3','A3'], thickness: 20, floor: { kind: 'wood' }, wall: { kind: 'brick' } };
    const wtBox = roomToWallBox(wtRoom);
    assert('roomToWallBox thickness scales with ZOOM', Math.abs(wtBox.thickness - 40) < 1e-9);
    ZOOM = prevZ;
    applyZoom();

    // snap to device pixels (prevents 1px seams at high zoom)
    const prevDpr = VIEW.dpr;
    VIEW.dpr = 2;
    assert('snapCss rounds to 1/dpr grid', Math.abs(snapCss(1.25) - 1.5) < 1e-12);
    const rr = snappedRectFromCenter({ x: 10.25, y: 9.75 }, 5.1, 3.1);
    // edges should land on 0.5 increments when dpr=2
    assert('snappedRectFromCenter x aligned', Math.abs((rr.x * 2) - Math.round(rr.x * 2)) < 1e-12);
    assert('snappedRectFromCenter y aligned', Math.abs((rr.y * 2) - Math.round(rr.y * 2)) < 1e-12);
    VIEW.dpr = prevDpr;

    // sqrt3 / rowStep math
    assert('sqrt3 constant', Math.abs(sqrt3 - Math.sqrt(3)) < 1e-12);
    const rs = rowStep();
    assert('rowStep uses sqrt3', Math.abs(rs - Math.sqrt(3) * GRID.size) < 1e-9);
  }

  // ===== Boot =====
  async function init() {
    const state = getState();
    const floors = getFloorsFromState(state);
    VIEW.floorId = pickActiveFloorId(state, floors);

    // Persisted zoom + SS
    SUPERSAMPLE = readSupersample();
    ZOOM = readZoom();
    applyZoom();
    syncZoomUI();

    const camHex = state && state.view && state.view.camera_hex ? String(state.view.camera_hex) : null;
    if (camHex) {
      try {
        const p = parseHexId(camHex);
        VIEW.camera.col = p.col;
        VIEW.camera.row = p.row;
      } catch {}
    } else {
      const pc = (normalizeTokenCharacterIds(getTokensArray(state))).find(isPlayerToken);
      if (pc && pc.hex) {
        try {
          const p = parseHexId(pc.hex);
          VIEW.camera.col = p.col;
          VIEW.camera.row = p.row;
        } catch {}
      }
    }

    if (state.fog && typeof state.fog === 'object') elFogToggle.checked = !!state.fog.enabled;
    elSsSelect.value = String(readSupersample());

    // Run sanity checks only when explicitly requested.
    if (shouldRunSelfTests()) {
      try { runSelfTests(); }
      catch (e) {
        if (elError) {
          elError.hidden = false;
          elError.textContent = String(e && e.stack ? e.stack : e);
        }
        throw e;
      }
    }

    wireUI();
    syncEditorButtons();
    updateEditorPanelVisibility();
    updateStateDebug();
    renderChatLog();
    setPlaytestMode(readPlaytestMode());

    // Remote state (DB/API) hookup with DB default.
    const qp = getQueryParamsCached();
    const fromQuery = qp.get('stateUrl') || qp.get('state_url') || qp.get('state') || '';
    const fromWindow = (window && window.BATTLE_STATE_URL) ? String(window.BATTLE_STATE_URL) : '';
    const explicitUrl = (fromQuery || fromWindow || '').trim();

    if (explicitUrl) {
      const source = stateSourceFromUrl(explicitUrl);
      if (source === 'file') {
        applySourceSelection('file');
      } else {
        STATE_URL = explicitUrl;
        STATE_SOURCE = 'database';
        startStatePolling();
        syncSourceSelect();
        setToolStatus('DB: idle');
        const campaignId = resolveCampaignIdHintFromUrl();
        if (campaignId) {
          CURRENT_CAMPAIGN_ID = campaignId;
          await ensureCampaignMeta(campaignId);
        }
        refreshPoiSelect(CURRENT_CAMPAIGN_ID);
      }
    } else {
      const battleId = resolveBattleIdHintFromUrl();
      const campaignId = resolveCampaignIdHintFromUrl();
      if (battleId) {
        STATE_URL = `/api/battles/${encodeURIComponent(battleId)}`;
        STATE_SOURCE = 'database';
        startStatePolling();
        syncSourceSelect();
        setToolStatus('DB: idle');
        if (campaignId) {
          CURRENT_CAMPAIGN_ID = campaignId;
          await ensureCampaignMeta(campaignId);
        }
        refreshPoiSelect(campaignId || CURRENT_CAMPAIGN_ID);
      } else if (campaignId) {
        const info = await fetchCampaignInfo(campaignId);
        if (info && info.meta != null) CURRENT_CAMPAIGN_META = info.meta;
        if (info && info.battleId) {
          CURRENT_CAMPAIGN_ID = campaignId;
          CURRENT_BATTLE_ID = String(info.battleId);
          STATE_URL = `/api/battles/${encodeURIComponent(info.battleId)}`;
          STATE_SOURCE = 'database';
          startStatePolling();
          syncSourceSelect();
          setToolStatus('DB: idle');
          refreshPoiSelect(campaignId);
        } else {
          if (elError) {
            elError.hidden = false;
            elError.textContent = 'Campaign not found or missing active_battle_id.';
          }
          applySourceSelection('embedded');
        }
      } else {
        applySourceSelection('embedded');
      }
    }

    const ro = new ResizeObserver(() => resize());
    if (els.canvasWrap) ro.observe(els.canvasWrap);

    window.addEventListener('resize', resize, { passive: true });

    resize();
    requestAnimationFrame(() => {
      safeRedraw();
      requestAnimationFrame(safeRedraw);
    });
  }

  init();
  </script>
</body>
</html>






