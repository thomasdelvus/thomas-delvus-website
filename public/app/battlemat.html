<!--
Battlemat Core Rewrite
Version: v6.07
-->
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Battlemat Core v6.07</title>
  <style>
    :root{
      --bg:#0f1115;
      --panel:#161a22;
      --panel2:#121621;
      --text:#e9eef7;
      --muted:#9aa6bb;
      --border:rgba(255,255,255,0.12);
      --border2:rgba(255,255,255,0.08);
      --good:#43d17a;
      --bad:#ff5a5a;
    }
    html,body{height:100%;margin:0;}
    body{
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;
      background:var(--bg);
      color:var(--text);
      display:grid;
      grid-template-rows:auto 1fr;
    }
    #topbar{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
      padding:10px 12px;
      background:var(--panel);
      border-bottom:1px solid var(--border2);
    }
    #status{
      display:flex;
      align-items:center;
      gap:10px;
      min-height:26px;
      flex-wrap:wrap;
    }
    .pill{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding:4px 10px;
      border-radius:999px;
      background:rgba(255,255,255,0.08);
      border:1px solid var(--border);
      font-size:12px;
      color:var(--text);
      white-space:nowrap;
    }
    .dot{width:8px;height:8px;border-radius:50%;background:var(--good);box-shadow:0 0 0 2px rgba(67,209,122,0.15);}
    .mini{font-size:12px;color:var(--muted);display:inline-flex;align-items:center;gap:6px;white-space:nowrap;}
    .mini input[type="text"]{
      width:72px;
      padding:4px 8px;
      border-radius:8px;
      border:1px solid var(--border);
      background:rgba(0,0,0,0.25);
      color:var(--text);
      outline:none;
    }
    select{
      padding:4px 8px;
      border-radius:8px;
      border:1px solid var(--border);
      background:rgba(0,0,0,0.25);
      color:var(--text);
      outline:none;
      font-size:12px;
    }
    button{
      padding:6px 10px;
      border-radius:10px;
      border:1px solid var(--border);
      background:rgba(255,255,255,0.08);
      color:var(--text);
      cursor:pointer;
      font-size:12px;
    }
    button:hover{background:rgba(255,255,255,0.12);}
    .sep{width:1px;height:18px;background:var(--border2);margin:0 2px;}

    #controls{
      display:flex;
      align-items:center;
      gap:8px;
      flex-wrap:wrap;
      justify-content:flex-end;
    }

    #layout{
      display:grid;
      grid-template-columns: 1fr 320px;
      gap:12px;
      padding:12px;
      min-height:0;
    }

    #canvasWrap{
      background:#0b0d12;
      border:1px solid var(--border);
      border-radius:12px;
      box-shadow:0 10px 30px rgba(0,0,0,0.35);
      overflow:hidden;
      min-height:0;
    }

    canvas{width:100%;height:100%;display:block;background:#0b0d12;}

    #sidebar{
      background:var(--panel2);
      border:1px solid var(--border);
      border-radius:12px;
      padding:12px;
      overflow:auto;
      min-height:0;
    }

    #sidebar h3{
      margin:0 0 8px 0;
      font-size:13px;
      color:var(--text);
      letter-spacing:0.02em;
    }

    #kvs{
      display:grid;
      grid-template-columns: 1fr auto;
      gap:6px 10px;
      font-size:12px;
      color:var(--muted);
      margin-bottom:12px;
    }

    #turns{
      font-size:12px;
      color:var(--muted);
      display:flex;
      flex-direction:column;
      gap:6px;
      margin-bottom:12px;
    }

    .turnRow{
      display:flex;
      justify-content:space-between;
      gap:10px;
      padding:6px 8px;
      border:1px solid rgba(255,255,255,0.10);
      border-radius:10px;
      background:rgba(255,255,255,0.04);
    }
    .turnRow.active{border-color:rgba(67,209,122,0.35); background:rgba(67,209,122,0.08); color:var(--text);}

    #errorBox{
      border:1px solid rgba(255,90,90,0.35);
      background:rgba(255,90,90,0.08);
      border-radius:12px;
      padding:10px;
      font-size:12px;
      color:var(--text);
      white-space:pre-wrap;
    }

    .dpad{
      display:inline-flex;
      gap:6px;
      align-items:center;
      margin-left:6px;
    }
    .dpad button{padding:6px 8px; border-radius:10px; min-width:34px;}

    @media (max-width: 980px){
      #layout{grid-template-columns:1fr;}
    }
  </style>
</head>
<body>
  <div id="topbar">
    <div id="status">
      <div class="pill" title="Battlemat version" id="versionPill"><span class="dot"></span><span id="versionText">v6.07</span></div>
      <div class="mini" id="battleTitle">Battlemat</div>
      <div class="sep"></div>
      <div class="mini">Floor <select id="floorSelect"></select></div>
      <div class="pill" title="DevicePixelRatio × Supersample">
        DPR <span id="dprText">?</span>
        &nbsp;·&nbsp; SS <span id="ssText">?</span>
      </div>
    </div>

    <div id="controls">
      <label class="mini"><input type="checkbox" id="fogToggle" checked /> Fog</label>
      <label class="mini"><input type="checkbox" id="spriteToggle" checked /> Sprites</label>
      <label class="mini"><input type="checkbox" id="labelBoldToggle" /> Bright Labels</label>

      <div class="mini">SS
        <select id="ssSelect" title="Supersample quality">
          <option value="1">1×</option>
          <option value="2">2×</option>
          <option value="3">3×</option>
        </select>
      </div>

      <div class="mini">Center
        <select id="centerOn" title="Follow a PC token"></select>
      </div>

      <div class="mini">Jump
        <input id="jumpHex" type="text" value="U16" />
        <button id="btnJump">Go</button>
      </div>

      <button id="btnRedraw">Redraw</button>

      <div class="dpad" title="Pan camera">
        <button id="btnLeft">←</button>
        <button id="btnUp">↑</button>
        <button id="btnDown">↓</button>
        <button id="btnRight">→</button>
      </div>

      <div class="dpad" title="Zoom">
        <button id="btnZoomOut">−</button>
        <button id="btnZoomIn">+</button>
      </div>
      <div class="mini" title="Map zoom"><span id="zoomText">100%</span></div>
    </div>
  </div>

  <div id="layout">
    <div id="canvasWrap"><canvas id="canvas" aria-label="Battlemat canvas"></canvas></div>
    <div id="sidebar">
      <h3>Status</h3>
      <div id="kvs"></div>

      <h3>Initiative</h3>
      <div id="turns"></div>

      <div id="errorBox" hidden></div>
    </div>
  </div>

  <script>
  // =====================================================================================
  // Battlemat Core Rewrite v6.07
  // Goals: small core renderer (hexes + camera + layers + orientation + fog) + supersample.
  // =====================================================================================

  const VERSION = 'v6.07';

  // ===== DOM =====
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d', { alpha: false, desynchronized: true });

  // Offscreen wall layer (we punch openings out of walls here, then composite onto main canvas)
  const wallCanvas = document.createElement('canvas');
  const wallCtx = wallCanvas.getContext('2d', { alpha: true, desynchronized: true });

  const elVersion = document.getElementById('versionText');
  const elTitle = document.getElementById('battleTitle');
  const elFogToggle = document.getElementById('fogToggle');
  const elSpriteToggle = document.getElementById('spriteToggle');
  const elLabelBoldToggle = document.getElementById('labelBoldToggle');
  const elFloorSelect = document.getElementById('floorSelect');
  const elCenterOn = document.getElementById('centerOn');
  const elJumpHex = document.getElementById('jumpHex');
  const elError = document.getElementById('errorBox');
  const elDpr = document.getElementById('dprText');
  const elSs = document.getElementById('ssText');
  const elSsSelect = document.getElementById('ssSelect');

  if (elVersion) elVersion.textContent = VERSION;

  // ===== Constants =====
  const sqrt3 = Math.sqrt(3);

  const GRID = {
    // Flat-top hex geometry: size is center-to-vertex.
    baseSize: 42,
    size: 42,
    lineWidth: 2,
    lineAlpha: 0.10,
    labelAlpha: 0.18,
    labelFont: 'bold 12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial',
  };

  const COLORS = {
    bg: '#0b0d12',
    wall: '#666',
    door: '#b67a2c',
    window: '#bfe2ff',

    floorStone: 'rgb(223, 208, 165)',
    floorWood:  'rgb(213, 181, 140)',

    // Placeholder prop colors (used when sprites are off or missing)
    objectWood: 'rgb(173, 131, 89)',
    chestWood:  'rgb(110, 72, 40)',
    stairsWood: 'rgb(140, 98, 64)',

    // Beds (placeholder colors)
    bedFabric: 'rgb(147, 116, 84)',
    bedPillow: 'rgb(175, 159, 141)',

    // Hearth (placeholder color)
    hearth: 'rgb(147, 53, 53)',
    floorCobble: 'rgb(154, 160, 166)',

    tokenHero: '#4aa3ff',
    tokenEnemy: '#111',
    tokenTextDark: 'rgba(0,0,0,0.72)',
    tokenTextLight: 'rgba(255,255,255,0.88)',

    fogUnseen: 'rgb(128,128,128)',
    fogExplored: 'rgb(170,170,170)',
  };

  const VIEW = {
    // Camera is in hex coords (col,row), row 0 is "row 1" at the bottom.
    camera: { col: 6, row: 6 },
    anchor: { x: 0, y: 0 },
    dx: 0,
    dy: 0,

    // Active floor id (single-floor states still work)
    floorId: null,

    // If set, camera will automatically follow that token id (and flip floors when needed)
    followTokenId: null,

    // DevicePixelRatio × supersample scale (set in resize())
    dpr: 1,
  };

  const PAN_STEP = 2;
  const STORAGE_SS = 'battlemat.supersample';
  const STORAGE_ZOOM = 'battlemat.zoom';

  // ===== Remote state (DB/API) =====
  const DEFAULT_POLL_MS = 1000;
  let CURRENT_STATE = null;
  let STATE_URL = null;
  let STATE_POLL_TIMER = null;
  let LAST_STATE_JSON = '';

  function getQueryParams(search = window.location.search) {
    const s = String(search || '').trim();
    const out = new Map();
    if (!s || s === '?') return out;
    const q = (s[0] === '?') ? s.slice(1) : s;
    for (const part of q.split('&')) {
      if (!part) continue;
      const [kRaw, vRaw] = part.split('=');
      const k = decodeURIComponent((kRaw || '').replaceAll('+', ' ')).trim();
      const v = decodeURIComponent((vRaw || '').replaceAll('+', ' ')).trim();
      if (k) out.set(k, v);
    }
    return out;
  }

  function resolveBattleIdFromUrl() {
    const qp = getQueryParams();
    const bid = (
      qp.get('battle_id') ||
      qp.get('battleId') ||
      qp.get('battle') ||
      qp.get('id') ||
      ''
    ).trim();
    return bid || null;
  }

  function resolveStateUrl() {
    const qp = getQueryParams();
    const fromQuery = qp.get('stateUrl') || qp.get('state_url') || qp.get('state') || '';
    const fromWindow = (window && window.BATTLE_STATE_URL) ? String(window.BATTLE_STATE_URL) : '';
    const url = (fromQuery || fromWindow || '').trim();
    if (url) return url;

    // Canonical site routing: /play/27 -> /app/battlemat?battle_id=27
    // We can auto-derive the API URL from battle_id.
    const battleId = resolveBattleIdFromUrl();
    if (battleId) return `/api/battles/${encodeURIComponent(battleId)}`;

    return null;
  }

  function resolvePollMs() {
    const qp = getQueryParams();
    const qv = qp.get('pollMs') || qp.get('poll_ms') || '';
    const wv = (window && window.BATTLE_STATE_POLL_MS != null) ? String(window.BATTLE_STATE_POLL_MS) : '';
    const raw = (qv || wv || '').trim();
    if (raw === '') return DEFAULT_POLL_MS;
    const n = Number(raw);
    if (!Number.isFinite(n)) return DEFAULT_POLL_MS;
    return Math.max(0, Math.floor(n));
  }

  async function fetchStateOnce(url) {
    const u = String(url || '').trim();
    if (!u) return null;

    // Cache-bust so you can serve plain JSON from static hosting or through proxies.
    const sep = u.includes('?') ? '&' : '?';
    const fetchUrl = u + sep + '_ts=' + Date.now();

    const res = await fetch(fetchUrl, {
      method: 'GET',
      cache: 'no-store',
      headers: { 'Accept': 'application/json' },
    });

    if (!res.ok) throw new Error('State fetch failed: ' + res.status + ' ' + res.statusText);

    const txt = await res.text();
    const jsonText = txt.trim();
    if (!jsonText) throw new Error('State fetch returned empty body');

    let parsedOuter;
    try { parsedOuter = JSON.parse(jsonText); }
    catch (e) {
      throw new Error('State fetch returned non-JSON: ' + (e && e.message ? e.message : String(e)));
    }

    // Common DB shape: { ..., state_json: "{...}" }
    if (parsedOuter && typeof parsedOuter === 'object' && parsedOuter.state_json != null) {
      const sj = parsedOuter.state_json;

      if (typeof sj === 'string') {
        const sjText = sj.trim();
        if (!sjText) throw new Error('Battle record has empty state_json');

        let parsedState;
        try { parsedState = JSON.parse(sjText); }
        catch (e) {
          throw new Error('Battle record has invalid state_json JSON: ' + (e && e.message ? e.message : String(e)));
        }

        // Use state_json text for change detection (avoids redrawing if other DB fields change).
        return { parsed: parsedState, jsonText: sjText };
      }

      // state_json provided as object already
      try {
        const stable = JSON.stringify(sj);
        return { parsed: sj, jsonText: stable };
      } catch {
        // Fallback: if it can't stringify, still apply it
        return { parsed: sj, jsonText: '[[state_json_object]]' };
      }
    }

    // If the endpoint returns the scene JSON directly.
    return { parsed: parsedOuter, jsonText };
  }

  function applyFetchedState(parsed, jsonText) {
    CURRENT_STATE = parsed;
    LAST_STATE_JSON = String(jsonText || '');

    // If the DB state specifies a floor/camera, apply it.
    try {
      const st = CURRENT_STATE;
      const floors = getFloorsFromState(st);
      const fid = pickActiveFloorId(st, floors);
      VIEW.floorId = fid;

      const camHex = st && st.view && st.view.camera_hex ? String(st.view.camera_hex) : null;
      if (camHex) {
        const p = parseHexId(camHex);
        VIEW.camera.col = p.col;
        VIEW.camera.row = p.row;
      }
    } catch {}
  }

  async function pollStateLoop() {
    if (!STATE_URL) return;

    try {
      const got = await fetchStateOnce(STATE_URL);
      if (!got) return;

      // Only apply when the server payload changes.
      if (got.jsonText !== LAST_STATE_JSON) {
        applyFetchedState(got.parsed, got.jsonText);
        safeRedraw();
      }
    } catch (e) {
      console.warn('[Battlemat] state poll error:', e);
      // Show last error in UI, but don't spam.
      if (elError) {
        elError.hidden = false;
        elError.textContent = 'State fetch error:' + String.fromCharCode(10) + String(e && e.stack ? e.stack : e);
      }
    }
  }

  function startStatePolling() {
    const pollMs = resolvePollMs();
    if (!STATE_URL) return;

    // Always do one immediate fetch.
    pollStateLoop();

    if (pollMs <= 0) return;
    if (STATE_POLL_TIMER) clearInterval(STATE_POLL_TIMER);
    STATE_POLL_TIMER = setInterval(pollStateLoop, pollMs);
  }

  // ===== Sprites (core, optional) =====
  const SPRITES = {
    basePath: '/assets/sprites/',
    cache: new Map(),
    defs: {
      // Objects
      'bed':         { file: 'bed.png', rotate: 'deg' },
      'bed.double':  { file: 'bed_double.png', rotate: 'deg' },
      'chair':       { file: 'chair.png', rotate: 'deg' },
      'table.round': { file: 'table_round.png', rotate: 'deg' },
      'table.rect':  { file: 'table_rectangle.png', rotate: 'deg' },
      'table.sqr':   { file: 'table_square.png', rotate: 'deg' },
      'chest':       { file: 'chest_closed.png', rotate: 'deg' },
      'hearth':      { file: 'hearth.png', rotate: 'deg' },
      'cooking.hearth': { file: 'cooking_hearth.png', rotate: 'deg' },
      'stairs':      { file: 'stairs.png', rotate: 'deg' },

      // Doors (prefer dot-style kinds, but keep aliases for convenience/compat)
      'door':         { file: 'door_wood.png', rotate: 'none' },
      'door.wood':    { file: 'door_wood.png', rotate: 'none' },
      'door_wood':    { file: 'door_wood.png', rotate: 'none' },

      // Tokens (optional)
      'token.pc':    { file: 'token_pc.png', rotate: 'none' },
      'token.npc':   { file: 'token_npc.png', rotate: 'none' },
    }
  };

  function getSpriteDef(kind) {
    const k = String(kind || '').toLowerCase();
    return SPRITES.defs[k] || null;
  }

  function scheduleSpriteRedraw() {
    // Debounce redraws when multiple images finish loading at once.
    if (scheduleSpriteRedraw._pending) return;
    scheduleSpriteRedraw._pending = true;
    requestAnimationFrame(() => {
      scheduleSpriteRedraw._pending = false;
      if (elSpriteToggle && elSpriteToggle.checked) safeRedraw();
    });
  }

  function loadSprite(file) {
    const f = String(file || '').trim();
    if (!f) return null;

    if (SPRITES.cache.has(f)) return SPRITES.cache.get(f);

    const img = new Image();
    img.decoding = 'async';
    img.addEventListener('load', () => scheduleSpriteRedraw(), { once: true });
    img.addEventListener('error', () => scheduleSpriteRedraw(), { once: true });
    img.src = SPRITES.basePath + f;

    SPRITES.cache.set(f, img);
    return img;
  }

  function drawSprite(img, x, y, w, h, rotRad = 0) {
    // Always preserve sprite aspect ratio ("contain" behavior).
    if (!img || !img.complete || !img.naturalWidth || !img.naturalHeight) return false;

    const iw = img.naturalWidth;
    const ih = img.naturalHeight;
    const s = Math.min(w / iw, h / ih);
    const dw = iw * s;
    const dh = ih * s;

    ctx.save();
    ctx.translate(x, y);
    if (rotRad) ctx.rotate(rotRad);
    ctx.drawImage(img, -dw / 2, -dh / 2, dw, dh);
    ctx.restore();
    return true;
  }

  function drawSpriteContainAnchored(img, x, y, w, h, anchorX = 0.5, anchorY = 0.5) {
    // "Contain" fit, but with a specific anchor point (0..1) inside the drawn sprite.
    if (!img || !img.complete || !img.naturalWidth || !img.naturalHeight) return false;

    const iw = img.naturalWidth;
    const ih = img.naturalHeight;
    const s = Math.min(w / iw, h / ih);
    const dw = iw * s;
    const dh = ih * s;

    const ax = clamp(Number(anchorX), 0, 1);
    const ay = clamp(Number(anchorY), 0, 1);

    ctx.drawImage(img, x - dw * ax, y - dh * ay, dw, dh);
    return true;
  }

  // ===== Repeat textures (optional) =====
  const TEXTURE_DEFS = {
    aliases: {
      wall: { brick: 'stone_brick_red' },
      floor: {
        wood: 'wood_oak',
        stone: 'stone_cobble',
        cobble: 'stone_cobble',
        gravel: 'stone_gravel',
      },
    },

    wall: {
      wood_oak:         { file: 'wood_oak.png',         scale: 0.50 },
      wood_elm:         { file: 'wood_elm.png',         scale: 0.50 },
      wood_dark:        { file: 'wood_dark.png',        scale: 0.50 },

      stone_cobble:     { file: 'stone_cobble.png',     scale: 0.45 },
      stone_gravel:     { file: 'stone_gravel.png',     scale: 0.55 },

      brick_gray:       { file: 'brick_gray.png',       scale: 0.40 },
      brick_red:        { file: 'brick_red.png',        scale: 0.40 },
      brick_dark:       { file: 'brick_dark.png',       scale: 0.40 },

      // Convenience / compatibility
      wood:             { file: 'wood_oak.png',         scale: 0.50 },
      cobble:           { file: 'stone_cobble.png',     scale: 0.45 },
      stone:            { file: 'stone_cobble.png',     scale: 0.45 },
      brick:            { file: 'brick_gray.png',       scale: 0.45 },
    },

    floor: {
      wood_oak:         { file: 'wood_oak.png',         scale: 0.50 },
      wood_elm:         { file: 'wood_elm.png',         scale: 0.50 },
      wood_dark:        { file: 'wood_dark.png',        scale: 0.50 },

      stone_cobble:     { file: 'stone_cobble.png',     scale: 0.45 },
      stone_gravel:     { file: 'stone_gravel.png',     scale: 0.55 },

      brick_gray:       { file: 'brick_gray.png',       scale: 0.40 },
      brick_red:        { file: 'brick_red.png',        scale: 0.40 },
      brick_dark:       { file: 'brick_dark.png',       scale: 0.40 },

      // Convenience / compatibility
      wood:             { file: 'wood_oak.png',         scale: 0.50 },
      cobble:           { file: 'stone_cobble.png',     scale: 0.45 },
      stone:            { file: 'stone_cobble.png',     scale: 0.45 },
      brick:            { file: 'brick_gray.png',       scale: 0.45 },
    }
  };

  function resolveTextureDef(category, kind) {
    const cat = String(category || '').toLowerCase();
    const k0 = String(kind || '').toLowerCase();
    if (!cat || !k0) return null;

    const group = (TEXTURE_DEFS && TEXTURE_DEFS[cat]) ? TEXTURE_DEFS[cat] : null;
    if (!group) return null;

    if (group[k0]) return group[k0];

    const aliases = (TEXTURE_DEFS.aliases && TEXTURE_DEFS.aliases[cat]) ? TEXTURE_DEFS.aliases[cat] : null;
    const aliased = aliases && aliases[k0] ? String(aliases[k0]).toLowerCase() : '';
    if (aliased && group[aliased]) return group[aliased];

    return null;
  }

  const PATTERN_CACHE = new Map();

  const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v));
  const isFiniteNum = (v) => Number.isFinite(Number(v));

  // Snap CSS-space coords to the device-pixel grid to avoid 1px seams at high zoom.
  // VIEW.dpr is devicePixelRatio × supersample, so snapping to 1/VIEW.dpr lines up with the backing store.
  function snapCss(v) {
    const d = Number(VIEW && VIEW.dpr) || 1;
    return Math.round(Number(v) * d) / d;
  }

  function snappedRectFromCenter(centerS, w, h) {
    const x1 = snapCss(centerS.x - w / 2);
    const y1 = snapCss(centerS.y - h / 2);
    const x2 = snapCss(centerS.x + w / 2);
    const y2 = snapCss(centerS.y + h / 2);
    return { x: x1, y: y1, w: Math.max(0, x2 - x1), h: Math.max(0, y2 - y1) };
  }

  // ===== Supersample + Zoom =====
  let SUPERSAMPLE = 1;
  let ZOOM = 1;

  function effectivePatternScale(defScale) {
    // Patterns should zoom with the map so tiles stay visually consistent.
    return clamp((Number(defScale) || 1) * (Number(ZOOM) || 1), 0.02, 10);
  }

  function getRepeatPatternForCtx(targetCtx, tex) {
    const file = (typeof tex === 'string') ? tex : (tex && tex.file);
    const defScale = (tex && typeof tex === 'object' && isFiniteNum(tex.scale)) ? Number(tex.scale) : 1;

    const f = String(file || '').trim();
    if (!f) return null;

    const ctxKey = (targetCtx === wallCtx) ? 'wall' : 'main';
    const effScale = effectivePatternScale(defScale);
    const key = ctxKey + '|' + f + '|s=' + String(effScale.toFixed(4));

    const cached = PATTERN_CACHE.get(key);
    if (cached && cached.pattern) return cached.pattern;

    const img = loadSprite(f);
    if (!img || !img.complete || !img.naturalWidth || !img.naturalHeight) return null;

    const pat = targetCtx.createPattern(img, 'repeat');
    if (!pat) return null;

    if (typeof pat.setTransform === 'function') {
      pat.setTransform(new DOMMatrix([effScale, 0, 0, effScale, 0, 0]));
      PATTERN_CACHE.set(key, { pattern: pat });
      return pat;
    }

    // Fallback: pre-scale into an offscreen tile canvas, then pattern that.
    const tw = Math.max(1, Math.round(img.naturalWidth * effScale));
    const th = Math.max(1, Math.round(img.naturalHeight * effScale));
    const tile = document.createElement('canvas');
    tile.width = tw;
    tile.height = th;
    const tctx = tile.getContext('2d');
    tctx.imageSmoothingEnabled = true;
    try { tctx.imageSmoothingQuality = 'high'; } catch {}
    tctx.drawImage(img, 0, 0, tw, th);

    const pat2 = targetCtx.createPattern(tile, 'repeat');
    if (!pat2) return null;

    PATTERN_CACHE.set(key, { pattern: pat2 });
    return pat2;
  }

  function readSupersample() {
    const raw = localStorage.getItem(STORAGE_SS);
    const v = parseFloat(raw != null ? raw : '1');
    if (!Number.isFinite(v)) return 1;
    return clamp(v, 1, 3);
  }

  function setSupersample(v) {
    const n = clamp(parseFloat(String(v)), 1, 3);
    localStorage.setItem(STORAGE_SS, String(n));
    SUPERSAMPLE = n;
    if (elSsSelect) elSsSelect.value = String(n);
    resize();
  }

  function readZoom() {
    const raw = localStorage.getItem(STORAGE_ZOOM);
    const v = parseFloat(raw != null ? raw : '1');
    if (!Number.isFinite(v)) return 1;
    return clamp(v, 0.60, 2.25);
  }

  function applyZoom() {
    GRID.size = GRID.baseSize * ZOOM;
  }

  function syncZoomUI() {
    const el = document.getElementById('zoomText');
    if (el) el.textContent = Math.round(ZOOM * 100) + '%';
  }

  function setZoom(v, opts = {}) {
    const n = clamp(parseFloat(String(v)), 0.60, 2.25);
    ZOOM = n;
    applyZoom();
    if (opts.persist !== false) localStorage.setItem(STORAGE_ZOOM, String(n));
    syncZoomUI();
    safeRedraw();
  }

  // ===== Canonical state (demo) =====
  const DEFAULT_STATE = {
    meta: { title: 'Cross Keys Inn — Demo (upper + ground)', battleId: 'local', round: 1 },

    pois: [
      { poiNumber: 1, id: 'CrossKeysInn',  name: 'The Cross Keys Inn',  zone: 'Downtown' },
      { poiNumber: 2, id: 'EightBellsInn', name: 'The Eight Bells Inn', zone: 'Downtown' },
    ],

    view: { camera_hex: 'U16', floorId: 'upper' },

    fog: {
      enabled: true,
      mode: 'room',
      visibleRoomIdsByFloor: { upper: [], ground: [] },
      exploredRoomIdsByFloor: { upper: ['Hallway1','Hallway2'], ground: ['Kitchen'] },
      autoCompute: true,
      autoExplore: true,
      maxDepth: 1,
      unseenAlpha: 0.92,
      exploredAlpha: 0.55,
    },

      floors: [
      {
        id: 'upper',
        name: 'Upper',
        rooms: [
          //Closed buildings
          { id:'NextDoor', corners: ['L26','V26','V21','L21'], thickness: 20, floor: { kind: 'fog' }, wall: { kind: 'brick_gray' } },

          //Cross Keys Inn
          { id: 'CrossKeysUpperFloor', buildingId:'CrossKeysInn', corners: ['L21','AJ21','AJ12','L12'], thickness: 15, floor: { kind: 'fog' }, wall: { kind: 'wood_dark' } },
          { id: 'Hallway1', buildingId:'CrossKeysInn', corners: ['AD21','AF21','AF12','AD12'], thickness: 15, floor: { kind: 'wood_oak' }, wall: { kind: 'wood_dark' } },
          { id: 'Hallway2', buildingId:'CrossKeysInn', corners: ['R17','AD17','AD15','R15'], thickness: 15, floor: { kind: 'wood_oak' }, wall: { kind: 'wood_dark' } },
          { id: 'Hallway3', buildingId:'CrossKeysInn', corners: ['P21','R21','R12','P12'], thickness: 15, floor: { kind: 'wood_oak' }, wall: { kind: 'wood_dark' } },
          { id: '1stFloorStairsDown', buildingId:'CrossKeysInn', corners: ['Z21','AD21','AD19','Z19'], thickness: 20, floor: { kind: 'wood_oak' }, wall: { kind: 'wood_dark' } },

          { id: 'Bedroom1', buildingId:'CrossKeysInn', corners: ['L21','P21','P18','L18'], thickness: 15, floor: { kind: 'wood_oak' }, wall: { kind: 'wood_dark' } },
          { id: 'Bedroom2', buildingId:'CrossKeysInn', corners: ['L18','P18','P15','L15'], thickness: 15, floor: { kind: 'wood_oak' }, wall: { kind: 'wood_dark' } },
          { id: 'Bedroom3', buildingId:'CrossKeysInn', corners: ['L15','P15','P12','L12'], thickness: 15, floor: { kind: 'wood_oak' }, wall: { kind: 'wood_dark' } },
          { id: 'Bedroom4', buildingId:'CrossKeysInn', corners: ['R15','X15','X12','R12'], thickness: 15, floor: { kind: 'wood_oak' }, wall: { kind: 'wood_dark' } },
          { id: 'Bedroom5', buildingId:'CrossKeysInn', corners: ['R21','X21','X17','R17'], thickness: 15, floor: { kind: 'wood_oak' }, wall: { kind: 'wood_dark' } },
          { id: 'Bedroom5_Closet', buildingId:'CrossKeysInn', corners: ['X21','Z21','Z19','X19'], thickness: 15, floor: { kind: 'wood_oak' }, wall: { kind: 'wood_dark' } },
          { id: 'Bedroom6', buildingId:'CrossKeysInn', corners: ['X19','AD19','AD17','X17'], thickness: 15, floor: { kind: 'wood_oak' }, wall: { kind: 'wood_dark' } },
          { id: 'Bedroom7', buildingId:'CrossKeysInn', corners: ['X15','AD15','AD12','X12'], thickness: 15, floor: { kind: 'wood_oak' }, wall: { kind: 'wood_dark' } },
          { id: 'Bedroom8', buildingId:'CrossKeysInn', corners: ['AF15','AJ15','AJ12','AF12'], thickness: 15, floor: { kind: 'wood_oak' }, wall: { kind: 'wood_dark' } },
          { id: 'Bedroom9', buildingId:'CrossKeysInn', corners: ['AF19','AJ19','AJ15','AF15'], thickness: 15, floor: { kind: 'wood_oak' }, wall: { kind: 'wood_dark' } },
          { id: 'Bedroom10', buildingId:'CrossKeysInn', corners: ['AF21','AJ21','AJ19','AF19'], thickness: 15, floor: { kind: 'wood_oak' }, wall: { kind: 'wood_dark' } },
        ],
        openings: [
          { id: 'door_room1', kind: 'door.wood', hex: 'P19',  orientation: 'v',  openPct: 1.0, hinge: 'right', swing: 1  },
          { id: 'door_room2', kind: 'door.wood', hex: 'P16',  orientation: 'v',  openPct: 1.0, hinge: 'right', swing: 1 },
          { id: 'door_room3', kind: 'door.wood', hex: 'P13',  orientation: 'v',  openPct: 1.0, hinge: 'right', swing: 1  },
          { id: 'door_room4', kind:'door.wood', hex:'V15', orientation:'h', openPct: 1.0, hinge: 'left', swing: 1 },

          { id: 'door_room5', kind: 'door.wood', hex: 'V17',  orientation: 'h',  openPct: 1.0  },
          { id: 'door_room5_closet', kind: 'door.wood', hex: 'X20',  orientation: 'v',  openPct: 1.0  },
          { id: 'door_room6', kind: 'door.wood', hex: 'AB17', orientation: 'h',  openPct: 1.0  },
          { id: 'door_room7', kind: 'door.wood', hex: 'Z15', orientation: 'h',  openPct: 1.0, hinge: 'right', swing: 1   },
          { id: 'door_room8', kind: 'door.wood', hex: 'AF13', orientation: 'v', hinge: 'left',  openPct: 1.0  },
          { id: 'door_room9', kind: 'door.wood', hex: 'AF17', orientation: 'v',  openPct: 1.0  },
          { id: 'door_room10',kind: 'door.wood', hex: 'AF20', orientation: 'v',  openPct: 1.0  },

          // Portals
          { id:'portal_down_AB20', kind:'portal', hex:'AB20', trigger:'enter', to:{ floorId:'ground', hex:'Z20' } },

          { id:'bedroom1_window1', kind:'window', hex:'L20', orientation:'v' },
          { id:'bedroom1_window2', kind:'window', hex:'L19', orientation:'v' },

          { id:'bedroom2_window1', kind:'window', hex:'L17', orientation:'v' },
          { id:'bedroom2_window2', kind:'window', hex:'L16', orientation:'v' },

          { id:'bedroom3_window1', kind:'window', hex:'L14', orientation:'v' },
          { id:'bedroom3_window2', kind:'window', hex:'L13', orientation:'v' },
          { id:'bedroom3_window3', kind:'window', hex:'M12.5', orientation:'h' },
          { id:'bedroom3_window4', kind:'window', hex:'N12', orientation:'h' },

          { id:'hallway3_window1', kind:'window', hex:'Q12.5', orientation:'h' },

          { id:'bedroom4_window1', kind:'window', hex:'U12.5', orientation:'h' },
          { id:'bedroom4_window2', kind:'window', hex:'V12', orientation:'h' },

          { id:'bedroom5_window1', kind:'window', hex:'Z12', orientation:'h' },
          { id:'bedroom5_window2', kind:'window', hex:'AA12.5', orientation:'h' },

          { id:'hallway1_window1', kind:'window', hex:'AE12.5', orientation:'h' },

          { id:'bedroom8_window1', kind:'window', hex:'AH12', orientation:'h' },

          { id:'thresh_R16',  kind: 'threshold', hex: 'R16',  orientation: 'v', span: 2.4, parent: 'Hallway2' },
          { id:'thresh_AD16', kind:'threshold', hex:'AD16', orientation:'v', span: 2.4, parent:'Hallway2' },
          { id:'thresh_AD20', kind: 'threshold', hex: 'AD20', orientation: 'v', span: 2.4, parent: '1stFloorStairsDown' },
          { id:'thresh_AD20', kind: 'threshold', hex: 'Q12.5', orientation: 'h', span: 2.4, parent: 'Hallway3' },
        ],
        objects: [
          // Bedroom 1
          { id:'room1_bed1', kind: 'bed', hex: 'M21', rotDeg: 0, ox: -0.5, oy: 0.70, spriteScale:2.4 },
          { id:'room1_bed2', kind: 'bed', hex: 'N20', rotDeg: 0, ox: 0.00, oy: -0.17, spriteScale:2.4 },
          { id:'room1_bed3', kind: 'bed', hex: 'O21', rotDeg: 0, ox: +0.5, oy: 0.70, spriteScale:2.4 },
          
          // Bedroom 2
          { id:'room2_bed1', kind: 'bed', hex: 'M18', rotDeg: 270, ox: 0.00, oy: 0.00, spriteScale:2.4 },
          { id:'room2_bed2', kind: 'bed', hex: 'M16', rotDeg: 270, ox: 0.00, oy: 0.00, spriteScale:2.4 },
          
          // Bedroom 3
          { id:'room3_bed1', kind: 'bed', hex: 'M15', rotDeg: 0, ox: -0.50, oy: 0.70, spriteScale:2.4 },
          { id:'room3_bed2', kind: 'bed', hex: 'N14', rotDeg: 0, ox: 0.00, oy: -0.17, spriteScale:2.4 },
          { id:'room3_bed3', kind: 'bed', hex: 'O15', rotDeg: 0, ox: 0.50, oy: 0.70, spriteScale:2.4 },

          // Bedroom 4
          { id:'room4_bed', kind: 'bed.double', hex: 'S14', rotDeg: 270, ox: 0.00, oy: 0.00, spriteScale:2.4 },
          { id:'room4_chair1', kind: 'chair', hex: 'W14', rotDeg: 60, ox: -0.20, oy: 0.00, spriteScale:0.8  },
          { id:'room4_chair2', kind: 'chair', hex: 'W13', rotDeg: 120, ox: -0.20, oy: 0.00, spriteScale:0.8  },
          { id:'room4_chair3', kind: 'chair', hex: 'U13', rotDeg: 240, ox: 0.20, oy: 0.00, spriteScale:0.8  },
          { id:'room4_table', kind: 'table.round', hex: 'V13', wHex: 1.2, hHex: 1.2, rotDeg: 0, spriteScale:1.5 },
          { id:'room4_chest', kind: 'chest', hex: 'S15', rotDeg: 0, ox: 0.00, oy: -0.25, scale: 1.0, spriteScale:0.75 },
          { id:'room4_hearth', kind: 'hearth', hex: 'W15', rotDeg: 0, wHex: 1.1, hHex: 1.1, ox: 0.00, oy: -0.30 },
          { id:'room4_side1', kind: 'table.sqr', hex: 'S13', ox: -1.0, oy: 0.00, rotDeg: 90, spriteScale:0.5 },
          { id:'room4_side2', kind: 'table.sqr', hex: 'S15', ox: -1.0, oy: 0.00, rotDeg: 90, spriteScale:0.5 },

          // Bedroom 5
          { id:'room5_bed', kind: 'bed.double', hex: 'S20', rotDeg: 270, ox: 0.00, oy: 0.00, spriteScale:2.4 },
          { id:'room5_chair1', kind: 'chair', hex: 'W21', rotDeg: 60, ox: -0.20, oy: 0.00, spriteScale:0.8  },
          { id:'room5_chair2', kind: 'chair', hex: 'W20', rotDeg: 120, ox: -0.20, oy: 0.00, spriteScale:0.8  },
          { id:'room5_chair3', kind: 'chair', hex: 'U20', rotDeg: 240, ox: 0.20, oy: 0.00, spriteScale:0.8  },
          { id:'room5_chair4', kind: 'chair', hex: 'U21', rotDeg: 300, ox: 0.20, oy: 0.00, spriteScale:0.8  },
          { id:'room5_table', kind: 'table.round', hex: 'V20', wHex: 1.2, hHex: 1.2, rotDeg: 0, spriteScale:1.5 },
          { id:'room5_chest', kind: 'chest', hex: 'S18', rotDeg: 180, ox: 0.00, oy: 0.25, scale: 1.0, spriteScale:0.75 },
          { id:'room5_hearth', kind: 'hearth', hex: 'X18', rotDeg: 90, wHex: 1.1, hHex: 1.1, ox: -0.56, oy: 0.00 },
          { id:'room5_side1', kind: 'table.sqr', hex: 'S21', ox: -1.0, oy: 0.00, rotDeg: 90, spriteScale:0.5 },
          { id:'room5_side2', kind: 'table.sqr', hex: 'S19', ox: -1.0, oy: 0.00, rotDeg: 90, spriteScale:0.5 },

          // Bedroom 6
          { id:'room6_hearth', kind: 'cooking.hearth', hex: 'X18', wHex: 1.1, hHex: 1.1, rotDeg: 270, ox: 0.94, oy: 0.00 },

          // Bedroom 7
          { id:'room7_bed', kind: 'bed.double', hex: 'AC14', rotDeg: 90, ox: 0.00, oy: 0.00, spriteScale:2.4 },
          { id:'room7_chair1', kind: 'chair', hex: 'AA14', rotDeg: 60, ox: -0.20, oy: 0.00, spriteScale:0.8  },
          { id:'room7_chair3', kind: 'chair', hex: 'Y13', rotDeg: 240, ox: 0.20, oy: 0.00, spriteScale:0.8  },
          { id:'room7_chair4', kind: 'chair', hex: 'Y14', rotDeg: 300, ox: 0.20, oy: 0.00, spriteScale:0.8  },
          { id:'room7_table', kind: 'table.round', hex: 'Z13', wHex: 1.2, hHex: 1.2, rotDeg: 0, spriteScale:1.5 },
          { id:'room7_chest', kind: 'chest', hex: 'AC15', rotDeg: 0, ox: 0.00, oy: -0.25, scale: 1.0, spriteScale:0.75 },
          { id:'room7_hearth', kind: 'hearth', hex: 'Y15', rotDeg: 0, wHex: 1.1, hHex: 1.1, ox: 0.00, oy: -0.30 },
          { id:'room7_side1', kind: 'table.sqr', hex: 'AC13', ox: 1.0, oy: 0.00, rotDeg: 90, spriteScale:0.5 },
          { id:'room7_side2', kind: 'table.sqr', hex: 'AC15', ox: 1.0, oy: 0.00, rotDeg: 90, spriteScale:0.5 },

          // Bedroom 8
          { id:'room8_bed1', kind: 'bed', hex: 'AG15', rotDeg: 0, ox: -0.50, oy: 0.70, spriteScale:2.4 },
          { id:'room8_bed2', kind: 'bed', hex: 'AH14', rotDeg: 0, ox: 0.00, oy: -0.17, spriteScale:2.4 },
          { id:'room8_bed3', kind: 'bed', hex: 'AI15', rotDeg: 0, ox: 0.50, oy: 0.70, spriteScale:2.4 },

          // Bedroom 9
          { id:'room9_bed1', kind: 'bed', hex: 'AI19', rotDeg: 90, ox: 0.00, oy: 0.00, spriteScale:2.4 },
          { id:'room9_bed2', kind: 'bed', hex: 'AI18', rotDeg: 90, ox: 0.00, oy: 0.00, spriteScale:2.4 },
          { id:'room9_bed3', kind: 'bed', hex: 'AI17', rotDeg: 90, ox: 0.00, oy: 0.00, spriteScale:2.4 },
          { id:'room9_bed4', kind: 'bed', hex: 'AI16', rotDeg: 90, ox: 0.00, oy: 0.00, spriteScale:2.4 },

          // Bedroom 10
          { id:'room10_bed1', kind: 'bed', hex: 'AI21', rotDeg: 90, ox: 0.00, oy: 0.00, spriteScale:2.4 },

          { id:'stairs_down', kind:'stairs', hex:'AB20', wHex: 1.0, hHex: 1.09, rotDeg: 270, ox: 0.0, oy: 0.0, spriteScale:4.70 },
        ],
      },
      {
        id: 'ground',
        name: 'Ground',
        rooms: [
          { id: 'CrossKeysGroundFloor', buildingId:'CrossKeysInn', corners: ['M21.5','AJ21','AJ12.5','M13'], thickness: 20, floor: { kind: 'fog' }, wall: { kind: 'brick' } },
          { id: 'Pub', buildingId:'CrossKeysInn', corners: ['M21.5','X21','X12.5','M13'], thickness: 20, floor: { kind: 'wood' }, wall: { kind: 'brick' } },
          { id: 'Kitchen', buildingId:'CrossKeysInn', corners: ['X21','AJ21','AJ12.5','X12.5'], thickness: 20, floor: { kind: 'wood' }, wall: { kind: 'brick' } },
        ],
        openings: [
          { id: 'pub_window1', kind:'window', hex:'M20', orientation:'v' },
          { id: 'pub_window2', kind:'window', hex:'M19', orientation:'v' },
          { id: 'pub_window3', kind:'window', hex:'M15', orientation:'v' },
          { id: 'pub_window4', kind:'window', hex:'M14', orientation:'v' },
          { id: 'pub_window5', kind:'window', hex:'N12.5', orientation:'h' },
          { id: 'pub_window6', kind:'window', hex:'O12', orientation:'h' },
          { id: 'pub_window7', kind:'window', hex:'P12.5', orientation:'h' },
          { id: 'pub_window8', kind:'window', hex:'Z12.5', orientation:'h' },
          { id: 'pub_window9', kind:'window', hex:'AB12.5', orientation:'h' },

          { id: 'kitchen_door', kind:'door', hex:'X14', orientation:'v', openPct: 0 },

          // Portals
          { id: 'portal_up_AA21', kind:'portal', hex:'AA21', trigger:'enter', to:{ floorId:'upper', hex:'AC21' } },
          { id: 'portal_up_AA20', kind:'portal', hex:'AA20', trigger:'enter', to:{ floorId:'upper', hex:'AC20' } },
        ],
        objects: [
          { id: 'pub_table1', kind: 'table.rect', hex: 'O20', wHex: 1.0, hHex: 1.0, rotDeg: 0 },
          { id: 'pub_table1_c1', kind: 'chair', hex: 'P20', rotDeg: 90, ox: 0.00, oy: 0.00, spriteScale:0.75  },
          { id: 'pub_table1_c2', kind: 'chair', hex: 'P19', rotDeg: 90, ox: 0.00, oy: 0.00, spriteScale:0.75  },
          { id: 'pub_table1_c3', kind: 'chair', hex: 'N20', rotDeg: 270, ox: 0.00, oy: 0.00, spriteScale:0.75  },
          { id: 'pub_table1_c4', kind: 'chair', hex: 'N19', rotDeg: 270, ox: 0.00, oy: 0.00, spriteScale:0.75  },

          { id:'Kitchen_hearth', kind: 'cooking.hearth', hex: 'X18', rotDeg: 270, ox: 0.94, oy: 0.00 },
        ],
      }
    ],

    tokens: [
      { id: 'a', name: 'Aelar', side: 'PC', hex: 'U16', label: 'A', init: 14, hp: 42, floorId: 'upper' },
      { id: 'b', name: 'Bran', side: 'PC', hex: 'S16', label: 'B', init: 12, hp: 35, floorId: 'ground' },
      { id: 'g1', name: 'Goblin 1', side: 'NPC', hex: 'U19', label: 'G1', init: 10, hp: 8, floorId: 'upper' },
      { id: 'g2', name: 'Goblin 2', side: 'NPC', hex: 'V19', label: 'G2', init: 10, hp: 8, floorId: 'upper' },
      { id: 'g3', name: 'Goblin 3', side: 'NPC', hex: 'W19', label: 'G3', init: 10, hp: 8, floorId: 'upper' },
    ]
  };
    
  // ===== State access =====
  function getState() {
    // 1) If we have a fetched state, use it.
    if (CURRENT_STATE && typeof CURRENT_STATE === 'object') return CURRENT_STATE;

    // 2) Otherwise fall back to injected state.
    const injected = (window && window.BATTLE_STATE != null) ? window.BATTLE_STATE : null;
    const raw = injected != null ? injected : DEFAULT_STATE;
    if (typeof raw === 'string') {
      try { return JSON.parse(raw); } catch { return DEFAULT_STATE; }
    }
    return raw;
  }

  // ===== Hex id helpers =====
  function colToLetters(col) {
    let n = col + 1;
    let s = '';
    while (n > 0) {
      const r = (n - 1) % 26;
      s = String.fromCharCode(65 + r) + s;
      n = Math.floor((n - 1) / 26);
    }
    return s;
  }

  function lettersToCol(letters) {
    const u = String(letters).toUpperCase();
    let n = 0;
    for (let i = 0; i < u.length; i++) {
      const c = u.charCodeAt(i);
      if (c < 65 || c > 90) throw new Error('Bad column letters');
      n = n * 26 + (c - 64);
    }
    return n - 1;
  }

  function parseHexId(hex) {
    const m = String(hex).trim().toUpperCase().match(/^([A-Z]+)([0-9]+)$/);
    if (!m) throw new Error('Bad hex: ' + hex);
    return { col: lettersToCol(m[1]), row: parseInt(m[2], 10) - 1 };
  }

  function parseHex(hex) {
    try { return parseHexId(hex); } catch { return null; }
  }

  function isHalfStep(n) {
    const v = Number(n);
    if (!Number.isFinite(v)) return false;
    return Math.abs(v * 2 - Math.round(v * 2)) < 1e-6;
  }

  function parseOpeningHexId(hex) {
    const m = String(hex).trim().toUpperCase().match(/^([A-Z]+)([0-9]+(?:\.[0-9]+)?)$/);
    if (!m) throw new Error('Bad opening hex: ' + hex);

    const col = lettersToCol(m[1]);
    const rowNum = parseFloat(m[2]);
    if (!isHalfStep(rowNum)) throw new Error('Opening hex must be .0 or .5: ' + hex);

    return { col, row: rowNum - 1 };
  }

  function parseOpeningHex(hex) {
    try { return parseOpeningHexId(hex); } catch { return null; }
  }

  function parseCornerHexId(hex) {
    const m = String(hex).trim().toUpperCase().match(/^([A-Z]+)([0-9]+(?:\.[0-9]+)?)$/);
    if (!m) throw new Error('Bad corner hex: ' + hex);

    const col = lettersToCol(m[1]);
    const rowNum = parseFloat(m[2]);
    if (!Number.isFinite(rowNum)) throw new Error('Bad corner row: ' + hex);

    return { col, row: rowNum - 1 };
  }

  function hexId(col, row) {
    return colToLetters(col) + String(row + 1);
  }

  // ===== World geometry (flat-top) =====
  function colStep() { return 1.5 * GRID.size; }
  function rowStep() { return sqrt3 * GRID.size; }

  // Row 0 is bottom row ("1"), row increases upward.
  function hexCenterWorld(col, row) {
    const x = col * colStep();
    const y = -(row * rowStep() + (col & 1) * (rowStep() / 2));
    return { x, y };
  }

  // ===== Camera transform =====
  function cameraWorld() { return hexCenterWorld(VIEW.camera.col, VIEW.camera.row); }

  function worldToScreen(p) {
    const cam = cameraWorld();
    return { x: VIEW.anchor.x + (p.x - cam.x) + VIEW.dx, y: VIEW.anchor.y + (p.y - cam.y) + VIEW.dy };
  }

  // ===== Floors (multi-floor) =====
  function getFloorsFromState(state) {
    const f = state && state.floors;
    if (Array.isArray(f)) return f;

    if (f && typeof f === 'object') {
      return Object.entries(f).map(([id, data]) => ({ id, ...(data || {}) }));
    }

    return [{
      id: (state && state.view && (state.view.floorId || state.view.floor_id || state.view.floor)) ? String(state.view.floorId || state.view.floor_id || state.view.floor) : 'floor1',
      name: 'Floor',
      rooms: Array.isArray(state && state.rooms) ? state.rooms : [],
      openings: Array.isArray(state && state.openings) ? state.openings : [],
      objects: Array.isArray(state && state.objects) ? state.objects : [],
    }];
  }

  function pickActiveFloorId(state, floors) {
    const wanted = state && state.view ? (state.view.floorId || state.view.floor_id || state.view.floor || state.view.level) : null;
    const w = wanted != null ? String(wanted) : '';
    if (w && floors.some(f => String(f.id) === w)) return w;
    return floors.length ? String(floors[0].id) : 'floor1';
  }

  function floorById(floors, id) {
    const target = String(id || '');
    return floors.find(f => String(f.id) === target) || null;
  }

  function entityFloorId(e) {
    if (!e || typeof e !== 'object') return '';
    return String(e.floorId || e.floor_id || e.floor || e.level || e.z || '');
  }

  function tokensOnFloor(state, floorId) {
    const all = Array.isArray(state && state.tokens) ? state.tokens : [];
    return all.filter(t => {
      const fid = entityFloorId(t);
      return fid ? fid === String(floorId) : true;
    });
  }

  // ===== Rooms / walls geometry =====
  function roomHasWalls(room) {
    const thick = Number(room && room.thickness != null ? room.thickness : 0);
    const wk = room && room.wall && room.wall.kind ? String(room.wall.kind).toLowerCase() : 'brick';
    return thick > 0 && wk !== 'none';
  }

  function roomToWallBox(room) {
    const corners = Array.isArray(room && room.corners) ? room.corners : [];
    if (corners.length !== 4) throw new Error('Room corners must be [TL, TR, BR, BL]');

    const tl = parseCornerHexId(corners[0]);
    const tr = parseCornerHexId(corners[1]);
    const br = parseCornerHexId(corners[2]);
    const bl = parseCornerHexId(corners[3]);

    const pTL = hexCenterWorld(tl.col, tl.row);
    const pTR = hexCenterWorld(tr.col, tr.row);
    const pBR = hexCenterWorld(br.col, br.row);
    const pBL = hexCenterWorld(bl.col, bl.row);

    const xL = (pTL.x + pBL.x) / 2;
    const xR = (pTR.x + pBR.x) / 2;
    const yTop = (pTL.y + pTR.y) / 2;
    const yBot = (pBL.y + pBR.y) / 2;

    const thicknessBase = Number(room && room.thickness != null ? room.thickness : 20);
    // room.thickness is specified at 100% zoom; scale by ZOOM so walls stay proportional.
    const thickness = thicknessBase * (Number(ZOOM) || 1);

    const t = roomHasWalls(room) ? thickness : 0;

    const half = t / 2;

    const mid = { x1: xL, y1: yTop, x2: xR, y2: yBot };
    const floor = { x1: xL + half, y1: yTop + half, x2: xR - half, y2: yBot - half };

    return { xL, xR, yTop, yBot, thickness: t, mid, floor };
  }

  function roomFloorRectWorld(room, box) {
    const src = (roomHasWalls(room) ? box.floor : box.mid);
    return { x1: src.x1, y1: src.y1, x2: src.x2, y2: src.y2 };
  }

  function buildWallSegments(rooms) {
    const segs = [];
    for (const r of (Array.isArray(rooms) ? rooms : [])) {
      if (!r || !roomHasWalls(r)) continue;
      const box = roomToWallBox(r);
      const t = box.thickness;

      const color = (r && r.color) ? String(r.color) : COLORS.wall;
      const wallKind = (r && r.wall && r.wall.kind) ? String(r.wall.kind).toLowerCase() : 'brick';

      segs.push({ orientation: 'h', y: box.yTop, x1: box.xL, x2: box.xR, thickness: t, color, wallKind });
      segs.push({ orientation: 'h', y: box.yBot, x1: box.xL, x2: box.xR, thickness: t, color, wallKind });
      segs.push({ orientation: 'v', x: box.xL, y1: box.yTop, y2: box.yBot, thickness: t, color, wallKind });
      segs.push({ orientation: 'v', x: box.xR, y1: box.yTop, y2: box.yBot, thickness: t, color, wallKind });
    }
    return segs;
  }

  function findNearestWallSegment(wallSegs, orient, p) {
    const want = (orient === 'h' || orient === 'v') ? orient : 'h';
    let best = null;
    let bestD2 = Infinity;

    for (const s of (Array.isArray(wallSegs) ? wallSegs : [])) {
      if (!s || s.orientation !== want) continue;

      if (want === 'h') {
        const dy = Math.abs((p && p.y) - s.y);
        let dx = 0;
        if ((p && p.x) < s.x1) dx = s.x1 - (p.x);
        else if ((p && p.x) > s.x2) dx = (p.x) - s.x2;
        const d2 = dx * dx + dy * dy;
        if (d2 < bestD2) { bestD2 = d2; best = s; }
      } else {
        const dx = Math.abs((p && p.x) - s.x);
        let dy = 0;
        if ((p && p.y) < s.y1) dy = s.y1 - (p.y);
        else if ((p && p.y) > s.y2) dy = (p.y) - s.y2;
        const d2 = dx * dx + dy * dy;
        if (d2 < bestD2) { bestD2 = d2; best = s; }
      }
    }

    return best;
  }

  function quant01(v) { return Math.round(v * 100) / 100; }

  function dedupeWallSegments(segs) {
    const map = new Map();

    for (const s of (Array.isArray(segs) ? segs : [])) {
      if (!s) continue;
      const o = s.orientation;
      if (o === 'h') {
        const y = quant01(s.y);
        const x1 = quant01(Math.min(s.x1, s.x2));
        const x2 = quant01(Math.max(s.x1, s.x2));
        const key = `h|${y}|${x1}|${x2}`;
        const prev = map.get(key);
        if (!prev) map.set(key, { ...s, y, x1, x2 });
        else prev.thickness = Math.max(prev.thickness, s.thickness);
      } else {
        const x = quant01(s.x);
        const y1 = quant01(Math.min(s.y1, s.y2));
        const y2 = quant01(Math.max(s.y1, s.y2));
        const key = `v|${x}|${y1}|${y2}`;
        const prev = map.get(key);
        if (!prev) map.set(key, { ...s, x, y1, y2 });
        else prev.thickness = Math.max(prev.thickness, s.thickness);
      }
    }

    return [...map.values()];
  }

  function drawWallSegments(targetCtx, wallSegs) {
    const wantTextures = !!(elSpriteToggle && elSpriteToggle.checked);

    for (const s of (Array.isArray(wallSegs) ? wallSegs : [])) {
      if (!s || !s.thickness) continue;

      const t = s.thickness;
      const half = t / 2;

      let fill = s.color || COLORS.wall;
      if (wantTextures) {
        const def = resolveTextureDef('wall', s.wallKind);
        if (def) {
          const pat = getRepeatPatternForCtx(targetCtx, def);
          if (pat) fill = pat;
        }
      }
      targetCtx.fillStyle = fill;

      if (s.orientation === 'h') {
        const x1 = s.x1 - half;
        const x2 = s.x2 + half;
        const y1 = s.y - half;
        const y2 = s.y + half;

        const p1 = worldToScreen({ x: x1, y: y1 });
        const p2 = worldToScreen({ x: x2, y: y2 });
        const w = p2.x - p1.x;
        const h = p2.y - p1.y;
        if (w > 0 && h > 0) targetCtx.fillRect(p1.x, p1.y, w, h);
      } else {
        const x1 = s.x - half;
        const x2 = s.x + half;
        const y1 = s.y1 - half;
        const y2 = s.y2 + half;

        const p1 = worldToScreen({ x: x1, y: y1 });
        const p2 = worldToScreen({ x: x2, y: y2 });
        const w = p2.x - p1.x;
        const h = p2.y - p1.y;
        if (w > 0 && h > 0) targetCtx.fillRect(p1.x, p1.y, w, h);
      }
    }
  }

  // ===== Floor fills =====
  function floorColor(kind) {
    const k = String(kind || 'wood').toLowerCase();
    if (k === 'fog') return COLORS.fogUnseen;
    if (k === 'stone') return COLORS.floorStone;
    if (k === 'cobble') return COLORS.floorCobble;
    if (k.startsWith('stairs')) return COLORS.floorWood;
    return COLORS.floorWood;
  }

  function isFogFloorRoom(room) {
    const k = room && room.floor && room.floor.kind ? String(room.floor.kind).toLowerCase() : '';
    return k === 'fog';
  }

  function drawFloorsLayered(rooms) {
    const wantTextures = !!(elSpriteToggle && elSpriteToggle.checked);

    for (const r of (Array.isArray(rooms) ? rooms : [])) {
      const box = roomToWallBox(r);
      const f = roomFloorRectWorld(r, box);
      const p1 = worldToScreen({ x: f.x1, y: f.y1 });
      const p2 = worldToScreen({ x: f.x2, y: f.y2 });
      const w = p2.x - p1.x;
      const h = p2.y - p1.y;
      if (w <= 0 || h <= 0) continue;

      const fk = (r && r.floor && r.floor.kind) ? String(r.floor.kind).toLowerCase() : 'wood';

      let fill = floorColor(fk);
      if (wantTextures) {
        const def = resolveTextureDef('floor', fk);
        if (def) {
          const pat = getRepeatPatternForCtx(ctx, def);
          if (pat) fill = pat;
        }
      }

      ctx.fillStyle = fill;
      ctx.fillRect(p1.x, p1.y, w, h);
}
  }

  // ===== Openings =====
  function openingOrientation(opening) {
    const o = opening && opening.orientation ? String(opening.orientation).toLowerCase() : 'h';
    if (o === 'v' || o === 'vert' || o === 'vertical') return 'v';
    return 'h';
  }

  function openingSpan(opening) {
    const s = Number(opening && opening.span != null ? opening.span : 1);
    return clamp(Number.isFinite(s) ? s : 1, 0.5, 4);
  }

  function isDoorKind(kind) {
    const k = String(kind || '').toLowerCase();
    return (k === 'door' || k.startsWith('door_') || k.startsWith('door.'));
  }

  // Pixel padding applied to wall cutouts / seam fills.
  // To avoid 1px seams at certain zoom levels, we apply a small buffer.
  // For thresholds, we ONLY buffer in the axis perpendicular to the opening orientation:
  //   - vertical threshold (orientation 'v') => widen horizontally (+4px)
  //   - horizontal threshold (orientation 'h') => widen vertically (+4px)
  // This keeps the threshold span aligned to the parent floor, while still covering subpixel seams.
  function openingPadAxes(opening) {
    const kind = String(opening && opening.kind ? opening.kind : 'door').toLowerCase();
    const orient = openingOrientation(opening);

    // No padding needed for portals (they don't cut walls/floors).
    if (kind === 'portal' || kind === 'connector') return { x: 0, y: 0 };

    // Thresholds: buffer only perpendicular to the opening orientation.
    if (kind === 'threshold') {
      return (orient === 'v') ? { x: 4, y: 0 } : { x: 0, y: 4 };
    }

    // Doors/windows: small buffer in both axes helps hide seams.
    return { x: 4, y: 4 };
  }

  // Opening length in world-units (CSS px). For thresholds, we auto-size to the parent room's
  // interior span so the knockout matches the parent floor space exactly.
  function openingLengthWorld(opening, rooms) {
    const kind = String(opening && opening.kind ? opening.kind : 'door').toLowerCase();
    const orient = openingOrientation(opening);

    if (kind === 'threshold') {
      const parentId = (opening && opening.parent != null) ? String(opening.parent) : '';
      const parent = parentId ? roomById(rooms, parentId) : null;
      if (parent) {
        const box = roomToWallBox(parent);
        const fr = roomFloorRectWorld(parent, box);
        const worldLen = (orient === 'h') ? Math.abs(fr.x2 - fr.x1) : Math.abs(fr.y2 - fr.y1);
        // Guardrails: never return something absurdly tiny.
        return Math.max(worldLen, GRID.size * 0.6);
      }
      // If no parent is provided/found, fall back to span sizing.
    }

    const baseLen = GRID.size * 1.2;
    const span = openingSpan(opening);
    return baseLen * span;
  }

  function cutOpeningHole(targetCtx, opening, wallSegs, rooms) {
    const kind = String(opening && opening.kind ? opening.kind : 'door').toLowerCase();
    if (kind === 'portal' || kind === 'connector') return;

    const orient = openingOrientation(opening);
    const p = parseOpeningHex(opening.hex);
    if (!p) return;

    const hexWorld = hexCenterWorld(p.col, p.row);
    const seg = findNearestWallSegment(wallSegs, orient, hexWorld);

    const len = openingLengthWorld(opening, rooms);

    const cx = hexWorld.x;
    const cy = hexWorld.y;
    const thickness = seg ? seg.thickness : 28;

    const centerS = worldToScreen({ x: cx, y: cy });
    const pad = openingPadAxes(opening);

    // Axis-aligned screen rect (no rotation) so this matches seam fills exactly.
    // Base rect dimensions depend on orientation, then we apply axis-specific padding.
    const baseW = (orient === 'v') ? thickness : len;
    const baseH = (orient === 'v') ? len : thickness;
    const w = baseW + (pad.x || 0);
    const h = baseH + (pad.y || 0);

    const rr = snappedRectFromCenter(centerS, w, h);
    if (rr.w > 0 && rr.h > 0) targetCtx.fillRect(rr.x, rr.y, rr.w, rr.h);
  }

  function drawOpeningMarker(opening, wallSegs) {
    const kind = String(opening && opening.kind ? opening.kind : 'door').toLowerCase();
    if (kind === 'threshold' || kind === 'portal' || kind === 'connector') return;

    const orient = openingOrientation(opening);
    const p = parseOpeningHex(opening.hex);
    if (!p) return;

    const hexWorld = hexCenterWorld(p.col, p.row);
    const seg = findNearestWallSegment(wallSegs, orient, hexWorld);

    const cx = hexWorld.x;
    const cy = hexWorld.y;
    const thickness = seg ? seg.thickness : 28;

    const c = worldToScreen({ x: cx, y: cy });
    const len = (GRID.size * 1.2) * openingSpan(opening);
    const openPct = clamp(Number(opening && opening.openPct != null ? opening.openPct : 0), 0, 1);

    ctx.save();
    ctx.translate(c.x, c.y);
    if (orient === 'v') ctx.rotate(Math.PI / 2);

    if (kind === 'window') {
      ctx.strokeStyle = COLORS.window;
      ctx.globalAlpha = 0.85;
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(-len / 2, 0);
      ctx.lineTo(len / 2, 0);
      ctx.stroke();

      ctx.globalAlpha = 0.45;
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(-len / 2, -thickness * 0.25);
      ctx.lineTo(len / 2, -thickness * 0.25);
      ctx.moveTo(-len / 2, thickness * 0.25);
      ctx.lineTo(len / 2, thickness * 0.25);
      ctx.stroke();

      ctx.restore();
      return;
    }

    // Door sprites (e.g. kind: 'door_wood')
    if (isDoorKind(kind) && (elSpriteToggle && elSpriteToggle.checked)) {
      const def = getSpriteDef(kind);
      if (def) {
        const img = loadSprite(def.file);
        if (img && img.complete && img.naturalWidth && img.naturalHeight) {
          const hingeSide = String(opening && opening.hinge != null ? opening.hinge : 'left').toLowerCase();
          const hingeRight = (hingeSide === 'right' || hingeSide === 'r');

          const rawSwing = Number(opening && (opening.swing ?? opening.swingDir ?? opening.polarity));
          const swingSign = (rawSwing === 1 || rawSwing === -1) ? rawSwing : -1;

          const hingeX = hingeRight ? (len / 2) : (-len / 2);
          const hingeY = 0;

          const leafLen = len * 0.80;
          const boxW = leafLen;
          const boxH = thickness * 1.25;

          // Allow door openings to scale their sprite just like objects do.
          // (e.g. { kind:'door.wood', ..., spriteScale: 1.3 })
          let sx = 1, sy = 1;
          if (isFiniteNum(def.scale)) { sx *= Number(def.scale); sy *= Number(def.scale); }
          if (isFiniteNum(def.scaleX)) sx *= Number(def.scaleX);
          if (isFiniteNum(def.scaleY)) sy *= Number(def.scaleY);
          if (isFiniteNum(opening.spriteScale)) { sx *= Number(opening.spriteScale); sy *= Number(opening.spriteScale); }
          if (isFiniteNum(opening.spriteScaleX)) sx *= Number(opening.spriteScaleX);
          if (isFiniteNum(opening.spriteScaleY)) sy *= Number(opening.spriteScaleY);

          const ang = openPct * (Math.PI / 2);

          ctx.save();
          ctx.translate(hingeX, hingeY);
          ctx.rotate((hingeRight ? -1 : 1) * swingSign * ang);

          const ok = drawSpriteContainAnchored(
            img,
            0,
            0,
            boxW * sx,
            boxH * sy,
            hingeRight ? 1 : 0,
            0.5
          );
          ctx.restore();

          if (ok) {
            ctx.restore();
            return;
          }
        }
      }
    }

    ctx.strokeStyle = COLORS.door;
    ctx.lineWidth = 4;
    ctx.globalAlpha = 0.9;

    if (openPct < 0.05) {
      ctx.beginPath();
      ctx.moveTo(-len / 2, 0);
      ctx.lineTo(len / 2, 0);
      ctx.stroke();
    } else {
      const hingeSide = String(opening && opening.hinge != null ? opening.hinge : 'left').toLowerCase();
      const hingeRight = (hingeSide === 'right' || hingeSide === 'r');

      const rawSwing = Number(opening && (opening.swing ?? opening.swingDir ?? opening.polarity));
      const swingSign = (rawSwing === 1 || rawSwing === -1) ? rawSwing : -1;

      const hingeX = hingeRight ? (len / 2) : (-len / 2);
      const hingeY = 0;

      const leafLen = len * 0.80;
      const ang = openPct * (Math.PI / 2);

      const x2 = hingeX + (hingeRight ? -1 : 1) * leafLen * Math.cos(ang);
      const y2 = hingeY + swingSign * leafLen * Math.sin(ang);

      ctx.beginPath();
      ctx.moveTo(hingeX, hingeY);
      ctx.lineTo(x2, y2);
      ctx.stroke();

      ctx.fillStyle = COLORS.door;
      ctx.globalAlpha = 0.95;
      ctx.beginPath();
      ctx.arc(hingeX, hingeY, 2.2, 0, Math.PI * 2);
      ctx.fill();
    }

    ctx.restore();
  }

  function roomById(rooms, id) {
    const target = String(id || '');
    if (!target) return null;
    return (Array.isArray(rooms) ? rooms : []).find(r => r && String(r.id) === target) || null;
  }

  function roomFloorKind(room) {
    return (room && room.floor && room.floor.kind) ? String(room.floor.kind) : 'wood';
  }

  function floorFillStyle(kind, wantTextures) {
    const fk = String(kind || 'wood').toLowerCase();
    if (!wantTextures) return floorColor(fk);
    const def = resolveTextureDef('floor', fk);
    if (!def) return floorColor(fk);
    const pat = getRepeatPatternForCtx(ctx, def);
    return pat || floorColor(fk);
  }

  function buildRoomMeta(rooms) {
    const meta = new Map();
    for (const r of (Array.isArray(rooms) ? rooms : [])) {
      if (!r || !r.id) continue;
      const box = roomToWallBox(r);
      const f = roomFloorRectWorld(r, box);
      meta.set(String(r.id), { room: r, floorRect: f });
    }
    return meta;
  }

  function roomContainsWorldPoint(roomRect, p) {
    if (!roomRect) return false;
    return (p.x >= roomRect.x1 && p.x <= roomRect.x2 && p.y >= roomRect.y1 && p.y <= roomRect.y2);
  }

  function pickRoomAtWorldPoint(roomMeta, p) {
    let bestId = null;
    let bestArea = Infinity;

    for (const [id, info] of roomMeta.entries()) {
      const r = info.floorRect;
      if (!roomContainsWorldPoint(r, p)) continue;
      const area = Math.abs((r.x2 - r.x1) * (r.y2 - r.y1));
      if (area < bestArea) { bestArea = area; bestId = id; }
    }

    return bestId;
  }

  function openingRoomIds(opening, roomMeta) {
    const orient = openingOrientation(opening);
    const p = parseOpeningHex(opening.hex);
    if (!p) return [];

    const hw = hexCenterWorld(p.col, p.row);

    // NOTE: this is only used to derive thickness for sampling.
    const seg = findNearestWallSegment(buildWallSegments([...roomMeta.values()].map(v => v.room)), orient, hw);

    let cx = hw.x, cy = hw.y;
    let thickness = 28;
    if (seg) thickness = seg.thickness;

    const eps = Math.max(6, thickness * 0.6);
    const samples = (orient === 'h')
      ? [{ x: cx, y: cy - eps }, { x: cx, y: cy + eps }]
      : [{ x: cx - eps, y: cy }, { x: cx + eps, y: cy }];

    const ids = new Set();
    for (const s of samples) {
      const id = pickRoomAtWorldPoint(roomMeta, s);
      if (id) ids.add(id);
    }
    return [...ids];
  }

  let RENDER_FOG = null;

  function openingPreferredRoomId(opening, rooms) {
    const parentId = opening && opening.parent ? String(opening.parent) : '';
    if (parentId) return parentId;

    const roomMetaAll = buildRoomMeta(rooms);
    const ids = openingRoomIds(opening, roomMetaAll);
    if (!ids.length) return '';

    if (RENDER_FOG && RENDER_FOG.enabled) {
      for (const id of ids) if (RENDER_FOG.visible && RENDER_FOG.visible.has(id)) return id;
      for (const id of ids) if (RENDER_FOG.explored && RENDER_FOG.explored.has(id)) return id;
    }
    return String(ids[0] || '');
  }

  function openingKnockoutFill(opening, rooms, fogEnabled, wantTextures) {
    const rid = openingPreferredRoomId(opening, rooms);
    const room = rid ? roomById(rooms, rid) : null;
    const fk = room ? roomFloorKind(room) : 'wood';

    if (!fogEnabled) return floorFillStyle(fk, wantTextures);

    if (RENDER_FOG && RENDER_FOG.enabled && rid && RENDER_FOG.visible && RENDER_FOG.visible.has(rid)) {
      return floorFillStyle(fk, wantTextures);
    }
    return floorColor('fog');
  }

  function drawOpeningSeamFills(openings, rooms, wallSegs, fogEnabled) {
    const wantTextures = !!(elSpriteToggle && elSpriteToggle.checked);

    for (const o of (Array.isArray(openings) ? openings : [])) {
      const kind = String(o && o.kind ? o.kind : '').toLowerCase();
      const isDoor = isDoorKind(kind);
      if (kind !== 'threshold' && !isDoor && kind !== 'portal') continue;

      const orient = openingOrientation(o);
      const p = parseOpeningHex(o.hex);
      if (!p) continue;

      const hexWorld = hexCenterWorld(p.col, p.row);
      const seg = findNearestWallSegment(wallSegs, orient, hexWorld);

      const len = openingLengthWorld(o, rooms);

      const cx = hexWorld.x;
      const cy = hexWorld.y;
      const thickness = seg ? seg.thickness : 28;

      const centerS = worldToScreen({ x: cx, y: cy });
      const pad = openingPadAxes(o);

      // Axis-aligned screen-space rect so patterns stay aligned with the floor.
      const baseW = (orient === 'v') ? thickness : len;
      const baseH = (orient === 'v') ? len : thickness;
      const w = baseW + (pad.x || 0);
      const h = baseH + (pad.y || 0);

      ctx.save();
      ctx.fillStyle = openingKnockoutFill(o, rooms, fogEnabled, wantTextures);
      const rr = snappedRectFromCenter(centerS, w, h);
      ctx.fillRect(rr.x, rr.y, rr.w, rr.h);
      ctx.restore();
    }
  }

  // ===== Fog (room-based, per-floor) =====
  function normalizeFog(state, floorId) {
    const raw = (state && state.fog && typeof state.fog === 'object') ? state.fog : {};

    const enabled = !!raw.enabled;
    const autoCompute = raw.autoCompute !== false;
    const autoExplore = raw.autoExplore !== false;
    const maxDepth = clamp(Number.isFinite(Number(raw.maxDepth)) ? Number(raw.maxDepth) : 1, 0, 12);

    const unseenAlpha = clamp(Number.isFinite(Number(raw.unseenAlpha)) ? Number(raw.unseenAlpha) : 0.92, 0, 1);
    const exploredAlpha = clamp(Number.isFinite(Number(raw.exploredAlpha)) ? Number(raw.exploredAlpha) : 0.55, 0, 1);

    const perVis = (raw.visibleRoomIdsByFloor && typeof raw.visibleRoomIdsByFloor === 'object') ? raw.visibleRoomIdsByFloor : null;
    const perExp = (raw.exploredRoomIdsByFloor && typeof raw.exploredRoomIdsByFloor === 'object') ? raw.exploredRoomIdsByFloor : null;

    const getVis = () => {
      if (perVis) return Array.isArray(perVis[floorId]) ? perVis[floorId] : [];
      return Array.isArray(raw.visibleRoomIds) ? raw.visibleRoomIds : [];
    };

    const getExp = () => {
      if (perExp) return Array.isArray(perExp[floorId]) ? perExp[floorId] : [];
      return Array.isArray(raw.exploredRoomIds) ? raw.exploredRoomIds : [];
    };

    const setVis = (ids) => {
      if (perVis) perVis[floorId] = ids;
      else raw.visibleRoomIds = ids;
    };

    const setExp = (ids) => {
      if (perExp) perExp[floorId] = ids;
      else raw.exploredRoomIds = ids;
    };

    return {
      enabled,
      autoCompute,
      autoExplore,
      maxDepth,
      unseenAlpha,
      exploredAlpha,
      get visibleRoomIds() { return getVis(); },
      get exploredRoomIds() { return getExp(); },
      setVisibleRoomIds: setVis,
      setExploredRoomIds: setExp,
    };
  }

  function isPlayerToken(t) {
    return String(t && t.side ? t.side : '').toUpperCase() === 'PC';
  }

  function computeRenderFog(state, floorId, rooms, openings, tokens) {
    const fog = normalizeFog(state, floorId);
    if (!fog.enabled) return null;

    const roomMeta = buildRoomMeta(rooms);

    const explored = new Set((fog.exploredRoomIds || []).map(String));
    const visible = new Set((fog.visibleRoomIds || []).map(String));

    if (!fog.autoCompute) {
      return { enabled: true, explored, visible, maxDepth: fog.maxDepth, exploredAlpha: fog.exploredAlpha, unseenAlpha: fog.unseenAlpha };
    }

    const pcs = (Array.isArray(tokens) ? tokens : []).filter(isPlayerToken);
    const start = new Set();
    for (const t of pcs) {
      const hp = parseHex(t.hex);
      if (!hp) continue;
      const world = hexCenterWorld(hp.col, hp.row);
      const rid = pickRoomAtWorldPoint(roomMeta, world);
      if (rid) start.add(rid);
    }

    const adj = new Map();
    const addEdge = (a, b) => {
      if (!a || !b || a === b) return;
      if (!adj.has(a)) adj.set(a, new Set());
      if (!adj.has(b)) adj.set(b, new Set());
      adj.get(a).add(b);
      adj.get(b).add(a);
    };

    for (const o of (Array.isArray(openings) ? openings : [])) {
      const k = String(o && o.kind ? o.kind : 'door').toLowerCase();
      if (k === 'portal' || k === 'connector') continue;

      const openPct = clamp(Number(o && o.openPct != null ? o.openPct : 0), 0, 1);
      const isOpenForSight = (k === 'threshold') || (k === 'window') || (isDoorKind(k) && openPct >= 0.5);
      if (!isOpenForSight) continue;

      const ids = openingRoomIds(o, roomMeta);
      if (ids.length === 2) addEdge(ids[0], ids[1]);
    }

    const q = [];
    const dist = new Map();

    for (const rid of start) {
      q.push(rid);
      dist.set(rid, 0);
    }

    const vis = new Set();
    while (q.length) {
      const cur = q.shift();
      const d = dist.get(cur) || 0;
      vis.add(cur);
      if (d >= fog.maxDepth) continue;
      const ns = adj.get(cur);
      if (!ns) continue;
      for (const n of ns) {
        if (!dist.has(n)) {
          dist.set(n, d + 1);
          q.push(n);
        }
      }
    }

    if (fog.autoExplore) {
      for (const rid of vis) explored.add(rid);
      fog.setExploredRoomIds([...explored]);
    }

    fog.setVisibleRoomIds([...vis]);

    return { enabled: true, explored, visible: vis, maxDepth: fog.maxDepth, exploredAlpha: fog.exploredAlpha, unseenAlpha: fog.unseenAlpha };
  }

  function drawRememberedRoomOverlays(rooms) {
    if (!RENDER_FOG || !RENDER_FOG.enabled) return;

    ctx.save();
    ctx.globalAlpha = RENDER_FOG.exploredAlpha;
    ctx.fillStyle = COLORS.fogExplored;

    for (const r of (Array.isArray(rooms) ? rooms : [])) {
      if (!r || !r.id) continue;
      if (isFogFloorRoom(r)) continue;

      const id = String(r.id);
      if (!RENDER_FOG.explored.has(id)) continue;
      if (RENDER_FOG.visible.has(id)) continue;

      const box = roomToWallBox(r);
      const f = roomFloorRectWorld(r, box);
      const p1 = worldToScreen({ x: f.x1, y: f.y1 });
      const p2 = worldToScreen({ x: f.x2, y: f.y2 });
      const w = p2.x - p1.x;
      const h = p2.y - p1.y;
      if (w > 0 && h > 0) ctx.fillRect(p1.x, p1.y, w, h);
    }

    ctx.restore();
  }

  // ===== Objects / tokens orientation =====
  function degToRad(deg) { return (deg * Math.PI) / 180; }

  function facingToDeg(facing) {
    const f = String(facing || '').toUpperCase();
    const map = { N:0, NE:60, E:90, SE:120, S:180, SW:240, W:270, NW:300 };
    return map[f] != null ? map[f] : 0;
  }

  function objectRotationRad(o) {
    if (!o) return 0;
    if (Number.isFinite(o.rotDeg)) return degToRad(Number(o.rotDeg));
    if (Number.isFinite(o.deg)) return degToRad(Number(o.deg));
    if (Number.isFinite(o.rot)) return degToRad(Number(o.rot));
    if (o.facing) return degToRad(facingToDeg(o.facing));
    if (o.orientation && typeof o.orientation === 'number') return degToRad(o.orientation);
    if (o.head) return degToRad(facingToDeg(o.head));
    return 0;
  }

  function objectCenterWorld(o) {
    const p = parseHex(o && o.hex);
    if (!p) return null;

    const base = hexCenterWorld(p.col, p.row);

    const ox = Number.isFinite(Number(o && (o.ox ?? o.offsetX ?? o.xOffset ?? o.dx))) ? Number(o.ox ?? o.offsetX ?? o.xOffset ?? o.dx) : 0;
    const oy = Number.isFinite(Number(o && (o.oy ?? o.offsetY ?? o.yOffset ?? o.dy))) ? Number(o.oy ?? o.offsetY ?? o.yOffset ?? o.dy) : 0;

    return { x: base.x + ox * GRID.size, y: base.y + oy * GRID.size };
  }

  function objectCenterScreen(o) {
    const w = objectCenterWorld(o);
    if (!w) return null;
    return worldToScreen(w);
  }

  function objectSizePx(o) {
    const base = GRID.size * 1.15;

    const wHex = Number.isFinite(Number(o && o.wHex)) ? Number(o.wHex) : 1;
    const hHex = Number.isFinite(Number(o && o.hHex)) ? Number(o.hHex) : 1;
    const scale = Number.isFinite(Number(o && o.scale)) ? Number(o.scale) : 1;

    const kind = String(o && o.kind ? o.kind : '').toLowerCase();
    const kindMul = (kind === 'cooking.hearth') ? 2.2 : 1.0;

    return { w: base * wHex * scale * kindMul, h: base * hHex * scale * kindMul };
  }

  function objectVisible(o, roomMetaAll) {
    if (!RENDER_FOG || !RENDER_FOG.enabled) return true;

    const kind = String(o && o.kind ? o.kind : '').toLowerCase();

    const w = objectCenterWorld(o);
    if (!w) return true;

    const rid = pickRoomAtWorldPoint(roomMetaAll, w);
    if (!rid) return true;

    if (kind === 'hearth' || kind === 'cooking.hearth') return RENDER_FOG.explored.has(rid) || RENDER_FOG.visible.has(rid);

    return RENDER_FOG.visible.has(rid) || RENDER_FOG.explored.has(rid);
  }

  function roundRectPath(targetCtx, x, y, w, h, r) {
    const rr = Math.max(0, Math.min(r, Math.min(Math.abs(w), Math.abs(h)) / 2));
    targetCtx.beginPath();
    targetCtx.moveTo(x + rr, y);
    targetCtx.lineTo(x + w - rr, y);
    targetCtx.quadraticCurveTo(x + w, y, x + w, y + rr);
    targetCtx.lineTo(x + w, y + h - rr);
    targetCtx.quadraticCurveTo(x + w, y + h, x + w - rr, y + h);
    targetCtx.lineTo(x + rr, y + h);
    targetCtx.quadraticCurveTo(x, y + h, x, y + h - rr);
    targetCtx.lineTo(x, y + rr);
    targetCtx.quadraticCurveTo(x, y, x + rr, y);
    targetCtx.closePath();
  }

  function drawObject(o, roomMetaAll) {
    if (!o) return;
    if (!objectVisible(o, roomMetaAll)) return;

    const c = objectCenterScreen(o);
    if (!c) return;

    const { w, h } = objectSizePx(o);
    const rot = objectRotationRad(o);

    const kind = String(o.kind || 'object').toLowerCase();

    if (elSpriteToggle && elSpriteToggle.checked) {
      const def = getSpriteDef(kind);
      if (def) {
        const img = loadSprite(def.file);

        let sx = 1, sy = 1;
        if (isFiniteNum(def.scale)) { sx = Number(def.scale); sy = Number(def.scale); }
        if (isFiniteNum(def.scaleX)) sx = Number(def.scaleX);
        if (isFiniteNum(def.scaleY)) sy = Number(def.scaleY);

        if (isFiniteNum(o.spriteScale)) { sx *= Number(o.spriteScale); sy *= Number(o.spriteScale); }
        if (isFiniteNum(o.spriteScaleX)) sx *= Number(o.spriteScaleX);
        if (isFiniteNum(o.spriteScaleY)) sy *= Number(o.spriteScaleY);

        const ok = drawSprite(img, c.x, c.y, w * sx, h * sy, def.rotate === 'deg' ? rot : 0);
        if (ok) return;
      }
    }

    ctx.save();
    ctx.translate(c.x, c.y);
    if (rot) ctx.rotate(rot);

    ctx.fillStyle = 'rgba(255,255,255,0.08)';
    ctx.strokeStyle = 'rgba(0,0,0,0.25)';
    ctx.lineWidth = 1;

    if (kind === 'stairs') {
      const rw = w * 2;
      const rh = h * 4;
      const topW = rw * 0.4;

      ctx.fillStyle = COLORS.stairsWood;
      ctx.beginPath();
      ctx.moveTo(-rw/2,  rh/2);
      ctx.lineTo( rw/2,  rh/2);
      ctx.lineTo( topW/2, -rh/2);
      ctx.lineTo(-topW/2, -rh/2);
      ctx.closePath();
      ctx.fill();

    } else if (kind === 'chest') {
      const rw = w * 0.90, rh = h * 0.70;

      ctx.fillStyle = COLORS.chestWood;
      ctx.strokeStyle = 'rgba(0,0,0,0.22)';
      ctx.lineWidth = 1;

      roundRectPath(ctx, -rw/2, -rh/2, rw, rh, Math.min(10, rh/3));
      ctx.fill();
      ctx.stroke();

      ctx.strokeStyle = 'rgba(0,0,0,0.32)';
      ctx.lineWidth = 2;
      const slats = 4;
      for (let i = 1; i < slats; i++) {
        const x = -rw/2 + (rw * i)/slats;
        ctx.beginPath();
        ctx.moveTo(x, -rh/2);
        ctx.lineTo(x, rh/2);
        ctx.stroke();
      }

    } else if (kind === 'hearth' || kind === 'cooking.hearth') {
      const rw = w * 1.15;
      const rh = h * 0.55;
      ctx.fillStyle = COLORS.hearth;
      ctx.fillRect(-rw/2, -rh/2, rw, rh);

    } else if (kind === 'bed' || kind === 'bed.double') {
      const isDouble = (kind === 'bed.double');
      const BOOST = 2.0;
      const widthMul = isDouble ? 1.3 : 0.75;

      const rw = w * 0.70 * BOOST * widthMul;
      const rh = h * 0.95 * BOOST;

      ctx.fillStyle = COLORS.bedFabric;
      roundRectPath(ctx, -rw/2, -rh/2, rw, rh, Math.min(18, rw/3));
      ctx.fill();
      ctx.stroke();

      ctx.fillStyle = COLORS.bedPillow;
      const pad = Math.max(6, Math.min(14, Math.min(rw, rh) * 0.08));
      const pillowH = Math.max(10, rh * 0.22);
      const innerW = Math.max(0, rw - pad * 2);

      const pillowRadius = Math.min(14, pillowH * 0.5);
      const drawPillow = (x, y, pw) => {
        roundRectPath(ctx, x, y, pw, pillowH, pillowRadius);
        ctx.fill();
      };

      if (!isDouble) {
        drawPillow(-rw/2 + pad, -rh/2 + pad, innerW);
      } else {
        const gap = Math.max(6, Math.min(14, innerW * 0.06));
        const pw = Math.max(0, (innerW - gap) / 2);
        const x0 = -rw/2 + pad;
        const y0 = -rh/2 + pad;
        drawPillow(x0, y0, pw);
        drawPillow(x0 + pw + gap, y0, pw);
      }

    } else if (kind === 'table.round') {
      const r = Math.min(w, h) * 0.64;
      ctx.fillStyle = COLORS.objectWood;
      ctx.beginPath();
      ctx.arc(0, 0, r, 0, Math.PI * 2);
      ctx.fill();
      ctx.stroke();

    } else if (kind === 'table.sqr' || kind === 'table.square') {
      // Square side-table (used as a non-sprite fallback)
      const s = Math.min(w, h) * 0.75;
      ctx.fillStyle = COLORS.objectWood;
      roundRectPath(ctx, -s/2, -s/2, s, s, Math.min(10, s/5));
      ctx.fill();
      ctx.stroke();

    } else if (kind.startsWith('table')) {
      const rw = w * 0.90, rh = h * 0.55;
      ctx.fillStyle = COLORS.objectWood;
      roundRectPath(ctx, -rw/2, -rh/2, rw, rh, Math.min(10, rh/3));
      ctx.fill();
      ctx.stroke();

    } else if (kind === 'chair') {
      const rw = Math.min(w, h) * 0.65;
      const r = rw / 2;
      const rectH = rw * 0.55;
      const yShift = -(rectH - r) / 2;

      ctx.fillStyle = COLORS.objectWood;
      ctx.beginPath();
      ctx.moveTo(-rw / 2, yShift);
      ctx.arc(0, yShift, r, Math.PI, 0, false);
      ctx.lineTo(rw / 2, yShift + rectH);
      ctx.lineTo(-rw / 2, yShift + rectH);
      ctx.closePath();
      ctx.fill();

    } else {
      const rw = w * 0.80, rh = h * 0.55;
      roundRectPath(ctx, -rw/2, -rh/2, rw, rh, 10);
      ctx.fill();
      ctx.stroke();
    }

    ctx.fillStyle = 'rgba(233,238,247,0.55)';
    ctx.font = '11px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(String(kind).replaceAll('.', ' '), 0, 0);

    ctx.restore();
  }

  // ===== Tokens =====
  function tokenVisible(t, roomMetaAll) {
    if (!RENDER_FOG || !RENDER_FOG.enabled) return true;
    if (isPlayerToken(t)) return true;

    const p = parseHex(t && t.hex);
    if (!p) return true;
    const w = hexCenterWorld(p.col, p.row);
    const rid = pickRoomAtWorldPoint(roomMetaAll, w);
    if (!rid) return true;

    return RENDER_FOG.visible.has(rid);
  }

  function drawTokenLabel(t, x, y, isPC) {
    const label = (t && t.label) ? String(t.label) : (t && t.name ? String(t.name).slice(0, 2) : '?');

    ctx.fillStyle = isPC ? COLORS.tokenTextDark : COLORS.tokenTextLight;
    ctx.font = 'bold 14px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(label, x, y);
  }

  function drawToken(t, roomMetaAll) {
    if (!t || !t.hex) return;
    if (!tokenVisible(t, roomMetaAll)) return;

    const p = parseHexId(t.hex);
    const c = worldToScreen(hexCenterWorld(p.col, p.row));

    const r = GRID.size * 0.40;
    const isPC = isPlayerToken(t);

    if (elSpriteToggle && elSpriteToggle.checked) {
      const def = getSpriteDef(isPC ? 'token.pc' : 'token.npc');
      if (def) {
        const img = loadSprite(def.file);
        const ok = drawSprite(img, c.x, c.y, r * 2.2, r * 2.2, 0);
        if (ok) {
          drawTokenLabel(t, c.x, c.y, isPC);
          return;
        }
      }
    }

    ctx.save();
    ctx.fillStyle = isPC ? COLORS.tokenHero : COLORS.tokenEnemy;
    ctx.beginPath();
    ctx.arc(c.x, c.y, r, 0, Math.PI * 2);
    ctx.fill();

    ctx.strokeStyle = 'rgba(255,255,255,0.15)';
    ctx.lineWidth = 2;
    ctx.stroke();

    drawTokenLabel(t, c.x, c.y, isPC);

    ctx.restore();
  }

  // ===== Grid =====
  function drawHexOutline(center, size) {
    const pts = [];
    for (let i = 0; i < 6; i++) {
      const a = (Math.PI / 180) * (60 * i);
      pts.push({ x: center.x + size * Math.cos(a), y: center.y + size * Math.sin(a) });
    }

    ctx.beginPath();
    ctx.moveTo(pts[0].x, pts[0].y);
    for (let i = 1; i < pts.length; i++) ctx.lineTo(pts[i].x, pts[i].y);
    ctx.closePath();
    ctx.stroke();
  }

  function drawGrid() {
    const rect = canvas.getBoundingClientRect();
    const w = Math.max(1, rect.width);
    const h = Math.max(1, rect.height);

    const colsR = Math.ceil((w / 2) / colStep()) + 4;
    const rowsR = Math.ceil((h / 2) / rowStep()) + 4;

    const c0 = VIEW.camera.col;
    const r0 = VIEW.camera.row;

    ctx.save();
    ctx.strokeStyle = `rgba(255,255,255,${GRID.lineAlpha})`;
    ctx.lineWidth = GRID.lineWidth;

    for (let dc = -colsR; dc <= colsR; dc++) {
      for (let dr = -rowsR; dr <= rowsR; dr++) {
        const col = c0 + dc;
        const row = r0 + dr;
        const p = worldToScreen(hexCenterWorld(col, row));

        if (p.x < -100 || p.x > w + 100 || p.y < -100 || p.y > h + 100) continue;
        drawHexOutline(p, GRID.size);
      }
    }

    const bright = !!(elLabelBoldToggle && elLabelBoldToggle.checked);
    ctx.globalAlpha = bright ? 1 : GRID.labelAlpha;
    ctx.fillStyle = bright ? 'rgba(233,238,247,0.96)' : 'rgba(233,238,247,0.65)';
    ctx.font = bright
      ? '900 14px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial'
      : GRID.labelFont;
    ctx.textAlign = 'left';
    ctx.textBaseline = 'middle';

    if (bright) {
      ctx.lineWidth = 4;
      ctx.strokeStyle = 'rgba(0,0,0,0.70)';
      ctx.lineJoin = 'round';
    }

    for (let dc = -colsR; dc <= colsR; dc++) {
      for (let dr = -rowsR; dr <= rowsR; dr++) {
        const col = c0 + dc;
        const row = r0 + dr;
        const p = worldToScreen(hexCenterWorld(col, row));
        if (p.x < -100 || p.x > w + 100 || p.y < -100 || p.y > h + 100) continue;

        const label = hexId(col, row);
        const lx = p.x - GRID.size * 0.35;
        const ly = p.y + 4;

        if (bright) ctx.strokeText(label, lx, ly);
        ctx.fillText(label, lx, ly);
      }
    }

    ctx.restore();
  }

  // ===== UI rendering =====
  function escapeHtml(s) {
    return String(s)
      .replaceAll('&', '&amp;')
      .replaceAll('<', '&lt;')
      .replaceAll('>', '&gt;')
      .replaceAll('"', '&quot;')
      .replaceAll("'", '&#39;');
  }

  function updateSidebar(state, floor, rooms, openings, objects, tokens) {
    const kvs = document.getElementById('kvs');
    const turns = document.getElementById('turns');
    if (!kvs || !turns) return;

    const meta = state && state.meta ? state.meta : {};
    const round = Number(meta.round != null ? meta.round : 1);

    const camHex = (state && state.view && state.view.camera_hex)
      ? String(state.view.camera_hex)
      : hexId(VIEW.camera.col, VIEW.camera.row);

    const fog = normalizeFog(state, VIEW.floorId);
    const fogLabel = fog.enabled
      ? ('ON (' + fog.visibleRoomIds.length + ' vis / ' + fog.exploredRoomIds.length + ' exp)')
      : 'off';

    const lines = [
      ['Version', VERSION],
      ['Battle', meta.battleId != null ? String(meta.battleId) : ''],
      ['Floor', floor && floor.name ? String(floor.name) : String(VIEW.floorId || '')],
      ['Round', String(round)],
      ['Camera', camHex],
      ['Zoom', Math.round(ZOOM * 100) + '%'],
      ['Rooms', String(rooms.length)],
      ['Openings', String(openings.length)],
      ['Objects', String(objects.length)],
      ['Tokens', String(tokens.length)],
      ['Fog', fogLabel],
      ['Fog maxDepth', String(fog.maxDepth)],
    ];

    kvs.innerHTML = lines
      .map(([k, v]) => '<div>' + escapeHtml(k) + '</div><div style="color:var(--text); text-align:right;">' + escapeHtml(v) + '</div>')
      .join('');

    const sorted = [...tokens]
      .filter(t => t && t.id)
      .sort((a, b) => (Number(b.init) || 0) - (Number(a.init) || 0));

    const activeId = (state && state.turn && state.turn.activeTokenId) ? String(state.turn.activeTokenId) : '';

    turns.innerHTML = sorted.map(t => {
      const isActive = activeId && String(t.id) === activeId;
      const name = t.name ? String(t.name) : String(t.id);
      const right = (t.hp != null) ? ('HP ' + t.hp) : '';
      return '<div class="turnRow' + (isActive ? ' active' : '') + '">' + '<div>' + escapeHtml(name) + ' <span style="opacity:0.65">(' + escapeHtml(String(t.init ?? '')) + ')</span></div>'
        + '<div style="opacity:0.85">' + escapeHtml(right) + '</div>'
        + '</div>';
    }).join('');
  }

  function populateFloorSelect(floors) {
    if (!elFloorSelect) return;

    const opts = floors.map(f => {
      const id = String(f.id);
      const name = f.name ? String(f.name) : id;
      return '<option value="' + escapeHtml(id) + '">' + escapeHtml(name) + '</option>';
    });

    elFloorSelect.innerHTML = opts.join('');
    elFloorSelect.value = String(VIEW.floorId || (floors[0] ? floors[0].id : ''));
  }

  function populateCenterOn(state) {
    if (!elCenterOn) return;

    const tokens = tokensOnFloor(state, VIEW.floorId);
    const pcs = tokens.filter(isPlayerToken);
    const wanted = VIEW.followTokenId || '';

    const opts = ['<option value="">None</option>'];
    for (const t of pcs) {
      const label = t.name ? t.name : t.id;
      opts.push('<option value="' + escapeHtml(t.id) + '">' + escapeHtml(label) + '</option>');
    }

    elCenterOn.innerHTML = opts.join('');
    elCenterOn.value = pcs.some(t => t.id === wanted) ? wanted : '';
    if (elCenterOn.value === '') VIEW.followTokenId = null;
  }

  // ===== Main render =====
  function clear() {
    // Use backing-store derived CSS size so we always cover the full drawable area.
    // This prevents 1px edge seams that can appear on the right/bottom when the
    // layout produces fractional CSS pixels.
    const d = Number(VIEW && VIEW.dpr) || 1;
    const w = Math.max(1, canvas.width / d);
    const h = Math.max(1, canvas.height / d);
    ctx.fillStyle = COLORS.bg;
    ctx.fillRect(0, 0, w, h);
  }

  function redraw() {
    const state = getState();

    if (!canvas.width || !canvas.height || !wallCanvas.width || !wallCanvas.height) return;

    const floors = getFloorsFromState(state);
    const activeFloorId = VIEW.floorId || pickActiveFloorId(state, floors);
    const floor = floorById(floors, activeFloorId) || floors[0];
    VIEW.floorId = floor ? String(floor.id) : activeFloorId;

    const title = (state.meta && state.meta.title) ? String(state.meta.title) : 'Battlemat';
    elTitle.textContent = title;

    if (VIEW.followTokenId) {
      const allTokens = Array.isArray(state.tokens) ? state.tokens : [];
      const t = allTokens.find(x => x && x.id === VIEW.followTokenId);
      if (t && t.hex) {
        const fid = entityFloorId(t) || VIEW.floorId;
        if (fid && fid !== VIEW.floorId) {
          setActiveFloor(fid, { fromFollow: true });
          return;
        }

        const p = parseHexId(t.hex);
        VIEW.camera.col = p.col;
        VIEW.camera.row = p.row;
      } else {
        VIEW.followTokenId = null;
        if (elCenterOn) elCenterOn.value = '';
      }
    }

    const rooms = Array.isArray(floor && floor.rooms) ? floor.rooms : [];
    const openings = Array.isArray(floor && floor.openings) ? floor.openings : [];
    const objects = Array.isArray(floor && floor.objects) ? floor.objects : [];
    const tokens = tokensOnFloor(state, VIEW.floorId);

    const fogEnabled = !!elFogToggle.checked;
    if (state.fog && typeof state.fog === 'object') state.fog.enabled = fogEnabled;

    RENDER_FOG = computeRenderFog(state, VIEW.floorId, rooms, openings, tokens);

    let roomsToDraw = rooms;
    let openingsToDraw = openings;

    if (!fogEnabled) {
      roomsToDraw = rooms.filter(r => !isFogFloorRoom(r));
    }

    if (RENDER_FOG && RENDER_FOG.enabled) {
      const baseFogRoomIds = new Set();
      for (const r of rooms) {
        if (isFogFloorRoom(r) && r && r.id) baseFogRoomIds.add(String(r.id));
      }

      const renderableRoomIds = new Set([...RENDER_FOG.explored]);
      roomsToDraw = rooms.filter(r => {
        const id = r && r.id ? String(r.id) : '';
        if (!id) return true;
        if (baseFogRoomIds.has(id)) return true;
        return renderableRoomIds.has(id);
      });

      const roomMetaAll = buildRoomMeta(rooms);
      openingsToDraw = openings.filter(o => {
        const ids = openingRoomIds(o, roomMetaAll);
        if (ids.length === 2) return (renderableRoomIds.has(ids[0]) || renderableRoomIds.has(ids[1]));
        return true;
      });
    }

    populateFloorSelect(floors);
    populateCenterOn(state);

    clear();

    drawFloorsLayered(roomsToDraw);

    const roomsForWalls = (RENDER_FOG && RENDER_FOG.enabled)
      ? roomsToDraw.filter(r => (isFogFloorRoom(r) ? roomHasWalls(r) : true))
      : roomsToDraw;

    const wallSegsRaw = buildWallSegments(roomsForWalls);
    const wallSegs = dedupeWallSegments(wallSegsRaw);

    // Floor-aware knockout fills for doors/thresholds (so wall openings match the underlying texture)
    drawOpeningSeamFills(openingsToDraw, rooms, wallSegs, fogEnabled);

    wallCtx.save();
    wallCtx.setTransform(1, 0, 0, 1, 0, 0);
    wallCtx.clearRect(0, 0, wallCanvas.width, wallCanvas.height);
    wallCtx.restore();

    wallCtx.setTransform(VIEW.dpr, 0, 0, VIEW.dpr, 0, 0);

    drawWallSegments(wallCtx, wallSegs);

    wallCtx.save();
    wallCtx.globalCompositeOperation = 'destination-out';
    wallCtx.fillStyle = '#000';

    for (const o of openingsToDraw) {
      const k = String(o && o.kind ? o.kind : 'door').toLowerCase();
      wallCtx.globalAlpha = (k === 'window') ? 0.25 : 1;
      cutOpeningHole(wallCtx, o, wallSegs, rooms);
    }

    wallCtx.restore();

    ctx.save();
    ctx.setTransform(1, 0, 0, 1, 0, 0);
    ctx.drawImage(wallCanvas, 0, 0);
    ctx.restore();

    ctx.setTransform(VIEW.dpr, 0, 0, VIEW.dpr, 0, 0);

    for (const o of openingsToDraw) drawOpeningMarker(o, wallSegs);

    const roomMetaAll = buildRoomMeta(rooms);
    for (const o of objects) drawObject(o, roomMetaAll);

    drawRememberedRoomOverlays(rooms);

    for (const t of tokens) drawToken(t, roomMetaAll);

    drawGrid();

    updateSidebar(state, floor, rooms, openings, objects, tokens);

    if (state.view && typeof state.view === 'object') state.view.camera_hex = hexId(VIEW.camera.col, VIEW.camera.row);
  }

  function safeRedraw() {
    try {
      if (elError) { elError.hidden = true; elError.textContent = ''; }
      redraw();
    } catch (e) {
      console.error('[Battlemat] redraw failed:', e);
      if (elError) {
        elError.hidden = false;
        elError.textContent = String(e && e.stack ? e.stack : e);
      }
    }
  }

  // ===== Controls =====
  function pan(dc, dr) {
    if (VIEW.followTokenId) {
      VIEW.followTokenId = null;
      if (elCenterOn) elCenterOn.value = '';
    }
    VIEW.camera.col += dc;
    VIEW.camera.row += dr;
    safeRedraw();
  }

  function setCameraToHex(hex, opts = {}) {
    const manual = (opts.manual !== false);
    const p = parseHexId(hex);
    VIEW.camera.col = p.col;
    VIEW.camera.row = p.row;

    if (manual) {
      VIEW.followTokenId = null;
      if (elCenterOn) elCenterOn.value = '';
    }

    safeRedraw();
  }

  function setActiveFloor(floorId, opts = {}) {
    const state = getState();
    const floors = getFloorsFromState(state);

    const target = String(floorId || '');
    const f = floorById(floors, target);
    if (!f) return;

    VIEW.floorId = target;

    if (state.view && typeof state.view === 'object') state.view.floorId = target;

    if (!opts.fromFollow) {
      const pcs = tokensOnFloor(state, target).filter(isPlayerToken);
      if (pcs.length && pcs[0].hex) {
        try {
          const p = parseHexId(pcs[0].hex);
          VIEW.camera.col = p.col;
          VIEW.camera.row = p.row;
        } catch {}
      }
    }

    safeRedraw();
  }

  function wireUI() {
    const req = (id) => {
      const el = document.getElementById(id);
      if (!el) console.warn('[Battlemat] missing control #' + id);
      return el;
    };

    const btnLeft = req('btnLeft');
    const btnRight = req('btnRight');
    const btnUp = req('btnUp');
    const btnDown = req('btnDown');
    const btnZoomOut = req('btnZoomOut');
    const btnZoomIn = req('btnZoomIn');
    const btnRedraw = req('btnRedraw');
    const btnJump = req('btnJump');

    if (btnLeft) btnLeft.onclick = () => pan(-PAN_STEP, 0);
    if (btnRight) btnRight.onclick = () => pan(PAN_STEP, 0);
    if (btnUp) btnUp.onclick = () => pan(0, PAN_STEP);
    if (btnDown) btnDown.onclick = () => pan(0, -PAN_STEP);

    const ZOOM_STEP = 0.10;
    if (btnZoomOut) btnZoomOut.onclick = () => setZoom(ZOOM - ZOOM_STEP);
    if (btnZoomIn) btnZoomIn.onclick = () => setZoom(ZOOM + ZOOM_STEP);

    if (btnRedraw) btnRedraw.onclick = () => safeRedraw();

    if (btnJump) btnJump.onclick = () => {
      const v = String(elJumpHex.value || '').trim();
      if (!v) return;
      try { setCameraToHex(v, { manual: true }); }
      catch (e) { console.warn('[Battlemat] Bad jump hex:', v, e); }
    };

    if (elFogToggle) elFogToggle.onchange = () => safeRedraw();
    if (elSpriteToggle) elSpriteToggle.onchange = () => safeRedraw();
    if (elLabelBoldToggle) elLabelBoldToggle.onchange = () => safeRedraw();

    if (elFloorSelect) {
      elFloorSelect.onchange = () => setActiveFloor(elFloorSelect.value, { fromFollow: false });
    }

    if (elCenterOn) {
      elCenterOn.onchange = () => {
        const id = String(elCenterOn.value || '');
        VIEW.followTokenId = id || null;
        safeRedraw();
      };
    }

    if (elSsSelect) {
      elSsSelect.onchange = () => setSupersample(elSsSelect.value);
    }

    window.onkeydown = (ev) => {
      if (ev.target && (ev.target.tagName === 'INPUT' || ev.target.tagName === 'SELECT' || ev.target.isContentEditable)) return;
      const k = ev.key;
      if (k === 'ArrowLeft' || k === 'a' || k === 'A') pan(-PAN_STEP, 0);
      else if (k === 'ArrowRight' || k === 'd' || k === 'D') pan(PAN_STEP, 0);
      else if (k === 'ArrowUp' || k === 'w' || k === 'W') pan(0, PAN_STEP);
      else if (k === 'ArrowDown' || k === 's' || k === 'S') pan(0, -PAN_STEP);
      else if (k === 'r' || k === 'R') safeRedraw();
      else if (k === '+' || k === '=' ) setZoom(ZOOM + 0.10);
      else if (k === '-' || k === '_' ) setZoom(ZOOM - 0.10);
    };
  }

  // ===== Resize =====
  function resize() {
    SUPERSAMPLE = readSupersample();
    ZOOM = readZoom();
    applyZoom();
    syncZoomUI();

    const wrap = document.getElementById('canvasWrap');

    // Prefer integer CSS sizes (clientWidth/Height) to avoid fractional px gaps that
    // can show up as a 1px line along the right/bottom edge.
    let cssW = Math.max(1, wrap ? wrap.clientWidth : 1);
    let cssH = Math.max(1, wrap ? wrap.clientHeight : 1);

    // Fallback: if layout is mid-transition and client sizes are 0, use a rounded rect.
    if (wrap && (cssW <= 1 || cssH <= 1)) {
      const rect = wrap.getBoundingClientRect();
      cssW = Math.max(1, Math.round(rect.width));
      cssH = Math.max(1, Math.round(rect.height));
    }

    const dpr = Math.max(1, window.devicePixelRatio || 1);
    const scale = dpr * SUPERSAMPLE;

    VIEW.dpr = scale;
    VIEW.anchor.x = cssW / 2;
    VIEW.anchor.y = cssH / 2;

    if (elDpr) elDpr.textContent = dpr.toFixed(2);
    if (elSs) elSs.textContent = String(SUPERSAMPLE);

    canvas.width = Math.max(1, Math.floor(cssW * scale));
    canvas.height = Math.max(1, Math.floor(cssH * scale));

    wallCanvas.width = canvas.width;
    wallCanvas.height = canvas.height;

    ctx.setTransform(scale, 0, 0, scale, 0, 0);
    wallCtx.setTransform(scale, 0, 0, scale, 0, 0);

    ctx.imageSmoothingEnabled = true;
    try { ctx.imageSmoothingQuality = 'high'; } catch {}

    safeRedraw();
  }

  // ===== Self-tests (tiny sanity checks) =====
  function runSelfTests() {
    const assert = (name, cond) => {
      if (!cond) throw new Error('SelfTest failed: ' + name);
    };

    // half-step openings
    const oh = parseOpeningHexId('M12.5');
    assert('parseOpeningHexId col', oh.col === lettersToCol('M'));
    assert('parseOpeningHexId row', Math.abs(oh.row - 11.5) < 1e-9);

    // integer hex
    const hh = parseHexId('U16');
    assert('parseHexId row', hh.row === 15);

    // corner decimals
    const ch = parseCornerHexId('M21.5');
    assert('parseCornerHexId half row', Math.abs(ch.row - 20.5) < 1e-9);

    // texture alias
    const td = resolveTextureDef('floor', 'wood');
    assert('resolveTextureDef alias', !!td && td.file === 'wood_oak.png');

    // threshold auto-span sizing
    const testRooms = [{
      id: 'TestRoom',
      corners: ['A6', 'D6', 'D3', 'A3'],
      thickness: 20,
      floor: { kind: 'wood' },
      wall: { kind: 'brick' },
    }];
    const testRoom = testRooms[0];
    const box = roomToWallBox(testRoom);
    const fr = roomFloorRectWorld(testRoom, box);

    const thH = { kind: 'threshold', hex: 'B5', orientation: 'h', parent: 'TestRoom' };
    const thV = { kind: 'threshold', hex: 'D4', orientation: 'v', parent: 'TestRoom' };
    assert('openingLengthWorld threshold-h uses parent span', Math.abs(openingLengthWorld(thH, testRooms) - Math.abs(fr.x2 - fr.x1)) < 1e-6);
    assert('openingLengthWorld threshold-v uses parent span', Math.abs(openingLengthWorld(thV, testRooms) - Math.abs(fr.y2 - fr.y1)) < 1e-6);

    const noParent = { kind: 'threshold', hex: 'B5', orientation: 'h', span: 2 };
    assert('openingLengthWorld threshold fallback to span', Math.abs(openingLengthWorld(noParent, testRooms) - (GRID.size * 1.2 * 2)) < 1e-6);

    // opening padding (axis-specific)
    const pV = openingPadAxes({ kind: 'threshold', orientation: 'v' });
    const pH = openingPadAxes({ kind: 'threshold', orientation: 'h' });
    assert('openingPadAxes threshold v pads X only', pV.x === 4 && pV.y === 0);
    assert('openingPadAxes threshold h pads Y only', pH.x === 0 && pH.y === 4);
    const pD = openingPadAxes({ kind: 'door', orientation: 'v' });
    assert('openingPadAxes door pads both axes', pD.x === 4 && pD.y === 4);

    // door kind detection
    assert('isDoorKind door', isDoorKind('door') === true);
    assert('isDoorKind door_wood', isDoorKind('door_wood') === true);
    assert('isDoorKind door.wood', isDoorKind('door.wood') === true);
    assert('isDoorKind door.steel (prefix)', isDoorKind('door.steel') === true);
    assert('isDoorKind window false', isDoorKind('window') === false);

    // door sprite swing direction should match the line-based door math for both hinge sides.
    // Non-sprite math uses: y2 = swingSign * sin(ang) (independent of hinge side), while x flips for hingeRight.
    // For sprite math, we rotate about hinge. Base leaf direction is +X for hinge-left, -X for hinge-right.
    // Using rotAng = (hingeRight ? -1 : 1) * swingSign * ang preserves y2 sign across hinge sides.
    {
      const ang = 0.75; // arbitrary radians
      for (const hingeRight of [false, true]) {
        for (const swingSign of [-1, 1]) {
          const baseX = hingeRight ? -1 : 1;
          const rotAng = (hingeRight ? -1 : 1) * swingSign * ang;
          const ySprite = baseX * Math.sin(rotAng);
          const yLine = swingSign * Math.sin(ang);
          assert('door sprite swing matches line (hingeRight=' + hingeRight + ', swing=' + swingSign + ')', Math.abs(ySprite - yLine) < 1e-12);
        }
      }
    }

    // door sprite scaling (openings)
    const doorDef = getSpriteDef('door.wood');
    const sOpen = { kind: 'door.wood', spriteScale: 1.5, spriteScaleX: 2, spriteScaleY: 0.5 };
    let sx = 1, sy = 1;
    if (doorDef) {
      if (isFiniteNum(doorDef.scale)) { sx *= Number(doorDef.scale); sy *= Number(doorDef.scale); }
      if (isFiniteNum(doorDef.scaleX)) sx *= Number(doorDef.scaleX);
      if (isFiniteNum(doorDef.scaleY)) sy *= Number(doorDef.scaleY);
    }
    if (isFiniteNum(sOpen.spriteScale)) { sx *= Number(sOpen.spriteScale); sy *= Number(sOpen.spriteScale); }
    if (isFiniteNum(sOpen.spriteScaleX)) sx *= Number(sOpen.spriteScaleX);
    if (isFiniteNum(sOpen.spriteScaleY)) sy *= Number(sOpen.spriteScaleY);
    assert('door opening spriteScale combines', Math.abs(sx - (1.5 * 2)) < 1e-12 && Math.abs(sy - (1.5 * 0.5)) < 1e-12);

    // query parsing
    const qp = getQueryParams('?stateUrl=%2Fdata%2Fbattle.json&pollMs=1500');
    assert('getQueryParams stateUrl', qp.get('stateUrl') === '/data/battle.json');
    assert('getQueryParams pollMs', qp.get('pollMs') === '1500');

    // clamp zoom
    assert('clamp zoom low', clamp(0.1, 0.6, 2.25) === 0.6);
    assert('clamp zoom high', clamp(9, 0.6, 2.25) === 2.25);

    // zoom math
    const base = GRID.baseSize;
    const prev = ZOOM;
    ZOOM = 1.35;
    applyZoom();
    assert('applyZoom sets GRID.size', Math.abs(GRID.size - base * 1.35) < 1e-9);
    ZOOM = prev;
    applyZoom();

    // wall thickness scales with zoom
    const prevZ = ZOOM;
    ZOOM = 2;
    const wtRoom = { id: 'WallTest', corners: ['A6','D6','D3','A3'], thickness: 20, floor: { kind: 'wood' }, wall: { kind: 'brick' } };
    const wtBox = roomToWallBox(wtRoom);
    assert('roomToWallBox thickness scales with ZOOM', Math.abs(wtBox.thickness - 40) < 1e-9);
    ZOOM = prevZ;
    applyZoom();

    // snap to device pixels (prevents 1px seams at high zoom)
    const prevDpr = VIEW.dpr;
    VIEW.dpr = 2;
    assert('snapCss rounds to 1/dpr grid', Math.abs(snapCss(1.25) - 1.5) < 1e-12);
    const rr = snappedRectFromCenter({ x: 10.25, y: 9.75 }, 5.1, 3.1);
    // edges should land on 0.5 increments when dpr=2
    assert('snappedRectFromCenter x aligned', Math.abs((rr.x * 2) - Math.round(rr.x * 2)) < 1e-12);
    assert('snappedRectFromCenter y aligned', Math.abs((rr.y * 2) - Math.round(rr.y * 2)) < 1e-12);
    VIEW.dpr = prevDpr;

    // sqrt3 / rowStep math
    assert('sqrt3 constant', Math.abs(sqrt3 - Math.sqrt(3)) < 1e-12);
    const rs = rowStep();
    assert('rowStep uses sqrt3', Math.abs(rs - Math.sqrt(3) * GRID.size) < 1e-9);
  }

  // ===== Boot =====
  function init() {
    const state = getState();
    const floors = getFloorsFromState(state);
    VIEW.floorId = pickActiveFloorId(state, floors);

    // Persisted zoom + SS
    SUPERSAMPLE = readSupersample();
    ZOOM = readZoom();
    applyZoom();
    syncZoomUI();

    const camHex = state && state.view && state.view.camera_hex ? String(state.view.camera_hex) : null;
    if (camHex) {
      try {
        const p = parseHexId(camHex);
        VIEW.camera.col = p.col;
        VIEW.camera.row = p.row;
      } catch {}
    } else {
      const pc = (Array.isArray(state.tokens) ? state.tokens : []).find(isPlayerToken);
      if (pc && pc.hex) {
        try {
          const p = parseHexId(pc.hex);
          VIEW.camera.col = p.col;
          VIEW.camera.row = p.row;
        } catch {}
      }
    }

    if (state.fog && typeof state.fog === 'object') elFogToggle.checked = !!state.fog.enabled;
    elSsSelect.value = String(readSupersample());

    // Run sanity checks early so we fail loudly with a useful message.
    try { runSelfTests(); }
    catch (e) {
      if (elError) {
        elError.hidden = false;
        elError.textContent = String(e && e.stack ? e.stack : e);
      }
      throw e;
    }

    wireUI();

    // Remote state (DB/API) hookup
    STATE_URL = resolveStateUrl();
    if (STATE_URL) startStatePolling();

    const ro = new ResizeObserver(() => resize());
    ro.observe(document.getElementById('canvasWrap'));

    window.addEventListener('resize', resize, { passive: true });

    resize();
    requestAnimationFrame(() => {
      safeRedraw();
      requestAnimationFrame(safeRedraw);
    });
  }

  init();
  </script>
</body>
</html>
