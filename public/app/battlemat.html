<!--
  Version 3.46

  Copyright ¬© 2025 Thomas Delvus. All rights reserved.  

  This HTML document and its contents (including the code, layout, text, data structures, and embedded/linked assets)
  are protected by copyright law.

  Permission is granted to access and use this file for personal, non-commercial tabletop gameplay and reference.

  You may NOT copy, reproduce, modify, translate, redistribute, publish, sell, sublicense, or incorporate this work
  (in whole or in part) into any software product, service, website, platform, ‚Äúsystem,‚Äù template library, dataset,
  or AI/training workflow without prior written permission from the copyright holder.

  Unauthorized use is prohibited.
-->


<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Hex Battlemat</title>
  <style>
    body {
      margin: 0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      background: #f3f3f3;
      color: #111;
    }

    header {
      padding: 10px 14px;
      border-bottom: 1px solid rgba(0,0,0,0.12);
      background: #fff;
      font-weight: 650;
    }

    main {
      padding: 12px;
      display: flex;
      justify-content: center;
      overflow-x: auto;   /* center when possible; allow horizontal scroll on small windows */
      overflow-y: hidden;
    }

    /* Two-column layout: battlemat + right stack */
    .layout {
      display: flex;
      gap: 12px;
      align-items: flex-start;
      margin: 0 auto;
    }

    /* Left column stacks: battlemat + compact key bar */
    .mat-col {
      display: flex;
      flex-direction: column;
      gap: 10px;
      align-items: flex-start;
      flex: 0 0 auto;
    }

    /* Right column: fixed height to match canvas; narration expands */
    aside[aria-label="Right panels"] {
      display: flex;
      flex-direction: column;
      gap: 12px;
      height: 750px; /* match canvas height */
      width: 360px;
      flex: 0 0 360px;
      min-height: 0;
    }

    /* Compact key bar under the battlemat */
    .keybar {
      width: 100%;
      box-sizing: border-box;
      background: #fff;
      border: 1px solid rgba(0,0,0,0.10);
      border-radius: 10px;
      padding: 8px 10px;
      font-size: 0.88rem;
    }

    .keybar-title {
      display: flex;
      justify-content: space-between;
      align-items: baseline;
      gap: 10px;
      margin-bottom: 6px;
    }

    .keybar .legend-swatch {
      width: 18px;
      height: 18px;
      font-size: 10px;
      margin-right: 5px;
    }

    .keybar-list {
      display: flex;
      flex-wrap: wrap;
      gap: 6px 12px;
      list-style: none;
      padding: 0;
      margin: 0;
    }

    .keybar-list li { white-space: nowrap; }

    /* Pane */
    .pane {
      background: #fff;
      border: 1px solid rgba(0,0,0,0.10);
      border-radius: 10px;
      padding: 10px;
      box-sizing: border-box;
      min-height: 0;
    }

    .panel-title {
      display: flex;
      justify-content: space-between;
      align-items: baseline;
      gap: 10px;
      margin-bottom: 8px;
    }

    .panel-title h3 {
      margin: 0;
      font-size: 1rem;
      font-weight: 650;
    }

    .subtle {
      opacity: 0.7;
      font-size: 0.9rem;
      white-space: nowrap;
    }

    .refresh-btn {
      appearance: none;
      border: 1px solid rgba(0,0,0,0.18);
      background: #fff;
      border-radius: 8px;
      padding: 6px 10px;
      font-size: 0.86rem;
      font-weight: 650;
      cursor: pointer;
      line-height: 1;
    }

    .refresh-btn:hover { background: rgba(0,0,0,0.03); }
    .refresh-btn:active { background: rgba(0,0,0,0.06); }
    .refresh-btn:focus { outline: 2px solid rgba(0,0,0,0.25); outline-offset: 2px; }

    .toggle-btn {
      appearance: none;
      border: 1px solid rgba(0,0,0,0.18);
      background: #fff;
      border-radius: 8px;
      padding: 6px 10px;
      font-size: 0.86rem;
      font-weight: 650;
      cursor: pointer;
      line-height: 1;
    }

    .toggle-btn:hover { background: rgba(0,0,0,0.03); }
    .toggle-btn:active { background: rgba(0,0,0,0.06); }
    .toggle-btn:focus { outline: 2px solid rgba(0,0,0,0.25); outline-offset: 2px; }

    .tex-select {
      appearance: none;
      border: 1px solid rgba(0,0,0,0.18);
      background: #fff;
      border-radius: 8px;
      padding: 6px 8px;
      font-size: 0.86rem;
      font-weight: 650;
      cursor: pointer;
      line-height: 1;
    }

    .tex-select:hover { background: rgba(0,0,0,0.03); }
    .tex-select:active { background: rgba(0,0,0,0.06); }
    .tex-select:focus { outline: 2px solid rgba(0,0,0,0.25); outline-offset: 2px; }

    .status-wrap {
      overflow: auto;
      border: 1px solid rgba(0,0,0,0.10);
      border-radius: 10px;
    }

    table {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.92rem;
    }

    thead th {
      position: sticky;
      top: 0;
      background: #f6f6f6;
      text-align: left;
      font-weight: 650;
      padding: 8px 10px;
      border-bottom: 1px solid rgba(0,0,0,0.10);
    }

    tbody td {
      padding: 8px 10px;
      border-bottom: 1px solid rgba(0,0,0,0.08);
      vertical-align: top;
    }

    .chip {
      display: inline-block;
      padding: 2px 8px;
      border-radius: 999px;
      margin: 2px 6px 0 0;
      border: 1px solid rgba(0,0,0,0.12);
      background: #f2f2f2;
      font-size: 0.82rem;
      white-space: nowrap;
    }

    .side-pc  { border-left: 4px solid rgba(80, 160, 220, 0.85); }
    .side-en  { border-left: 4px solid rgba(220, 120, 80, 0.85); }
    .side-npc { border-left: 4px solid rgba(160, 160, 160, 0.85); }

    tr.dead {
      background: rgba(0,0,0,0.04);
      color: rgba(0,0,0,0.55);
    }
    tr.dead .subtle { opacity: 0.5; }
    tr.dead.side-pc,
    tr.dead.side-en,
    tr.dead.side-npc {
      border-left-color: rgba(120,120,120,0.85);
    }

    /* Active turn highlight (Status table) */
    tr.active-turn td {
      border-top: 2px solid rgba(0,0,0,0.85);
      border-bottom: 2px solid rgba(0,0,0,0.85);
      background: rgba(0,0,0,0.03);
    }
    tr.active-turn td:first-child { border-left: 2px solid rgba(0,0,0,0.85); }
    tr.active-turn td:last-child  { border-right: 2px solid rgba(0,0,0,0.85); }

    tr.active-turn.dead td {
      border-color: rgba(0,0,0,0.40);
      background: rgba(0,0,0,0.02);
    }

    .hp {
      font-variant-numeric: tabular-nums;
      white-space: nowrap;
    }

    /* Single-line ‚Äúlast action‚Äù (replaces Math panel) */
    #actionLine {
      margin-top: 10px;
      padding: 8px 10px;
      border: 1px solid rgba(0,0,0,0.10);
      border-radius: 10px;
      background: rgba(0,0,0,0.03);
      font-size: 0.90rem;
      font-weight: 650;
      line-height: 1.2;
      overflow-wrap: anywhere;
    }

    /* Small inline diagnostics (optional) */
    .diag {
      margin-top: 10px;
      padding: 8px 10px;
      border: 1px solid rgba(0,0,0,0.10);
      background: rgba(0,0,0,0.03);
      font-size: 0.85rem;
      line-height: 1.25;
      overflow-wrap: anywhere;
      border-radius: 10px;
    }
    .diag .bad { color: #b00020; font-weight: 650; }
    .diag .ok  { color: #0b6b0b; font-weight: 650; }

    /* Narration grows to fill remaining space */
    #paneNarration {
      flex: 1 1 auto;
      display: flex;
      flex-direction: column;
      min-height: 0;
    }

    #paneNarration textarea {
      flex: 1 1 auto;
      min-height: 140px;
      resize: none;
    }

    textarea {
      width: 100%;
      box-sizing: border-box;
      resize: vertical;
      padding: 8px 10px;
      border: 1px solid rgba(0,0,0,0.18);
      border-radius: 8px;
      background: #fff;
      font: inherit;
      line-height: 1.25;
    }

    textarea.mono {
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    }

    /* Legend swatches */
    .legend-swatch {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 20px;
      height: 20px;
      margin-right: 6px;
      border-radius: 3px;
      vertical-align: middle;
      border: 1px solid rgba(0,0,0,0.6);
      font-size: 11px;
      font-weight: 700;
      color: rgba(0,0,0,0.85);
      line-height: 1;
    }

    .legend-swatch.door { background: #b07a3f; }
    .legend-swatch.window { background: #cfe6f6; }
    .legend-swatch.table { background: #b07a3f; border-radius: 50%; }

    .legend-swatch.hex {
      position: relative;
      z-index: 0;
      border-radius: 0;
      clip-path: polygon(25% 6%, 75% 6%, 100% 50%, 75% 94%, 25% 94%, 0% 50%);
      border: none;
    }

    .legend-swatch.hex::before {
      content: "";
      position: absolute;
      inset: 0;
      background: rgba(0,0,0,0.45);
      clip-path: inherit;
      transform: scale(1.12);
      z-index: -1;
    }

    .legend-swatch.pc { background: rgba(80,160,220,0.95); border-radius: 50%; }
    .legend-swatch.en { background: rgba(220,120,80,0.95); border-radius: 50%; }
  </style>
</head>
<body>
  <header>Hex Battlemat</header>

  <main>
    <div class="layout">
      <div class="mat-col">
        <canvas id="mat" width="940" height="750" aria-label="Hex battlemat"></canvas>

        <!-- Key / Legend (compact, bottom of battlemat) -->
        <section class="keybar" aria-label="Map key">
          <div class="keybar-title">
            <strong>Key</strong>
            <div style="display:flex; align-items:center; gap:8px; flex-wrap:wrap; justify-content:flex-end;">
              <label class="subtle" style="display:flex; align-items:center; gap:6px;">
                Floor
                <select id="floorTexSel" class="tex-select" title="Preview floor texture">
                  <!-- populated by JS -->
                </select>
              </label>
              <label class="subtle" style="display:flex; align-items:center; gap:6px;">
                Wall
                <select id="wallTexSel" class="tex-select" title="Preview wall texture">
                  <!-- populated by JS -->
                </select>
              </label>
              <button id="textureToggleBtn" class="toggle-btn" type="button" title="Toggle textures">Textures: Off</button>
            </div>
          </div>
          <ul class="keybar-list">
            <li><span class="legend-swatch door">D</span> Door</li>
            <li><span class="legend-swatch window">W</span> Window</li>
            <li><span class="legend-swatch table">T</span> Table <span class="subtle">(blocks)</span></li>
            <li><span class="legend-swatch hex">~</span> Difficult</li>
            <li><span class="legend-swatch pc">A</span> Player</li>
            <li><span class="legend-swatch en">W</span> Enemy</li>
          </ul>
        </section>
      </div>

      <aside aria-label="Right panels">
        <!-- Status -->
        <section class="pane" aria-label="Combat status panel">
          <div class="panel-title">
            <h3>Status</h3>
            <div style="display:flex; align-items:center; gap:10px;">
              <div class="subtle" id="roundLine">Round ‚Äî</div>
              <button id="refreshModeBtn" class="refresh-btn" type="button" title="Toggle refresh">Refresh</button>
            </div>
          </div>

          <!-- URL/API diagnostics (helps debug /play/<id> routing). Set DEBUG_DIAG=true to show. -->
          <div class="diag" id="diagBox" aria-label="Diagnostics" style="display:none"></div>

          <div class="status-wrap" aria-label="Status table">
            <table>
              <thead>
                <tr>
                  <th>Actor</th>
                  <th>Init</th>
                  <th>HP</th>
                </tr>
              </thead>
              <tbody id="statusBody"></tbody>
            </table>
          </div>

          <div id="actionLine" aria-label="Last action"></div>
        </section>

        <!-- Narration -->
        <section class="pane" id="paneNarration" aria-label="Narration">
          <div class="panel-title">
            <h3>Narration</h3>
          </div>
          <textarea id="narrationBox" rows="7" placeholder="Scene beats, GM notes, what just happened‚Ä¶"></textarea>
        </section>
      </aside>
    </div>
  </main>

  <!-- ===================== EDIT ONLY THIS BLOCK: SCENE JSON =====================
     - Edit ONLY the JSON inside this tag.
     - Keep it VALID JSON (double quotes, no trailing commas, no comments).
     - If JSON is invalid, the engine will keep showing the last valid scene and print an error.
     ===================== END SCENE JSON =================================== -->
  <script type="application/json" id="scene-json">
{
  "round": 1,
  "lastAction": "üé≤ 16  ‚öîÔ∏è Longsword  ‚Üí  7 dmg",
  "narration": "The crypt is silent but for the soft scrape of bone on stone.\nAelar steps forward, blade raised ‚Äî and the air suddenly turns *cold*.\n\nCaelin: \"I don‚Äôt like this‚Ä¶\"\n\nA shadow shifts near the sarcophagus.",
  "rooms": [
    {
      "id": "room1",
      "corners": ["D11", "N11", "N1", "D1"],
      "thickness": 30,
      "color": "#555",
      "floor": { "kind": "stone" },
      "wall": { "kind": "brick" }
    }
  ],
  "openings": [
    {"id": "win_s_1", "kind": "window", "room": "room1", "wall": "S", "at": "F1", "state": "closed"},
    {"id": "win_s_2", "kind": "window", "room": "room1", "wall": "S", "at": "H1", "state": "closed"},
    {"id": "win_s_3", "kind": "window", "room": "room1", "wall": "S", "at": "J1", "state": "closed"},
    {"id": "win_s_4", "kind": "window", "room": "room1", "wall": "S", "at": "L1", "state": "closed"},

    {"id": "door_e_1", "kind": "door", "room": "room1", "wall": "E", "at": "N6", "state": "closed"},
    {"id": "door_e_2", "kind": "door", "room": "room1", "wall": "E", "at": "N5", "state": "closed"}
  ],
  "objects": [
    {"id": "table1", "kind": "table", "cells": ["I4", "I5", "J5"], "blocks": true, "label": "T"},
    {"id": "sarc1", "kind": "sarcophagus", "cells": ["J8", "K8", "L8"], "blocks": true, "label": "S"},
    {"id": "difficult_1", "kind": "difficult", "cells": ["G2", "H3", "I3"], "blocks": false, "label": "~", "color": "rgba(120,120,120,0.18)"}
  ],
  "actors": [
    {"id": "lich", "name": "Lich", "side": "EN", "init": 15, "hp": 135, "maxHp": 135, "effects": [], "at": "F9", "label": "L"},
    {"id": "wraith1", "name": "Wraith 1", "side": "EN", "init": 12, "hp": 67, "maxHp": 67, "effects": [], "at": "H7", "label": "W1"},
    {"id": "wraith2", "name": "Wraith 2", "side": "EN", "init": 11, "hp": 0, "maxHp": 67, "effects": [], "at": "K9", "label": "W2"},
    {"id": "wraith3", "name": "Wraith 3", "side": "EN", "init": 10, "hp": 67, "maxHp": 67, "effects": [], "at": "E6", "label": "W3"},

    {"id": "pc1", "name": "Aelar", "side": "PC", "init": 14, "hp": 42, "maxHp": 42, "effects": [], "at": "K2", "label": "A"},
    {"id": "pc2", "name": "Brunna", "side": "PC", "init": 13, "hp": 55, "maxHp": 55, "effects": [], "at": "L3", "label": "B"},
    {"id": "pc3", "name": "Caelin", "side": "PC", "init": 12, "hp": 38, "maxHp": 38, "effects": [], "at": "M3", "label": "C"}
  ]
}
  </script>

  <script>
    // =====================================================================
    // DB / API WIRING (safe, minimal) ‚Äî reads /play/<battle_id> and loads state
    // =====================================================================

    function getBattleIdFromUrl() {
      const m = window.location.pathname.match(/^\/play\/([^\/?#]+)/i);
      if (m) return decodeURIComponent(m[1]);
      const u = new URL(window.location.href);
      return u.searchParams.get('battle_id');
    }

    const API_BASE = ''; // same origin

    function battleStateUrl(battleId) {
      return `${API_BASE}/api/battles/${encodeURIComponent(battleId)}`;
    }

    async function saveSceneToApi(battleId, sceneObj) {
      if (!battleId) throw new Error('saveSceneToApi called without battleId');

      const endpoint = battleStateUrl(battleId);
      const res = await fetch(endpoint, {
        method: 'PUT',
        headers: {
          'Accept': 'application/json',
          'Content-Type': 'application/json',
        },
        cache: 'no-store',
        body: JSON.stringify({ state_json: sceneObj })
      });

      const text = await res.text();
      if (!res.ok) throw new Error(`Save failed: HTTP ${res.status} ${res.statusText || ''} :: ${text}`);
      try { return JSON.parse(text); } catch { return { ok: true, raw: text }; }
    }

    function looksLikeScene(obj) {
      if (!obj || typeof obj !== 'object') return false;
      return (
        Array.isArray(obj.rooms) ||
        Array.isArray(obj.actors) ||
        Array.isArray(obj.objects) ||
        Array.isArray(obj.openings) ||
        Array.isArray(obj.poi)
      );
    }

    // Optional diagnostics (hide by default)
    const DEBUG_DIAG = false;
    function setDiag(html) {
      const box = document.getElementById('diagBox');
      if (!box) return;
      if (!DEBUG_DIAG) {
        box.style.display = 'none';
        box.innerHTML = '';
        return;
      }
      box.style.display = 'block';
      box.innerHTML = html;
    }

    async function tryLoadSceneFromApi() {
      const battleId = getBattleIdFromUrl();
      const endpoint = battleId ? battleStateUrl(battleId) : '(no battle_id)';

      setDiag(
        `URL Path: <code>${escapeHtml(window.location.pathname)}</code><br>` +
        `battle_id: <span class="${battleId ? 'ok' : 'bad'}">${escapeHtml(String(battleId || 'NONE'))}</span><br>` +
        `Fetch: <code>${escapeHtml(endpoint)}</code>`
      );

      if (!battleId) {
        const roundLine = document.getElementById('roundLine');
        if (roundLine) roundLine.textContent = 'No battle_id in URL';
        return false;
      }
      try {
        const res = await fetch(endpoint, {
          method: 'GET',
          headers: { 'Accept': 'application/json' },
          cache: 'no-store'
        });

        if (!res.ok) {
          setDiag(
            `URL Path: <code>${escapeHtml(window.location.pathname)}</code><br>` +
            `battle_id: <span class="ok">${escapeHtml(String(battleId))}</span><br>` +
            `Fetch: <code>${escapeHtml(endpoint)}</code><br>` +
            `<span class="bad">HTTP ${escapeHtml(String(res.status))}: ${escapeHtml(res.statusText || 'Error')}</span>`
          );
          return false;
        }

        const data = await res.json();

        let sceneObj = null;
        if (data && typeof data.state_json === 'string') sceneObj = JSON.parse(data.state_json);
        else if (data && typeof data.state === 'object') sceneObj = data.state;
        else if (data && typeof data === 'object') sceneObj = data;

        if (!looksLikeScene(sceneObj)) {
          setDiag(
            `URL Path: <code>${escapeHtml(window.location.pathname)}</code><br>` +
            `battle_id: <span class="ok">${escapeHtml(String(battleId))}</span><br>` +
            `Fetch: <code>${escapeHtml(endpoint)}</code><br>` +
            `<span class="bad">API returned JSON but it does not look like a SCENE. Using embedded default.</span>`
          );
          return false;
        }

        const sceneTag = document.getElementById('scene-json');
        if (sceneTag) sceneTag.textContent = JSON.stringify(sceneObj, null, 2);

        setDiag(
          `URL Path: <code>${escapeHtml(window.location.pathname)}</code><br>` +
          `battle_id: <span class="ok">${escapeHtml(String(battleId))}</span><br>` +
          `Fetch: <code>${escapeHtml(endpoint)}</code><br>` +
          `<span class="ok">Loaded state from API.</span>`
        );

        return true;
      } catch (e) {
        setDiag(
          `URL Path: <code>${escapeHtml(window.location.pathname)}</code><br>` +
          `battle_id: <span class="ok">${escapeHtml(String(battleId || ''))}</span><br>` +
          `Fetch: <code>${escapeHtml(endpoint)}</code><br>` +
          `<span class="bad">Fetch/parse error: ${escapeHtml(e && e.message ? e.message : String(e))}</span>`
        );
        return false;
      }
    }

    // =====================================================================
    // AUTO-REFRESH (multi-step)
    // =====================================================================

    const RefreshMode = { FAST: 'fast', S15: '15s', S30: '30s', S60: '60s', OFF: 'off' };

    const FAST_MS = 5000;
    const S15_MS = 15000;
    const S30_MS = 30000;
    const S60_MS = 60000;

    const FAST_TO_15_IDLE_MS = 60000;
    const S15_TO_30_IDLE_MS = 180000;
    const S30_TO_60_IDLE_MS = 300000;
    const S60_TO_OFF_IDLE_MS = 600000;

    const REFRESH = {
      mode: RefreshMode.S60,
      timer: null,
      battleId: null,
      lastVersionKey: null,
      lastChangeAt: Date.now(),
    };

    function modeLabel(mode) {
      if (mode === RefreshMode.FAST) return 'Refresh: 5s';
      if (mode === RefreshMode.S15) return 'Refresh: 15s';
      if (mode === RefreshMode.S30) return 'Refresh: 30s';
      if (mode === RefreshMode.S60) return 'Refresh: 60s';
      return 'Refresh: Off';
    }

    function modeDelayMs(mode) {
      if (mode === RefreshMode.FAST) return FAST_MS;
      if (mode === RefreshMode.S15) return S15_MS;
      if (mode === RefreshMode.S30) return S30_MS;
      if (mode === RefreshMode.S60) return S60_MS;
      return null;
    }

    function setRefreshUI() {
      const btn = document.getElementById('refreshModeBtn');
      if (!btn) return;
      btn.textContent = modeLabel(REFRESH.mode);
      btn.title = (REFRESH.mode === RefreshMode.OFF)
        ? 'Enable refresh (5s)'
        : 'Reset to 5s';
    }

    function setRefreshMode(mode) {
      REFRESH.mode = mode;
      if (REFRESH.timer) { clearTimeout(REFRESH.timer); REFRESH.timer = null; }
      setRefreshUI();
      scheduleRefreshTick(true);
    }

    function refreshButtonPressed() {
      // Any press = ‚Äúwake up‚Äù and go straight to FAST/5s.
      REFRESH.lastChangeAt = Date.now();
      try {
        if (REFRESH.battleId) {
          localStorage.setItem(`battlemat:refresh:auto:${REFRESH.battleId}`, 'auto');
          localStorage.setItem(`battlemat:refresh:last:${REFRESH.battleId}`, RefreshMode.FAST);
        }
      } catch (_) {}
      setRefreshMode(RefreshMode.FAST);
    }

    function scheduleRefreshTick(immediate) {
      if (REFRESH.timer) { clearTimeout(REFRESH.timer); REFRESH.timer = null; }
      if (REFRESH.mode === RefreshMode.OFF) return;
      const delay = immediate ? 0 : modeDelayMs(REFRESH.mode);
      REFRESH.timer = setTimeout(refreshTick, delay == null ? 0 : delay);
    }

    function applyScene(sceneObj) {
      // Capture where actors *were* before we swap in the new scene.
      try {
        if (SCENE_NORM?.actors?.length) {
          PENDING_PREV_POS = captureActorPositions(SCENE_NORM);
        }
      } catch (_) {
        PENDING_PREV_POS = null;
      }

      const sceneTag = document.getElementById('scene-json');
      if (sceneTag) sceneTag.textContent = JSON.stringify(sceneObj, null, 2);
      safeDrawGrid();
    }

    async function fetchSceneAndVersionKey(battleId) {
      const endpoint = battleStateUrl(battleId);
      const res = await fetch(endpoint, {
        method: 'GET',
        headers: { 'Accept': 'application/json' },
        cache: 'no-store'
      });
      if (!res.ok) throw new Error(`HTTP ${res.status} ${res.statusText || ''}`);
      const data = await res.json();

      let sceneObj = null;
      if (data && typeof data.state_json === 'string') sceneObj = JSON.parse(data.state_json);
      else if (data && typeof data.state === 'object') sceneObj = data.state;
      else if (data && typeof data === 'object') sceneObj = data;

      if (!looksLikeScene(sceneObj)) throw new Error('API JSON did not look like a SCENE');

      let versionKey = null;
      if (data && (typeof data.version === 'number' || typeof data.version === 'string')) {
        versionKey = `v:${String(data.version)}`;
      } else if (data && (typeof data.updated_at === 'number' || typeof data.updated_at === 'string')) {
        versionKey = `t:${String(data.updated_at)}`;
      }

      return { sceneObj, versionKey };
    }

    async function refreshTick() {
      try {
        if (REFRESH.mode === RefreshMode.OFF) return;

        // If we don't have a battleId (e.g., Canvas preview), we still "tick" so
        // the user can see the Auto/Off behavior and idle backoff.
        if (!REFRESH.battleId) {
          safeDrawGrid();
          const idleMs = Date.now() - (REFRESH.lastChangeAt || Date.now());
          if (REFRESH.mode === RefreshMode.FAST && idleMs > FAST_TO_15_IDLE_MS) {
            REFRESH.mode = RefreshMode.S15;
          } else if (REFRESH.mode === RefreshMode.S15 && idleMs > S15_TO_30_IDLE_MS) {
            REFRESH.mode = RefreshMode.S30;
          } else if (REFRESH.mode === RefreshMode.S30 && idleMs > S30_TO_60_IDLE_MS) {
            REFRESH.mode = RefreshMode.S60;
          } else if (REFRESH.mode === RefreshMode.S60 && idleMs > S60_TO_OFF_IDLE_MS) {
            REFRESH.mode = RefreshMode.OFF;
          }
          setRefreshUI();
          scheduleRefreshTick(false);
          return;
        }

        const { sceneObj, versionKey } = await fetchSceneAndVersionKey(REFRESH.battleId);

        const changed = (!versionKey) || (REFRESH.lastVersionKey !== versionKey);
        if (changed) {
          if (versionKey) REFRESH.lastVersionKey = versionKey;
          REFRESH.lastChangeAt = Date.now();

          // Snap back to FAST if we detect activity
          if (REFRESH.mode !== RefreshMode.FAST) {
            REFRESH.mode = RefreshMode.FAST;
          }

          applyScene(sceneObj);
        } else {
          const idleMs = Date.now() - (REFRESH.lastChangeAt || Date.now());

          if (REFRESH.mode === RefreshMode.FAST && idleMs > FAST_TO_15_IDLE_MS) {
            REFRESH.mode = RefreshMode.S15;
          } else if (REFRESH.mode === RefreshMode.S15 && idleMs > S15_TO_30_IDLE_MS) {
            REFRESH.mode = RefreshMode.S30;
          } else if (REFRESH.mode === RefreshMode.S30 && idleMs > S30_TO_60_IDLE_MS) {
            REFRESH.mode = RefreshMode.S60;
          } else if (REFRESH.mode === RefreshMode.S60 && idleMs > S60_TO_OFF_IDLE_MS) {
            REFRESH.mode = RefreshMode.OFF;
          }
        }

        setRefreshUI();
        scheduleRefreshTick(false);
      } catch {
        // Swallow transient errors and keep polling.
        setRefreshUI();
        scheduleRefreshTick(false);
      }
    }

    document.getElementById('refreshModeBtn')?.addEventListener('click', (ev) => {
      ev.stopPropagation();
      refreshButtonPressed();
    });

    // =====================================================================
    // ENGINE (do not edit during play)
    // =====================================================================

    let SCENE = {};
    let LAST_GOOD_SCENE = null;
    let SCENE_PARSE_ERROR = null;

    // ====== MOVEMENT TRAILS (lightweight, derived) ======
    const TRAIL_TTL_MS = 90_000;     // keep recent trails (ms)
    const TRAIL_MAX_SEGMENTS = 24;  // per-actor cap
    let PENDING_PREV_POS = null;    // Map(actorId -> { at, side }) captured just before applyScene()
    const MOVE_TRAILS = new Map();  // actorId -> Array<{ from, to, ts, side }>

    function captureActorPositions(sceneNorm) {
      const m = new Map();
      for (const a of (sceneNorm?.actors || [])) {
        const id = String(a.id ?? '').trim();
        const at = String(a.at ?? '').trim().toUpperCase();
        if (!id || !at) continue;
        m.set(id, { at, side: String(a.side || 'NPC').toUpperCase() });
      }
      return m;
    }

    function pruneTrails(now) {
      const t = Number(now || Date.now());
      for (const [id, segs] of MOVE_TRAILS.entries()) {
        const kept = (segs || []).filter(s => (t - (s.ts || 0)) <= TRAIL_TTL_MS);
        if (!kept.length) MOVE_TRAILS.delete(id);
        else MOVE_TRAILS.set(id, kept.slice(-TRAIL_MAX_SEGMENTS));
      }
    }

    function updateTrailsFromPending() {
      if (!PENDING_PREV_POS) return;
      const prev = PENDING_PREV_POS;
      PENDING_PREV_POS = null;

      const now = Date.now();
      pruneTrails(now);

      for (const a of (SCENE_NORM?.actors || [])) {
        const id = String(a.id ?? '').trim();
        if (!id) continue;

        const curAt = String(a.at ?? '').trim().toUpperCase();
        const curSide = String(a.side || 'NPC').toUpperCase();
        const p = prev.get(id);
        if (!p) continue;

        const from = String(p.at || '').trim().toUpperCase();
        const to = curAt;
        if (!from || !to || from === to) continue;

        const seg = { from, to, ts: now, side: curSide || p.side || 'NPC' };
        const list = MOVE_TRAILS.get(id) || [];
        list.push(seg);
        MOVE_TRAILS.set(id, list.slice(-TRAIL_MAX_SEGMENTS));
      }

      pruneTrails(now);
    }

    function sideTrailStyle(side) {
      const s = String(side || 'NPC').toUpperCase();
      if (s === 'PC') return { stroke: 'rgba(80,160,220,0.30)', fill: 'rgba(80,160,220,0.22)' };
      if (s === 'EN') return { stroke: 'rgba(220,120,80,0.30)', fill: 'rgba(220,120,80,0.22)' };
      return { stroke: 'rgba(120,120,120,0.28)', fill: 'rgba(120,120,120,0.18)' };
    }

    function drawArrowHead(x1, y1, x2, y2, sizePx) {
      const dx = x2 - x1;
      const dy = y2 - y1;
      const ang = Math.atan2(dy, dx);
      const s = Number(sizePx || 8);

      ctx.save();
      ctx.translate(x2, y2);
      ctx.rotate(ang);
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.lineTo(-s, -s * 0.55);
      ctx.lineTo(-s,  s * 0.55);
      ctx.closePath();
      ctx.fill();
      ctx.restore();
    }

    function drawFootsteps(x1, y1, x2, y2, dotR, stepPx) {
      const dx = x2 - x1;
      const dy = y2 - y1;
      const dist = Math.hypot(dx, dy);
      if (dist < 1) return;
      const step = Math.max(6, Number(stepPx || (size * 0.65)));
      const n = Math.max(2, Math.floor(dist / step));

      for (let i = 0; i <= n; i++) {
        const t = i / n;
        const x = x1 + dx * t;
        const y = y1 + dy * t;
        ctx.beginPath();
        ctx.arc(x, y, dotR, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    function drawMoveTrails() {
      const now = Date.now();
      pruneTrails(now);

      ctx.save();
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';

      for (const segs of MOVE_TRAILS.values()) {
        for (const s of (segs || [])) {
          const p1 = labelToPixel(s.from);
          const p2 = labelToPixel(s.to);
          if (!p1 || !p2) continue;

          const style = sideTrailStyle(s.side);
          const age = Math.max(0, now - (s.ts || now));
          const fade = Math.max(0, 1 - (age / TRAIL_TTL_MS));

          ctx.globalAlpha = 0.9 * fade;
          ctx.strokeStyle = style.stroke;
          ctx.fillStyle = style.fill;
          ctx.lineWidth = 2;

          ctx.setLineDash([6, 8]);
          ctx.beginPath();
          ctx.moveTo(p1.x, p1.y);
          ctx.lineTo(p2.x, p2.y);
          ctx.stroke();

          ctx.setLineDash([]);
          drawFootsteps(p1.x, p1.y, p2.x, p2.y, 2.2, size * 0.70);

          ctx.globalAlpha = 0.65 * fade;
          drawArrowHead(p1.x, p1.y, p2.x, p2.y, 9);
        }
      }

      ctx.restore();
    }

    function loadSceneFromJsonTag() {
      const el = document.getElementById('scene-json');
      const raw = el ? String(el.textContent || '').trim() : '';
      if (!raw) {
        SCENE_PARSE_ERROR = 'SCENE JSON is empty.';
        return (LAST_GOOD_SCENE || {});
      }
      try {
        const obj = JSON.parse(raw);
        LAST_GOOD_SCENE = obj;
        SCENE_PARSE_ERROR = null;
        return obj;
      } catch (e) {
        SCENE_PARSE_ERROR = `SCENE JSON parse error: ${e && e.message ? e.message : String(e)}`;
        try { console.error('[Battlemat] ' + SCENE_PARSE_ERROR); } catch (_) {}
        return (LAST_GOOD_SCENE || {});
      }
    }

    // ====== GRID CONFIG ======
    const cols = 17;        // A..Q
    const rows = 11;        // 1..11
    const size = 34.5;      // hex radius (center -> corner)
    const margin = 55;

    const canvas = document.getElementById('mat');
    const ctx = canvas.getContext('2d');
    const SQRT3 = Math.sqrt(3);
    const letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';

    let ROOM_GEOMS = null;
    let SCENE_NORM = null;

    const CONFIG = {
      room: { yInsetFrac: 0.25 },
      labels: {
        dyFrac: 0.70,
        // Hex label readability tuning
        inRoomColor: [0, 0, 0],
        outRoomColor: [0, 0, 0],
        inRoomAlpha: 0.22,
        outRoomAlpha: 0.03
      },
      opening: {
        minAcross: 18,
        acrossMul: 1.05,
        spanNSMul: 1.5,
        spanEWMul: 1.0,
      },
      grid: {
        baseStrokeW: 1.2,
        baseStrokeA: 0.07,
        overlayStrokeW: 1.1,
        overlayStrokeA: 0.04,
      }
    };

    // =====================================================================
    // TEXTURES (floors + walls)
    // =====================================================================

    const TEX = {
      enabled: false,
      patterns: new Map(), // kind -> CanvasPattern
      tiles: new Map(),    // kind -> HTMLCanvasElement
      overrideFloorKind: '__room__',
      overrideWallKind: '__room__'
    };

    function readTexturePref() {
      try {
        const v = (localStorage.getItem('battlemat:textures:enabled') || '').trim();
        return v === '1' || v.toLowerCase() === 'true' || v.toLowerCase() === 'on';
      } catch (_) {
        return false;
      }
    }

    function writeTexturePref(on) {
      try { localStorage.setItem('battlemat:textures:enabled', on ? '1' : '0'); } catch (_) {}
    }

    const TEX_OVERRIDE_ROOM = '__room__';

    const FLOOR_PRESETS = [
      { value: TEX_OVERRIDE_ROOM, label: 'Room setting' },
      { value: 'stone', label: 'Stone (slab)' },
      { value: 'stone:cobble', label: 'Stone (cobble)' },
      { value: 'stone:dark', label: 'Stone (dark)' },
      { value: 'stone:blocks', label: 'Stone (blocks)' },
      { value: 'stone:marble', label: 'Stone (marble)' },
      { value: 'stone:blocks', label: 'Stone (blocks)' },
      { value: 'wood:oak', label: 'Wood (oak)' },
      { value: 'wood:pine', label: 'Wood (pine)' },
      { value: 'wood:dark', label: 'Wood (dark)' },
      { value: 'wood:gray', label: 'Wood (gray)' },
      { value: 'dirt:earth', label: 'Dirt (earth)' },
      { value: 'dirt:sand', label: 'Dirt (sand)' },
      { value: 'dirt:mud', label: 'Dirt (mud)' },
      { value: 'grass', label: 'Grass' },
      { value: 'carpet:red', label: 'Carpet (red)' },
      { value: 'carpet:blue', label: 'Carpet (blue)' },
      { value: 'carpet:green', label: 'Carpet (green)' },
      { value: 'carpet:purple', label: 'Carpet (purple)' }
    ];

    const WALL_PRESETS = [
      { value: TEX_OVERRIDE_ROOM, label: 'Room setting' },
      { value: 'brick:red', label: 'Brick (red)' },
      { value: 'brick:pale', label: 'Brick (pale)' },
      { value: 'brick:soot', label: 'Brick (soot)' },
      { value: 'stone', label: 'Stone (slab)' },
      { value: 'stone:cobble', label: 'Stone (cobble)' },
      { value: 'stone:dark', label: 'Stone (dark)' },
      { value: 'wood:oak', label: 'Wood (oak)' },
      { value: 'wood:dark', label: 'Wood (dark)' }
    ];

    function readTextureOverride(which) {
      const key = which === 'wall' ? 'battlemat:textures:wallOverride' : 'battlemat:textures:floorOverride';
      try {
        const v = String(localStorage.getItem(key) || '').trim();
        return v || TEX_OVERRIDE_ROOM;
      } catch (_) {
        return TEX_OVERRIDE_ROOM;
      }
    }

    function writeTextureOverride(which, value) {
      const key = which === 'wall' ? 'battlemat:textures:wallOverride' : 'battlemat:textures:floorOverride';
      try { localStorage.setItem(key, String(value || TEX_OVERRIDE_ROOM)); } catch (_) {}
    }

    function populateSelect(sel, presets, selectedVal) {
      sel.innerHTML = '';
      for (const p of presets) {
        const opt = document.createElement('option');
        opt.value = p.value;
        opt.textContent = p.label;
        sel.appendChild(opt);
      }
      sel.value = selectedVal || TEX_OVERRIDE_ROOM;
    }

    function initTextureSelectors() {
      const floorSel = document.getElementById('floorTexSel');
      const wallSel = document.getElementById('wallTexSel');
      if (!floorSel || !wallSel) return;

      // Load persisted overrides
      TEX.overrideFloorKind = readTextureOverride('floor');
      TEX.overrideWallKind = readTextureOverride('wall');

      populateSelect(floorSel, FLOOR_PRESETS, TEX.overrideFloorKind);
      populateSelect(wallSel, WALL_PRESETS, TEX.overrideWallKind);

      floorSel.addEventListener('change', () => {
        TEX.overrideFloorKind = floorSel.value || TEX_OVERRIDE_ROOM;
        writeTextureOverride('floor', TEX.overrideFloorKind);
        safeDrawGrid();
      });

      wallSel.addEventListener('change', () => {
        TEX.overrideWallKind = wallSel.value || TEX_OVERRIDE_ROOM;
        writeTextureOverride('wall', TEX.overrideWallKind);
        safeDrawGrid();
      });
    }

    function setTextureUi() {
      const btn = document.getElementById('textureToggleBtn');
      if (!btn) return;
      btn.textContent = TEX.enabled ? 'Textures: On' : 'Textures: Off';
      btn.title = TEX.enabled ? 'Turn textures off' : 'Turn textures on';
    }

    function toggleTextures() {
      TEX.enabled = !TEX.enabled;
      writeTexturePref(TEX.enabled);
      setTextureUi();
      safeDrawGrid();
    }

    document.getElementById('textureToggleBtn')?.addEventListener('click', (ev) => {
      ev.stopPropagation();
      toggleTextures();
    });

    // Small deterministic PRNG for ‚Äúnatural‚Äù texture variation (seeded by kind)
    function seededRng(seedStr) {
      let h = 2166136261;
      const s = String(seedStr || 'seed');
      for (let i = 0; i < s.length; i++) {
        h ^= s.charCodeAt(i);
        h = Math.imul(h, 16777619);
      }
      let state = h >>> 0;
      return function rand() {
        state = (Math.imul(1664525, state) + 1013904223) >>> 0;
        return state / 4294967296;
      };
    }

    function offscreenTile(w, h) {
      const c = document.createElement('canvas');
      c.width = w; c.height = h;
      return c;
    }

    function makeWoodTile(variant) {
      const c = offscreenTile(220, 220);
      const g = c.getContext('2d');
      const vRaw = String(variant || '').trim().toLowerCase();

      // Palettes
      const PAL = {
        oak:   { bg: '#c9b08a', plank: 'rgba(140, 95, 55, 0.18)', grain: 'rgba(60, 35, 20, 0.16)' },
        pine:  { bg: '#d7c59f', plank: 'rgba(155, 110, 65, 0.16)', grain: 'rgba(80, 50, 25, 0.14)' },
        dark:  { bg: '#7f6a52', plank: 'rgba(50, 32, 18, 0.22)', grain: 'rgba(20, 12, 7, 0.20)' },
        gray:  { bg: '#b7b1a9', plank: 'rgba(80, 75, 70, 0.14)', grain: 'rgba(35, 35, 35, 0.14)' },
      };

      // Support variant flags like "wood:pine:horizontal" or "wood:oak:vertical".
      // Default: vertical planks (oak included); you can force orientation with :horizontal / :vertical.
      const baseVariant = vRaw.split(':')[0] || 'oak';
      const flags = vRaw.split(':').slice(1);

      let orient = 'v';
      const flagStr = flags.join(':');
      if (flagStr.includes('horizontal') || flagStr.includes('h')) orient = 'h';
      if (flagStr.includes('vertical') || flagStr.includes('v')) orient = 'v';

      // Cleaner oak planks (no knots/circles, fewer scratch marks)
      const cleanOak = (baseVariant === 'oak');

      const P = PAL[baseVariant] || PAL.oak;
      const rand = seededRng('wood:' + (vRaw || 'oak'));

      g.fillStyle = P.bg;
      g.fillRect(0, 0, c.width, c.height);

      const plank = 28;
      const scratchMul = 0.5; // reduce wood grain/scratch strength (~half)

      g.strokeStyle = P.grain;
      g.lineWidth = 1;

      if (orient === 'h') {
        // HORIZONTAL planks (seams are horizontal; planks run left‚Üíright)
        for (let y = 0; y < c.height + plank; y += plank) {
          g.fillStyle = P.plank;
          g.fillRect(0, y, c.width, plank);

          // grain (left‚Üíright)
          const a0 = g.globalAlpha;
          g.globalAlpha = a0 * scratchMul;
          const grainN = cleanOak ? 2 : 6;

          for (let i = 0; i < grainN; i++) {
            g.beginPath();
            g.moveTo(0, y + 2 + rand() * (plank - 4));
            g.bezierCurveTo(
              c.width * 0.35, y + (plank * 0.50) + (rand() - 0.5) * 10,
              c.width * 0.65, y + (plank * 0.50) + (rand() - 0.5) * 10,
              c.width, y + 2 + rand() * (plank - 4)
            );
            g.stroke();

            // subtle short grain scratches (disabled for clean oak)
            if (!cleanOak) {
              const x = rand() * c.width;
              g.globalAlpha = a0 * scratchMul * 0.65;
              g.beginPath();
              g.moveTo(x, y + 4 + rand() * (plank - 8));
              g.lineTo(x + 18 + rand() * 22, y + 4 + rand() * (plank - 8));
              g.stroke();
              g.globalAlpha = a0 * scratchMul;
            }
          }

          g.globalAlpha = a0;

          // seams
          g.strokeStyle = 'rgba(0,0,0,0.10)';
          g.beginPath();
          g.moveTo(0, y + plank);
          g.lineTo(c.width, y + plank);
          g.stroke();

          // highlight strip
          g.fillStyle = 'rgba(255,255,255,0.03)';
          g.fillRect(0, y + 1, c.width, 2);

          // restore grain stroke
          g.strokeStyle = P.grain;
          g.lineWidth = 1;
        }
      } else {
        // VERTICAL planks
        for (let x = 0; x < c.width + plank; x += plank) {
          g.fillStyle = P.plank;
          g.fillRect(x, 0, plank, c.height);

          // grain (top‚Üíbottom)
          const a0 = g.globalAlpha;
          g.globalAlpha = a0 * scratchMul;

          const grainN = cleanOak ? 3 : 6;
          for (let i = 0; i < grainN; i++) {
            const y = rand() * c.height;
            g.beginPath();
            g.moveTo(x + 2, y);
            g.bezierCurveTo(
              x + plank * 0.35, y + (rand() - 0.5) * 18,
              x + plank * 0.65, y + (rand() - 0.5) * 18,
              x + plank - 2, y
            );
            g.stroke();
          }

          g.globalAlpha = a0;

          // seams
          g.strokeStyle = 'rgba(0,0,0,0.10)';
          g.beginPath();
          g.moveTo(x + plank, 0);
          g.lineTo(x + plank, c.height);
          g.stroke();

          // highlight strip
          g.fillStyle = 'rgba(255,255,255,0.03)';
          g.fillRect(x + 1, 0, 2, c.height);

          // restore grain stroke
          g.strokeStyle = P.grain;
          g.lineWidth = 1;
        }
      }

      // knots (disabled for clean oak to avoid repeating circle artifacts)
      if (!cleanOak) {
        for (let k = 0; k < 14; k++) {
          const x = rand() * c.width;
          const y = rand() * c.height;
          const r = 3 + rand() * 7;
          g.strokeStyle = 'rgba(50, 25, 10, 0.18)';
          g.lineWidth = 1;
          g.beginPath();
          g.ellipse(x, y, r * 1.2, r, rand() * Math.PI, 0, Math.PI * 2);
          g.stroke();
        }
      }

      return c;
    }

    function makeStoneTile(variant) {
      const v = String(variant || '').trim().toLowerCase();
      const isCobble = (v === 'cobble' || v === 'cobblestone');
      const isDark = (v === 'dark' || v === 'basalt');
      const isMarble = (v === 'marble');
      const isBlocks = (v === 'blocks' || v === 'block' || v.includes('ashlar') || v.includes('block'));

      // Slightly larger tile for "blocks" to reduce obvious repetition.
      const c = isBlocks ? offscreenTile(320, 320) : offscreenTile(240, 240);
      const g = c.getContext('2d');
      const rand = seededRng('stone:' + (v || 'slab'));

      const base = isMarble ? '#d7d7d7' : (isDark ? '#8a8a8a' : '#b6b6b6');
      g.fillStyle = base;
      g.fillRect(0, 0, c.width, c.height);

      // --- Regular interlocking blocks (ashlar style) ---
      if (isBlocks) {
        const mortar = 3;
        const rowH = 40; // block height
        const lens = [54, 72, 92, 64, 84];

        // Mortar base (slightly darker)
        g.fillStyle = isDark ? '#7c7c7c' : '#a9a9a9';
        g.fillRect(0, 0, c.width, c.height);

        let row = 0;
        for (let y = 0; y < c.height + rowH; y += (rowH + mortar)) {
          const offset = (row % 2 === 0) ? 0 : Math.floor((lens[1] + mortar) / 2);
          let x = -offset;

          while (x < c.width + 120) {
            const baseLen = lens[Math.floor(rand() * lens.length)];
            const len = baseLen + Math.floor((rand() - 0.5) * 10); // tiny variation

            // Per-block shading (subtle)
            const shadeA = (isDark ? 0.18 : 0.12) + rand() * 0.08;
            g.fillStyle = `rgba(110,110,110,${shadeA})`;
            g.fillRect(x + mortar, y + mortar, len, rowH);

            // Bevel: highlight top/left, shadow bottom/right
            g.fillStyle = 'rgba(255,255,255,0.06)';
            g.fillRect(x + mortar + 1, y + mortar + 1, len - 2, 2);
            g.fillRect(x + mortar + 1, y + mortar + 1, 2, rowH - 2);

            g.fillStyle = 'rgba(0,0,0,0.07)';
            g.fillRect(x + mortar + 1, y + mortar + rowH - 3, len - 2, 2);
            g.fillRect(x + mortar + len - 3, y + mortar + 1, 2, rowH - 2);

            // Edge definition (very light)
            g.strokeStyle = 'rgba(0,0,0,0.10)';
            g.lineWidth = 1;
            g.strokeRect(x + mortar, y + mortar, len, rowH);

            x += (len + mortar);
          }
          row++;
        }

        // Speckle / grit
        const specks = isDark ? 1100 : 850;
        for (let i = 0; i < specks; i++) {
          const xx = rand() * c.width;
          const yy = rand() * c.height;
          const a = 0.03 + rand() * 0.06;
          g.fillStyle = `rgba(0,0,0,${a})`;
          g.fillRect(xx, yy, 1, 1);
        }

        return c;
      }

      // --- Slabs vs cobbles ---
      const cell = isCobble ? 34 : 48;
      for (let y = 0; y < c.height + cell; y += cell) {
        for (let x = 0; x < c.width + cell; x += cell) {
          // Make slabs a bit more regular (less jitter) than cobble.
          const jitterX = (rand() - 0.5) * (isCobble ? 10 : 4);
          const jitterY = (rand() - 0.5) * (isCobble ? 10 : 4);
          const w = cell + (rand() - 0.5) * (isCobble ? 18 : 10);
          const h = cell + (rand() - 0.5) * (isCobble ? 18 : 10);

          const shade = isDark ? 0.16 : 0.12;
          g.fillStyle = `rgba(110,110,110,${shade + rand() * 0.10})`;
          g.fillRect(x + jitterX, y + jitterY, w, h);

          g.strokeStyle = `rgba(0,0,0,${isCobble ? 0.14 : 0.09})`;
          g.lineWidth = 1;
          g.strokeRect(x + jitterX, y + jitterY, w, h);
        }
      }

      // Marble veins
      if (isMarble) {
        g.strokeStyle = 'rgba(60,60,60,0.10)';
        g.lineWidth = 2;
        for (let i = 0; i < 6; i++) {
          g.beginPath();
          let x = rand() * c.width;
          let y = rand() * c.height;
          g.moveTo(x, y);
          for (let k = 0; k < 6; k++) {
            x += (rand() - 0.5) * 70;
            y += (rand() - 0.5) * 40;
            g.lineTo(x, y);
          }
          g.stroke();
        }
      }

      // Speckle
      const specks = isDark ? 900 : 600;
      for (let i = 0; i < specks; i++) {
        const x = rand() * c.width;
        const y = rand() * c.height;
        const a = 0.03 + rand() * 0.06;
        g.fillStyle = `rgba(0,0,0,${a})`;
        g.fillRect(x, y, 1, 1);
      }

      return c;
    }

    function makeBrickTile(variant) {
      const v = String(variant || '').trim().toLowerCase();
      const rand = seededRng('brick:' + (v || 'red'));

      const c = offscreenTile(240, 160);
      const g = c.getContext('2d');

      const PAL = {
        red:   { mortar: '#c9c3b8', lo: [120,60,40], hi: [165,95,70] },
        pale:  { mortar: '#d6d2c9', lo: [130,110,95], hi: [170,150,130] },
        soot:  { mortar: '#bfb8ad', lo: [85,55,45],  hi: [130,85,70] },
      };
      const P = PAL[v] || PAL.red;

      g.fillStyle = P.mortar;
      g.fillRect(0, 0, c.width, c.height);

      const brickW = 46;
      const brickH = 22;
      const mortar = 3;

      for (let row = 0; row < 8; row++) {
        const y = row * (brickH + mortar);
        const offset = (row % 2 === 0) ? 0 : Math.floor(brickW / 2);
        for (let x0 = -offset; x0 < c.width + brickW; x0 += (brickW + mortar)) {
          const r = P.lo[0] + Math.floor(rand() * (P.hi[0] - P.lo[0]));
          const gg = P.lo[1] + Math.floor(rand() * (P.hi[1] - P.lo[1]));
          const b = P.lo[2] + Math.floor(rand() * (P.hi[2] - P.lo[2]));
          g.fillStyle = `rgb(${r},${gg},${b})`;
          g.fillRect(x0 + mortar, y + mortar, brickW, brickH);

          // subtle bevel
          g.fillStyle = 'rgba(255,255,255,0.06)';
          g.fillRect(x0 + mortar + 1, y + mortar + 1, brickW - 2, 2);
          g.fillStyle = 'rgba(0,0,0,0.05)';
          g.fillRect(x0 + mortar + 1, y + mortar + brickH - 2, brickW - 2, 2);

          g.strokeStyle = 'rgba(0,0,0,0.12)';
          g.lineWidth = 1;
          g.strokeRect(x0 + mortar, y + mortar, brickW, brickH);
        }
      }

      // grit
      for (let i = 0; i < 180; i++) {
        const x = rand() * c.width;
        const y = rand() * c.height;
        g.fillStyle = 'rgba(0,0,0,0.05)';
        g.fillRect(x, y, 1, 1);
      }

      return c;
    }

    function makeDirtTile(variant) {
      const v = String(variant || '').trim().toLowerCase();
      const rand = seededRng('dirt:' + (v || 'earth'));

      const c = offscreenTile(240, 240);
      const g = c.getContext('2d');

      const PAL = {
        earth: { bg: '#9b835e', dark: 'rgba(60,40,20,0.10)', light: 'rgba(255,255,255,0.06)' },
        sand:  { bg: '#d2c18b', dark: 'rgba(120,95,55,0.08)', light: 'rgba(255,255,255,0.07)' },
        mud:   { bg: '#6f5a42', dark: 'rgba(20,15,10,0.14)', light: 'rgba(255,255,255,0.04)' },
      };
      const P = PAL[v] || PAL.earth;

      g.fillStyle = P.bg;
      g.fillRect(0, 0, c.width, c.height);

      // blotchy noise
      for (let i = 0; i < 1200; i++) {
        const x = rand() * c.width;
        const y = rand() * c.height;
        const r = 1 + rand() * 6;
        g.fillStyle = (rand() < 0.6) ? P.dark : P.light;
        g.beginPath();
        g.arc(x, y, r, 0, Math.PI * 2);
        g.fill();
      }

      // small pebbles
      g.strokeStyle = 'rgba(0,0,0,0.10)';
      g.lineWidth = 1;
      for (let k = 0; k < 55; k++) {
        const x = rand() * c.width;
        const y = rand() * c.height;
        const rx = 2 + rand() * 4;
        const ry = 1 + rand() * 3;
        g.fillStyle = 'rgba(255,255,255,0.08)';
        g.beginPath();
        g.ellipse(x, y, rx, ry, rand() * Math.PI, 0, Math.PI * 2);
        g.fill();
        g.beginPath();
        g.ellipse(x, y, rx, ry, rand() * Math.PI, 0, Math.PI * 2);
        g.stroke();
      }

      return c;
    }

    function makeGrassTile() {
      const rand = seededRng('grass');
      const c = offscreenTile(240, 240);
      const g = c.getContext('2d');

      g.fillStyle = '#8ea86c';
      g.fillRect(0, 0, c.width, c.height);

      // mottling
      for (let i = 0; i < 1200; i++) {
        const x = rand() * c.width;
        const y = rand() * c.height;
        const a = 0.03 + rand() * 0.06;
        g.fillStyle = `rgba(0,0,0,${a})`;
        g.fillRect(x, y, 1, 1);
      }

      // blades
      g.strokeStyle = 'rgba(30,60,20,0.10)';
      g.lineWidth = 1;
      for (let k = 0; k < 220; k++) {
        const x = rand() * c.width;
        const y = rand() * c.height;
        const len = 6 + rand() * 16;
        const ang = (-Math.PI / 2) + (rand() - 0.5) * 0.9;
        g.beginPath();
        g.moveTo(x, y);
        g.lineTo(x + Math.cos(ang) * len, y + Math.sin(ang) * len);
        g.stroke();
      }

      return c;
    }

    function makeCarpetTile(variant) {
      const v = String(variant || '').trim().toLowerCase();
      const rand = seededRng('carpet:' + (v || 'red'));
      const c = offscreenTile(240, 240);
      const g = c.getContext('2d');

      const PAL = {
        red:   { bg: '#9d3a2f', stripe: 'rgba(255,255,255,0.10)', dark: 'rgba(0,0,0,0.12)' },
        blue:  { bg: '#2f4f7a', stripe: 'rgba(255,255,255,0.10)', dark: 'rgba(0,0,0,0.12)' },
        green: { bg: '#2f6b4a', stripe: 'rgba(255,255,255,0.10)', dark: 'rgba(0,0,0,0.12)' },
        purple:{ bg: '#5b3a7a', stripe: 'rgba(255,255,255,0.10)', dark: 'rgba(0,0,0,0.12)' },
      };
      const P = PAL[v] || PAL.red;

      g.fillStyle = P.bg;
      g.fillRect(0, 0, c.width, c.height);

      // woven noise
      for (let i = 0; i < 2200; i++) {
        const x = rand() * c.width;
        const y = rand() * c.height;
        const a = 0.02 + rand() * 0.05;
        g.fillStyle = `rgba(255,255,255,${a})`;
        g.fillRect(x, y, 1, 1);
      }

      // simple border + stripes
      g.fillStyle = P.dark;
      g.fillRect(0, 0, c.width, 10);
      g.fillRect(0, c.height - 10, c.width, 10);
      g.fillRect(0, 0, 10, c.height);
      g.fillRect(c.width - 10, 0, 10, c.height);

      g.fillStyle = P.stripe;
      for (let y = 18; y < c.height; y += 28) {
        g.fillRect(0, y, c.width, 2);
      }

      return c;
    }

    function normalizeTextureKind(kind) {
      const raw = String(kind || '').trim().toLowerCase();
      if (!raw) return { base: 'stone', variant: '', key: 'stone' };

      let base = raw;
      let variant = '';

      // Prefer explicit variant via ':'  (e.g. "wood:oak")
      if (raw.includes(':')) {
        const parts = raw.split(':');
        base = (parts[0] || raw).trim();
        variant = parts.slice(1).join(':').trim();
      } else if (raw.includes('.')) {
        // Allow "stone.cobble" or "brick.soot" etc
        const parts = raw.split('.');
        const head = (parts[0] || raw).trim();
        if (parts.length >= 2 && ['wood','stone','brick','dirt','grass','carpet','marble','cobble','cobblestone','planks','timber','slab','slabs','tile','tiles','sand','mud'].includes(head)) {
          base = head;
          variant = parts.slice(1).join('.').trim();
        }
      } else if (raw.includes('-')) {
        const parts = raw.split('-');
        const head = (parts[0] || raw).trim();
        if (parts.length >= 2 && ['wood','stone','brick','dirt','carpet'].includes(head)) {
          base = head;
          variant = parts.slice(1).join('-').trim();
        }
      }

      // Synonyms / convenience
      const syn = {
        planks: 'wood',
        timber: 'wood',
        slabs: 'stone',
        slab: 'stone',
        tiles: 'stone',
        tile: 'stone',
        bricks: 'brick',
      };
      base = syn[base] || base;

      if (base === 'cobble' || base === 'cobblestone') { base = 'stone'; if (!variant) variant = 'cobble'; }
      if (base === 'marble') { base = 'stone'; if (!variant) variant = 'marble'; }
      if (base === 'sand') { base = 'dirt'; if (!variant) variant = 'sand'; }

      // Clamp to supported bases (fallback to stone)
      if (!['wood','stone','brick','dirt','grass','carpet'].includes(base)) {
        base = 'stone';
        variant = '';
      }

      const key = base + (variant ? ':' + variant : '');
      return { base, variant, key };
    }

    function textureTileFor(kind) {
      const nk = normalizeTextureKind(kind);
      const key = nk.key;
      if (TEX.tiles.has(key)) return TEX.tiles.get(key);

      let tile;
      if (nk.base === 'wood') tile = makeWoodTile(nk.variant);
      else if (nk.base === 'brick') tile = makeBrickTile(nk.variant);
      else if (nk.base === 'dirt') tile = makeDirtTile(nk.variant);
      else if (nk.base === 'grass') tile = makeGrassTile();
      else if (nk.base === 'carpet') tile = makeCarpetTile(nk.variant);
      else tile = makeStoneTile(nk.variant);

      TEX.tiles.set(key, tile);
      return tile;
    }

    function texturePatternFor(kind) {
      const nk = normalizeTextureKind(kind);
      const key = nk.key;
      if (TEX.patterns.has(key)) return TEX.patterns.get(key);

      const tile = textureTileFor(key);
      const pat = ctx.createPattern(tile, 'repeat');
      TEX.patterns.set(key, pat);
      return pat;
    }

    function floorKindForRoom(room) {
      const ov = String(TEX.overrideFloorKind || '').trim();
      if (ov && ov !== TEX_OVERRIDE_ROOM) return ov;
      const k = room?.floor?.kind ?? room?.floorKind ?? room?.floor_kind ?? '';
      const s = String(k || '').trim().toLowerCase();
      return s || 'stone';
    }

    function wallKindForRoom(room) {
      const ov = String(TEX.overrideWallKind || '').trim();
      if (ov && ov !== TEX_OVERRIDE_ROOM) return ov;
      const k = room?.wall?.kind ?? room?.wallKind ?? room?.wall_kind ?? '';
      const s = String(k || '').trim().toLowerCase();
      return s || 'brick';
    }

    function drawTexturedRoom(room, g) {
      const t = Math.max(1, Number(g.thickness || 18));
      const half = t / 2;

      const outer = {
        x: g.leftX - half,
        y: g.topY - half,
        w: (g.rightX - g.leftX) + t,
        h: (g.botY - g.topY) + t,
      };

      const inner = {
        x: g.leftX + half,
        y: g.topY + half,
        w: (g.rightX - g.leftX) - t,
        h: (g.botY - g.topY) - t,
      };

      // 1) Floor
      const fk = floorKindForRoom(room);
      const fpat = texturePatternFor(fk);
      ctx.save();
      ctx.beginPath();
      ctx.rect(inner.x, inner.y, inner.w, inner.h);
      ctx.clip();
      ctx.globalAlpha = 0.95;
      ctx.fillStyle = fpat;
      ctx.fillRect(inner.x - 2000, inner.y - 2000, inner.w + 4000, inner.h + 4000);

      // subtle vignette
      ctx.globalAlpha = 0.10;
      const grad = ctx.createLinearGradient(inner.x, inner.y, inner.x, inner.y + inner.h);
      grad.addColorStop(0, 'rgba(0,0,0,0.00)');
      grad.addColorStop(1, 'rgba(0,0,0,0.40)');
      ctx.fillStyle = grad;
      ctx.fillRect(inner.x, inner.y, inner.w, inner.h);
      ctx.restore();

      // 2) Walls ring
      const wk = wallKindForRoom(room);
      const wpat = texturePatternFor(wk);
      ctx.save();
      ctx.beginPath();
      ctx.rect(outer.x, outer.y, outer.w, outer.h);
      ctx.rect(inner.x, inner.y, inner.w, inner.h);
      // even-odd clip (with fallback)
      try { ctx.clip('evenodd'); } catch { ctx.clip(); }
      ctx.globalAlpha = 0.95;
      ctx.fillStyle = wpat;
      ctx.fillRect(outer.x - 2000, outer.y - 2000, outer.w + 4000, outer.h + 4000);
      ctx.restore();

      // 3) Edge definition
      ctx.save();
      ctx.globalAlpha = 0.55;
      ctx.strokeStyle = 'rgba(0,0,0,0.55)';
      ctx.lineWidth = 2;
      ctx.strokeRect(inner.x, inner.y, inner.w, inner.h);
      ctx.globalAlpha = 0.35;
      ctx.strokeRect(outer.x, outer.y, outer.w, outer.h);
      ctx.restore();
    }

    // =====================================================================
    // SPRITES (Option 2 foundation)
    // =====================================================================

    const SPRITE_BASE = '/assets/sprites';

    const SPRITE_DEFS = {
      'table':        { url: `${SPRITE_BASE}/table_round.png`,    wHex: 1.8, hHex: 1.8, ax: 0.5, ay: 0.52, shadow: true },
      'table.round':  { url: `${SPRITE_BASE}/table_round.png`,    wHex: 1.8, hHex: 1.8, ax: 0.5, ay: 0.52, shadow: true },
      'table.rect':   { url: `${SPRITE_BASE}/table_rect.png`,     wHex: 2.2, hHex: 1.6, ax: 0.5, ay: 0.55, shadow: true },
      'sarcophagus':  { url: `${SPRITE_BASE}/sarcophagus.png`,    wHex: 2.4, hHex: 1.4, ax: 0.5, ay: 0.58, shadow: true },
      'pillar':       { url: `${SPRITE_BASE}/pillar_stone.png`,   wHex: 1.2, hHex: 1.2, ax: 0.5, ay: 0.60, shadow: true },
      'rect':         { url: `${SPRITE_BASE}/crate_rect.png`,     wHex: 2.0, hHex: 1.4, ax: 0.5, ay: 0.58, shadow: true },
      'token.pc':     { url: `${SPRITE_BASE}/token_pc.png`,       wHex: 0.95, hHex: 0.95, ax: 0.5, ay: 0.55, shadow: true },
      'token.en':     { url: `${SPRITE_BASE}/token_enemy.png`,    wHex: 0.95, hHex: 0.95, ax: 0.5, ay: 0.55, shadow: true },
      'token.npc':    { url: `${SPRITE_BASE}/token_npc.png`,      wHex: 0.95, hHex: 0.95, ax: 0.5, ay: 0.55, shadow: true }
    };

    const SPRITE_CACHE = new Map();
    const SPRITE_PROMISES = new Map();

    function spriteDefForKey(key) {
      if (!key) return null;
      const k = String(key).trim().toLowerCase();
      return SPRITE_DEFS[k] || null;
    }

    function spriteKeyForObject(obj) {
      const s = obj && obj.sprite ? String(obj.sprite).trim().toLowerCase() : '';
      if (s && SPRITE_DEFS[s]) return s;

      const k = obj && obj.kind ? String(obj.kind).trim().toLowerCase() : '';
      if (k && SPRITE_DEFS[k]) return k;
      if (k && k.includes('.')) {
        const base = k.split('.')[0];
        if (SPRITE_DEFS[base]) return base;
      }
      return null;
    }

    function spriteKeyForActor(actor) {
      const s = actor && actor.sprite ? String(actor.sprite).trim().toLowerCase() : '';
      if (s && SPRITE_DEFS[s]) return s;
      const side = String(actor?.side || 'NPC').toUpperCase();
      if (side === 'PC') return 'token.pc';
      if (side === 'EN') return 'token.en';
      return 'token.npc';
    }

    function ensureImage(url) {
      const u = String(url || '').trim();
      if (!u) return Promise.reject(new Error('Missing sprite url'));
      if (SPRITE_CACHE.has(u)) {
        const img = SPRITE_CACHE.get(u);
        if (img && img.complete) return Promise.resolve(img);
      }
      if (SPRITE_PROMISES.has(u)) return SPRITE_PROMISES.get(u);

      const p = new Promise((resolve, reject) => {
        const img = new Image();
        img.onload = () => { SPRITE_CACHE.set(u, img); resolve(img); };
        img.onerror = () => reject(new Error('Failed to load sprite: ' + u));
        img.src = u;
      });

      SPRITE_PROMISES.set(u, p);
      return p;
    }

    function isSpriteReady(key) {
      const def = spriteDefForKey(key);
      if (!def) return false;
      const img = SPRITE_CACHE.get(def.url);
      return !!(img && img.complete);
    }

    async function preloadSceneSprites(sceneNorm) {
      const urls = new Set();

      for (const o of (sceneNorm?.objects || [])) {
        const key = spriteKeyForObject(o);
        const def = spriteDefForKey(key);
        if (def?.url) urls.add(def.url);
      }

      for (const a of (sceneNorm?.actors || [])) {
        const key = spriteKeyForActor(a);
        const def = spriteDefForKey(key);
        if (def?.url) urls.add(def.url);
      }

      const promises = Array.from(urls).map(u => ensureImage(u).catch(() => null));
      await Promise.allSettled(promises);
    }

    let LAST_SPRITE_KEYSET = '';
    let SPRITE_REDRAW_SCHEDULED = false;

    function requiredSpriteKeyset(sceneNorm) {
      const keys = [];
      for (const o of (sceneNorm?.objects || [])) {
        const k = spriteKeyForObject(o);
        if (k) keys.push('o:' + k);
      }
      for (const a of (sceneNorm?.actors || [])) {
        const k = spriteKeyForActor(a);
        if (k) keys.push('a:' + k);
      }
      keys.sort();
      return keys.join('|');
    }

    function requestSpritePreload(sceneNorm) {
      const ks = requiredSpriteKeyset(sceneNorm);
      if (!ks || ks === LAST_SPRITE_KEYSET) return;
      LAST_SPRITE_KEYSET = ks;

      preloadSceneSprites(sceneNorm).then(() => {
        if (SPRITE_REDRAW_SCHEDULED) return;
        SPRITE_REDRAW_SCHEDULED = true;
        requestAnimationFrame(() => {
          SPRITE_REDRAW_SCHEDULED = false;
          safeDrawGrid();
        });
      });
    }

    function hexWidthPx() { return 2 * size; }
    function hexHeightPx() { return SQRT3 * size; }

    function drawSoftShadow(x, y, w, h, alpha) {
      const a = (alpha == null) ? 0.18 : alpha;
      ctx.save();
      ctx.globalAlpha = a;
      ctx.fillStyle = 'rgba(0,0,0,1)';
      ctx.beginPath();
      ctx.ellipse(x, y, w * 0.42, h * 0.22, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
    }

    function drawSpriteAt(key, x, y, rotDeg, scaleMul, alphaMul) {
      const def = spriteDefForKey(key);
      if (!def) return false;
      const img = SPRITE_CACHE.get(def.url);
      if (!img || !img.complete) return false;

      const w = (def.wHex ?? 1) * hexWidthPx() * (scaleMul ?? 1);
      const h = (def.hHex ?? 1) * hexHeightPx() * (scaleMul ?? 1);
      const ax = (def.ax ?? 0.5);
      const ay = (def.ay ?? 0.5);

      if (def.shadow) {
        drawSoftShadow(x + 2, y + (h * 0.12), w, h, 0.16);
      }

      ctx.save();
      ctx.globalAlpha = (alphaMul == null) ? 1 : alphaMul;
      ctx.translate(x, y);
      if (rotDeg) ctx.rotate((Math.PI / 180) * rotDeg);
      ctx.drawImage(img, -w * ax, -h * ay, w, h);
      ctx.restore();

      return true;
    }

    // ====== COORDINATE SYSTEM & GRID MATH ======
    function qrToPixel(q, r) {
      const drawR = (rows - 1 - r);
      const columnOffset = (q % 2 === 0) ? 0 : 0.5;
      const x = size * (3/2) * q;
      const y = size * SQRT3 * (drawR + columnOffset);
      return { x: x + margin, y: y + margin };
    }

    function hexCorners(cx, cy) {
      const pts = [];
      for (let i = 0; i < 6; i++) {
        const a = (Math.PI / 180) * (60 * i);
        pts.push({ x: cx + size * Math.cos(a), y: cy + size * Math.sin(a) });
      }
      return pts;
    }

    function drawHexPath(pts) {
      ctx.beginPath();
      ctx.moveTo(pts[0].x, pts[0].y);
      for (let i = 1; i < pts.length; i++) ctx.lineTo(pts[i].x, pts[i].y);
      ctx.closePath();
    }

    function labelFor(q, r) { return `${letters[q]}${r + 1}`; }

    function parseLabel(label) {
      const m = String(label).trim().toUpperCase().match(/^([A-Z])([0-9]{1,2})$/);
      if (!m) return null;
      const q = letters.indexOf(m[1]);
      const r = Number(m[2]) - 1;
      if (q < 0 || q >= cols) return null;
      if (r < 0 || r >= rows) return null;
      return { q, r };
    }

    function labelToPixel(label) {
      const pos = parseLabel(label);
      if (!pos) return null;
      return qrToPixel(pos.q, pos.r);
    }

    // ====== SCENE COERCION HELPERS ======

    function effectLabel(e) {
      if (typeof e === 'string') return e;
      if (e == null) return '';
      const t = typeof e;
      if (t === 'number' || t === 'boolean' || t === 'bigint') return String(e);
      if (t === 'object') {
        const label = e.name ?? e.label ?? e.id ?? e.type;
        if (label != null) return String(label);
        try { return JSON.stringify(e); } catch { return '[effect]'; }
      }
      return String(e);
    }

    function coerceNarration(v) {
      if (v == null) return '';
      if (typeof v === 'string') return v;
      if (Array.isArray(v)) return v.map(x => (x == null ? '' : String(x))).join('\n');
      try { return JSON.stringify(v); } catch { return String(v); }
    }

    function coerceActiveActorId(v) {
      if (v == null) return '';
      try { return String(v).trim(); } catch { return ''; }
    }

    function coerceLastAction(v) {
      if (v == null) return '';
      if (typeof v === 'string') return v;
      if (typeof v !== 'object') return String(v);

      try {
        const actor = v.actorName || v.actor || v.actor_id || v.actorId || '';
        const from = v.from || '';
        const to = v.to || '';
        const movePart = (from && to) ? `${from}‚Üí${to}` : (to ? `‚Üí${to}` : '');

        const atk = v.attack || v.atk || null;
        const dmg = v.damage || v.dmg || null;

        const roll = (atk && (atk.total ?? atk.roll ?? atk.toHit ?? atk.hitRoll)) ?? (v.total ?? v.roll ?? null);
        const weapon = (atk && (atk.name || atk.weapon)) || v.weapon || v.item || '';
        const dmgVal = (dmg && (dmg.value ?? dmg.amount)) ?? v.damageValue ?? v.dmgValue ?? null;

        const note = (typeof v.note === 'string' && v.note.trim()) ? v.note.trim() : '';

        const bits = [];
        if (actor) bits.push(String(actor));
        if (movePart) bits.push(String(movePart));

        const atkBits = [];
        if (roll != null && roll !== '') atkBits.push(`üé≤ ${roll}`);
        if (weapon) atkBits.push(`‚öîÔ∏è ${weapon}`);
        if (dmgVal != null && dmgVal !== '') atkBits.push(`‚Üí ${dmgVal} dmg`);
        if (atkBits.length) bits.push(atkBits.join(' '));

        if (note) bits.push(`‚Äî ${note}`);

        const out = bits.join('  ');
        if (out.trim()) return out;
      } catch (_) {}

      try { return JSON.stringify(v); } catch { return '[action]'; }
    }

    function normalizeScene() {
      const src = (typeof SCENE === 'object' && SCENE) ? SCENE : {};

      const warn = (msg, obj) => {
        try { console.warn(`[Battlemat] ${msg}`, obj ?? ''); } catch (_) {}
      };

      const roomsIn = Array.isArray(src.rooms) ? src.rooms : [];
      const roomsOut = [];
      const roomIds = new Set();
      for (let i = 0; i < roomsIn.length; i++) {
        const r = roomsIn[i] || {};
        const corners = Array.isArray(r.corners) ? r.corners : null;
        if (!corners || corners.length !== 4) {
          warn(`Room skipped: corners must be 4 labels`, r);
          continue;
        }
        if (corners.map(parseLabel).some(p => !p)) {
          warn(`Room skipped: invalid corner label(s)`, r);
          continue;
        }
        let id = String(r.id || '').trim();
        if (!id) id = `room_${i + 1}`;
        if (roomIds.has(id)) {
          warn(`Room id duplicated; making unique: ${id}`, r);
          let k = 2;
          while (roomIds.has(`${id}_${k}`)) k++;
          id = `${id}_${k}`;
        }
        roomIds.add(id);

        const floorKind = String(r.floorKind ?? r.floor_kind ?? '').trim();
        const wallKind = String(r.wallKind ?? r.wall_kind ?? '').trim();

        let floor = null;
        if (r.floor && typeof r.floor === 'object') floor = r.floor;
        else if (floorKind) floor = { kind: floorKind };

        let wall = null;
        if (r.wall && typeof r.wall === 'object') wall = r.wall;
        else if (wallKind) wall = { kind: wallKind };

        roomsOut.push({
          id,
          corners: corners.map(c => String(c).trim().toUpperCase()),
          thickness: Number(r.thickness ?? 18),
          color: String(r.color || '#555'),
          floor,
          wall
        });
      }

      const openingsIn = Array.isArray(src.openings) ? src.openings : [];
      const openingsOut = [];
      for (let i = 0; i < openingsIn.length; i++) {
        const o = openingsIn[i] || {};
        const kind = String(o.kind || 'door').toLowerCase();
        if (kind !== 'door' && kind !== 'window') {
          warn(`Opening skipped: kind must be door/window`, o);
          continue;
        }
        const room = String(o.room || '').trim();
        if (!room || !roomIds.has(room)) {
          warn(`Opening skipped: unknown room id '${room}'`, o);
          continue;
        }
        const wall = String(o.wall || '').trim().toUpperCase();
        if (!['N','S','E','W'].includes(wall)) {
          warn(`Opening skipped: wall must be N/S/E/W`, o);
          continue;
        }
        const at = String(o.at || '').trim().toUpperCase();
        if (!parseLabel(at)) {
          warn(`Opening skipped: invalid at label`, o);
          continue;
        }
        const state = String((o.state ?? 'closed')).toLowerCase();
        openingsOut.push({ ...o, kind, room, wall, at, state });
      }

      const objectsIn = Array.isArray(src.objects) ? src.objects : [];
      const objectsOut = [];
      for (let i = 0; i < objectsIn.length; i++) {
        const o = objectsIn[i] || {};
        const kind = String(o.kind || 'object').toLowerCase();
        const blocks = Boolean(o.blocks ?? false);

        let cells = [];
        if (Array.isArray(o.cells) && o.cells.length) {
          cells = o.cells.map(c => String(c).trim().toUpperCase()).filter(Boolean);
        } else if (o.at) {
          cells = [String(o.at).trim().toUpperCase()];
        }

        cells = cells.filter(lab => !!parseLabel(lab));
        if (!cells.length) {
          warn('Object skipped: missing/invalid at/cells', o);
          continue;
        }

        objectsOut.push({
          ...o,
          kind,
          blocks,
          cells,
          label: (o.label != null) ? String(o.label) : null,
          color: (o.color != null) ? String(o.color) : null
        });
      }

      const actorsIn = Array.isArray(src.actors) ? src.actors : [];
      const actorsOut = [];
      for (let i = 0; i < actorsIn.length; i++) {
        const a = actorsIn[i] || {};
        const at = String(a.at || '').trim().toUpperCase();
        if (!parseLabel(at)) {
          warn(`Actor skipped: invalid at label`, a);
          continue;
        }
        const side = String(a.side || 'NPC').toUpperCase();
        actorsOut.push({ ...a, at, side: (side === 'PC' || side === 'EN') ? side : 'NPC' });
      }

      const poiIn = Array.isArray(src.poi) ? src.poi : [];
      const poiOut = [];
      const poiIds = new Set();

      for (let i = 0; i < poiIn.length; i++) {
        const p = poiIn[i] || {};
        const type = String(p.type || '').trim().toLowerCase();
        if (!type) continue;

        let id = String(p.id || '').trim();
        if (!id) id = `poi_${i + 1}`;
        if (poiIds.has(id)) {
          let k = 2;
          while (poiIds.has(`${id}_${k}`)) k++;
          id = `${id}_${k}`;
        }
        poiIds.add(id);

        if (type === 'arrow') {
          const from = String(p.from || '').trim().toUpperCase();
          const to = String(p.to || '').trim().toUpperCase();
          if (!parseLabel(from) || !parseLabel(to)) {
            warn('POI arrow skipped: invalid from/to', p);
            continue;
          }
          poiOut.push({
            ...p,
            id,
            type,
            from,
            to,
            color: String(p.color || 'rgba(40,40,40,0.65)'),
            width: Number(p.width ?? 4),
            label: (p.label != null) ? String(p.label) : ''
          });
          continue;
        }

        poiOut.push({ ...p, id, type });
      }

      return {
        round: Number(src.round ?? 1),
        activeActorId: coerceActiveActorId(src.active_actor_id ?? src.activeActorId ?? src?.ui?.active_actor_id ?? src?.ui?.activeActorId),
        lastAction: coerceLastAction(src.lastAction ?? src.last_action ?? src.action),
        narration: coerceNarration(src.narration ?? src.notes ?? src.narrative),
        rooms: roomsOut,
        openings: openingsOut,
        objects: objectsOut,
        actors: actorsOut,
        poi: poiOut
      };
    }

    // ====== POI (Annotations) ======
    function drawArrowPx(x1, y1, x2, y2, color, width, label) {
      const dx = x2 - x1;
      const dy = y2 - y1;
      const len = Math.max(1, Math.hypot(dx, dy));
      const ux = dx / len;
      const uy = dy / len;

      const inset = size * 0.55;
      const sx = x1 + ux * inset;
      const sy = y1 + uy * inset;
      const ex = x2 - ux * inset;
      const ey = y2 - uy * inset;

      ctx.save();
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';

      ctx.globalAlpha = 0.35;
      ctx.beginPath();
      ctx.moveTo(sx, sy);
      ctx.lineTo(ex, ey);
      ctx.strokeStyle = 'rgba(255,255,255,1)';
      ctx.lineWidth = Math.max(3, Number(width || 4) + 2);
      ctx.stroke();

      ctx.globalAlpha = 1;
      ctx.beginPath();
      ctx.moveTo(sx, sy);
      ctx.lineTo(ex, ey);
      ctx.strokeStyle = color || 'rgba(40,40,40,0.65)';
      ctx.lineWidth = Math.max(2, Number(width || 4));
      ctx.stroke();

      const headLen = Math.max(10, size * 0.45);
      const headW = headLen * 0.75;
      const angle = Math.atan2(ey - sy, ex - sx);

      ctx.save();
      ctx.translate(ex, ey);
      ctx.rotate(angle);
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.lineTo(-headLen, headW * 0.5);
      ctx.lineTo(-headLen, -headW * 0.5);
      ctx.closePath();
      ctx.fillStyle = color || 'rgba(40,40,40,0.65)';
      ctx.fill();
      ctx.restore();

      if (label) {
        const mx = (sx + ex) / 2;
        const my = (sy + ey) / 2;
        const txt = String(label).slice(0, 20);
        ctx.font = 'bold 12px ui-monospace, system-ui, sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'bottom';
        ctx.fillStyle = 'rgba(255,255,255,0.90)';
        ctx.fillText(txt, mx, my - 2);
        ctx.fillStyle = 'rgba(0,0,0,0.65)';
        ctx.fillText(txt, mx, my - 3);
      }

      ctx.restore();
    }

    const POI_DRAG = { active: false, from: null, to: null };

    function drawPoi() {
      const poi = Array.isArray(SCENE_NORM?.poi) ? SCENE_NORM.poi : [];
      for (const p of poi) {
        if (!p || String(p.type || '').toLowerCase() !== 'arrow') continue;
        const a = labelToPixel(p.from);
        const b = labelToPixel(p.to);
        if (!a || !b) continue;
        drawArrowPx(a.x, a.y, b.x, b.y, p.color, p.width, p.label);
      }

      if (POI_DRAG.active && POI_DRAG.from && POI_DRAG.to) {
        const a = labelToPixel(POI_DRAG.from);
        const b = labelToPixel(POI_DRAG.to);
        if (a && b) drawArrowPx(a.x, a.y, b.x, b.y, 'rgba(40,40,40,0.40)', 3, '');
      }
    }

    function nearestHexLabelFromPixel(px, py) {
      let best = null;
      let bestD = Infinity;
      for (let q = 0; q < cols; q++) {
        for (let r = 0; r < rows; r++) {
          const p = qrToPixel(q, r);
          const d = Math.hypot(px - p.x, py - p.y);
          if (d < bestD) {
            bestD = d;
            best = labelFor(q, r);
          }
        }
      }
      if (bestD > size * 0.95) return null;
      return best;
    }

    function canvasEventToLocalPx(ev) {
      const rect = canvas.getBoundingClientRect();
      const x = (ev.clientX - rect.left) * (canvas.width / rect.width);
      const y = (ev.clientY - rect.top) * (canvas.height / rect.height);
      return { x, y };
    }

    function addArrowPoi(from, to) {
      if (!from || !to || from === to) return;

      const el = document.getElementById('scene-json');
      const raw = el ? String(el.textContent || '').trim() : '';
      if (!raw) return;

      let obj;
      try { obj = JSON.parse(raw); } catch { return; }
      if (!obj || typeof obj !== 'object') return;

      if (!Array.isArray(obj.poi)) obj.poi = [];

      const hasCrypto = (typeof crypto !== 'undefined') && crypto && typeof crypto.randomUUID === 'function';
      const id = hasCrypto ? `poi_${crypto.randomUUID()}` : `poi_${Date.now()}_${Math.floor(Math.random()*1e6)}`;

      obj.poi.push({ id, type: 'arrow', from, to, color: 'rgba(40,40,40,0.65)', width: 4, label: '' });

      el.textContent = JSON.stringify(obj, null, 2);
      safeDrawGrid();

      try {
        const battleId = getBattleIdFromUrl();
        if (battleId) saveSceneToApi(battleId, obj).catch(() => {});
      } catch (_) {}
    }

    canvas.addEventListener('mousedown', (ev) => {
      if (ev.button !== 0) return;
      if (!ev.shiftKey) return;
      const p = canvasEventToLocalPx(ev);
      const lab = nearestHexLabelFromPixel(p.x, p.y);
      if (!lab) return;
      POI_DRAG.active = true;
      POI_DRAG.from = lab;
      POI_DRAG.to = lab;
      safeDrawGrid();
    });

    canvas.addEventListener('mousemove', (ev) => {
      if (!POI_DRAG.active) return;
      const p = canvasEventToLocalPx(ev);
      const lab = nearestHexLabelFromPixel(p.x, p.y);
      if (!lab) return;
      if (POI_DRAG.to !== lab) {
        POI_DRAG.to = lab;
        safeDrawGrid();
      }
    });

    function endPoiDrag(commit) {
      if (!POI_DRAG.active) return;
      const from = POI_DRAG.from;
      const to = POI_DRAG.to;
      POI_DRAG.active = false;
      POI_DRAG.from = null;
      POI_DRAG.to = null;
      if (commit) addArrowPoi(from, to);
      else safeDrawGrid();
    }

    canvas.addEventListener('mouseup', () => {
      if (!POI_DRAG.active) return;
      endPoiDrag(true);
    });

    canvas.addEventListener('mouseleave', () => {
      if (!POI_DRAG.active) return;
      endPoiDrag(false);
    });

    // ====== ROOM GEOMETRY (RECT WALLS) ======
    function getRoomGeom(room) {
      const c = Array.isArray(room.corners) ? room.corners : null;
      if (!c || c.length !== 4) return null;

      const pTL = labelToPixel(c[0]);
      const pTR = labelToPixel(c[1]);
      const pBR = labelToPixel(c[2]);
      const pBL = labelToPixel(c[3]);
      if (!pTL || !pTR || !pBR || !pBL) return null;

      const hexH = SQRT3 * size;
      const yInset = hexH * CONFIG.room.yInsetFrac;

      return {
        id: String(room.id || ''),
        leftX:  pTL.x,
        rightX: pTR.x,
        topY:   pTL.y + yInset,
        botY:   pBL.y - yInset,
        thickness: Number(room.thickness ?? 18),
        color: String(room.color || 'rgba(0,0,0,0.88)')
      };
    }

    function drawRooms() {
      const rooms = Array.isArray(SCENE_NORM?.rooms) ? SCENE_NORM.rooms : [];
      if (!rooms.length || !ROOM_GEOMS) return;

      for (const room of rooms) {
        const g = ROOM_GEOMS.get(String(room.id || ''));
        if (!g) continue;

        if (TEX.enabled) {
          drawTexturedRoom(room, g);
          continue;
        }

        ctx.save();
        ctx.globalAlpha = 1.0;
        ctx.strokeStyle = g.color;
        ctx.lineWidth = g.thickness;
        ctx.lineJoin = 'miter';
        ctx.lineCap = 'butt';

        ctx.beginPath();
        ctx.moveTo(g.leftX,  g.topY);
        ctx.lineTo(g.rightX, g.topY);
        ctx.lineTo(g.rightX, g.botY);
        ctx.lineTo(g.leftX,  g.botY);
        ctx.closePath();
        ctx.stroke();

        ctx.restore();
      }
    }

    // ====== OBJECTS ======
    function objectCentroidPx(cells) {
      let sx = 0, sy = 0, n = 0;
      for (const lab of (cells || [])) {
        const p = labelToPixel(lab);
        if (!p) continue;
        sx += p.x; sy += p.y; n++;
      }
      if (!n) return null;
      return { x: sx / n, y: sy / n };
    }

    function objectBoundsPx(cells) {
      let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
      let n = 0;
      for (const lab of (cells || [])) {
        const p = labelToPixel(lab);
        if (!p) continue;
        minX = Math.min(minX, p.x);
        minY = Math.min(minY, p.y);
        maxX = Math.max(maxX, p.x);
        maxY = Math.max(maxY, p.y);
        n++;
      }
      if (!n) return null;
      return { minX, minY, maxX, maxY };
    }

    function roundRectPath(x, y, w, h, r) {
      const rr = Math.max(0, Math.min(r, Math.min(w, h) / 2));
      ctx.beginPath();
      ctx.moveTo(x + rr, y);
      ctx.arcTo(x + w, y, x + w, y + h, rr);
      ctx.arcTo(x + w, y + h, x, y + h, rr);
      ctx.arcTo(x, y + h, x, y, rr);
      ctx.arcTo(x, y, x + w, y, rr);
      ctx.closePath();
    }

    function drawObjects() {
      const objs = Array.isArray(SCENE_NORM?.objects) ? SCENE_NORM.objects : [];
      if (!objs.length) return;

      for (const obj of objs) {
        const cells = Array.isArray(obj.cells) ? obj.cells : [];
        if (!cells.length) continue;

        const blocks = Boolean(obj.blocks);
        const kind = String(obj.kind || 'object').toLowerCase();
        const glyph = (obj.label != null && String(obj.label).trim())
          ? String(obj.label).trim().slice(0, 3)
          : kind.slice(0, 1).toUpperCase();

        const fill = obj.color
          ? String(obj.color)
          : (blocks ? 'rgba(0,0,0,0.20)' : 'rgba(0,0,0,0.10)');

        if (kind !== 'table' && kind !== 'rect' && kind !== 'sarcophagus' && kind !== 'pillar') {
          for (let i = 0; i < cells.length; i++) {
            const lab = String(cells[i]).trim().toUpperCase();
            const p = labelToPixel(lab);
            if (!p) continue;

            const pts = hexCorners(p.x, p.y);
            drawHexPath(pts);
            ctx.save();
            ctx.fillStyle = fill;
            ctx.fill();

            ctx.lineWidth = 1;
            ctx.strokeStyle = 'rgba(0,0,0,0.18)';
            ctx.stroke();

            if (kind === 'difficult' || i === 0) {
              ctx.font = 'bold 12px ui-monospace, system-ui, sans-serif';
              ctx.fillStyle = 'rgba(0,0,0,0.55)';
              ctx.textAlign = 'center';
              ctx.textBaseline = 'middle';
              ctx.fillText(glyph, p.x, p.y);
            }

            ctx.restore();
          }
          continue;
        }

        const spriteKey = spriteKeyForObject(obj);
        const rot = Number(obj.rot ?? 0);

        if (spriteKey && isSpriteReady(spriteKey)) {
          const c = objectCentroidPx(cells);
          if (c) {
            const yBias = size * 0.10;
            drawSpriteAt(spriteKey, c.x, c.y + yBias, rot, 1, 1);

            if (obj.label != null && String(obj.label).trim()) {
              ctx.save();
              ctx.font = 'bold 13px ui-monospace, system-ui, sans-serif';
              ctx.fillStyle = 'rgba(0,0,0,0.55)';
              ctx.textAlign = 'center';
              ctx.textBaseline = 'middle';
              ctx.fillText(String(obj.label).trim().slice(0, 3), c.x, c.y);
              ctx.restore();
            }
            continue;
          }
        }

        if (kind === 'table') {
          const c = objectCentroidPx(cells);
          if (!c) continue;
          const radius = size * 1.25;

          ctx.save();
          ctx.beginPath();
          ctx.arc(c.x, c.y, radius, 0, Math.PI * 2);
          ctx.fillStyle = '#b07a3f';
          ctx.fill();

          ctx.lineWidth = 2;
          ctx.strokeStyle = 'rgba(0,0,0,0.85)';
          ctx.stroke();

          const tLabel = (obj.label != null && String(obj.label).trim()) ? String(obj.label).trim().slice(0, 3) : 'T';
          ctx.font = 'bold 14px ui-monospace, system-ui, sans-serif';
          ctx.fillStyle = 'rgba(0,0,0,0.85)';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText(tLabel, c.x, c.y);

          ctx.restore();
        }

        if (kind === 'rect' || kind === 'sarcophagus') {
          const c = objectCentroidPx(cells);
          const b = objectBoundsPx(cells);
          if (!c || !b) continue;

          const padX = size * 0.85;
          const padY = size * 0.55;
          const w = (b.maxX - b.minX) + padX * 2;
          const h = (b.maxY - b.minY) + padY * 2;

          const radius = Math.max(6, Math.min(size * 0.35, Math.min(w, h) * 0.25));
          const fillRect = obj.color ? String(obj.color) : '#b07a3f';
          const outline = 'rgba(0,0,0,0.85)';
          const labelRect = (obj.label != null && String(obj.label).trim()) ? String(obj.label).trim().slice(0, 3) : (kind === 'sarcophagus' ? 'S' : 'R');

          ctx.save();
          ctx.translate(c.x, c.y);
          if (rot) ctx.rotate((Math.PI / 180) * rot);

          roundRectPath(-w/2, -h/2, w, h, radius);
          ctx.fillStyle = fillRect;
          ctx.fill();
          ctx.lineWidth = 2;
          ctx.strokeStyle = outline;
          ctx.stroke();

          ctx.font = 'bold 14px ui-monospace, system-ui, sans-serif';
          ctx.fillStyle = 'rgba(0,0,0,0.85)';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText(labelRect, 0, 0);

          ctx.restore();
        }

        if (kind === 'pillar') {
          const c = objectCentroidPx(cells);
          if (!c) continue;
          ctx.save();
          ctx.beginPath();
          ctx.arc(c.x, c.y, size * 0.60, 0, Math.PI * 2);
          ctx.fillStyle = obj.color ? String(obj.color) : 'rgba(0,0,0,0.20)';
          ctx.fill();
          ctx.lineWidth = 2;
          ctx.strokeStyle = 'rgba(0,0,0,0.70)';
          ctx.stroke();
          ctx.restore();
        }
      }
    }

    // ====== OPENINGS (DOORS/WINDOWS) ======
    function drawOpenings() {
      const openings = Array.isArray(SCENE_NORM?.openings) ? SCENE_NORM.openings : [];
      if (!openings.length || !ROOM_GEOMS) return;

      for (const o of openings) {
        const kind = String(o.kind || 'door').toLowerCase();
        if (kind !== 'door' && kind !== 'window') continue;

        const state = String(o.state ?? 'closed').toLowerCase();

        const g = ROOM_GEOMS.get(String(o.room || ''));
        if (!g) continue;

        const wall = String(o.wall || '').toUpperCase();
        const atPx = labelToPixel(o.at);
        if (!atPx) continue;

        let x = atPx.x;
        let y = atPx.y;
        if (wall === 'N') y = g.topY;
        else if (wall === 'S') y = g.botY;
        else if (wall === 'E') x = g.rightX;
        else if (wall === 'W') x = g.leftX;
        else continue;

        const thicknessAcross = Number(o.thicknessAcross ?? Math.max(CONFIG.opening.minAcross, g.thickness * CONFIG.opening.acrossMul));
        const spanAlong = (wall === 'N' || wall === 'S')
          ? Number(o.spanAlong ?? (CONFIG.opening.spanNSMul * size))
          : Number(o.spanAlong ?? (CONFIG.opening.spanEWMul * SQRT3 * size));

        const rectW = (wall === 'N' || wall === 'S') ? spanAlong : thicknessAcross;
        const rectH = (wall === 'N' || wall === 'S') ? thicknessAcross : spanAlong;

        ctx.save();
        ctx.translate(x, y);

        const isDoor = (kind === 'door');
        const isWindow = (kind === 'window');
        const isOpen = (state === 'open');

        if (isOpen) {
          if (isWindow) {
            ctx.fillStyle = '#eeeeee';
            ctx.strokeStyle = '#eeeeee';
            ctx.lineWidth = 1;
          } else {
            ctx.fillStyle = '#ffffff';
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 0;
          }
        } else {
          if (isDoor) ctx.fillStyle = '#b07a3f';
          else ctx.fillStyle = '#cfe6f6';
          ctx.strokeStyle = 'rgba(0,0,0,0.6)';
          ctx.lineWidth = 2;
        }

        ctx.beginPath();
        ctx.rect(-rectW/2, -rectH/2, rectW, rectH);
        ctx.fill();
        ctx.stroke();

        ctx.font = 'bold 12px ui-monospace, system-ui, sans-serif';
        if (Math.max(rectW, rectH) >= 55) ctx.font = 'bold 13px ui-monospace, system-ui, sans-serif';
        if (!isOpen) {
          ctx.fillStyle = 'rgba(0,0,0,0.55)';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText(isWindow ? 'W' : 'D', 0, 0);
        }

        ctx.restore();
      }
    }

    function drawToken(q, r, label, side, dead, actorObj) {
      const { x, y } = qrToPixel(q, r);

      const tokenKey = actorObj ? spriteKeyForActor(actorObj) : ((side === 'PC') ? 'token.pc' : (side === 'EN' ? 'token.en' : 'token.npc'));
      const alpha = dead ? 0.55 : 1.0;

      if (tokenKey && isSpriteReady(tokenKey)) {
        drawSpriteAt(tokenKey, x, y + (size * 0.10), 0, 1, alpha);

        ctx.save();
        ctx.font = 'bold 13px ui-monospace, system-ui, sans-serif';
        ctx.fillStyle = dead ? 'rgba(0,0,0,0.28)' : 'rgba(0,0,0,0.60)';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(label, x, y);
        ctx.restore();
        return;
      }

      let fill = 'rgba(160,160,160,0.95)';
      if (dead) fill = 'rgba(140,140,140,0.85)';
      else if (side === 'PC') fill = 'rgba(80,160,220,0.95)';
      else if (side === 'EN') fill = 'rgba(220,120,80,0.95)';

      ctx.beginPath();
      ctx.arc(x, y, size * 0.40, 0, Math.PI * 2);
      ctx.fillStyle = fill;
      ctx.fill();

      ctx.lineWidth = 0.75;
      ctx.strokeStyle = 'rgba(0,0,0,0.85)';
      ctx.stroke();

      ctx.font = 'bold 14px ui-monospace, system-ui, sans-serif';
      ctx.fillStyle = dead ? 'rgba(0,0,0,0.35)' : 'rgba(0,0,0,0.72)';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(label, x, y);
    }

    function drawHexOverlay() {
      for (let q = 0; q < cols; q++) {
        for (let r = 0; r < rows; r++) {
          const { x, y } = qrToPixel(q, r);
          const pts = hexCorners(x, y);
          drawHexPath(pts);
          ctx.lineWidth = CONFIG.grid.overlayStrokeW;
          ctx.strokeStyle = `rgba(0,0,0,${CONFIG.grid.overlayStrokeA})`;
          ctx.stroke();
        }
      }
    }

    function drawGrid() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      ctx.fillStyle = '#d7d7d7';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      for (let q = 0; q < cols; q++) {
        for (let r = 0; r < rows; r++) {
          const { x, y } = qrToPixel(q, r);
          const pts = hexCorners(x, y);

          drawHexPath(pts);
          ctx.fillStyle = '#ffffff';
          ctx.fill();

          ctx.lineWidth = CONFIG.grid.baseStrokeW;
          ctx.strokeStyle = `rgba(0,0,0,${CONFIG.grid.baseStrokeA})`;
          ctx.stroke();
        }
      }

      SCENE = loadSceneFromJsonTag();
      SCENE_NORM = normalizeScene();

      requestSpritePreload(SCENE_NORM);

      ROOM_GEOMS = new Map();
      for (const room of (SCENE_NORM?.rooms || [])) {
        const g = getRoomGeom(room);
        if (g && g.id) ROOM_GEOMS.set(g.id, g);
      }

      drawRooms();
      drawOpenings();
      drawObjects();
      drawHexOverlay();

      updateTrailsFromPending();
      drawMoveTrails();

      drawPoi();

      const LABEL_DY = size * CONFIG.labels.dyFrac;
      ctx.font = '13px "Times New Roman", Georgia, "Century Schoolbook", "Book Antiqua", serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';

      // Make labels pop inside rooms, fade away outside rooms.
      const inAnyRoomInterior = (px, py) => {
        if (!ROOM_GEOMS || !ROOM_GEOMS.size) return false;
        for (const g of ROOM_GEOMS.values()) {
          const half = Math.max(1, Number(g.thickness || 18) / 2);
          const ix1 = g.leftX + half;
          const ix2 = g.rightX - half;
          const iy1 = g.topY + half;
          const iy2 = g.botY - half;
          if (px >= ix1 && px <= ix2 && py >= iy1 && py <= iy2) return true;
        }
        return false;
      };

      const inRGB = CONFIG.labels.inRoomColor || [245,245,245];
      const outRGB = CONFIG.labels.outRoomColor || [255,255,255];
      const inA = Number(CONFIG.labels.inRoomAlpha ?? 0.55);
      const outA = Number(CONFIG.labels.outRoomAlpha ?? 0.06);

      for (let q = 0; q < cols; q++) {
        for (let r = 0; r < rows; r++) {
          const { x, y } = qrToPixel(q, r);
          const inRoom = inAnyRoomInterior(x, y);
          const rgb = inRoom ? inRGB : outRGB;
          const a = inRoom ? inA : outA;
          ctx.fillStyle = `rgba(${rgb[0]},${rgb[1]},${rgb[2]},${a})`;
          ctx.fillText(labelFor(q, r), x, y + LABEL_DY);
        }
      }

      for (const a of (SCENE_NORM?.actors || [])) {
        const pos = parseLabel(a.at);
        if (!pos) continue;
        const isDead = Number(a.hp ?? 0) <= 0 || (Array.isArray(a.effects) && (a.effects.includes('dead') || a.effects.includes('down')));
        drawToken(pos.q, pos.r, a.label || a.name?.slice(0, 1) || '?', a.side, isDead, a);
      }

      renderStatus();
    }

    // Notes (Narration) persistence
    const NOTES = {
      battleId: null,
      keyNarr: null,
      debounce: null,
      dirty: false,
      lastSceneNarration: ''
    };

    function notesKey(base, battleId) {
      return `battlemat:${base}:${battleId || 'local'}`;
    }

    function initNotesUi(battleId) {
      NOTES.battleId = battleId || null;
      NOTES.keyNarr = notesKey('narration', battleId);

      const narr = document.getElementById('narrationBox');
      const fallback = String(SCENE_NORM?.narration || '').trim();
      NOTES.lastSceneNarration = fallback;

      try {
        const stored = localStorage.getItem(NOTES.keyNarr) || '';
        if (narr) narr.value = stored || fallback;
        NOTES.dirty = !!stored;
      } catch (_) {
        if (narr) narr.value = fallback;
        NOTES.dirty = false;
      }

      const save = () => {
        try {
          if (narr) localStorage.setItem(NOTES.keyNarr, narr.value || '');
        } catch (_) {}
      };

      const onInput = () => {
        NOTES.dirty = true;
        if (NOTES.debounce) clearTimeout(NOTES.debounce);
        NOTES.debounce = setTimeout(save, 200);
      };

      narr?.addEventListener('input', onInput);
    }

    function syncNarrationFromScene() {
      const narr = document.getElementById('narrationBox');
      if (!narr) return;

      const sceneText = String(SCENE_NORM?.narration || '').trim();
      if (!sceneText) return;

      const cur = String(narr.value || '');
      const curTrim = cur.trim();
      const last = String(NOTES.lastSceneNarration || '').trim();

      if (NOTES.dirty && curTrim !== last) return;
      if (document.activeElement === narr && curTrim !== last) return;

      if (!curTrim || curTrim === last) {
        narr.value = sceneText;
        NOTES.lastSceneNarration = sceneText;
      }
    }

    function renderStatus() {
      const tbody = document.getElementById('statusBody');
      const roundLine = document.getElementById('roundLine');
      if (!tbody || !roundLine) return;

      if (SCENE_PARSE_ERROR) roundLine.textContent = 'SCENE JSON ERROR';
      else roundLine.textContent = `Round ${SCENE_NORM?.round ?? '‚Äî'}`;

      const actionLine = document.getElementById('actionLine');
      const la = String(SCENE_NORM?.lastAction || '').trim();
      if (actionLine) {
        if (la) {
          actionLine.style.display = 'block';
          actionLine.textContent = la;
        } else {
          actionLine.style.display = 'none';
          actionLine.textContent = '';
        }
      }

      syncNarrationFromScene();

      const actors = Array.isArray(SCENE_NORM?.actors) ? SCENE_NORM.actors.slice() : [];
      actors.sort((a, b) => {
        const ai = Number(a.init ?? 0);
        const bi = Number(b.init ?? 0);
        if (bi !== ai) return bi - ai;
        return String(a.name ?? a.id).localeCompare(String(b.name ?? b.id));
      });

            const activeId = String(SCENE_NORM?.activeActorId || '').trim();

      tbody.innerHTML = '';
      for (const a of actors) {
        const tr = document.createElement('tr');
        const hpVal = Number(a.hp ?? 0);
        const effectsArr = Array.isArray(a.effects) ? a.effects : [];
        const isDead = hpVal <= 0 || effectsArr.includes('dead') || effectsArr.includes('down');

        const side = String(a.side || 'NPC').toUpperCase();
        const isActive = activeId && String(a.id || '').trim() === activeId;
        tr.className =
          (side === 'PC' ? 'side-pc' : (side === 'EN' ? 'side-en' : 'side-npc')) +
          (isDead ? ' dead' : '') +
          (isActive ? ' active-turn' : '');

        const effects = Array.isArray(a.effects) ? a.effects : [];
        const effectsHtml = effects.length
          ? effects.map(e => `<span class="chip">${escapeHtml(effectLabel(e))}</span>`).join('')
          : '';

        tr.innerHTML = `
          <td>
            <div style="display:flex; align-items:baseline; gap:8px; flex-wrap:wrap;">
              <span style="font-weight:650;">${escapeHtml((isActive ? '‚ñ∂ ' : '') + (a.name ?? a.id ?? 'Actor'))}</span>
              <span class="subtle">${escapeHtml(a.at ?? '')}</span>
            </div>
            ${effectsHtml ? `<div style="margin-top:4px;">${effectsHtml}</div>` : ''}
          </td>
          <td class="hp">${escapeHtml(String(a.init ?? 0))}</td>
          <td class="hp">${escapeHtml(String(a.hp ?? '‚Äî'))} / ${escapeHtml(String(a.maxHp ?? '‚Äî'))}</td>
        `;

        tbody.appendChild(tr);
      }
    }

    function escapeHtml(s) {
      return String(s)
        .replaceAll('&', '&amp;')
        .replaceAll('<', '&lt;')
        .replaceAll('>', '&gt;')
        .replaceAll('"', '&quot;')
        .replaceAll("'", '&#39;');
    }

    function safeDrawGrid() {
      try {
        drawGrid();
      } catch (e) {
        console.error('[Battlemat] drawGrid failed:', e);
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = '#d7d7d7';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = 'rgba(0,0,0,0.65)';
        ctx.font = '14px ui-monospace, system-ui, sans-serif';
        ctx.textAlign = 'left';
        ctx.textBaseline = 'top';
        ctx.fillText('Battlemat render error (see console).', 14, 14);
      }
    }

    // Minimal self-tests (safe in production; they only log if something is off)
    function runSelfTests() {
      try {
        console.assert(typeof modeDelayMs === 'function', 'modeDelayMs should exist');
        console.assert(modeDelayMs(RefreshMode.FAST) === FAST_MS, 'FAST delay should be 5000ms');
        console.assert(modeDelayMs(RefreshMode.S15) === S15_MS, '15s delay should be 15000ms');
        console.assert(modeDelayMs(RefreshMode.S30) === S30_MS, '30s delay should be 30000ms');
        console.assert(modeDelayMs(RefreshMode.S60) === S60_MS, '60s delay should be 60000ms');
        console.assert(FAST_TO_15_IDLE_MS === 60000, 'FAST‚Üí15 idle should be 60s');
        console.assert(S15_TO_30_IDLE_MS === 180000, '15‚Üí30 idle should be 3m');
        console.assert(S30_TO_60_IDLE_MS === 300000, '30‚Üí60 idle should be 5m');
        console.assert(S60_TO_OFF_IDLE_MS === 600000, '60‚ÜíOff idle should be 10m');

        // lastAction + narration + effects robustness
        console.assert(coerceActiveActorId(' pc1 ') === 'pc1', 'coerceActiveActorId should trim');
        console.assert(coerceLastAction({ a: 1 }).includes('a'), 'coerceLastAction should stringify objects');
        console.assert(coerceNarration({ n: 1 }).includes('n'), 'coerceNarration should stringify objects');
        console.assert(effectLabel({ name: 'Poisoned' }) === 'Poisoned', 'effectLabel should prefer name');
        console.assert(effectLabel({ label: 'Stunned' }) === 'Stunned', 'effectLabel should prefer label');
        console.assert(effectLabel(7) === '7', 'effectLabel should stringify primitives');

        // texture kind parsing
        const n1 = normalizeTextureKind('wood:pine');
        console.assert(n1.base === 'wood' && n1.variant === 'pine' && n1.key === 'wood:pine', 'normalizeTextureKind wood:pine');
        const n2 = normalizeTextureKind('stone.cobble');
        console.assert(n2.base === 'stone' && n2.variant === 'cobble' && n2.key === 'stone:cobble', 'normalizeTextureKind stone.cobble');
        const n3 = normalizeTextureKind('cobblestone');
        console.assert(n3.base === 'stone' && n3.variant === 'cobble', 'normalizeTextureKind cobblestone');

        // textures should be callable
        console.assert(typeof texturePatternFor === 'function', 'texturePatternFor should exist');
        console.assert(!!texturePatternFor('stone'), 'texturePatternFor(stone) should return a pattern');
        console.assert(typeof drawTexturedRoom === 'function', 'drawTexturedRoom should exist');

        // wood texture should still generate a tile canvas (and not throw)
        const wtile = textureTileFor('wood:oak');
        console.assert(!!wtile && wtile.width > 0 && wtile.height > 0, 'wood:oak tile should exist');
        const wtile2 = textureTileFor('wood:pine');
        console.assert(!!wtile2 && wtile2.width > 0 && wtile2.height > 0, 'wood:pine tile should exist');
      } catch (_) {}
    }

    // Boot
    (async () => {
      await tryLoadSceneFromApi();

      // Textures toggle (persisted) ‚Äî set before first render so the first frame matches UI state.
      TEX.enabled = readTexturePref();
      setTextureUi();
      initTextureSelectors();

      safeDrawGrid();

      const bid = getBattleIdFromUrl();
      initNotesUi(bid);
      runSelfTests();

      REFRESH.battleId = bid;
      REFRESH.lastChangeAt = Date.now();

      if (REFRESH.battleId) {
        try {
          const { versionKey } = await fetchSceneAndVersionKey(REFRESH.battleId);
          if (versionKey) REFRESH.lastVersionKey = versionKey;
        } catch (_) {}

        let restore = RefreshMode.S60;
        let autoPref = 'auto';
        try {
          autoPref = (localStorage.getItem(`battlemat:refresh:auto:${REFRESH.battleId}`) || 'auto').trim();
          const saved = (localStorage.getItem(`battlemat:refresh:last:${REFRESH.battleId}`) || '').trim();
          if (saved && saved !== RefreshMode.OFF) restore = saved;
        } catch (_) {}

        setRefreshMode(autoPref === 'off' ? RefreshMode.OFF : restore);
      } else {
        setRefreshMode(RefreshMode.OFF);
      }
    })();
  </script>
</body>
</html>
