<!doctype html>
<!--
  Battlemat - V4
  Version 4.21

  Notes:
  - Restores full room/wall rendering pipeline (walls/floors/doors/windows) while keeping the grid + labels drawn on top.
  - Textures are always ON (no toggle).
  - Brick texture uses small, consistent medium-gray bricks.
-->
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Battlemat - V4</title>
  <style>
    :root{
      --bg:#f5f6f7;
      --panel:#ffffff;
      --line:#e6e8eb;
      --text:#111827;
      --muted:#6b7280;
      --pill:#f3f4f6;
      --shadow:0 10px 30px rgba(0,0,0,.06);
      --radius:12px;
    }
    html,body{height:100%; margin:0; font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,Arial,sans-serif; color:var(--text); background:var(--bg);}
    .app{display:grid; grid-template-columns: 1fr 340px; gap:16px; padding:16px; height:100%; box-sizing:border-box;}
    .left{display:flex; flex-direction:column; gap:10px; min-width:0;}

    .stage{flex:1; background:var(--panel); border:1px solid var(--line); border-radius:var(--radius); box-shadow:var(--shadow); padding:10px; display:flex; align-items:center; justify-content:center; min-height:540px;}
    canvas{background:#fff; border-radius:10px; width:100%; height:100%;}

    .bottom{background:var(--panel); border:1px solid var(--line); border-radius:var(--radius); box-shadow:var(--shadow); padding:10px; display:flex; align-items:center; justify-content:space-between; gap:10px; flex-wrap:wrap;}

    .legend{display:flex; gap:10px; flex-wrap:wrap; align-items:center;}
    .legend .item{display:flex; align-items:center; gap:6px; font-size:12px; color:var(--muted);}
    .swatch{width:14px; height:14px; border-radius:4px; border:1px solid rgba(0,0,0,.12);}

    .right{display:flex; flex-direction:column; gap:12px;}
    .panel{background:var(--panel); border:1px solid var(--line); border-radius:var(--radius); box-shadow:var(--shadow); padding:12px;}
    .panel-title{font-weight:700; font-size:13px; margin:0 0 8px 0;}

    .row{display:flex; align-items:center; justify-content:space-between; gap:10px;}
    .subtle{color:var(--muted); font-size:12px;}
    .pill{background:var(--pill); border:1px solid var(--line); border-radius:999px; padding:6px 10px; font-size:12px; color:#111; cursor:pointer; user-select:none;}
    .pill:active{transform:translateY(1px);}

    table{width:100%; border-collapse:collapse; font-size:12px;}
    th,td{padding:6px 6px; border-bottom:1px solid var(--line); text-align:left;}
    th{color:var(--muted); font-weight:600;}

    textarea{width:100%; height:520px; resize:none; border:1px solid var(--line); border-radius:10px; padding:10px; font-size:12px; line-height:1.35; box-sizing:border-box; outline:none;}

    select{border:1px solid var(--line); border-radius:999px; padding:6px 10px; font-size:12px; background:#fff;}
    .hexJump{border:1px solid var(--line); border-radius:999px; padding:8px 12px; font-size:12px; background:#fff; width:110px; box-sizing:border-box; outline:none;}
    .hexJump:focus{border-color:#cbd5e1;}
    .btn{border:1px solid var(--line); border-radius:999px; padding:8px 12px; background:#fff; cursor:pointer; font-size:12px;}
    .btn:hover{background:#fafafa;}

    @media (max-width: 1060px){
      .app{grid-template-columns: 1fr;}
      .right{order:2;}
    }
  </style>
</head>
<body>
  <div class="app">
    <div class="left">
      <div class="stage">
        <canvas id="mat" width="1000" height="820"></canvas>
      </div>

      <div class="bottom">
        <div class="legend" aria-label="Legend">
          <div class="item"><span class="swatch" style="background:#b07a2f"></span>Door</div>
          <div class="item"><span class="swatch" style="background:#cfe9ff"></span>Window</div>
          <div class="item"><span class="swatch" style="background:#4aa3ff"></span>Player</div>
          <div class="item"><span class="swatch" style="background:#111"></span>Enemy</div>
          <div class="item"><span class="swatch" style="background:#d1d5db"></span>Difficult</div>
        </div>

        <div class="row" style="gap:8px;">
          <span class="subtle">Floor</span>
          <select id="floorSelect">
            <option value="stone" selected>Stone</option>
            <option value="wood">Wood</option>
          </select>
          <input class="hexJump" id="cameraHexInput" type="text" placeholder="Jump to (e.g., H6, AA27)" />
          <button class="btn" id="cameraGoBtn">Jump</button>
          <button class="btn" id="redrawBtn">Redraw</button>
        </div>
      </div>
    </div>

    <div class="right">
      <div class="panel">
        <div class="row">
          <div class="panel-title" style="margin:0;">Status</div>
          <div class="pill" style="border:none; background:transparent; cursor:default;" id="versionLine">v4.21</div>
        </div>
        <div class="row subtle" style="margin-top:6px;">
          <div id="roundLine">Round 1</div>
          <span class="pill" id="refreshBtn">Refresh: 60s</span>
        </div>
        <div style="margin-top:10px;">
          <table>
            <thead>
              <tr><th>Actor</th><th>Init</th><th>HP</th></tr>
            </thead>
            <tbody id="statusBody"></tbody>
          </table>
        </div>
      </div>

      <div class="panel" style="flex:1; display:flex; flex-direction:column;">
        <div class="panel-title">Narration</div>
        <textarea id="narration" placeholder="Scene beats, GM notes, what just happened..."></textarea>
      </div>
    </div>
  </div>

  <script>
    'use strict';

    /**
     * Core idea:
     * - Keep a simple, deterministic flat-top hex coordinate system.
     * - Draw rooms/walls/floors first.
     * - Then doors/windows/props/tokens.
     * - Finally draw hex grid + hex labels on top.
     */

    // ---------------------------
    // Canvas + sizing
    // ---------------------------
    const canvas = document.getElementById('mat');
    const ctx = canvas.getContext('2d');
    const stageEl = document.querySelector('.stage');

    function resizeCanvasToStage(){
      if(!stageEl) return;
      const cs = getComputedStyle(stageEl);
      const padX = (parseFloat(cs.paddingLeft)||0) + (parseFloat(cs.paddingRight)||0);
      const padY = (parseFloat(cs.paddingTop)||0) + (parseFloat(cs.paddingBottom)||0);

      const w = Math.max(480, Math.floor(stageEl.clientWidth - padX));
      const h = Math.max(360, Math.floor(stageEl.clientHeight - padY));

      if(canvas.width !== w || canvas.height !== h){
        canvas.width = w;
        canvas.height = h;
      }
    }

    // Grid: flat-top hexes
    const GRID = {
      // Flat-top hex geometry
      size: 42,      // hex radius
      originX: 70,   // world-space origin
      originY: 70,
    };

    // Absolute world extents (labels are stable: A1..DZ90 etc)
    // Camera selects which slice is visible.
    const WORLD = {
      cols: 140,
      rows: 90,
    };

    // View/camera state (in hex coords). Rendering translates world -> screen.
    const VIEW = {
      camera: { col: 30, row: 31 },
      anchor: { x: canvas.width / 2, y: canvas.height / 2 },
      dx: 0,
      dy: 0,
      // On boot, we currently auto-center on the scene bounds.
      // Set false to honor the manual VIEW.camera values above.
      autoCenterOnBoot: true,
    }; 

    // Visual tuning
    const COLORS = {
      grid: 'rgba(0,0,0,0.15)',
      gridBold: 'rgba(0,0,0,0.18)',
      label: 'rgba(0,0,0,0.16)',
      labelBold: 'rgba(0,0,0,0.18)',
      fog: 'rgba(0,0,0,0.55)',
      door: '#b07a2f',
      window: '#cfe9ff',
      enemy: '#111111',
      player: '#4aa3ff',
    };

    // ---------------------------
    // Scene data (default)
    // ---------------------------
    // NOTE: This provides walls/floors by default so you can verify rendering.
    // If you later load scene JSON from an API, merge it over this.
    const DEFAULT_SCENE = {
      battleId: 'local',
      round: 1,
      rooms: [
        {
          id: 'CrossKeysUpperFloor',
          corners: ['B11','Z11','Z2','B2'],
          thickness: 20,
          color: '#555',
          floor: { kind: 'wood' },
          wall: { kind: 'brick' },
        },
        {
          id: 'Bedroom1',
          corners: ['B11','F11','F8','B8'],
          thickness: 20,
          color: '#555',
          floor: { kind: 'wood' },
          wall: { kind: 'brick' },
        },
        {
          id: 'Bedroom2',
          corners: ['B8','F8','F5','B5'],
          thickness: 20,
          color: '#555',
          floor: { kind: 'wood' },
          wall: { kind: 'brick' },
        },
        {
          id: 'Bedroom3',
          corners: ['B5','F5','F2','B2'],
          thickness: 20,
          color: '#555',
          floor: { kind: 'wood' },
          wall: { kind: 'brick' },
        },
        {
          id: 'Bedroom4',
          corners: ['H5','N5','N2','H2'],
          thickness: 36,
          color: '#555',
          floor: { kind: 'wood' },
          wall: { kind: 'brick' },
        },
        {
          id: 'Bedroom5',
          corners: ['H11','N11','N7','H7'],
          thickness: 36,
          color: '#555',
          floor: { kind: 'wood' },
          wall: { kind: 'brick' },
        },
        {
          id: 'Bedroom6',
          corners: ['N9','T9','T7','N7'],
          thickness: 36,
          color: '#555',
          floor: { kind: 'wood' },
          wall: { kind: 'brick' },
        },
        {
          id: 'Bedroom7',
          corners: ['N5','T5','T2','N2'],
          thickness: 26,
          color: '#555',
          floor: { kind: 'wood' },
          wall: { kind: 'brick' },
        },
        {
          id: 'Bedroom8',
          corners: ['V5','Z5','Z2','V2'],
          thickness: 26,
          color: '#555',
          floor: { kind: 'wood' },
          wall: { kind: 'brick' },
        },
        {
          id: 'Bedroom9',
          corners: ['V8','Z8','Z5','V5'],
          thickness: 26,
          color: '#555',
          floor: { kind: 'wood' },
          wall: { kind: 'brick' },
        },
        {
          id: 'Bedroom10',
          corners: ['V11','Z11','Z8','V8'],
          thickness: 36,
          color: '#555',
          floor: { kind: 'wood' },
          wall: { kind: 'brick' },
        },
        
      ],
      openings: [
        { id: 'door_room1', kind: 'door', at: 'F9', facing: 'E', widthPx: 70 },
        { id: 'door_room2', kind: 'door', at: 'F6', facing: 'E', widthPx: 70 },
        { id: 'door_room3', kind: 'door', at: 'F3', facing: 'E', widthPx: 70 },
        { id: 'door_room4', kind: 'door', at: 'J5', facing: 'N', widthPx: 70 },
        { id: 'door_room5', kind: 'door', at: 'K6', facing: 'S', widthPx: 70 },
        { id: 'door_room6', kind: 'door', at: 'Q6', facing: 'D', widthPx: 70 },
        { id: 'door_room7', kind: 'door', at: 'S4', facing: 'N', widthPx: 70 },
        { id: 'door_room8', kind: 'door', at: 'V3', facing: 'W', widthPx: 70 },
        { id: 'door_room9', kind: 'door', at: 'V6', facing: 'W', widthPx: 70 },
        { id: 'door_room1', kind: 'door', at: 'V10', facing: 'W', widthPx: 70 },
        { id: 'west_window1', kind: 'window', at: 'B10', facing: 'W', widthPx: 70 },
        { id: 'west_window2', kind: 'window', at: 'B9', facing: 'W', widthPx: 70 },
        { id: 'west_window3', kind: 'window', at: 'B7', facing: 'W', widthPx: 70 },
        { id: 'west_window4', kind: 'window', at: 'B6', facing: 'W', widthPx: 70 },
        { id: 'west_window5', kind: 'window', at: 'B4', facing: 'W', widthPx: 70 },
        { id: 'west_window6', kind: 'window', at: 'B3', facing: 'W', widthPx: 70 },
        { id: 'south_window1', kind: 'window', at: 'C1', facing: 'S', widthPx: 70 },
        { id: 'south_window2', kind: 'window', at: 'D2', facing: 'S', widthPx: 70 },
        { id: 'south_window3', kind: 'window', at: 'G1', facing: 'S', widthPx: 70 },
        { id: 'south_window4', kind: 'window', at: 'J2', facing: 'S', widthPx: 70 },
        { id: 'south_window5', kind: 'window', at: 'K1', facing: 'S', widthPx: 70 },
        { id: 'south_window6', kind: 'window', at: 'Q1', facing: 'S', widthPx: 70 },
        { id: 'south_window7', kind: 'window', at: 'R2', facing: 'S', widthPx: 70 },
        { id: 'south_window8', kind: 'window', at: 'U1', facing: 'S', widthPx: 70 },
        { id: 'south_window9', kind: 'window', at: 'X2', facing: 'S', widthPx: 70 },


      ],
      actors: [
        { id: 'lich', name: 'Lich', side: 'ENEMY', at: 'K9', init: 15, hp: 135 },
        { id: 'w1', name: 'Wraith 1', side: 'ENEMY', at: 'J6', init: 12, hp: 67 },
        { id: 'w2', name: 'Wraith 2', side: 'ENEMY', at: 'G8', init: 11, hp: 67 },
        { id: 'w3', name: 'Wraith 3', side: 'ENEMY', at: 'D7', init: 10, hp: 67 },
        { id: 'a', name: 'Aelar', side: 'PLAYER', at: 'J3', init: 14, hp: 42 },
        { id: 'b', name: 'Brunna', side: 'PLAYER', at: 'K3', init: 13, hp: 55 },
        { id: 'c', name: 'Caelin', side: 'PLAYER', at: 'L4', init: 12, hp: 38 },
      ],
      fog: {
        enabled: false,
        visibleRooms: ['room_left'],
      },
      narration: "The crypt is silent but for the soft scrape of bone on stone.\n\nAelar steps forward, blade raised â€” and the air suddenly turns cold.\n\nCaelin: \"I don't like this...\"\n\nA shadow shifts near the sarcophagus."
    };

    // Active scene
    let SCENE = structuredClone(DEFAULT_SCENE);

    // ---------------------------
    // Utilities: hex math
    // ---------------------------
    // Excel-style column labels: 0->A, 25->Z, 26->AA, ...
    function colToLabel(col){
      let n = col + 1; // 1-based
      let out = '';
      while(n > 0){
        n--; // make it 0..25
        out = String.fromCharCode(65 + (n % 26)) + out;
        n = Math.floor(n / 26);
      }
      return out;
    }

    function labelToCol(label){
      const s = String(label || '').trim().toUpperCase();
      if(!/^[A-Z]+$/.test(s)) return -1;
      let n = 0;
      for(let i=0;i<s.length;i++){
        n = n * 26 + (s.charCodeAt(i) - 64); // A=1..Z=26
      }
      return n - 1; // back to 0-based
    }

    function clamp(n, a, b){ return Math.max(a, Math.min(b, n)); }

    function parseHexId(id){
      // e.g. "H6" or "AA27" => {col,row}
      const m = String(id).trim().toUpperCase().match(/^([A-Z]+)([0-9]{1,3})$/);
      if(!m) return null;
      const col = labelToCol(m[1]);
      const row = parseInt(m[2], 10);
      if(col < 0 || row < 1) return null;
      if(col >= WORLD.cols || row > WORLD.rows) return null;
      return { col, row };
    }

    function hexCenter(col, row){
      // Flat-top layout (odd-q vertical offset).
      // Coordinate system is "A1 in the lower-left" in *world* terms.
      // We map that to pixels by flipping against WORLD.rows.
      const s = GRID.size;
      const x = GRID.originX + (s * 1.5) * col;
      const rowFromTop = (WORLD.rows - row); // 0-based; row=WORLD.rows at top, row=1 at bottom
      const y = GRID.originY + (s * Math.sqrt(3)) * (rowFromTop + 0.5 * (col % 2));
      return { x, y };
    }

    function hexPolygon(cx, cy, s){
      // flat-top
      const pts = [];
      for(let i=0;i<6;i++){
        const a = Math.PI/180 * (60*i);
        pts.push({ x: cx + s*Math.cos(a), y: cy + s*Math.sin(a) });
      }
      return pts;
    }

    function drawPoly(p, fill=null, stroke=null, lw=1){
      ctx.beginPath();
      ctx.moveTo(p[0].x, p[0].y);
      for(let i=1;i<p.length;i++) ctx.lineTo(p[i].x, p[i].y);
      ctx.closePath();
      if(fill){ ctx.fillStyle = fill; ctx.fill(); }
      if(stroke){ ctx.strokeStyle = stroke; ctx.lineWidth = lw; ctx.stroke(); }
    }

    // Convert a corners array into a pixel-space bounding box rectangle.
    // NOTE: This is the simple rectangle mode you've been using for now.
    function cornersToRect(corners, thicknessPx = 30){
      // IMPORTANT: cornersToRect is a rectangle approximation on a hex grid.
      // To keep the "horizontal walls snap to lower-half" convention stable even when
      // corners span both even/odd columns (which have different center Y offsets),
      // compute vertical bounds using an explicit snap parity instead of raw min/max
      // corner center Ys.
      const hs = corners
        .map(parseHexId)
        .filter(Boolean);
      if(hs.length < 2) return null;

      let minCol = Infinity, maxCol = -Infinity;
      let minRow = Infinity, maxRow = -Infinity;
      for(const h of hs){
        minCol = Math.min(minCol, h.col);
        maxCol = Math.max(maxCol, h.col);
        minRow = Math.min(minRow, h.row);
        maxRow = Math.max(maxRow, h.row);
      }

      const s = GRID.size;
      const colStep = 1.5 * s;
      const rowStep = Math.sqrt(3) * s;

      // Expand by our agreed rules:
      // - X expands by quarter column-step (align vertical walls to boundary hex column)
      // - Y expands by half row-step (align horizontal walls to bottom-half convention)
      // X expansion depends on wall thickness so the *centerline* of vertical walls stays
      // centered on the hex center X regardless of thickness.
      // (Outer edge shifts by thickness/2, inner edge shifts by thickness/2 in the other direction.)
      const tPx = Number(thicknessPx || 0);
      const expandX = (tPx > 0) ? (tPx / 2) : (0.25 * colStep); // fallback if no thickness provided
      const expandY = 0.5 * rowStep;  // = sqrt3*s/2

      // X bounds are independent of row parity.
      const minX = GRID.originX + colStep * minCol;
      const maxX = GRID.originX + colStep * maxCol;

      // Y bounds: enforce the "lower-half" snap by always using odd-column parity (+0.5).
      // (Odd columns are shifted downward by +0.5 in our flat-top odd-q layout.)
      const snapParity = 1; // 0=upper half, 1=lower half

      function snappedCenterY(row){
        const rowFromTop = (WORLD.rows - row);
        return GRID.originY + rowStep * (rowFromTop + 0.5 * snapParity);
      }

      // Higher row numbers are higher up (smaller y) in our flipped coordinate system.
      const topY = snappedCenterY(maxRow);
      const botY = snappedCenterY(minRow);
      const minY = Math.min(topY, botY);
      const maxY = Math.max(topY, botY);

      return {
        x: minX - expandX,
        // Top outer boundary should originate at the hex centerline ("lower half" convention).
        y: minY,
        w: (maxX - minX) + 2 * expandX,
        // Keep the bottom outer boundary where it was (maxY + expandY).
        h: (maxY - minY) + expandY,
      };
    }

    // ---------------------------
    // Procedural textures
    // ---------------------------
    const patternCache = new Map();

    function makePattern(key, build){
      if(patternCache.has(key)) return patternCache.get(key);
      const p = build();
      patternCache.set(key, p);
      return p;
    }

    function patternBrickSmall(){
      // Small, consistent medium-gray bricks.
      return makePattern('brickSmall', () => {
        const c = document.createElement('canvas');
        // 1/4 size feel: keep tile small
        c.width = 64;
        c.height = 48;
        const g = c.getContext('2d');

        // background mortar
        g.fillStyle = '#7d7f82';
        g.fillRect(0,0,c.width,c.height);

        // brick fill
        const brick = '#8a8c8f';
        const edge = 'rgba(0,0,0,0.10)';
        const mortar = '#7d7f82';

        const bw = 16; // brick width
        const bh = 10; // brick height
        const gap = 2; // mortar thickness

        for(let y=0; y<c.height; y += (bh+gap)){
          const row = Math.floor(y/(bh+gap));
          const offset = (row % 2) ? Math.floor((bw+gap)/2) : 0;
          for(let x=-offset; x<c.width; x += (bw+gap)){
            g.fillStyle = brick;
            g.fillRect(x, y, bw, bh);
            g.strokeStyle = edge;
            g.lineWidth = 1;
            g.strokeRect(x+0.5, y+0.5, bw-1, bh-1);

            // speckles (subtle)
            g.fillStyle = 'rgba(0,0,0,0.05)';
            for(let i=0;i<2;i++){
              const sx = x + 2 + Math.random()*(bw-4);
              const sy = y + 2 + Math.random()*(bh-4);
              g.fillRect(sx, sy, 1, 1);
            }
          }
        }

        // thin mortar lines
        g.fillStyle = mortar;
        for(let y=bh; y<c.height; y += (bh+gap)){
          g.fillRect(0, y, c.width, gap);
        }
        return ctx.createPattern(c, 'repeat');
      });
    }

    function patternStone(){
      return makePattern('stone', () => {
        const c = document.createElement('canvas');
        c.width = 120;
        c.height = 120;
        const g = c.getContext('2d');
        g.fillStyle = '#b7b9bc';
        g.fillRect(0,0,c.width,c.height);
        g.strokeStyle = 'rgba(0,0,0,0.10)';
        g.lineWidth = 2;
        for(let y=0;y<120;y+=24){
          for(let x=0;x<120;x+=40){
            g.strokeRect(x+1, y+1, 38, 22);
          }
        }
        g.fillStyle = 'rgba(0,0,0,0.05)';
        for(let i=0;i<150;i++){
          g.fillRect(Math.random()*120, Math.random()*120, 1, 1);
        }
        return ctx.createPattern(c, 'repeat');
      });
    }

    function patternWood(){
      return makePattern('wood', () => {
        const c = document.createElement('canvas');
        c.width = 120;
        c.height = 120;
        const g = c.getContext('2d');
        g.fillStyle = '#d2c19a';
        g.fillRect(0,0,c.width,c.height);
        g.strokeStyle = 'rgba(0,0,0,0.10)';
        g.lineWidth = 2;
        for(let x=0;x<120;x+=20){
          g.beginPath();
          g.moveTo(x,0);
          g.lineTo(x,120);
          g.stroke();
        }
        g.strokeStyle = 'rgba(0,0,0,0.06)';
        for(let i=0;i<12;i++){
          g.beginPath();
          g.moveTo(0, Math.random()*120);
          g.bezierCurveTo(40, Math.random()*120, 80, Math.random()*120, 120, Math.random()*120);
          g.stroke();
        }
        g.fillStyle = 'rgba(0,0,0,0.07)';
        for(let i=0;i<60;i++){
          g.beginPath();
          g.arc(Math.random()*120, Math.random()*120, Math.random()*3, 0, Math.PI*2);
          g.stroke();
        }
        return ctx.createPattern(c, 'repeat');
      });
    }

    function floorPattern(kind){
      if(kind === 'wood') return patternWood();
      return patternStone();
    }

    // ---------------------------
    // Drawing: grid + labels
    // ---------------------------
    function drawHexGrid(){
      const s = GRID.size;

      // Draw only what's near the camera (keeps big worlds fast)
      const colRadius = Math.ceil(canvas.width / (1.5 * s)) + 4;
      const rowRadius = Math.ceil(canvas.height / (Math.sqrt(3) * s)) + 4;

      const cMin = clamp(VIEW.camera.col - colRadius, 0, WORLD.cols - 1);
      const cMax = clamp(VIEW.camera.col + colRadius, 0, WORLD.cols - 1);
      const rMin = clamp(VIEW.camera.row - rowRadius, 1, WORLD.rows);
      const rMax = clamp(VIEW.camera.row + rowRadius, 1, WORLD.rows);

      for(let col=cMin; col<=cMax; col++){
        for(let row=rMin; row<=rMax; row++){
          const c = hexCenter(col,row);
          const poly = hexPolygon(c.x,c.y,s);
          drawPoly(poly, null, COLORS.grid, 1);

          // labels (absolute world labels)
          // Avoid drawing labels that would be clipped by the canvas edge.
          const sx = c.x + VIEW.dx;
          const sy = c.y + VIEW.dy;
          const labelPad = 14;
          if(sx >= labelPad && sx <= canvas.width - labelPad && sy >= labelPad && sy <= canvas.height - labelPad){
            const label = `${colToLabel(col)}${row}`;
            const isEdge = (row === WORLD.rows || row === 1 || col === 0 || col === WORLD.cols-1);
            ctx.fillStyle = isEdge ? COLORS.labelBold : COLORS.label;
            ctx.font = '600 12px system-ui, sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(label, c.x, c.y);
          }
        }
      }
    }

    // ---------------------------
    // Drawing: rooms (walls + floors)
    // ---------------------------
    function drawRoom(room){
      const rect = cornersToRect(room.corners, room.thickness);
      if(!rect) return;

      const t = Number(room.thickness || 0);
      // Wall: brick pattern inside the wall band
      if(t > 0){
        ctx.save();
        ctx.fillStyle = patternBrickSmall();
        ctx.fillRect(rect.x, rect.y, rect.w, rect.h);

        // Cut out interior (to leave a wall ring)
        ctx.globalCompositeOperation = 'destination-out';
        ctx.fillRect(rect.x + t, rect.y + t, rect.w - 2*t, rect.h - 2*t);
        ctx.restore();

        // subtle outline (very light, to avoid the thin black line you flagged)
        ctx.save();
        ctx.strokeStyle = 'rgba(0,0,0,0.08)';
        ctx.lineWidth = 1;
        ctx.strokeRect(rect.x + 0.5, rect.y + 0.5, rect.w - 1, rect.h - 1);
        ctx.restore();
      }

      // Floor fill
      const floorKind = (room.floor && room.floor.kind) ? room.floor.kind : document.getElementById('floorSelect').value;
      ctx.save();
      ctx.fillStyle = floorPattern(floorKind);
      ctx.fillRect(rect.x + t, rect.y + t, rect.w - 2*t, rect.h - 2*t);
      ctx.restore();
    }

    function drawRooms(){
      if(!Array.isArray(SCENE.rooms)) return;
      for(const r of SCENE.rooms){
        drawRoom(r);
      }
    }

    // ---------------------------
    // Openings: doors/windows
    // ---------------------------
    function drawOpening(o){
      const h = parseHexId(o.at);
      if(!h) return;
      const w = Number(o.widthPx || 70);
      const thick = 18;

      // Rotation support (legacy + new):
      // - facing sets the default orientation (E/W = 90deg)
      // - rot adds an additional degrees rotation (e.g., rot: 90)
      // Accept both "rot" and legacy "Rot".
      const facing = String(o.facing || 'E').toUpperCase();
      const facingDeg = (facing === 'E' || facing === 'W') ? 90 : 0;
      const rotDeg = Number(o.rot ?? o.Rot ?? 0);
      const angle = (facingDeg + rotDeg) * Math.PI / 180;

      // Determine whether the opening is drawn horizontally (E-W) or vertically (N-S).
      // We snap to the nearest wall-band centerline in the matching orientation.
      const orientDegRaw = ((facingDeg + rotDeg) % 180 + 180) % 180; // 0..179
      const orientDeg = (Math.round(orientDegRaw / 90) * 90) % 180;  // snap to 0/90
      const isHorizontal = (orientDeg === 0);

      const s = GRID.size;
      const colStep = (s * 1.5);
      const rowStep = (s * Math.sqrt(3));
      const probe = hexCenter(h.col, h.row);

      let c;

      if(isHorizontal){
        // Horizontal openings: center inside the nearest horizontal wall band (top or bottom).
        // Use hex X without parity concerns; use probeY only to choose the nearest band.
        const x = GRID.originX + colStep * h.col;
        const probeY = probe.y;

        let bestY = null;
        let bestDist = Infinity;

        for(const r of (SCENE.rooms || [])){
          const rect = cornersToRect(r.corners, r.thickness);
          if(!rect) continue;
          if(x < rect.x || x > (rect.x + rect.w)) continue;

          const wallT = Number(o.wallThicknessPx ?? o.wallT ?? r.thickness ?? 30);
          if(!(wallT > 0)) continue;

          const yTop = rect.y + (wallT / 2);
          const yBot = (rect.y + rect.h) - (wallT / 2);

          const dTop = Math.abs(probeY - yTop);
          const dBot = Math.abs(probeY - yBot);

          if(dTop < bestDist){ bestDist = dTop; bestY = yTop; }
          if(dBot < bestDist){ bestDist = dBot; bestY = yBot; }
        }

        // If we found a plausible nearby wall band, use it; otherwise fall back to a stable "lower-half" snap.
        if(bestY !== null && bestDist <= rowStep){
          c = { x, y: bestY };
        } else {
          const rowFromTop = (WORLD.rows - h.row);
          const yStable = GRID.originY + rowStep * (rowFromTop + 0.5);
          c = { x, y: yStable };
        }
      } else {
        // Vertical openings: snap X to the nearest vertical wall band (left or right).
        // Keep Y at the probed hex center (parity is expected for vertical placement).
        const probeX = probe.x;
        const probeY = probe.y;

        let bestX = null;
        let bestDist = Infinity;

        for(const r of (SCENE.rooms || [])){
          const rect = cornersToRect(r.corners, r.thickness);
          if(!rect) continue;
          if(probeY < rect.y || probeY > (rect.y + rect.h)) continue;

          const wallT = Number(o.wallThicknessPx ?? o.wallT ?? r.thickness ?? 30);
          if(!(wallT > 0)) continue;

          const xLeft  = rect.x + (wallT / 2);
          const xRight = (rect.x + rect.w) - (wallT / 2);

          const dLeft = Math.abs(probeX - xLeft);
          const dRight = Math.abs(probeX - xRight);

          if(dLeft < bestDist){ bestDist = dLeft; bestX = xLeft; }
          if(dRight < bestDist){ bestDist = dRight; bestX = xRight; }
        }

        if(bestX !== null && bestDist <= colStep){
          c = { x: bestX, y: probe.y };
        } else {
          c = probe;
        }
      }

      ctx.save();
      if(o.kind === 'window'){
        ctx.fillStyle = COLORS.window;
        ctx.strokeStyle = 'rgba(0,0,0,0.15)';
      } else {
        ctx.fillStyle = COLORS.door;
        ctx.strokeStyle = 'rgba(0,0,0,0.20)';
      }
      ctx.lineWidth = 2;

      // Draw as a small rectangle centered on the hex, rotated as requested.
      ctx.translate(c.x, c.y);
      if(angle) ctx.rotate(angle);
      ctx.beginPath();
      ctx.rect(-w/2, -thick/2, w, thick);
      ctx.fill();
      ctx.stroke();

      ctx.restore();
    }

    function drawOpenings(
){
      if(!Array.isArray(SCENE.openings)) return;
      for(const o of SCENE.openings) drawOpening(o);
    }

    // ---------------------------
    // Actors (tokens)
    // ---------------------------
    function tokenColor(side){
      return (String(side).toUpperCase() === 'PLAYER') ? COLORS.player : COLORS.enemy;
    }

    function drawActor(a){
      const h = parseHexId(a.at);
      if(!h) return;
      const c = hexCenter(h.col, h.row);

      const fill = tokenColor(a.side);
      ctx.save();
      ctx.beginPath();
      ctx.arc(c.x, c.y, 18, 0, Math.PI*2);
      ctx.fillStyle = fill;
      ctx.fill();
      ctx.strokeStyle = 'rgba(0,0,0,0.25)';
      ctx.lineWidth = 2;
      ctx.stroke();

      // label inside
      ctx.fillStyle = '#fff';
      ctx.font = '700 12px system-ui, sans-serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      const inside = (a.name || '').trim().split(/\s+/)[0].slice(0,1).toUpperCase();
      ctx.fillText(inside || '?', c.x, c.y);

      // name under token
      ctx.fillStyle = 'rgba(0,0,0,0.55)';
      ctx.font = '600 12px system-ui, sans-serif';
      ctx.fillText(a.name || a.id, c.x, c.y + 28);
      ctx.restore();
    }

    function drawActors(){
      if(!Array.isArray(SCENE.actors)) return;
      for(const a of SCENE.actors) drawActor(a);
    }

    // ---------------------------
    // Fog of war
    // ---------------------------
    function drawFog(){
      if(!SCENE.fog || !SCENE.fog.enabled) return;

      const visible = new Set(SCENE.fog.visibleRooms || []);

      // Simple room-based fog for now:
      // - Darken everything
      // - Then punch holes for visible rooms
      ctx.save();
      ctx.fillStyle = COLORS.fog;
      // NOTE: drawFog is called inside the translated (camera) context.
      // Fill the *screen* area by drawing a world-space rect that maps onto the canvas.
      ctx.fillRect(-VIEW.dx, -VIEW.dy, canvas.width, canvas.height);

      ctx.globalCompositeOperation = 'destination-out';
      for(const r of (SCENE.rooms || [])){
        if(!visible.has(r.id)) continue;
        const rect = cornersToRect(r.corners, r.thickness);
        if(!rect) continue;
        const t = Number(r.thickness || 0);
        ctx.fillRect(rect.x + t, rect.y + t, rect.w - 2*t, rect.h - 2*t);
      }
      ctx.restore();
    }

    // ---------------------------
    // Render pipeline
    // ---------------------------
    function clear(){
      ctx.clearRect(0,0,canvas.width,canvas.height);
    }

    function render(){
      clear();

      // Anchor should follow the canvas size.
      VIEW.anchor.x = canvas.width / 2;
      VIEW.anchor.y = canvas.height / 2;

      // Translate world -> screen so that VIEW.camera lands at VIEW.anchor.
      const camPx = hexCenter(VIEW.camera.col, VIEW.camera.row);
      VIEW.dx = VIEW.anchor.x - camPx.x;
      VIEW.dy = VIEW.anchor.y - camPx.y;

      ctx.save();
      ctx.translate(VIEW.dx, VIEW.dy);

      drawRooms();
      drawOpenings();
      drawActors();
      drawFog();
      // Grid + labels LAST (on top)
      drawHexGrid();

      ctx.restore();
    }

    // ---------------------------
    // View helpers (camera)
    // ---------------------------
    function computeSceneBounds(scene){
      let minCol = Infinity, minRow = Infinity, maxCol = -Infinity, maxRow = -Infinity;

      function considerHexId(hexId){
        const h = parseHexId(hexId);
        if(!h) return;
        minCol = Math.min(minCol, h.col);
        maxCol = Math.max(maxCol, h.col);
        minRow = Math.min(minRow, h.row);
        maxRow = Math.max(maxRow, h.row);
      }

      for(const r of (scene.rooms || [])){
        for(const c of (r.corners || [])) considerHexId(c);
      }
      for(const o of (scene.openings || [])) considerHexId(o.at);
      for(const a of (scene.actors || [])) considerHexId(a.at);

      if(!Number.isFinite(minCol)){
        return { minCol: 0, maxCol: 0, minRow: 1, maxRow: 1 };
      }
      return { minCol, maxCol, minRow, maxRow };
    }

    function centerCameraOnScene(scene){
      const b = computeSceneBounds(scene);
      const col = Math.round((b.minCol + b.maxCol) / 2);
      const row = Math.round((b.minRow + b.maxRow) / 2);
      VIEW.camera.col = clamp(col, 0, WORLD.cols - 1);
      VIEW.camera.row = clamp(row, 1, WORLD.rows);
    }

    // Keyboard pan (arrow keys). Steps are 2 hexes to keep parity clean. Shift = faster.
    document.addEventListener('keydown', (e) => {
      const tag = (e.target && e.target.tagName) ? e.target.tagName.toLowerCase() : '';
      if(tag === 'textarea' || tag === 'input' || tag === 'select') return;

      const step = e.shiftKey ? 10 : 2;
      let handled = true;

      switch(e.key){
        case 'ArrowLeft':
          VIEW.camera.col = clamp(VIEW.camera.col - step, 0, WORLD.cols - 1);
          break;
        case 'ArrowRight':
          VIEW.camera.col = clamp(VIEW.camera.col + step, 0, WORLD.cols - 1);
          break;
        case 'ArrowUp':
          VIEW.camera.row = clamp(VIEW.camera.row + step, 1, WORLD.rows);
          break;
        case 'ArrowDown':
          VIEW.camera.row = clamp(VIEW.camera.row - step, 1, WORLD.rows);
          break;
        default:
          handled = false;
      }

      if(handled){
        e.preventDefault();
        render();
      }
    });

    // ---------------------------
    // UI wiring
    // ---------------------------
    const statusBody = document.getElementById('statusBody');
    const narrationBox = document.getElementById('narration');

    function refreshStatus(){
      const list = [...(SCENE.actors || [])].slice().sort((a,b) => (b.init||0)-(a.init||0));
      statusBody.innerHTML = '';
      for(const a of list){
        const tr = document.createElement('tr');
        tr.innerHTML = `<td>${escapeHtml(a.name || a.id)}</td><td>${escapeHtml(String(a.init ?? ''))}</td><td>${escapeHtml(String(a.hp ?? ''))}</td>`;
        statusBody.appendChild(tr);
      }
      document.getElementById('roundLine').textContent = `Round ${SCENE.round || 1}`;
      narrationBox.value = SCENE.narration || '';
    }

    function escapeHtml(s){
      return String(s)
        .replaceAll('&','&amp;')
        .replaceAll('<','&lt;')
        .replaceAll('>','&gt;')
        .replaceAll('"','&quot;')
        .replaceAll("'",'&#039;');
    }

    // Camera jump UI
    const cameraHexInput = document.getElementById('cameraHexInput');
    const cameraGoBtn = document.getElementById('cameraGoBtn');

    function flashInvalidHex(){
      if(!cameraHexInput) return;
      const prev = cameraHexInput.style.borderColor;
      cameraHexInput.style.borderColor = '#ef4444';
      setTimeout(() => { cameraHexInput.style.borderColor = prev || ''; }, 350);
    }

    function jumpCameraToHex(hexStr){
      const h = parseHexId(hexStr);
      if(!h) { flashInvalidHex(); return; }
      VIEW.camera.col = h.col;
      VIEW.camera.row = h.row;
      render();
    }

    if(cameraGoBtn){
      cameraGoBtn.addEventListener('click', () => {
        jumpCameraToHex(cameraHexInput?.value || '');
      });
    }

    if(cameraHexInput){
      cameraHexInput.addEventListener('keydown', (e) => {
        if(e.key === 'Enter'){
          e.preventDefault();
          jumpCameraToHex(cameraHexInput.value || '');
        }
      });
    }

    document.getElementById('redrawBtn').addEventListener('click', () => {
      render();
    });

    document.getElementById('floorSelect').addEventListener('change', () => {
      render();
    });

    // ---------------------------
    // Self-checks (lightweight "tests")
    function runSelfTests(){
      // Basic parsing
      console.assert(parseHexId('A1')?.col === 0 && parseHexId('A1')?.row === 1, '[Test] parseHexId A1');
      console.assert(parseHexId('P11')?.col === 15 && parseHexId('P11')?.row === 11, '[Test] parseHexId P11');
      console.assert(parseHexId('AA1')?.col === 26 && parseHexId('AA1')?.row === 1, '[Test] parseHexId AA1');
      console.assert(parseHexId('1A') === null, '[Test] parseHexId invalid format');
      console.assert(parseHexId('ZZ99') === null, '[Test] parseHexId out-of-range');

      // Coordinate orientation: A1 should be BELOW A11 in world space
      const a1 = hexCenter(0, 1);
      const a11 = hexCenter(0, 11);
      console.assert(a1.y > a11.y, '[Test] A1 is below A11 (A1 bottom-left)');

      // Expansion math: quarter column-step & half row-step
      const s = GRID.size;
      const expectedExpandX = 30 / 2; // cornersToRect default thicknessPx is 30, so expandX = t/2
      const expectedExpandY = 0.5 * (Math.sqrt(3) * s);

      const c1 = hexCenter(labelToCol('D'), 1);
      const c2 = hexCenter(labelToCol('D'), 11);
      const r = cornersToRect(['D1','D11']);
      console.assert(r && Math.abs(r.x - (Math.min(c1.x,c2.x) - expectedExpandX)) < 1e-6, '[Test] cornersToRect expandX');
      console.assert(r && Math.abs(r.y - Math.min(c1.y,c2.y)) < 1e-6, '[Test] cornersToRect topY aligns to hex centerline');
    }

    // Self-checks (lightweight "tests")
    // ---------------------------
    function validateScene(scene){
      const errs = [];
      if(!scene) errs.push('scene is null');
      if(!Array.isArray(scene.rooms) || scene.rooms.length === 0) errs.push('scene.rooms missing/empty (walls will not draw)');
      if(scene.rooms){
        for(const r of scene.rooms){
          if(!r.id) errs.push('room missing id');
          if(!Array.isArray(r.corners) || r.corners.length < 4) errs.push(`room ${r.id||'?'} missing corners`);
        }
      }
      if(errs.length){
        console.warn('[Battlemat] Scene validation warnings:', errs);
      }
      return errs;
    }

    // Boot
    (function boot(){
      resizeCanvasToStage();
      window.addEventListener('resize', () => {
        resizeCanvasToStage();
        render();
      });
      // Ensure default floor matches dropdown.
      try{
        const sel = document.getElementById('floorSelect');
        if(sel && sel.value){
          for(const r of SCENE.rooms){
            if(r.floor && r.floor.kind) continue;
            r.floor = { kind: sel.value };
          }
        }
      } catch(_){ }

      runSelfTests();
      validateScene(SCENE);
      // Start with camera centered on whatever is in the scene (unless disabled).
      if (VIEW.autoCenterOnBoot) centerCameraOnScene(SCENE);
      refreshStatus();
      render();
    })();

  </script>
</body>
</html>
