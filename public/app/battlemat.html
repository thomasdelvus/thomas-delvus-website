<!--
  Version 3.96

  Copyright ¬© 2025 Thomas Delvus. All rights reserved.

  This HTML document and its contents (including the code, layout, text, data structures, and embedded/linked assets)
  are protected by copyright law.

  Permission is granted to access and use this file for personal, non-commercial tabletop gameplay and reference.

  You may NOT copy, reproduce, modify, translate, redistribute, publish, sell, sublicense, or incorporate this work
  (in whole or in part) into any software product, service, website, platform, ‚Äúsystem,‚Äù template library, dataset,
  or AI/training workflow without prior written permission from the copyright holder.

  Unauthorized use is prohibited.
-->

<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Hex Battlemat</title>
  <style>
    body {
      margin: 0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      background: #f3f3f3;
      color: #111;
    }

    header {
      padding: 10px 14px;
      border-bottom: 1px solid rgba(0,0,0,0.12);
      background: #fff;
      font-weight: 650;
    }

    main {
      padding: 12px;
      display: flex;
      justify-content: center;
      overflow-x: auto;
      overflow-y: hidden;
    }

    .layout {
      display: flex;
      gap: 12px;
      align-items: flex-start;
      margin: 0 auto;
    }

    .mat-col {
      display: flex;
      flex-direction: column;
      gap: 10px;
      align-items: flex-start;
      flex: 0 0 auto;
    }

    aside[aria-label="Right panels"] {
      display: flex;
      flex-direction: column;
      gap: 12px;
      height: 1125px;
      width: 360px;
      flex: 0 0 360px;
      min-height: 0;
    }

    .keybar {
      width: 100%;
      box-sizing: border-box;
      background: #fff;
      border: 1px solid rgba(0,0,0,0.10);
      border-radius: 10px;
      padding: 8px 10px;
      font-size: 0.88rem;
    }

    .keybar-title {
      display: flex;
      justify-content: space-between;
      align-items: baseline;
      gap: 10px;
      margin-bottom: 6px;
    }

    .keybar .legend-swatch {
      width: 18px;
      height: 18px;
      font-size: 10px;
      margin-right: 5px;
    }

    .keybar-list {
      display: flex;
      flex-wrap: wrap;
      gap: 6px 12px;
      list-style: none;
      padding: 0;
      margin: 0;
    }

    .keybar-list li { white-space: nowrap; }

    .pane {
      background: #fff;
      border: 1px solid rgba(0,0,0,0.10);
      border-radius: 10px;
      padding: 10px;
      box-sizing: border-box;
      min-height: 0;
    }

    .panel-title {
      display: flex;
      justify-content: space-between;
      align-items: baseline;
      gap: 10px;
      margin-bottom: 8px;
    }

    .panel-title h3 {
      margin: 0;
      font-size: 1rem;
      font-weight: 650;
    }

    .subtle {
      opacity: 0.7;
      font-size: 0.9rem;
      white-space: nowrap;
    }

    .refresh-btn,
    .toggle-btn,
    .tex-select {
      appearance: none;
      border: 1px solid rgba(0,0,0,0.18);
      background: #fff;
      border-radius: 8px;
      padding: 6px 10px;
      font-size: 0.86rem;
      font-weight: 650;
      cursor: pointer;
      line-height: 1;
    }

    .tex-select { padding: 6px 8px; }

    .refresh-btn:hover,
    .toggle-btn:hover,
    .tex-select:hover { background: rgba(0,0,0,0.03); }
    .refresh-btn:active,
    .toggle-btn:active,
    .tex-select:active { background: rgba(0,0,0,0.06); }
    .refresh-btn:focus,
    .toggle-btn:focus,
    .tex-select:focus { outline: 2px solid rgba(0,0,0,0.25); outline-offset: 2px; }

    .status-wrap {
      overflow: auto;
      border: 1px solid rgba(0,0,0,0.10);
      border-radius: 10px;
    }

    table {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.92rem;
    }

    thead th {
      position: sticky;
      top: 0;
      background: #f6f6f6;
      text-align: left;
      font-weight: 650;
      padding: 8px 10px;
      border-bottom: 1px solid rgba(0,0,0,0.10);
    }

    tbody td {
      padding: 8px 10px;
      border-bottom: 1px solid rgba(0,0,0,0.08);
      vertical-align: top;
    }

    .chip {
      display: inline-block;
      padding: 2px 8px;
      border-radius: 999px;
      margin: 2px 6px 0 0;
      border: 1px solid rgba(0,0,0,0.12);
      background: #f2f2f2;
      font-size: 0.82rem;
      white-space: nowrap;
    }

    .side-pc  { border-left: 4px solid rgba(80, 160, 220, 0.85); }
    .side-en  { border-left: 4px solid rgba(220, 120, 80, 0.85); }
    .side-npc { border-left: 4px solid rgba(160, 160, 160, 0.85); }

    tr.dead {
      background: rgba(0,0,0,0.04);
      color: rgba(0,0,0,0.55);
    }
    tr.dead .subtle { opacity: 0.5; }
    tr.dead.side-pc,
    tr.dead.side-en,
    tr.dead.side-npc {
      border-left-color: rgba(120,120,120,0.85);
    }

    tr.active-turn td {
      border-top: 2px solid rgba(0,0,0,0.85);
      border-bottom: 2px solid rgba(0,0,0,0.85);
      background: rgba(0,0,0,0.03);
    }
    tr.active-turn td:first-child { border-left: 2px solid rgba(0,0,0,0.85); }
    tr.active-turn td:last-child  { border-right: 2px solid rgba(0,0,0,0.85); }

    tr.active-turn.dead td {
      border-color: rgba(0,0,0,0.40);
      background: rgba(0,0,0,0.02);
    }

    .hp {
      font-variant-numeric: tabular-nums;
      white-space: nowrap;
    }

    #actionLine {
      margin-top: 10px;
      padding: 8px 10px;
      border: 1px solid rgba(0,0,0,0.10);
      border-radius: 10px;
      background: rgba(0,0,0,0.03);
      font-size: 0.90rem;
      font-weight: 650;
      line-height: 1.2;
      overflow-wrap: anywhere;
    }

    .diag {
      margin-top: 10px;
      padding: 8px 10px;
      border: 1px solid rgba(0,0,0,0.10);
      background: rgba(0,0,0,0.03);
      font-size: 0.85rem;
      line-height: 1.25;
      overflow-wrap: anywhere;
      border-radius: 10px;
    }
    .diag .bad { color: #b00020; font-weight: 650; }
    .diag .ok  { color: #0b6b0b; font-weight: 650; }

    #paneNarration {
      flex: 1 1 auto;
      display: flex;
      flex-direction: column;
      min-height: 0;
    }

    #paneNarration textarea {
      flex: 1 1 auto;
      min-height: 140px;
      resize: none;
    }

    textarea {
      width: 100%;
      box-sizing: border-box;
      resize: vertical;
      padding: 8px 10px;
      border: 1px solid rgba(0,0,0,0.18);
      border-radius: 8px;
      background: #fff;
      font: inherit;
      line-height: 1.25;
    }

    textarea.mono {
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    }

    .legend-swatch {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 20px;
      height: 20px;
      margin-right: 6px;
      border-radius: 3px;
      vertical-align: middle;
      border: 1px solid rgba(0,0,0,0.6);
      font-size: 11px;
      font-weight: 700;
      color: rgba(0,0,0,0.85);
      line-height: 1;
    }

    .legend-swatch.door { background: #b07a3f; }
    .legend-swatch.window { background: #cfe6f6; }
    .legend-swatch.table { background: #b07a3f; border-radius: 50%; }

    .legend-swatch.hex {
      position: relative;
      z-index: 0;
      border-radius: 0;
      clip-path: polygon(25% 6%, 75% 6%, 100% 50%, 75% 94%, 25% 94%, 0% 50%);
      border: none;
    }

    .legend-swatch.hex::before {
      content: "";
      position: absolute;
      inset: 0;
      background: rgba(0,0,0,0.45);
      clip-path: inherit;
      transform: scale(1.12);
      z-index: -1;
    }

    .legend-swatch.pc { background: rgba(80,160,220,0.95); border-radius: 50%; }
    .legend-swatch.en { background: rgba(25,25,25,0.92); border-radius: 50%; }
  </style>
</head>
<body>
  <header>Hex Battlemat</header>

  <main>
    <div class="layout">
      <div class="mat-col">
        <canvas id="mat" width="1410" height="1125" aria-label="Hex battlemat"></canvas>

        <section class="keybar" aria-label="Map key">
          <div class="keybar-title">
            <strong>Key</strong>
            <div style="display:flex; align-items:center; gap:8px; flex-wrap:wrap; justify-content:flex-end;">
              <label class="subtle" style="display:flex; align-items:center; gap:6px;">
                Floor
                <select id="floorTexSel" class="tex-select" title="Preview floor texture"></select>
              </label>
            </div>
          </div>
          <ul class="keybar-list">
            <li><span class="legend-swatch door">D</span> Door</li>
            <li><span class="legend-swatch window">W</span> Window</li>
            <li><span class="legend-swatch table">T</span> Table <span class="subtle">(blocks)</span></li>
            <li><span class="legend-swatch hex">~</span> Difficult</li>
            <li><span class="legend-swatch pc">A</span> Player</li>
            <li><span class="legend-swatch en">W</span> Enemy</li>
          </ul>
        </section>
      </div>

      <aside aria-label="Right panels">
        <section class="pane" aria-label="Combat status panel">
          <div class="panel-title">
            <h3>Status</h3>
            <div style="display:flex; align-items:center; gap:10px;">
              <div class="subtle" id="roundLine">Round ‚Äî</div>
              <button id="refreshModeBtn" class="refresh-btn" type="button" title="Toggle refresh">Refresh</button>
            </div>
          </div>

          <div class="diag" id="diagBox" aria-label="Diagnostics" style="display:none"></div>

          <div class="status-wrap" aria-label="Status table">
            <table>
              <thead>
                <tr>
                  <th>Actor</th>
                  <th>Init</th>
                  <th>HP</th>
                </tr>
              </thead>
              <tbody id="statusBody"></tbody>
            </table>
          </div>

          <div id="actionLine" aria-label="Last action"></div>
        </section>

        <section class="pane" id="paneNarration" aria-label="Narration">
          <div class="panel-title">
            <h3>Narration</h3>
          </div>
          <textarea id="narrationBox" rows="7" placeholder="Scene beats, GM notes, what just happened‚Ä¶"></textarea>
        </section>
      </aside>
    </div>
  </main>

  <script type="application/json" id="scene-json">
{
  "round": 1,
  "active_actor_id": "pc1",
  "lastAction": "üé≤ 16  ‚öîÔ∏è Longsword  ‚Üí  7 dmg",
  "narration": "The crypt is silent but for the soft scrape of bone on stone.\nAelar steps forward, blade raised ‚Äî and the air suddenly turns cold.\n\nCaelin: \"I don‚Äôt like this‚Ä¶\"\n\nA shadow shifts near the sarcophagus.",
  "fog": {
    "enabled": true,
    "opacity": 0.88,
    "revealWalls": true,
    "visibleRooms": ["room_left"],
    "note": "Room-based fog-of-war: rooms not listed in visibleRooms are fogged."
  },
  "rooms": [
    {
      "id": "building1",
      "corners": ["D11", "N11", "N1", "D1"],
      "thickness": 30,
      "color": "#555",
      "floor": { "kind": "stone" },
      "wall": { "kind": "brick" }
    },
    {
      "id": "room_left",
      "corners": ["D11", "H11", "H1", "D1"],
      "thickness": 30,
      "color": "#555",
      "floor": { "kind": "stone" },
      "wall": { "kind": "brick" }
    },
    {
      "id": "room_right",
      "corners": ["H11", "N11", "N1", "H1"],
      "thickness": 30,
      "color": "#555",
      "floor": { "kind": "stone" },
      "wall": { "kind": "brick" }
    }
  ],
  "openings": [
    { "id": "win_s_1", "kind": "window", "room": "building1", "wall": "S", "at": "F1", "state": "closed" },
    { "id": "win_s_2", "kind": "window", "room": "building1", "wall": "S", "at": "H1", "state": "closed" },
    { "id": "win_s_3", "kind": "window", "room": "building1", "wall": "S", "at": "J1", "state": "closed" },
    { "id": "win_s_4", "kind": "window", "room": "building1", "wall": "S", "at": "L1", "state": "open" },

    { "id": "door_e_1", "kind": "door.wood", "room": "building1", "wall": "E", "at": "N6", "state": "open", "rot": 180 },
    { "id": "door_e_2", "kind": "door.wood", "room": "building1", "wall": "E", "at": "N5", "state": "closed", "rot": 0 },

    { "id": "door_mid_1", "kind": "door.wood", "room": "room_left", "wall": "E", "at": "H6", "state": "closed", "rot": 0 }
  ],
  "objects": [
    { "id": "sarc1", "kind": "sarcophagus", "cells": ["J8", "K8", "L8"], "blocks": true, "label": "S" },
    {
      "id": "difficult_1",
      "kind": "difficult",
      "cells": ["G2", "H3", "I3"],
      "blocks": false,
      "label": "~",
      "color": "rgba(120,120,120,0.18)"
    }
  ],
  "actors": [
    { "id": "lich", "name": "Lich", "side": "EN", "init": 15, "hp": 135, "maxHp": 135, "effects": [], "at": "K9", "label": "L", "sprite": "lich" },
    { "id": "wraith1", "name": "Wraith 1", "side": "EN", "init": 12, "hp": 67, "maxHp": 67, "effects": [], "at": "H7", "label": "W1", "sprite": "wraith" },
    { "id": "wraith2", "name": "Wraith 2", "side": "EN", "init": 11, "hp": 67, "maxHp": 67, "effects": [], "at": "F9", "label": "W2", "sprite": "wraith" },
    { "id": "wraith3", "name": "Wraith 3", "side": "EN", "init": 10, "hp": 67, "maxHp": 67, "effects": [], "at": "E6", "label": "W3", "sprite": "wraith" },

    { "id": "pc1", "name": "Aelar", "side": "PC", "init": 14, "hp": 42, "maxHp": 42, "effects": [], "at": "K2", "label": "A", "class": "ranger", "gender": "male" },
    { "id": "pc2", "name": "Brunna", "side": "PC", "init": 13, "hp": 55, "maxHp": 55, "effects": [], "at": "L3", "label": "B", "class": "cleric", "gender": "female" },
    { "id": "pc3", "name": "Caelin", "side": "PC", "init": 12, "hp": 38, "maxHp": 38, "effects": [], "at": "M3", "label": "C", "class": "wizard", "gender": "male" }
  ]
}
  </script>

  <script>
    // =====================================================================
    // DB / API WIRING
    // =====================================================================

    function getBattleIdFromUrl() {
      const m = window.location.pathname.match(/^\/play\/([^\/?#]+)/i);
      if (m) return decodeURIComponent(m[1]);
      const u = new URL(window.location.href);
      return u.searchParams.get('battle_id');
    }

    const API_BASE = '';

    function battleStateUrl(battleId) {
      return `${API_BASE}/api/battles/${encodeURIComponent(battleId)}`;
    }

    async function saveSceneToApi(battleId, sceneObj) {
      if (!battleId) throw new Error('saveSceneToApi called without battleId');

      const endpoint = battleStateUrl(battleId);
      const res = await fetch(endpoint, {
        method: 'PUT',
        headers: {
          'Accept': 'application/json',
          'Content-Type': 'application/json',
        },
        cache: 'no-store',
        body: JSON.stringify({ state_json: sceneObj })
      });

      const text = await res.text();
      if (!res.ok) throw new Error(`Save failed: HTTP ${res.status} ${res.statusText || ''} :: ${text}`);
      try { return JSON.parse(text); } catch { return { ok: true, raw: text }; }
    }

    function looksLikeScene(obj) {
      if (!obj || typeof obj !== 'object') return false;
      return (
        Array.isArray(obj.rooms) ||
        Array.isArray(obj.actors) ||
        Array.isArray(obj.objects) ||
        Array.isArray(obj.openings) ||
        Array.isArray(obj.poi)
      );
    }

    const DEBUG_DIAG = false;

    // Sprite diagnostics: logs one line per sprite key the first time it successfully draws.
    // Flip to false to silence logging.
    const DEBUG_SPRITES = true;
    const SPRITE_LOGGED_KEYS = new Set();

    function setDiag(html) {
      const box = document.getElementById('diagBox');
      if (!box) return;
      if (!DEBUG_DIAG) {
        box.style.display = 'none';
        box.innerHTML = '';
        return;
      }
      box.style.display = 'block';
      box.innerHTML = html;
    }

    async function tryLoadSceneFromApi() {
      const battleId = getBattleIdFromUrl();
      const endpoint = battleId ? battleStateUrl(battleId) : '(no battle_id)';

      setDiag(
        `URL Path: <code>${escapeHtml(window.location.pathname)}</code><br>` +
        `battle_id: <span class="${battleId ? 'ok' : 'bad'}">${escapeHtml(String(battleId || 'NONE'))}</span><br>` +
        `Fetch: <code>${escapeHtml(endpoint)}</code>`
      );

      if (!battleId) {
        const roundLine = document.getElementById('roundLine');
        if (roundLine) roundLine.textContent = 'No battle_id in URL';
        return false;
      }

      try {
        const res = await fetch(endpoint, {
          method: 'GET',
          headers: { 'Accept': 'application/json' },
          cache: 'no-store'
        });

        if (!res.ok) {
          setDiag(
            `URL Path: <code>${escapeHtml(window.location.pathname)}</code><br>` +
            `battle_id: <span class="ok">${escapeHtml(String(battleId))}</span><br>` +
            `Fetch: <code>${escapeHtml(endpoint)}</code><br>` +
            `<span class="bad">HTTP ${escapeHtml(String(res.status))}: ${escapeHtml(res.statusText || 'Error')}</span>`
          );
          return false;
        }

        const data = await res.json();

        let sceneObj = null;
        if (data && typeof data.state_json === 'string') sceneObj = JSON.parse(data.state_json);
        else if (data && typeof data.state === 'object') sceneObj = data.state;
        else if (data && typeof data === 'object') sceneObj = data;

        if (!looksLikeScene(sceneObj)) {
          setDiag(
            `URL Path: <code>${escapeHtml(window.location.pathname)}</code><br>` +
            `battle_id: <span class="ok">${escapeHtml(String(battleId))}</span><br>` +
            `Fetch: <code>${escapeHtml(endpoint)}</code><br>` +
            `<span class="bad">API returned JSON but it does not look like a SCENE. Using embedded default.</span>`
          );
          return false;
        }

        const sceneTag = document.getElementById('scene-json');
        if (sceneTag) sceneTag.textContent = JSON.stringify(sceneObj, null, 2);

        setDiag(
          `URL Path: <code>${escapeHtml(window.location.pathname)}</code><br>` +
          `battle_id: <span class="ok">${escapeHtml(String(battleId))}</span><br>` +
          `Fetch: <code>${escapeHtml(endpoint)}</code><br>` +
          `<span class="ok">Loaded state from API.</span>`
        );

        return true;
      } catch (e) {
        setDiag(
          `URL Path: <code>${escapeHtml(window.location.pathname)}</code><br>` +
          `battle_id: <span class="ok">${escapeHtml(String(battleId || ''))}</span><br>` +
          `Fetch: <code>${escapeHtml(endpoint)}</code><br>` +
          `<span class="bad">Fetch/parse error: ${escapeHtml(e && e.message ? e.message : String(e))}</span>`
        );
        return false;
      }
    }

    // =====================================================================
    // AUTO-REFRESH (multi-step)
    // =====================================================================

    const RefreshMode = { FAST: 'fast', S15: '15s', S30: '30s', S60: '60s', OFF: 'off' };

    const FAST_MS = 5000;
    const S15_MS = 15000;
    const S30_MS = 30000;
    const S60_MS = 60000;

    const FAST_TO_15_IDLE_MS = 60000;
    const S15_TO_30_IDLE_MS = 180000;
    const S30_TO_60_IDLE_MS = 300000;
    const S60_TO_OFF_IDLE_MS = 600000;

    const REFRESH = {
      mode: RefreshMode.S60,
      timer: null,
      battleId: null,
      lastVersionKey: null,
      lastChangeAt: Date.now(),
    };

    function modeLabel(mode) {
      if (mode === RefreshMode.FAST) return 'Refresh: 5s';
      if (mode === RefreshMode.S15) return 'Refresh: 15s';
      if (mode === RefreshMode.S30) return 'Refresh: 30s';
      if (mode === RefreshMode.S60) return 'Refresh: 60s';
      return 'Refresh: Off';
    }

    function modeDelayMs(mode) {
      if (mode === RefreshMode.FAST) return FAST_MS;
      if (mode === RefreshMode.S15) return S15_MS;
      if (mode === RefreshMode.S30) return S30_MS;
      if (mode === RefreshMode.S60) return S60_MS;
      return null;
    }

    function setRefreshUI() {
      const btn = document.getElementById('refreshModeBtn');
      if (!btn) return;
      btn.textContent = modeLabel(REFRESH.mode);
      btn.title = (REFRESH.mode === RefreshMode.OFF) ? 'Enable refresh (5s)' : 'Reset to 5s';
    }

    function setRefreshMode(mode) {
      REFRESH.mode = mode;
      if (REFRESH.timer) { clearTimeout(REFRESH.timer); REFRESH.timer = null; }
      setRefreshUI();
      scheduleRefreshTick(true);
    }

    function refreshButtonPressed() {
      REFRESH.lastChangeAt = Date.now();
      try {
        if (REFRESH.battleId) {
          localStorage.setItem(`battlemat:refresh:auto:${REFRESH.battleId}`, 'auto');
          localStorage.setItem(`battlemat:refresh:last:${REFRESH.battleId}`, RefreshMode.FAST);
        }
      } catch (_) {}
      setRefreshMode(RefreshMode.FAST);
    }

    function scheduleRefreshTick(immediate) {
      if (REFRESH.timer) { clearTimeout(REFRESH.timer); REFRESH.timer = null; }
      if (REFRESH.mode === RefreshMode.OFF) return;
      const delay = immediate ? 0 : modeDelayMs(REFRESH.mode);
      REFRESH.timer = setTimeout(refreshTick, delay == null ? 0 : delay);
    }

    function applyScene(sceneObj) {
      try {
        if (SCENE_NORM && SCENE_NORM.actors && SCENE_NORM.actors.length) {
          PENDING_PREV_POS = captureActorPositions(SCENE_NORM);
        }
      } catch (_) {
        PENDING_PREV_POS = null;
      }

      const sceneTag = document.getElementById('scene-json');
      if (sceneTag) sceneTag.textContent = JSON.stringify(sceneObj, null, 2);
      safeDrawGrid();
    }

    async function fetchSceneAndVersionKey(battleId) {
      const endpoint = battleStateUrl(battleId);
      const res = await fetch(endpoint, {
        method: 'GET',
        headers: { 'Accept': 'application/json' },
        cache: 'no-store'
      });
      if (!res.ok) throw new Error(`HTTP ${res.status} ${res.statusText || ''}`);
      const data = await res.json();

      let sceneObj = null;
      if (data && typeof data.state_json === 'string') sceneObj = JSON.parse(data.state_json);
      else if (data && typeof data.state === 'object') sceneObj = data.state;
      else if (data && typeof data === 'object') sceneObj = data;

      if (!looksLikeScene(sceneObj)) throw new Error('API JSON did not look like a SCENE');

      let versionKey = null;
      if (data && (typeof data.version === 'number' || typeof data.version === 'string')) {
        versionKey = `v:${String(data.version)}`;
      } else if (data && (typeof data.updated_at === 'number' || typeof data.updated_at === 'string')) {
        versionKey = `t:${String(data.updated_at)}`;
      }

      return { sceneObj, versionKey };
    }

    async function refreshTick() {
      try {
        if (REFRESH.mode === RefreshMode.OFF) return;

        if (!REFRESH.battleId) {
          safeDrawGrid();
          const idleMs = Date.now() - (REFRESH.lastChangeAt || Date.now());
          if (REFRESH.mode === RefreshMode.FAST && idleMs > FAST_TO_15_IDLE_MS) REFRESH.mode = RefreshMode.S15;
          else if (REFRESH.mode === RefreshMode.S15 && idleMs > S15_TO_30_IDLE_MS) REFRESH.mode = RefreshMode.S30;
          else if (REFRESH.mode === RefreshMode.S30 && idleMs > S30_TO_60_IDLE_MS) REFRESH.mode = RefreshMode.S60;
          else if (REFRESH.mode === RefreshMode.S60 && idleMs > S60_TO_OFF_IDLE_MS) REFRESH.mode = RefreshMode.OFF;

          setRefreshUI();
          scheduleRefreshTick(false);
          return;
        }

        const { sceneObj, versionKey } = await fetchSceneAndVersionKey(REFRESH.battleId);

        const changed = (!versionKey) || (REFRESH.lastVersionKey !== versionKey);
        if (changed) {
          if (versionKey) REFRESH.lastVersionKey = versionKey;
          REFRESH.lastChangeAt = Date.now();
          if (REFRESH.mode !== RefreshMode.FAST) REFRESH.mode = RefreshMode.FAST;
          applyScene(sceneObj);
        } else {
          const idleMs = Date.now() - (REFRESH.lastChangeAt || Date.now());
          if (REFRESH.mode === RefreshMode.FAST && idleMs > FAST_TO_15_IDLE_MS) REFRESH.mode = RefreshMode.S15;
          else if (REFRESH.mode === RefreshMode.S15 && idleMs > S15_TO_30_IDLE_MS) REFRESH.mode = RefreshMode.S30;
          else if (REFRESH.mode === RefreshMode.S30 && idleMs > S30_TO_60_IDLE_MS) REFRESH.mode = RefreshMode.S60;
          else if (REFRESH.mode === RefreshMode.S60 && idleMs > S60_TO_OFF_IDLE_MS) REFRESH.mode = RefreshMode.OFF;
        }

        setRefreshUI();
        scheduleRefreshTick(false);
      } catch {
        setRefreshUI();
        scheduleRefreshTick(false);
      }
    }

    document.getElementById('refreshModeBtn')?.addEventListener('click', (ev) => {
      ev.stopPropagation();
      refreshButtonPressed();
    });

    // =====================================================================
    // ENGINE (do not edit during play)
    // =====================================================================

    let SCENE = {};
    let LAST_GOOD_SCENE = null;
    let SCENE_PARSE_ERROR = null;

    // ====== MOVEMENT TRAILS (lightweight, derived) ======
    const TRAIL_TTL_MS = 90000;
    const TRAIL_MAX_SEGMENTS = 24;
    let PENDING_PREV_POS = null;
    const MOVE_TRAILS = new Map();

    // ====== GRID CONFIG ======
    const cols = 17;
    const rows = 11;
    // Grid ‚Äúzoom‚Äù (more pixels per hex = less pixelated tokens)
    const GRID_SCALE = 1.5;
    const size = 34.5 * GRID_SCALE;
    const margin = 55 * GRID_SCALE;

    // Solid floor used for non-textured floors + cutouts
    const SOLID_FLOOR_COLOR = '#ffffff';

    const canvas = document.getElementById('mat');
    const ctx = canvas.getContext('2d');

    // Canvas resolution ("effective DPI"):
    // Keep the same on-page size, but allocate more *backing pixels* so the grid + sprites
    // render sharper (retina-aware, with optional supersampling).
    const MAT_W = 1410;
    const MAT_H = 1125;
    const SUPERSAMPLE = 2.0; // try 1.5 or 2.0 for extra crispness (higher GPU/CPU)

    function setupCanvasResolution() {
      const dpr = (window.devicePixelRatio || 1) * SUPERSAMPLE;
      canvas.style.width = MAT_W + 'px';
      canvas.style.height = MAT_H + 'px';
      canvas.width = Math.round(MAT_W * dpr);
      canvas.height = Math.round(MAT_H * dpr);

      // Draw using CSS-pixel coordinates.
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

      // Ensure high-quality sprite scaling (helps reduce ‚Äúpixelly‚Äù minification)
      ctx.imageSmoothingEnabled = true;
      try { ctx.imageSmoothingQuality = 'high'; } catch (_) {}

      return dpr;
    }

    const CANVAS_DPR = setupCanvasResolution();
    const SQRT3 = Math.sqrt(3);
    const letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';

    let ROOM_GEOMS = null;
    let ROOM_BY_ID = null;
    let SCENE_NORM = null;

    // TEMP DEBUG: disable fog-of-war rendering so we can inspect wall/room overlap math.
    // Set to false for normal play.
    const DEBUG_FOG_DISABLE = false;

    const CONFIG = {
      room: { yInsetFrac: 0.25 },
      labels: {
        dyFrac: 0.70,
        inRoomColor: [0, 0, 0],
        outRoomColor: [0, 0, 0],
        inRoomAlpha: 0.22,
        outRoomAlpha: 0.03
      },
      opening: {
        minAcross: 18,
        acrossMul: 1.05,
        spanNSMul: 1.5,
        spanEWMul: 1.0,
        slotPadPx: 1.8,
      },
      grid: {
        baseStrokeW: 1.2,
        baseStrokeA: 0.07,
        overlayStrokeW: 1.1,
        overlayStrokeA: 0.04,
      }
    };

    // =====================================================================
    // COORDINATE SYSTEM & GRID MATH
    // =====================================================================

    function qrToPixel(q, r) {
      const drawR = (rows - 1 - r);
      const columnOffset = (q % 2 === 0) ? 0 : 0.5;
      const x = size * (3/2) * q;
      const y = size * SQRT3 * (drawR + columnOffset);
      return { x: x + margin, y: y + margin };
    }

    function hexCorners(cx, cy) {
      const pts = [];
      for (let i = 0; i < 6; i++) {
        const a = (Math.PI / 180) * (60 * i);
        pts.push({ x: cx + size * Math.cos(a), y: cy + size * Math.sin(a) });
      }
      return pts;
    }

    function drawHexPath(pts) {
      ctx.beginPath();
      ctx.moveTo(pts[0].x, pts[0].y);
      for (let i = 1; i < pts.length; i++) ctx.lineTo(pts[i].x, pts[i].y);
      ctx.closePath();
    }

    function labelFor(q, r) { return `${letters[q]}${r + 1}`; }

    function parseLabel(label) {
      const m = String(label).trim().toUpperCase().match(/^([A-Z])([0-9]{1,2})$/);
      if (!m) return null;
      const q = letters.indexOf(m[1]);
      const r = Number(m[2]) - 1;
      if (q < 0 || q >= cols) return null;
      if (r < 0 || r >= rows) return null;
      return { q, r };
    }

    function labelToPixel(label) {
      const pos = parseLabel(label);
      if (!pos) return null;
      return qrToPixel(pos.q, pos.r);
    }

    function hexWidthPx() { return 2 * size; }
    function hexHeightPx() { return SQRT3 * size; }

    // =====================================================================
    // SCENE LOADING
    // =====================================================================

    function loadSceneFromJsonTag() {
      const el = document.getElementById('scene-json');
      const raw = el ? String(el.textContent || '').trim() : '';
      if (!raw) {
        SCENE_PARSE_ERROR = 'SCENE JSON is empty.';
        return (LAST_GOOD_SCENE || {});
      }
      try {
        const obj = JSON.parse(raw);
        LAST_GOOD_SCENE = obj;
        SCENE_PARSE_ERROR = null;
        return obj;
      } catch (e) {
        SCENE_PARSE_ERROR = `SCENE JSON parse error: ${e && e.message ? e.message : String(e)}`;
        try { console.error('[Battlemat] ' + SCENE_PARSE_ERROR); } catch (_) {}
        return (LAST_GOOD_SCENE || {});
      }
    }

    // ====== SCENE COERCION HELPERS ======

    function effectLabel(e) {
      if (typeof e === 'string') return e;
      if (e == null) return '';
      const t = typeof e;
      if (t === 'number' || t === 'boolean' || t === 'bigint') return String(e);
      if (t === 'object') {
        const label = e.name ?? e.label ?? e.id ?? e.type;
        if (label != null) return String(label);
        try { return JSON.stringify(e); } catch { return '[effect]'; }
      }
      return String(e);
    }

    function coerceNarration(v) {
      if (v == null) return '';
      if (typeof v === 'string') return v;
      if (Array.isArray(v)) return v.map(x => (x == null ? '' : String(x))).join('\n');
      try { return JSON.stringify(v); } catch { return String(v); }
    }

    function coerceActiveActorId(v) {
      if (v == null) return '';
      try { return String(v).trim(); } catch { return ''; }
    }

    function coerceLastAction(v) {
      if (v == null) return '';
      if (typeof v === 'string') return v;
      if (typeof v !== 'object') return String(v);

      try {
        const actor = v.actorName || v.actor || v.actor_id || v.actorId || '';
        const from = v.from || '';
        const to = v.to || '';
        const movePart = (from && to) ? `${from}‚Üí${to}` : (to ? `‚Üí${to}` : '');

        const atk = v.attack || v.atk || null;
        const dmg = v.damage || v.dmg || null;

        const roll = (atk && (atk.total ?? atk.roll ?? atk.toHit ?? atk.hitRoll)) ?? (v.total ?? v.roll ?? null);
        const weapon = (atk && (atk.name || atk.weapon)) || v.weapon || v.item || '';
        const dmgVal = (dmg && (dmg.value ?? dmg.amount)) ?? v.damageValue ?? v.dmgValue ?? null;

        const note = (typeof v.note === 'string' && v.note.trim()) ? v.note.trim() : '';

        const bits = [];
        if (actor) bits.push(String(actor));
        if (movePart) bits.push(String(movePart));

        const atkBits = [];
        if (roll != null && roll !== '') atkBits.push(`üé≤ ${roll}`);
        if (weapon) atkBits.push(`‚öîÔ∏è ${weapon}`);
        if (dmgVal != null && dmgVal !== '') atkBits.push(`‚Üí ${dmgVal} dmg`);
        if (atkBits.length) bits.push(atkBits.join(' '));

        if (note) bits.push(`‚Äî ${note}`);

        const out = bits.join('  ');
        if (out.trim()) return out;
      } catch (_) {}

      try { return JSON.stringify(v); } catch { return '[action]'; }
    }

    function normalizeScene() {
      const src = (typeof SCENE === 'object' && SCENE) ? SCENE : {};

      const warn = (msg, obj) => {
        try { console.warn(`[Battlemat] ${msg}`, obj ?? ''); } catch (_) {}
      };

      const roomsIn = Array.isArray(src.rooms) ? src.rooms : [];
      const roomsOut = [];
      const roomIds = new Set();
      for (let i = 0; i < roomsIn.length; i++) {
        const r = roomsIn[i] || {};
        const corners = Array.isArray(r.corners) ? r.corners : null;
        if (!corners || corners.length !== 4) { warn('Room skipped: corners must be 4 labels', r); continue; }
        if (corners.map(parseLabel).some(p => !p)) { warn('Room skipped: invalid corner label(s)', r); continue; }

        let id = String(r.id || '').trim();
        if (!id) id = `room_${i + 1}`;
        if (roomIds.has(id)) {
          warn(`Room id duplicated; making unique: ${id}`, r);
          let k = 2;
          while (roomIds.has(`${id}_${k}`)) k++;
          id = `${id}_${k}`;
        }
        roomIds.add(id);

        const floorKind = String(r.floorKind ?? r.floor_kind ?? '').trim();
        const wallKind = String(r.wallKind ?? r.wall_kind ?? '').trim();

        let floor = null;
        if (r.floor && typeof r.floor === 'object') floor = r.floor;
        else if (floorKind) floor = { kind: floorKind };

        let wall = null;
        if (r.wall && typeof r.wall === 'object') wall = r.wall;
        else if (wallKind) wall = { kind: wallKind };

        roomsOut.push({
          id,
          corners: corners.map(c => String(c).trim().toUpperCase()),
          thickness: Number(r.thickness ?? 18),
          color: String(r.color || '#555'),
          floor,
          wall
        });
      }

      const openingsIn = Array.isArray(src.openings) ? src.openings : [];
      const openingsOut = [];
      for (let i = 0; i < openingsIn.length; i++) {
        const o = openingsIn[i] || {};
        const kindRaw = String(o.kind || 'door').toLowerCase();
        const kindBase = kindRaw.split('.')[0];
        if (kindBase !== 'door' && kindBase !== 'window') { warn('Opening skipped: kind must be door/window (or door.* / window.*)', o); continue; }

        const room = String(o.room || '').trim();
        if (!room || !roomIds.has(room)) { warn(`Opening skipped: unknown room id '${room}'`, o); continue; }

        const wall = String(o.wall || '').trim().toUpperCase();
        if (!['N','S','E','W'].includes(wall)) { warn('Opening skipped: wall must be N/S/E/W', o); continue; }

        const at = String(o.at || '').trim().toUpperCase();
        if (!parseLabel(at)) { warn('Opening skipped: invalid at label', o); continue; }

        const state = String((o.state ?? 'closed')).toLowerCase();
        openingsOut.push({ ...o, kind: kindRaw, room, wall, at, state });
      }

      const objectsIn = Array.isArray(src.objects) ? src.objects : [];
      const objectsOut = [];
      for (let i = 0; i < objectsIn.length; i++) {
        const o = objectsIn[i] || {};
        const kind = String(o.kind || 'object').toLowerCase();
        const blocks = Boolean(o.blocks ?? false);

        let cells = [];
        if (Array.isArray(o.cells) && o.cells.length) {
          cells = o.cells.map(c => String(c).trim().toUpperCase()).filter(Boolean);
        } else if (o.at) {
          cells = [String(o.at).trim().toUpperCase()];
        }

        cells = cells.filter(lab => !!parseLabel(lab));
        if (!cells.length) { warn('Object skipped: missing/invalid at/cells', o); continue; }

        objectsOut.push({
          ...o,
          kind,
          blocks,
          cells,
          label: (o.label != null) ? String(o.label) : null,
          color: (o.color != null) ? String(o.color) : null
        });
      }

      const actorsIn = Array.isArray(src.actors) ? src.actors : [];
      const actorsOut = [];
      for (let i = 0; i < actorsIn.length; i++) {
        const a = actorsIn[i] || {};
        const at = String(a.at || '').trim().toUpperCase();
        if (!parseLabel(at)) { warn('Actor skipped: invalid at label', a); continue; }
        const side = String(a.side || 'NPC').toUpperCase();
        actorsOut.push({ ...a, at, side: (side === 'PC' || side === 'EN') ? side : 'NPC' });
      }

      const poiIn = Array.isArray(src.poi) ? src.poi : [];
      const poiOut = [];
      const poiIds = new Set();

      for (let i = 0; i < poiIn.length; i++) {
        const p = poiIn[i] || {};
        const type = String(p.type || '').trim().toLowerCase();
        if (!type) continue;

        let id = String(p.id || '').trim();
        if (!id) id = `poi_${i + 1}`;
        if (poiIds.has(id)) {
          let k = 2;
          while (poiIds.has(`${id}_${k}`)) k++;
          id = `${id}_${k}`;
        }
        poiIds.add(id);

        if (type === 'arrow') {
          const from = String(p.from || '').trim().toUpperCase();
          const to = String(p.to || '').trim().toUpperCase();
          if (!parseLabel(from) || !parseLabel(to)) { warn('POI arrow skipped: invalid from/to', p); continue; }
          poiOut.push({
            ...p,
            id,
            type,
            from,
            to,
            color: String(p.color || 'rgba(40,40,40,0.65)'),
            width: Number(p.width ?? 4),
            label: (p.label != null) ? String(p.label) : ''
          });
          continue;
        }

        poiOut.push({ ...p, id, type });
      }

      return {
        round: Number(src.round ?? 1),
        activeActorId: coerceActiveActorId(src.active_actor_id ?? src.activeActorId ?? src?.ui?.active_actor_id ?? src?.ui?.activeActorId),
        lastAction: coerceLastAction(src.lastAction ?? src.last_action ?? src.action),
        narration: coerceNarration(src.narration ?? src.notes ?? src.narrative),
        fog: (src.fog && typeof src.fog === 'object') ? src.fog : ((src.fow && typeof src.fow === 'object') ? src.fow : null),
        rooms: roomsOut,
        openings: openingsOut,
        objects: objectsOut,
        actors: actorsOut,
        poi: poiOut
      };
    }

    // =====================================================================
    // TEXTURES (floors + walls)
    // =====================================================================

    // Sentinel used by UI to mean: "use the room's own floor kind".
    const TEX_OVERRIDE_ROOM = '__room__';

    const TEX = {
      enabled: true,
      patterns: new Map(),
      tiles: new Map(),
      overrideFloorKind: TEX_OVERRIDE_ROOM,
      overrideWallKind: TEX_OVERRIDE_ROOM
    };

    // Populate the floor preview selector (textures are ALWAYS enabled now).
    function initTextureSelectors() {
      const sel = document.getElementById('floorTexSel');
      if (!sel) return;

      const options = [
        { value: TEX_OVERRIDE_ROOM, label: 'Room floors' },
        { value: 'stone', label: 'Stone' },
        { value: 'stone:blocks', label: 'Stone blocks' },
        { value: 'stone:cobble', label: 'Cobble' },
        { value: 'stone:marble', label: 'Marble' },
        { value: 'wood:oak', label: 'Wood (oak)' },
        { value: 'wood:pine', label: 'Wood (pine)' },
        { value: 'wood:gray', label: 'Wood (gray)' },
        { value: 'dirt:earth', label: 'Dirt' },
        { value: 'dirt:sand', label: 'Sand' },
        { value: 'grass', label: 'Grass' },
        { value: 'carpet:red', label: 'Carpet (red)' },
        { value: 'carpet:blue', label: 'Carpet (blue)' },
        { value: 'carpet:green', label: 'Carpet (green)' },
        { value: 'carpet:purple', label: 'Carpet (purple)' },
      ];

      sel.innerHTML = '';
      for (const o of options) {
        const opt = document.createElement('option');
        opt.value = o.value;
        opt.textContent = o.label;
        sel.appendChild(opt);
      }

      sel.value = String(TEX.overrideFloorKind || TEX_OVERRIDE_ROOM);

      sel.addEventListener('change', () => {
        TEX.overrideFloorKind = String(sel.value || TEX_OVERRIDE_ROOM);
        safeDrawGrid();
      });
    }

    // Small deterministic PRNG for ‚Äúnatural‚Äù texture variation (seeded by kind)
    function seededRng(seedStr) {
      let h = 2166136261;
      const s = String(seedStr || 'seed');
      for (let i = 0; i < s.length; i++) {
        h ^= s.charCodeAt(i);
        h = Math.imul(h, 16777619);
      }
      let state = h >>> 0;
      return function rand() {
        state = (Math.imul(1664525, state) + 1013904223) >>> 0;
        return state / 4294967296;
      };
    }

    function offscreenTile(w, h) {
      const c = document.createElement('canvas');
      c.width = w; c.height = h;
      return c;
    }

    // (Texture makers unchanged from prior versions ‚Äî kept verbatim but compacted)
    function makeWoodTile(variant) {
      const c = offscreenTile(220, 220);
      const g = c.getContext('2d');
      const vRaw = String(variant || '').trim().toLowerCase();

      const PAL = {
        oak:   { bg: '#c9b08a', plank: 'rgba(140, 95, 55, 0.18)', grain: 'rgba(60, 35, 20, 0.16)' },
        pine:  { bg: '#d7c59f', plank: 'rgba(155, 110, 65, 0.16)', grain: 'rgba(80, 50, 25, 0.14)' },
        dark:  { bg: '#7f6a52', plank: 'rgba(50, 32, 18, 0.22)', grain: 'rgba(20, 12, 7, 0.20)' },
        gray:  { bg: '#b7b1a9', plank: 'rgba(80, 75, 70, 0.14)', grain: 'rgba(35, 35, 35, 0.14)' },
      };

      const baseVariant = vRaw.split(':')[0] || 'oak';
      const flags = vRaw.split(':').slice(1);

      let orient = 'v';
      const flagStr = flags.join(':');
      if (flagStr.includes('horizontal') || flagStr.includes('h')) orient = 'h';
      if (flagStr.includes('vertical') || flagStr.includes('v')) orient = 'v';

      const cleanOak = (baseVariant === 'oak');
      const P = PAL[baseVariant] || PAL.oak;
      const rand = seededRng('wood:' + (vRaw || 'oak'));

      g.fillStyle = P.bg;
      g.fillRect(0, 0, c.width, c.height);

      const plank = 28;
      const scratchMul = 0.5;

      g.strokeStyle = P.grain;
      g.lineWidth = 1;

      if (orient === 'h') {
        for (let y = 0; y < c.height + plank; y += plank) {
          g.fillStyle = P.plank;
          g.fillRect(0, y, c.width, plank);

          const a0 = g.globalAlpha;
          g.globalAlpha = a0 * scratchMul;
          const grainN = cleanOak ? 2 : 6;

          for (let i = 0; i < grainN; i++) {
            g.beginPath();
            g.moveTo(0, y + 2 + rand() * (plank - 4));
            g.bezierCurveTo(
              c.width * 0.35, y + (plank * 0.50) + (rand() - 0.5) * 10,
              c.width * 0.65, y + (plank * 0.50) + (rand() - 0.5) * 10,
              c.width, y + 2 + rand() * (plank - 4)
            );
            g.stroke();

            if (!cleanOak) {
              const x = rand() * c.width;
              g.globalAlpha = a0 * scratchMul * 0.65;
              g.beginPath();
              g.moveTo(x, y + 4 + rand() * (plank - 8));
              g.lineTo(x + 18 + rand() * 22, y + 4 + rand() * (plank - 8));
              g.stroke();
              g.globalAlpha = a0 * scratchMul;
            }
          }

          g.globalAlpha = a0;

          g.strokeStyle = 'rgba(0,0,0,0.10)';
          g.beginPath();
          g.moveTo(0, y + plank);
          g.lineTo(c.width, y + plank);
          g.stroke();

          g.fillStyle = 'rgba(255,255,255,0.03)';
          g.fillRect(0, y + 1, c.width, 2);

          g.strokeStyle = P.grain;
          g.lineWidth = 1;
        }
      } else {
        for (let x = 0; x < c.width + plank; x += plank) {
          g.fillStyle = P.plank;
          g.fillRect(x, 0, plank, c.height);

          const a0 = g.globalAlpha;
          g.globalAlpha = a0 * scratchMul;

          const grainN = cleanOak ? 3 : 6;
          for (let i = 0; i < grainN; i++) {
            const y = rand() * c.height;
            g.beginPath();
            g.moveTo(x + 2, y);
            g.bezierCurveTo(
              x + plank * 0.35, y + (rand() - 0.5) * 18,
              x + plank * 0.65, y + (rand() - 0.5) * 18,
              x + plank - 2, y
            );
            g.stroke();
          }

          g.globalAlpha = a0;

          g.strokeStyle = 'rgba(0,0,0,0.10)';
          g.beginPath();
          g.moveTo(x + plank, 0);
          g.lineTo(x + plank, c.height);
          g.stroke();

          g.fillStyle = 'rgba(255,255,255,0.03)';
          g.fillRect(x + 1, 0, 2, c.height);

          g.strokeStyle = P.grain;
          g.lineWidth = 1;
        }
      }

      if (!cleanOak) {
        for (let k = 0; k < 14; k++) {
          const x = rand() * c.width;
          const y = rand() * c.height;
          const r = 3 + rand() * 7;
          g.strokeStyle = 'rgba(50, 25, 10, 0.18)';
          g.lineWidth = 1;
          g.beginPath();
          g.ellipse(x, y, r * 1.2, r, rand() * Math.PI, 0, Math.PI * 2);
          g.stroke();
        }
      }

      return c;
    }

    function makeStoneTile(variant) {
      const v = String(variant || '').trim().toLowerCase();
      const isCobble = (v === 'cobble' || v === 'cobblestone');
      const isDark = (v === 'dark' || v === 'basalt');
      const isMarble = (v === 'marble');
      const isBlocks = (v === 'blocks' || v === 'block' || v.includes('ashlar') || v.includes('block'));

      const c = isBlocks ? offscreenTile(320, 320) : offscreenTile(240, 240);
      const g = c.getContext('2d');
      const rand = seededRng('stone:' + (v || 'slab'));

      const base = isMarble ? '#d7d7d7' : (isDark ? '#8a8a8a' : '#b6b6b6');
      g.fillStyle = base;
      g.fillRect(0, 0, c.width, c.height);

      if (isBlocks) {
        const mortar = 3;
        const rowH = 40;
        const lens = [54, 72, 92, 64, 84];

        g.fillStyle = isDark ? '#7c7c7c' : '#a9a9a9';
        g.fillRect(0, 0, c.width, c.height);

        let row = 0;
        for (let y = 0; y < c.height + rowH; y += (rowH + mortar)) {
          const offset = (row % 2 === 0) ? 0 : Math.floor((lens[1] + mortar) / 2);
          let x = -offset;

          while (x < c.width + 120) {
            const baseLen = lens[Math.floor(rand() * lens.length)];
            const len = baseLen + Math.floor((rand() - 0.5) * 10);

            const shadeA = (isDark ? 0.18 : 0.12) + rand() * 0.08;
            g.fillStyle = `rgba(110,110,110,${shadeA})`;
            g.fillRect(x + mortar, y + mortar, len, rowH);

            g.fillStyle = 'rgba(255,255,255,0.06)';
            g.fillRect(x + mortar + 1, y + mortar + 1, len - 2, 2);
            g.fillRect(x + mortar + 1, y + mortar + 1, 2, rowH - 2);

            g.fillStyle = 'rgba(0,0,0,0.07)';
            g.fillRect(x + mortar + 1, y + mortar + rowH - 3, len - 2, 2);
            g.fillRect(x + mortar + len - 3, y + mortar + 1, 2, rowH - 2);

            g.strokeStyle = 'rgba(0,0,0,0.10)';
            g.lineWidth = 1;
            g.strokeRect(x + mortar, y + mortar, len, rowH);

            x += (len + mortar);
          }
          row++;
        }

        const specks = isDark ? 1100 : 850;
        for (let i = 0; i < specks; i++) {
          const xx = rand() * c.width;
          const yy = rand() * c.height;
          const a = 0.03 + rand() * 0.06;
          g.fillStyle = `rgba(0,0,0,${a})`;
          g.fillRect(xx, yy, 1, 1);
        }

        return c;
      }

      const slabLike = !isCobble && !isMarble && !isBlocks;
      if (slabLike) {
        const mortar = 3;
        const rowH = 46;
        const lens = [54, 72, 92, 64, 84];

        g.fillStyle = isDark ? '#7c7c7c' : '#a9a9a9';
        g.fillRect(0, 0, c.width, c.height);

        let row = 0;
        for (let y = 0; y < c.height + rowH; y += (rowH + mortar)) {
          const offset = (row % 2 === 0) ? 0 : Math.floor((lens[1] + mortar) / 2);
          let x = -offset;

          while (x < c.width + 120) {
            const baseLen = lens[Math.floor(rand() * lens.length)];
            const len = baseLen + Math.floor((rand() - 0.5) * 8);

            const shadeA = (isDark ? 0.16 : 0.11) + rand() * 0.06;
            g.fillStyle = `rgba(110,110,110,${shadeA})`;
            g.fillRect(x + mortar, y + mortar, len, rowH);

            g.fillStyle = 'rgba(255,255,255,0.05)';
            g.fillRect(x + mortar + 1, y + mortar + 1, len - 2, 2);
            g.fillRect(x + mortar + 1, y + mortar + 1, 2, rowH - 2);

            g.fillStyle = 'rgba(0,0,0,0.06)';
            g.fillRect(x + mortar + 1, y + mortar + rowH - 3, len - 2, 2);
            g.fillRect(x + mortar + len - 3, y + mortar + 1, 2, rowH - 2);

            g.strokeStyle = 'rgba(0,0,0,0.10)';
            g.lineWidth = 1;
            g.strokeRect(x + mortar, y + mortar, len, rowH);

            if (rand() < 0.18) {
              g.strokeStyle = 'rgba(0,0,0,0.10)';
              g.lineWidth = 1;
              g.beginPath();
              const cx = x + mortar + 6 + rand() * (len - 12);
              const cy = y + mortar + 6 + rand() * (rowH - 12);
              g.moveTo(cx, cy);
              g.lineTo(cx + (rand() - 0.5) * 26, cy + (rand() - 0.5) * 18);
              g.stroke();
            }

            x += (len + mortar);
          }
          row++;
        }

        const specks = isDark ? 900 : 650;
        for (let i = 0; i < specks; i++) {
          const xx = rand() * c.width;
          const yy = rand() * c.height;
          const a = 0.03 + rand() * 0.06;
          g.fillStyle = `rgba(0,0,0,${a})`;
          g.fillRect(xx, yy, 1, 1);
        }

        return c;
      }

      const cell = isCobble ? 34 : 48;
      for (let y = 0; y < c.height + cell; y += cell) {
        for (let x = 0; x < c.width + cell; x += cell) {
          const jitterX = (rand() - 0.5) * (isCobble ? 10 : 4);
          const jitterY = (rand() - 0.5) * (isCobble ? 10 : 4);
          const w = cell + (rand() - 0.5) * (isCobble ? 18 : 10);
          const h = cell + (rand() - 0.5) * (isCobble ? 18 : 10);

          const shade = isDark ? 0.16 : 0.12;
          g.fillStyle = `rgba(110,110,110,${shade + rand() * 0.10})`;
          g.fillRect(x + jitterX, y + jitterY, w, h);

          g.strokeStyle = `rgba(0,0,0,${isCobble ? 0.14 : 0.09})`;
          g.lineWidth = 1;
          g.strokeRect(x + jitterX, y + jitterY, w, h);
        }
      }

      if (isMarble) {
        g.strokeStyle = 'rgba(60,60,60,0.10)';
        g.lineWidth = 2;
        for (let i = 0; i < 6; i++) {
          g.beginPath();
          let x = rand() * c.width;
          let y = rand() * c.height;
          g.moveTo(x, y);
          for (let k = 0; k < 6; k++) {
            x += (rand() - 0.5) * 70;
            y += (rand() - 0.5) * 40;
            g.lineTo(x, y);
          }
          g.stroke();
        }
      }

      const specks = isDark ? 900 : 600;
      for (let i = 0; i < specks; i++) {
        const x = rand() * c.width;
        const y = rand() * c.height;
        const a = 0.03 + rand() * 0.06;
        g.fillStyle = `rgba(0,0,0,${a})`;
        g.fillRect(x, y, 1, 1);
      }

      return c;
    }

    function makeBrickTile(variant) {
      // Uniform cool-gray brick wall (no random size/color variation).
      // Variants still supported: red / pale / soot / gray.
      let v = String(variant || '').trim().toLowerCase();
      if (!v) v = 'gray';

      // Larger tile reduces repetition, but the pattern is perfectly regular.
      const c = offscreenTile(256, 192);
      const g = c.getContext('2d');

      const PAL = {
        red:  { mortar: '#c9c3b8', brick: [145,  80,  55] },
        pale: { mortar: '#d6d2c9', brick: [155, 135, 118] },
        soot: { mortar: '#bfb8ad', brick: [112,  78,  64] },
        gray: { mortar: '#6a7078', brick: [118, 120, 124] },
      };
      const P = PAL[v] || PAL.gray;

      // Mortar base
      g.fillStyle = P.mortar;
      g.fillRect(0, 0, c.width, c.height);

      // Brick geometry (small bricks)
      const brickW = 16;
      const brickH = 8;
      const mortar = 2;
      const radius = 2;

      function rr(x, y, w, h, r) {
        const rr0 = Math.max(0, Math.min(r, Math.min(w, h) / 2));
        g.beginPath();
        g.moveTo(x + rr0, y);
        g.lineTo(x + w - rr0, y);
        g.quadraticCurveTo(x + w, y, x + w, y + rr0);
        g.lineTo(x + w, y + h - rr0);
        g.quadraticCurveTo(x + w, y + h, x + w - rr0, y + h);
        g.lineTo(x + rr0, y + h);
        g.quadraticCurveTo(x, y + h, x, y + h - rr0);
        g.lineTo(x, y + rr0);
        g.quadraticCurveTo(x, y, x + rr0, y);
        g.closePath();
      }

      const [br, bg, bb] = P.brick;
      const hi = [Math.min(255, br + 10), Math.min(255, bg + 10), Math.min(255, bb + 10)];
      const lo = [Math.max(0, br - 10), Math.max(0, bg - 10), Math.max(0, bb - 10)];

      // Draw rows with clean half-brick offset. No jitter.
      const stepY = brickH + mortar;
      const stepX = brickW + mortar;
      const rowsN = Math.ceil(c.height / stepY) + 1;

      for (let row = 0; row < rowsN; row++) {
        const y0 = row * stepY;
        const offset = (row % 2 === 0) ? 0 : Math.floor(brickW / 2);

        for (let x0 = -offset; x0 < c.width + brickW; x0 += stepX) {
          const x = x0 + mortar;
          const y = y0 + mortar;
          const w = brickW;
          const h = brickH;

          // Subtle constant vertical gradient for depth (same for every brick).
          const grad = g.createLinearGradient(x, y, x, y + h);
          grad.addColorStop(0, `rgb(${hi[0]},${hi[1]},${hi[2]})`);
          grad.addColorStop(1, `rgb(${lo[0]},${lo[1]},${lo[2]})`);

          rr(x, y, w, h, radius);
          g.fillStyle = grad;
          g.fill();

          // Gentle highlight + edge (uniform)
          g.save();
          g.globalAlpha = 0.12;
          rr(x + 1, y + 1, w - 2, h - 2, Math.max(0, radius - 1));
          g.strokeStyle = 'rgba(255,255,255,1)';
          g.lineWidth = 2;
          g.stroke();
          g.restore();

          g.strokeStyle = 'rgba(0,0,0,0.20)';
          g.lineWidth = 1;
          rr(x, y, w, h, radius);
          g.stroke();
        }
      }

      return c;
    }

    function makeDirtTile(variant) {
      const v = String(variant || '').trim().toLowerCase();
      const rand = seededRng('dirt:' + (v || 'earth'));

      const c = offscreenTile(240, 240);
      const g = c.getContext('2d');

      const PAL = {
        earth: { bg: '#9b835e', dark: 'rgba(60,40,20,0.10)', light: 'rgba(255,255,255,0.06)' },
        sand:  { bg: '#d2c18b', dark: 'rgba(120,95,55,0.08)', light: 'rgba(255,255,255,0.07)' },
        mud:   { bg: '#6f5a42', dark: 'rgba(20,15,10,0.14)', light: 'rgba(255,255,255,0.04)' },
      };
      const P = PAL[v] || PAL.earth;

      g.fillStyle = P.bg;
      g.fillRect(0, 0, c.width, c.height);

      for (let i = 0; i < 1200; i++) {
        const x = rand() * c.width;
        const y = rand() * c.height;
        const r = 1 + rand() * 6;
        g.fillStyle = (rand() < 0.6) ? P.dark : P.light;
        g.beginPath();
        g.arc(x, y, r, 0, Math.PI * 2);
        g.fill();
      }

      g.strokeStyle = 'rgba(0,0,0,0.10)';
      g.lineWidth = 1;
      for (let k = 0; k < 55; k++) {
        const x = rand() * c.width;
        const y = rand() * c.height;
        const rx = 2 + rand() * 4;
        const ry = 1 + rand() * 3;
        g.fillStyle = 'rgba(255,255,255,0.08)';
        g.beginPath();
        g.ellipse(x, y, rx, ry, rand() * Math.PI, 0, Math.PI * 2);
        g.fill();
        g.beginPath();
        g.ellipse(x, y, rx, ry, rand() * Math.PI, 0, Math.PI * 2);
        g.stroke();
      }

      return c;
    }

    function makeGrassTile() {
      const rand = seededRng('grass');
      const c = offscreenTile(240, 240);
      const g = c.getContext('2d');

      g.fillStyle = '#8ea86c';
      g.fillRect(0, 0, c.width, c.height);

      for (let i = 0; i < 1200; i++) {
        const x = rand() * c.width;
        const y = rand() * c.height;
        const a = 0.03 + rand() * 0.06;
        g.fillStyle = `rgba(0,0,0,${a})`;
        g.fillRect(x, y, 1, 1);
      }

      g.strokeStyle = 'rgba(30,60,20,0.10)';
      g.lineWidth = 1;
      for (let k = 0; k < 220; k++) {
        const x = rand() * c.width;
        const y = rand() * c.height;
        const len = 6 + rand() * 16;
        const ang = (-Math.PI / 2) + (rand() - 0.5) * 0.9;
        g.beginPath();
        g.moveTo(x, y);
        g.lineTo(x + Math.cos(ang) * len, y + Math.sin(ang) * len);
        g.stroke();
      }

      return c;
    }

    function makeCarpetTile(variant) {
      const v = String(variant || '').trim().toLowerCase();
      const rand = seededRng('carpet:' + (v || 'red'));
      const c = offscreenTile(240, 240);
      const g = c.getContext('2d');

      const PAL = {
        red:   { bg: '#9d3a2f', stripe: 'rgba(255,255,255,0.10)', dark: 'rgba(0,0,0,0.12)' },
        blue:  { bg: '#2f4f7a', stripe: 'rgba(255,255,255,0.10)', dark: 'rgba(0,0,0,0.12)' },
        green: { bg: '#2f6b4a', stripe: 'rgba(255,255,255,0.10)', dark: 'rgba(0,0,0,0.12)' },
        purple:{ bg: '#5b3a7a', stripe: 'rgba(255,255,255,0.10)', dark: 'rgba(0,0,0,0.12)' },
      };
      const P = PAL[v] || PAL.red;

      g.fillStyle = P.bg;
      g.fillRect(0, 0, c.width, c.height);

      for (let i = 0; i < 2200; i++) {
        const x = rand() * c.width;
        const y = rand() * c.height;
        const a = 0.02 + rand() * 0.05;
        g.fillStyle = `rgba(255,255,255,${a})`;
        g.fillRect(x, y, 1, 1);
      }

      g.fillStyle = P.dark;
      g.fillRect(0, 0, c.width, 10);
      g.fillRect(0, c.height - 10, c.width, 10);
      g.fillRect(0, 0, 10, c.height);
      g.fillRect(c.width - 10, 0, 10, c.height);

      g.fillStyle = P.stripe;
      for (let y = 18; y < c.height; y += 28) g.fillRect(0, y, c.width, 2);

      return c;
    }

    function normalizeTextureKind(kind) {
      const raw = String(kind || '').trim().toLowerCase();
      if (!raw) return { base: 'stone', variant: '', key: 'stone' };

      let base = raw;
      let variant = '';

      if (raw.includes(':')) {
        const parts = raw.split(':');
        base = (parts[0] || raw).trim();
        variant = parts.slice(1).join(':').trim();
      } else if (raw.includes('.')) {
        const parts = raw.split('.');
        const head = (parts[0] || raw).trim();
        if (parts.length >= 2 && ['wood','stone','brick','dirt','grass','carpet','marble','cobble','cobblestone','planks','timber','slab','slabs','tile','tiles','sand','mud'].includes(head)) {
          base = head;
          variant = parts.slice(1).join('.').trim();
        }
      } else if (raw.includes('-')) {
        const parts = raw.split('-');
        const head = (parts[0] || raw).trim();
        if (parts.length >= 2 && ['wood','stone','brick','dirt','carpet'].includes(head)) {
          base = head;
          variant = parts.slice(1).join('-').trim();
        }
      }

      const syn = { planks: 'wood', timber: 'wood', slabs: 'stone', slab: 'stone', tiles: 'stone', tile: 'stone', bricks: 'brick' };
      base = syn[base] || base;

      if (base === 'cobble' || base === 'cobblestone') { base = 'stone'; if (!variant) variant = 'cobble'; }
      if (base === 'marble') { base = 'stone'; if (!variant) variant = 'marble'; }
      if (base === 'sand') { base = 'dirt'; if (!variant) variant = 'sand'; }

      if (!['wood','stone','brick','dirt','grass','carpet'].includes(base)) {
        base = 'stone';
        variant = '';
      }

      const key = base + (variant ? ':' + variant : '');
      return { base, variant, key };
    }

    function textureTileFor(kind) {
      const nk = normalizeTextureKind(kind);
      const key = nk.key;
      if (TEX.tiles.has(key)) return TEX.tiles.get(key);

      let tile;
      if (nk.base === 'wood') tile = makeWoodTile(nk.variant);
      else if (nk.base === 'brick') tile = makeBrickTile(nk.variant);
      else if (nk.base === 'dirt') tile = makeDirtTile(nk.variant);
      else if (nk.base === 'grass') tile = makeGrassTile();
      else if (nk.base === 'carpet') tile = makeCarpetTile(nk.variant);
      else tile = makeStoneTile(nk.variant);

      TEX.tiles.set(key, tile);
      return tile;
    }

    function texturePatternFor(kind) {
      const nk = normalizeTextureKind(kind);
      const key = nk.key;
      if (TEX.patterns.has(key)) return TEX.patterns.get(key);

      const tile = textureTileFor(key);
      const pat = ctx.createPattern(tile, 'repeat');
      TEX.patterns.set(key, pat);
      return pat;
    }

    function floorKindForRoom(room) {
      const ov = String(TEX.overrideFloorKind || '').trim();
      if (ov && ov !== TEX_OVERRIDE_ROOM) return ov;
      const k = room?.floor?.kind ?? room?.floorKind ?? room?.floor_kind ?? '';
      const s = String(k || '').trim().toLowerCase();
      return s || 'stone';
    }

    function wallKindForRoom(room) {
      const ov = String(TEX.overrideWallKind || '').trim();
      if (ov && ov !== TEX_OVERRIDE_ROOM) return ov;
      const k = room?.wall?.kind ?? room?.wallKind ?? room?.wall_kind ?? '';
      const s = String(k || '').trim().toLowerCase();
      // Default wall look: the new gray brick.
      return s || 'brick:gray';
    }

    // =====================================================================
    // SPRITES (native sizing by default)
    // =====================================================================

    const SPRITE_BASE = '/assets/sprites';

    // Convention: 512px of sprite height == 1 hex height.
    const SPRITE_PX_PER_HEX = 512;

    let SPRITE_DEFS = {};
    const SPRITE_CACHE = new Map(); // url -> Image

    // Robust image readiness check: some browsers mark failed loads as complete=true but naturalWidth=0,
    // and drawImage() will throw "Passed-in image is \"broken\"".
    function isImgUsable(img) {
      if (!img) return false;
      if (img.__broken) return false;
      if (!img.complete) return false;
      const nw = Number(img.naturalWidth ?? img.width ?? 0);
      const nh = Number(img.naturalHeight ?? img.height ?? 0);
      return nw > 0 && nh > 0;
    }

    function spriteDefForKey(key) {
      if (!key) return null;
      const k = String(key).trim();
      return SPRITE_DEFS[k] || null;
    }

    function ensureSpriteLoaded(url) {
      const u = String(url || '').trim();
      if (!u) return null;
      if (SPRITE_CACHE.has(u)) return SPRITE_CACHE.get(u);

      const img = new Image();
      img.decoding = 'async';
      img.loading = 'eager';
      img.__broken = false;

      img.onload = () => {
        img.__broken = false;
        try { if (SCENE_NORM) safeDrawGrid(); } catch (_) {}
      };

      img.onerror = () => {
        img.__broken = true;
        try {
          console.warn('[Battlemat] Sprite failed to load:', u);
          // Re-render so we fall back to non-sprite tokens/rects instead of crashing.
          if (SCENE_NORM) safeDrawGrid();
        } catch (_) {}
      };

      img.src = u;

      SPRITE_CACHE.set(u, img);
      return img;
    }

    function requestSpritePreload(sceneNorm) {
      const keys = new Set();

      for (const o of (sceneNorm?.objects || [])) {
        const k = spriteKeyForObject(o);
        if (k) keys.add(k);
      }

      for (const a of (sceneNorm?.actors || [])) {
        const k = spriteKeyForActor(a);
        if (k) keys.add(k);
      }

      for (const op of (sceneNorm?.openings || [])) {
        const kind = String(op.kind || '').toLowerCase();
        const base = kind.split('.')[0];
        if (base !== 'door' && base !== 'window') continue;

        const isOpen = String(op.state || 'closed').toLowerCase() === 'open';

        const closedKey = (SPRITE_DEFS[kind] ? kind : (SPRITE_DEFS[base] ? base : null));
        if (closedKey) keys.add(closedKey);

        // If the opening is open and we have an open sprite, preload it.
        if (isOpen) {
          const openKey = (SPRITE_DEFS[`${kind}.open`] ? `${kind}.open` : (SPRITE_DEFS[`${base}.open`] ? `${base}.open` : null));
          if (openKey) keys.add(openKey);
        }
      }

      for (const k of keys) {
        const def = spriteDefForKey(k);
        if (def?.url) ensureSpriteLoaded(def.url);
      }
    }

    function isSpriteReady(key) {
      const def = spriteDefForKey(key);
      if (!def || !def.url) return false;
      const img = ensureSpriteLoaded(def.url);
      return isImgUsable(img);
    }

    function spriteCanvasSize(def, img, scaleMul) {
      const nw = Number(def?.wPx ?? img?.naturalWidth ?? img?.width ?? 0);
      const nh = Number(def?.hPx ?? img?.naturalHeight ?? img?.height ?? 0);

      const pxToCanvas = hexHeightPx() / Math.max(1, Number(SPRITE_PX_PER_HEX));
      const defScale = (def && def.scale != null) ? Number(def.scale) : 1;
      const entScale = (scaleMul != null) ? Number(scaleMul) : 1;

      return {
        w: nw * pxToCanvas * defScale * entScale,
        h: nh * pxToCanvas * defScale * entScale
      };
    }

    function drawSoftShadow(x, y, w, h, alpha) {
      ctx.save();
      ctx.globalAlpha = Math.max(0, Math.min(1, Number(alpha ?? 0.18)));
      ctx.fillStyle = 'rgba(0,0,0,1)';
      ctx.filter = 'blur(8px)';
      ctx.beginPath();
      ctx.ellipse(x, y, Math.max(6, w * 0.30), Math.max(6, h * 0.16), 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.filter = 'none';
      ctx.restore();
    }

    function drawSpriteAt(key, x, y, rotDeg, scaleMul, alphaMul, axOverride, ayOverride) {
      const def = spriteDefForKey(key);
      if (!def) return false;
      const img = ensureSpriteLoaded(def.url);
      if (!isImgUsable(img)) return false;

      try {
        if (DEBUG_SPRITES && key && !SPRITE_LOGGED_KEYS.has(String(key))) {
          console.log(
            '[sprite]',
            key,
            'src=', img.src,
            'natural=', (img.naturalWidth || img.width) + 'x' + (img.naturalHeight || img.height),
            'smoothing=', ctx.imageSmoothingEnabled
          );
          SPRITE_LOGGED_KEYS.add(String(key));
        }
      } catch (_) {}

      const sz = spriteCanvasSize(def, img, scaleMul);
      const w = sz.w;
      const h = sz.h;

      const axO = (axOverride != null && axOverride !== '') ? Number(axOverride) : null;
      const ayO = (ayOverride != null && ayOverride !== '') ? Number(ayOverride) : null;
      const ax = Number.isFinite(axO) ? axO : (def.ax ?? 0.5);
      const ay = Number.isFinite(ayO) ? ayO : (def.ay ?? 0.5);

      if (def.shadow) {
        drawSoftShadow(x + 2, y + (h * 0.12), w, h, 0.16);
      }

      ctx.save();
      ctx.globalAlpha = (alphaMul == null) ? 1 : alphaMul;
      ctx.translate(x, y);
      if (rotDeg) ctx.rotate((Math.PI / 180) * rotDeg);
      try {
        ctx.drawImage(img, -w * ax, -h * ay, w, h);
      } catch (e) {
        // If the browser considers the image "broken", avoid taking down the whole render.
        try { img.__broken = true; } catch (_) {}
        try { console.warn('[Battlemat] drawImage failed for sprite:', key, img?.src, e); } catch (_) {}
        ctx.restore();
        return false;
      }
      ctx.restore();

      return true;
    }

    function spriteKeyForObject(obj) {
      if (!obj || typeof obj !== 'object') return null;
      const explicit = (obj.sprite ?? obj.spriteKey ?? obj.sprite_key);
      if (explicit != null && String(explicit).trim()) return String(explicit).trim();

      const kind = String(obj.kind || '').trim().toLowerCase();
      if (!kind) return null;

      if (SPRITE_DEFS[kind]) return kind;
      return null;
    }

    function spriteKeyForActor(actorObj) {
      if (!actorObj || typeof actorObj !== 'object') return null;

      const explicit = (actorObj.sprite ?? actorObj.spriteKey ?? actorObj.sprite_key);
      if (explicit != null && String(explicit).trim()) return String(explicit).trim();

      const cls = String(actorObj.class ?? actorObj.cls ?? actorObj.archetype ?? '').trim().toLowerCase();
      const g = String(actorObj.gender ?? actorObj.sex ?? '').trim().toLowerCase();
      if (cls && g) {
        const key = `${cls}.${g}`;
        if (SPRITE_DEFS[key]) return key;
      }

      const side = String(actorObj.side || 'NPC').toUpperCase();
      if (side === 'PC' && SPRITE_DEFS['token.pc']) return 'token.pc';
      if (side === 'EN' && SPRITE_DEFS['token.en']) return 'token.en';
      if (SPRITE_DEFS['token.npc']) return 'token.npc';

      return null;
    }

    function entityRotDeg(ent, fallbackDeg) {
      if (!ent || typeof ent !== 'object') return (fallbackDeg ?? 0);

      let base = null;
      let v = (ent.rot ?? ent.rotation ?? ent.rotDeg);
      if (v != null && v !== '') {
        const n = Number(v);
        if (Number.isFinite(n)) base = n;
      }

      if (base == null) {
        const o = String(ent.orientation ?? ent.orient ?? ent.dir ?? '').trim().toLowerCase();
        if (o) {
          if (o === 'v' || o === 'vert' || o === 'vertical') base = 90;
          else if (o === 'h' || o === 'horiz' || o === 'horizontal') base = 0;
        }
      }

      if (base == null) base = (fallbackDeg ?? 0);

      const off = (ent.rotOffset ?? ent.rotRel ?? ent.rotDelta);
      if (off != null && off !== '') {
        const n = Number(off);
        if (Number.isFinite(n)) base = base + n;
      }

      let d = ((base % 360) + 360) % 360;
      const snapped = Math.round(d / 90) * 90;
      d = ((snapped % 360) + 360) % 360;
      return d;
    }

    // =====================================================================
    // MOVEMENT TRAILS
    // =====================================================================

    function captureActorPositions(sceneNorm) {
      const m = new Map();
      for (const a of (sceneNorm?.actors || [])) {
        const id = String(a.id ?? '').trim();
        const at = String(a.at ?? '').trim().toUpperCase();
        if (!id || !at) continue;
        m.set(id, { at, side: String(a.side || 'NPC').toUpperCase() });
      }
      return m;
    }

    function pruneTrails(now) {
      const t = Number(now || Date.now());
      for (const [id, segs] of MOVE_TRAILS.entries()) {
        const kept = (segs || []).filter(s => (t - (s.ts || 0)) <= TRAIL_TTL_MS);
        if (!kept.length) MOVE_TRAILS.delete(id);
        else MOVE_TRAILS.set(id, kept.slice(-TRAIL_MAX_SEGMENTS));
      }
    }

    function updateTrailsFromPending() {
      if (!PENDING_PREV_POS) return;
      const prev = PENDING_PREV_POS;
      PENDING_PREV_POS = null;

      const now = Date.now();
      pruneTrails(now);

      for (const a of (SCENE_NORM?.actors || [])) {
        const id = String(a.id ?? '').trim();
        const at = String(a.at ?? '').trim().toUpperCase();
        if (!id || !at) continue;
        const prevRec = prev.get(id);
        if (!prevRec) continue;
        const prevAt = String(prevRec.at || '').trim().toUpperCase();
        if (!prevAt || prevAt === at) continue;

        const seg = { from: prevAt, to: at, ts: now, side: String(a.side || prevRec.side || 'NPC').toUpperCase() };
        const arr = MOVE_TRAILS.get(id) || [];
        arr.push(seg);
        MOVE_TRAILS.set(id, arr.slice(-TRAIL_MAX_SEGMENTS));
      }
    }

    function drawTrails() {
      if (!MOVE_TRAILS.size) return;
      const now = Date.now();
      pruneTrails(now);

      ctx.save();
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';

      for (const segs of MOVE_TRAILS.values()) {
        for (const s of (segs || [])) {
          const a = labelToPixel(s.from);
          const b = labelToPixel(s.to);
          if (!a || !b) continue;

          const age = Math.max(0, now - (s.ts || now));
          const t = Math.max(0, Math.min(1, 1 - (age / TRAIL_TTL_MS)));
          const alpha = 0.08 + 0.18 * t;

          ctx.strokeStyle = (String(s.side || '').toUpperCase() === 'PC')
            ? `rgba(80,160,220,${alpha})`
            : `rgba(60,60,60,${alpha})`;
          ctx.lineWidth = 5;

          ctx.beginPath();
          ctx.moveTo(a.x, a.y);
          ctx.lineTo(b.x, b.y);
          ctx.stroke();
        }
      }

      ctx.restore();
    }

    // =====================================================================
    // NOTES (Narration) persistence
    // =====================================================================

    const NOTES = {
      battleId: null,
      keyNarr: null,
      debounce: null,
      dirty: false,
      lastSceneNarration: ''
    };

    function notesKey(base, battleId) {
      return `battlemat:${base}:${battleId || 'local'}`;
    }

    function initNotesUi(battleId) {
      NOTES.battleId = battleId || null;
      NOTES.keyNarr = notesKey('narration', battleId);

      const narr = document.getElementById('narrationBox');
      const fallback = String(SCENE_NORM?.narration || '').trim();
      NOTES.lastSceneNarration = fallback;

      try {
        const stored = localStorage.getItem(NOTES.keyNarr) || '';
        if (narr) narr.value = stored || fallback;
        NOTES.dirty = !!stored;
      } catch (_) {
        if (narr) narr.value = fallback;
        NOTES.dirty = false;
      }

      const save = () => {
        try { if (narr) localStorage.setItem(NOTES.keyNarr, narr.value || ''); } catch (_) {}
      };

      const onInput = () => {
        NOTES.dirty = true;
        if (NOTES.debounce) clearTimeout(NOTES.debounce);
        NOTES.debounce = setTimeout(save, 200);
      };

      narr?.addEventListener('input', onInput);
    }

    function syncNarrationFromScene() {
      const narr = document.getElementById('narrationBox');
      if (!narr) return;

      const sceneText = String(SCENE_NORM?.narration || '').trim();
      if (!sceneText) return;

      const cur = String(narr.value || '');
      const curTrim = cur.trim();
      const last = String(NOTES.lastSceneNarration || '').trim();

      if (NOTES.dirty && curTrim !== last) return;
      if (document.activeElement === narr && curTrim !== last) return;

      if (!curTrim || curTrim === last) {
        narr.value = sceneText;
        NOTES.lastSceneNarration = sceneText;
      }
    }

    // =====================================================================
    // STATUS TABLE
    // =====================================================================

    function renderStatus() {
      const tbody = document.getElementById('statusBody');
      const roundLine = document.getElementById('roundLine');
      if (!tbody || !roundLine) return;

      if (SCENE_PARSE_ERROR) roundLine.textContent = 'SCENE JSON ERROR';
      else roundLine.textContent = `Round ${SCENE_NORM?.round ?? '‚Äî'}`;

      const actionLine = document.getElementById('actionLine');
      const la = String(SCENE_NORM?.lastAction || '').trim();
      if (actionLine) {
        if (la) {
          actionLine.style.display = 'block';
          actionLine.textContent = la;
        } else {
          actionLine.style.display = 'none';
          actionLine.textContent = '';
        }
      }

      syncNarrationFromScene();

      const actors = Array.isArray(SCENE_NORM?.actors) ? SCENE_NORM.actors.slice() : [];
      actors.sort((a, b) => {
        const ai = Number(a.init ?? 0);
        const bi = Number(b.init ?? 0);
        if (bi !== ai) return bi - ai;
        return String(a.name ?? a.id).localeCompare(String(b.name ?? b.id));
      });

      const activeId = String(SCENE_NORM?.activeActorId || '').trim();

      tbody.innerHTML = '';
      for (const a of actors) {
        const tr = document.createElement('tr');
        const hpVal = Number(a.hp ?? 0);
        const effectsArr = Array.isArray(a.effects) ? a.effects : [];
        const isDead = hpVal <= 0 || effectsArr.includes('dead') || effectsArr.includes('down');

        const side = String(a.side || 'NPC').toUpperCase();
        const isActive = activeId && String(a.id || '').trim() === activeId;
        tr.className =
          (side === 'PC' ? 'side-pc' : (side === 'EN' ? 'side-en' : 'side-npc')) +
          (isDead ? ' dead' : '') +
          (isActive ? ' active-turn' : '');

        const effects = Array.isArray(a.effects) ? a.effects : [];
        const effectsHtml = effects.length
          ? effects.map(e => `<span class="chip">${escapeHtml(effectLabel(e))}</span>`).join('')
          : '';

        tr.innerHTML = `
          <td>
            <div style="display:flex; align-items:baseline; gap:8px; flex-wrap:wrap;">
              <span style="font-weight:650;">${escapeHtml((isActive ? '‚ñ∂ ' : '') + (a.name ?? a.id ?? 'Actor'))}</span>
              <span class="subtle">${escapeHtml(a.at ?? '')}</span>
            </div>
            ${effectsHtml ? `<div style="margin-top:4px;">${effectsHtml}</div>` : ''}
          </td>
          <td class="hp">${escapeHtml(String(a.init ?? 0))}</td>
          <td class="hp">${escapeHtml(String(a.hp ?? '‚Äî'))} / ${escapeHtml(String(a.maxHp ?? '‚Äî'))}</td>
        `;

        tbody.appendChild(tr);
      }
    }

    // =====================================================================
    // HELPERS
    // =====================================================================

    function escapeHtml(s) {
      return String(s)
        .replaceAll('&', '&amp;')
        .replaceAll('<', '&lt;')
        .replaceAll('>', '&gt;')
        .replaceAll('"', '&quot;')
        .replaceAll("'", '&#39;');
    }

    // =====================================================================
    // RENDERING (minimal baseline)
    // =====================================================================

    function buildRoomGeoms(sceneNorm) {
      const byId = new Map();
      const list = [];

      for (const room of (sceneNorm?.rooms || [])) {
        const corners = Array.isArray(room.corners) ? room.corners : [];
        const pts = corners.map(labelToPixel).filter(Boolean);
        if (pts.length !== 4) continue;

        let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
        for (const p of pts) {
          if (p.x < minX) minX = p.x;
          if (p.x > maxX) maxX = p.x;
          if (p.y < minY) minY = p.y;
          if (p.y > maxY) maxY = p.y;
        }

        // Expand from hex centers to a rectangle that fully covers the border hexes.
        const halfW = hexWidthPx() / 2;
        const halfH = hexHeightPx() / 2;

        const leftX = minX - halfW;
        const rightX = maxX + halfW;
        const topY = minY - halfH;
        const botY = maxY + halfH;

        const thickness = Math.max(0, Number(room.thickness ?? 0));
        const halfT = thickness / 2;

        const geom = {
          room,
          id: String(room.id || ''),
          thickness,
          leftX,
          rightX,
          topY,
          botY,
          outer: {
            x: leftX - halfT,
            y: topY - halfT,
            w: (rightX - leftX) + thickness,
            h: (botY - topY) + thickness,
          },
          inner: {
            x: leftX + halfT,
            y: topY + halfT,
            w: (rightX - leftX) - thickness,
            h: (botY - topY) - thickness,
          }
        };

        byId.set(geom.id, geom);
        list.push(geom);
      }

      // draw thicker first (e.g. building shell)
      list.sort((a, b) => (b.thickness || 0) - (a.thickness || 0));

      return { list, byId };
    }

    function drawBaseGrid() {
      ctx.clearRect(0, 0, MAT_W, MAT_H);
      ctx.fillStyle = '#ffffff';
      ctx.fillRect(0, 0, MAT_W, MAT_H);

      ctx.save();
      ctx.strokeStyle = 'rgba(0,0,0,0.10)';
      ctx.lineWidth = 1;
      for (let q = 0; q < cols; q++) {
        for (let r = 0; r < rows; r++) {
          const p = qrToPixel(q, r);
          const pts = hexCorners(p.x, p.y);
          drawHexPath(pts);
          ctx.stroke();
        }
      }
      ctx.restore();

      ctx.save();
      ctx.fillStyle = 'rgba(0,0,0,0.10)';
      ctx.font = '12px ui-monospace, system-ui, sans-serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      for (let q = 0; q < cols; q++) {
        for (let r = 0; r < rows; r++) {
          const p = qrToPixel(q, r);
          ctx.fillText(labelFor(q, r), p.x, p.y);
        }
      }
      ctx.restore();
    }

    function drawRoomGeom(geom) {
      const room = geom.room;
      const floorKind = String(room?.floor?.kind ?? '').trim().toLowerCase();
      const wallKind = String(room?.wall?.kind ?? '').trim().toLowerCase();

      // Floors
      if (geom.inner.w > 0 && geom.inner.h > 0 && floorKind !== 'none') {
        const fk = floorKindForRoom(room);
        const pat = texturePatternFor(fk);
        ctx.save();
        ctx.beginPath();
        ctx.rect(geom.inner.x, geom.inner.y, geom.inner.w, geom.inner.h);
        ctx.clip();
        ctx.globalAlpha = 0.95;
        ctx.fillStyle = pat;
        ctx.fillRect(geom.inner.x - 2000, geom.inner.y - 2000, geom.inner.w + 4000, geom.inner.h + 4000);
        ctx.restore();
      }

      // Walls
      if (geom.thickness > 0 && wallKind !== 'none') {
        const wk = wallKindForRoom(room);
        const pat = texturePatternFor(wk);
        ctx.save();
        ctx.beginPath();
        ctx.rect(geom.outer.x, geom.outer.y, geom.outer.w, geom.outer.h);
        ctx.rect(geom.inner.x, geom.inner.y, geom.inner.w, geom.inner.h);
        try { ctx.clip('evenodd'); } catch { ctx.clip(); }
        ctx.globalAlpha = 0.95;
        ctx.fillStyle = pat;
        ctx.fillRect(geom.outer.x - 2000, geom.outer.y - 2000, geom.outer.w + 4000, geom.outer.h + 4000);
        ctx.restore();
      }
    }

    function openingSpriteKey(op) {
      const kind = String(op.kind || '').toLowerCase();
      const base = kind.split('.')[0];
      const isOpen = String(op.state || 'closed').toLowerCase() === 'open';

      if (isOpen) {
        const kOpen = `${kind}.open`;
        if (SPRITE_DEFS[kOpen]) return kOpen;
        const bOpen = `${base}.open`;
        if (SPRITE_DEFS[bOpen]) return bOpen;
      }

      if (SPRITE_DEFS[kind]) return kind;
      if (SPRITE_DEFS[base]) return base;
      return null;
    }

    function drawOpenings() {
      for (const op of (SCENE_NORM?.openings || [])) {
        const at = labelToPixel(op.at);
        if (!at) continue;

        const wall = String(op.wall || '').toUpperCase();
        const dxdy = {
          N: { dx: 0, dy: -hexHeightPx() / 2 },
          S: { dx: 0, dy: +hexHeightPx() / 2 },
          E: { dx: +size, dy: 0 },
          W: { dx: -size, dy: 0 },
        }[wall] || { dx: 0, dy: 0 };

        const key = openingSpriteKey(op);
        const rot = entityRotDeg(op, 0);

        // IMPORTANT: if the sprite isn't ready (or is broken), fall back to a simple rect
        // so doors/windows never disappear.
        let drew = false;
        if (key && isSpriteReady(key)) {
          drew = drawSpriteAt(key, at.x + dxdy.dx, at.y + dxdy.dy, rot, 1, 1);
        }

        if (!drew) {
          ctx.save();
          ctx.fillStyle = (String(op.kind || '').toLowerCase().includes('window')) ? '#cfe6f6' : '#b07a3f';
          ctx.globalAlpha = 0.95;
          ctx.fillRect(at.x + dxdy.dx - 18, at.y + dxdy.dy - 6, 36, 12);
          ctx.restore();
        }
      }
    }

    function centroidForCells(cells) {
      const pts = (cells || []).map(labelToPixel).filter(Boolean);
      if (!pts.length) return null;
      let sx = 0, sy = 0;
      for (const p of pts) { sx += p.x; sy += p.y; }
      return { x: sx / pts.length, y: sy / pts.length };
    }

    function drawObjects() {
      for (const o of (SCENE_NORM?.objects || [])) {
        const p = centroidForCells(o.cells);
        if (!p) continue;
        const key = spriteKeyForObject(o);
        if (key && isSpriteReady(key)) {
          drawSpriteAt(key, p.x, p.y, entityRotDeg(o, 0), 1, 1);
        } else {
          ctx.save();
          ctx.fillStyle = o.color || '#b07a3f';
          ctx.globalAlpha = 0.85;
          ctx.beginPath();
          ctx.arc(p.x, p.y, 18, 0, Math.PI * 2);
          ctx.fill();
          ctx.restore();
        }

        if (o.label) {
          ctx.save();
          ctx.fillStyle = 'rgba(0,0,0,0.75)';
          ctx.font = '14px system-ui, sans-serif';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText(String(o.label), p.x, p.y);
          ctx.restore();
        }
      }
    }

    function drawToken(q, r, label, side, isDead) {
      const p = qrToPixel(q, r);
      ctx.save();
      const fill = (side === 'PC') ? 'rgba(80,160,220,0.95)' : (side === 'EN' ? 'rgba(25,25,25,0.92)' : 'rgba(160,160,160,0.92)');
      ctx.fillStyle = fill;
      ctx.globalAlpha = isDead ? 0.35 : 1;
      ctx.beginPath();
      ctx.arc(p.x, p.y, 18, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();

      ctx.save();
      ctx.fillStyle = (side === 'EN') ? 'rgba(255,255,255,0.92)' : 'rgba(0,0,0,0.82)';
      ctx.font = '12px ui-monospace, system-ui, sans-serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(String(label || '?'), p.x, p.y);
      ctx.restore();
    }

    function drawActors() {
      for (const a of (SCENE_NORM?.actors || [])) {
        const pos = parseLabel(a.at);
        if (!pos) continue;

        const effectsArr = Array.isArray(a.effects) ? a.effects : [];
        const isDead = Number(a.hp ?? 0) <= 0 || effectsArr.includes('dead') || effectsArr.includes('down');

        const key = spriteKeyForActor(a);
        const p = qrToPixel(pos.q, pos.r);

        if (key && isSpriteReady(key)) {
          drawSpriteAt(key, p.x, p.y, entityRotDeg(a, 0), 1, isDead ? 0.35 : 1);
        } else {
          drawToken(pos.q, pos.r, a.label || a.name?.slice(0, 1) || '?', a.side, isDead);
        }

        const name = String(a.name || '').trim();
        if (name) {
          ctx.save();
          ctx.font = '12px system-ui, sans-serif';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'alphabetic';
          ctx.fillStyle = (String(a.side || '').toUpperCase() === 'EN') ? 'rgba(255,255,255,0.92)' : 'rgba(0,0,0,0.75)';
          ctx.fillText(name, p.x, p.y + 34);
          ctx.restore();
        }
      }
    }

    function rectIntersection(a, b) {
      const x1 = Math.max(a.x, b.x);
      const y1 = Math.max(a.y, b.y);
      const x2 = Math.min(a.x + a.w, b.x + b.w);
      const y2 = Math.min(a.y + a.h, b.y + b.h);
      const w = x2 - x1;
      const h = y2 - y1;
      if (w <= 0 || h <= 0) return null;
      return { x: x1, y: y1, w, h };
    }

    // Returns up to 4 rectangles representing base minus cut (axis-aligned).
    function rectSubtract(base, cut) {
      const i = rectIntersection(base, cut);
      if (!i) return [base];

      const out = [];

      // top band
      if (i.y > base.y) out.push({ x: base.x, y: base.y, w: base.w, h: i.y - base.y });
      // bottom band
      const baseBottom = base.y + base.h;
      const iBottom = i.y + i.h;
      if (iBottom < baseBottom) out.push({ x: base.x, y: iBottom, w: base.w, h: baseBottom - iBottom });

      // middle bands (left/right)
      const midY = i.y;
      const midH = i.h;
      if (i.x > base.x) out.push({ x: base.x, y: midY, w: i.x - base.x, h: midH });
      const baseRight = base.x + base.w;
      const iRight = i.x + i.w;
      if (iRight < baseRight) out.push({ x: iRight, y: midY, w: baseRight - iRight, h: midH });

      // Filter degenerate
      return out.filter(r => r.w > 0 && r.h > 0);
    }

    function rectSubtractMany(base, cuts) {
      let parts = [base];
      for (const c of cuts) {
        const next = [];
        for (const p of parts) next.push(...rectSubtract(p, c));
        parts = next;
        if (!parts.length) break;
      }
      return parts;
    }

    function drawWallOutlinesOnly() {
      // Redraw ONLY the wall rings (no floor) so geometry stays readable above fog.
      // Intentionally no inner-edge stroke, to avoid thin black lines at wall/floor boundaries.
      for (const geom of (ROOM_GEOMS?.list || [])) {
        const room = geom.room;
        const wallKind = String(room?.wall?.kind ?? '').trim().toLowerCase();
        if (geom.thickness <= 0 || wallKind === 'none') continue;

        const wk = wallKindForRoom(room);
        const pat = texturePatternFor(wk);

        ctx.save();
        ctx.beginPath();
        ctx.rect(geom.outer.x, geom.outer.y, geom.outer.w, geom.outer.h);
        ctx.rect(geom.inner.x, geom.inner.y, geom.inner.w, geom.inner.h);
        try { ctx.clip('evenodd'); } catch { ctx.clip(); }
        ctx.globalAlpha = 0.95;
        ctx.fillStyle = pat;
        ctx.fillRect(geom.outer.x - 2000, geom.outer.y - 2000, geom.outer.w + 4000, geom.outer.h + 4000);
        ctx.restore();
      }
    }

    function drawFogOfWar() {
      if (DEBUG_FOG_DISABLE) return;
      const fog = (SCENE_NORM?.fog && typeof SCENE_NORM.fog === 'object') ? SCENE_NORM.fog : null;
      if (!fog || !fog.enabled) return;

      const visible = new Set(Array.isArray(fog.visibleRooms) ? fog.visibleRooms.map(String) : []);
      const opacity = Math.max(0, Math.min(1, Number(fog.opacity ?? 0.85)));
      const revealWalls = !!fog.revealWalls;

      // If rooms overlap (common when using shared hex columns for interior walls),
      // prevent fog from spilling into visible rooms by subtracting visible rects.
      const visibleRects = [];
      for (const geom of (ROOM_GEOMS?.list || [])) {
        const room = geom.room;
        const floorKind = String(room?.floor?.kind ?? '').trim().toLowerCase();
        if (floorKind === 'none') continue;
        if (!visible.has(String(geom.id))) continue;
        visibleRects.push({ x: geom.inner.x, y: geom.inner.y, w: geom.inner.w, h: geom.inner.h });
      }

      for (const geom of (ROOM_GEOMS?.list || [])) {
        const room = geom.room;
        const floorKind = String(room?.floor?.kind ?? '').trim().toLowerCase();
        if (floorKind === 'none') continue;
        if (visible.has(String(geom.id))) continue;

        const base = { x: geom.inner.x, y: geom.inner.y, w: geom.inner.w, h: geom.inner.h };
        const parts = rectSubtractMany(base, visibleRects);

        ctx.save();
        ctx.globalAlpha = opacity;
        ctx.fillStyle = 'rgba(70,70,70,1)';
        for (const p of parts) ctx.fillRect(p.x, p.y, p.w, p.h);
        ctx.restore();
      }

      if (revealWalls) {
        // Put walls/openings back on top so geometry stays readable.
        drawWallOutlinesOnly();
        drawOpenings();
      }
    }

    function drawGrid() {
      SCENE = loadSceneFromJsonTag();
      SCENE_NORM = normalizeScene();

      const geoms = buildRoomGeoms(SCENE_NORM);
      ROOM_GEOMS = geoms;
      ROOM_BY_ID = geoms.byId;

      requestSpritePreload(SCENE_NORM);

      drawBaseGrid();

      for (const g of (ROOM_GEOMS?.list || [])) drawRoomGeom(g);

      // Draw openings/contents BEFORE fog so hidden rooms are masked.
      drawOpenings();
      drawObjects();
      drawActors();

      drawFogOfWar();

      updateTrailsFromPending();
      drawTrails();

      renderStatus();
    }

    function safeDrawGrid() {
      try {
        drawGrid();
      } catch (e) {
        console.error('[Battlemat] drawGrid failed:', e);
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = '#d7d7d7';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = 'rgba(0,0,0,0.65)';
        ctx.font = '14px ui-monospace, system-ui, sans-serif';
        ctx.textAlign = 'left';
        ctx.textBaseline = 'top';
        ctx.fillText('Battlemat render error (see console).', 14, 14);
      }
    }

    // =====================================================================
    // SPRITE DEFINITIONS (EDIT HERE)
    // =====================================================================

    const ACTOR_SCALE = 0.5;

    SPRITE_DEFS = {
      'table':        { url: `${SPRITE_BASE}/table_round.png`,     ax: 0.5, ay: 0.52, shadow: true },
      'table.round':  { url: `${SPRITE_BASE}/table_round.png`,     ax: 0.5, ay: 0.52, shadow: true, scale: 0.75 },
      'table.rect':   { url: `${SPRITE_BASE}/table_rect.png`,      ax: 0.5, ay: 0.55, shadow: true },
      'sarcophagus':  { url: `${SPRITE_BASE}/sarcophagus.png`,     ax: 0.5, ay: 0.58, shadow: true },
      'pillar':       { url: `${SPRITE_BASE}/pillar_stone.png`,    ax: 0.5, ay: 0.60, shadow: true },
      'rect':         { url: `${SPRITE_BASE}/crate_rect.png`,      ax: 0.5, ay: 0.58, shadow: true },

      'token.pc':     { url: `${SPRITE_BASE}/token_pc.png`,        ax: 0.5, ay: 0.55, shadow: true, scale: ACTOR_SCALE },
      'token.en':     { url: `${SPRITE_BASE}/token_enemy.png`,     ax: 0.5, ay: 0.55, shadow: true, scale: ACTOR_SCALE },
      'token.npc':    { url: `${SPRITE_BASE}/token_npc.png`,       ax: 0.5, ay: 0.55, shadow: true, scale: ACTOR_SCALE },

      'fighter.male':     { url: `${SPRITE_BASE}/fighter_male.png`,      ax: 0.5, ay: 0.55, shadow: true, scale: ACTOR_SCALE },
      'fighter.female':   { url: `${SPRITE_BASE}/fighter_female.png`,    ax: 0.5, ay: 0.55, shadow: true, scale: ACTOR_SCALE },
      'cleric.male':      { url: `${SPRITE_BASE}/cleric_male.png`,       ax: 0.5, ay: 0.55, shadow: true, scale: ACTOR_SCALE },
      'cleric.female':    { url: `${SPRITE_BASE}/cleric_female.png`,     ax: 0.5, ay: 0.55, shadow: true, scale: ACTOR_SCALE },
      'wizard.male':      { url: `${SPRITE_BASE}/wizard_male.png`,       ax: 0.5, ay: 0.55, shadow: true, scale: ACTOR_SCALE },
      'wizard.female':    { url: `${SPRITE_BASE}/wizard_female.png`,     ax: 0.5, ay: 0.55, shadow: true, scale: ACTOR_SCALE },
      'rogue.male':       { url: `${SPRITE_BASE}/rogue_male.png`,        ax: 0.5, ay: 0.55, shadow: true, scale: ACTOR_SCALE },
      'rogue.female':     { url: `${SPRITE_BASE}/rogue_female.png`,      ax: 0.5, ay: 0.55, shadow: true, scale: ACTOR_SCALE },
      'ranger.male':      { url: `${SPRITE_BASE}/ranger_male.png`,       ax: 0.5, ay: 0.55, shadow: true, scale: ACTOR_SCALE },
      'ranger.female':    { url: `${SPRITE_BASE}/ranger_female.png`,     ax: 0.5, ay: 0.55, shadow: true, scale: ACTOR_SCALE },
      'paladin.male':     { url: `${SPRITE_BASE}/paladin_male.png`,      ax: 0.5, ay: 0.55, shadow: true, scale: ACTOR_SCALE },
      'paladin.female':   { url: `${SPRITE_BASE}/paladin_female.png`,    ax: 0.5, ay: 0.55, shadow: true, scale: ACTOR_SCALE },
      'bard.male':        { url: `${SPRITE_BASE}/bard_male.png`,         ax: 0.5, ay: 0.55, shadow: true, scale: ACTOR_SCALE },
      'bard.female':      { url: `${SPRITE_BASE}/bard_female.png`,       ax: 0.5, ay: 0.55, shadow: true, scale: ACTOR_SCALE },
      'druid.male':       { url: `${SPRITE_BASE}/druid_male.png`,        ax: 0.5, ay: 0.55, shadow: true, scale: ACTOR_SCALE },
      'druid.female':     { url: `${SPRITE_BASE}/druid_female.png`,      ax: 0.5, ay: 0.55, shadow: true, scale: ACTOR_SCALE },
      'monk.male':        { url: `${SPRITE_BASE}/monk_male.png`,         ax: 0.5, ay: 0.55, shadow: true, scale: ACTOR_SCALE },
      'monk.female':      { url: `${SPRITE_BASE}/monk_female.png`,       ax: 0.5, ay: 0.55, shadow: true, scale: ACTOR_SCALE },
      'barbarian.male':   { url: `${SPRITE_BASE}/barbarian_male.png`,    ax: 0.5, ay: 0.55, shadow: true, scale: ACTOR_SCALE },
      'barbarian.female': { url: `${SPRITE_BASE}/barbarian_female.png`,  ax: 0.5, ay: 0.55, shadow: true, scale: ACTOR_SCALE },
      'sorcerer.male':    { url: `${SPRITE_BASE}/sorcerer_male.png`,     ax: 0.5, ay: 0.55, shadow: true, scale: ACTOR_SCALE },
      'sorcerer.female':  { url: `${SPRITE_BASE}/sorcerer_female.png`,   ax: 0.5, ay: 0.55, shadow: true, scale: ACTOR_SCALE },
      'warlock.male':     { url: `${SPRITE_BASE}/warlock_male.png`,      ax: 0.5, ay: 0.55, shadow: true, scale: ACTOR_SCALE },
      'warlock.female':   { url: `${SPRITE_BASE}/warlock_female.png`,    ax: 0.5, ay: 0.55, shadow: true, scale: ACTOR_SCALE },

      'dragonkin.green': { url: `${SPRITE_BASE}/dragonkin_green.png`, ax: 0.5, ay: 0.55, shadow: true, scale: ACTOR_SCALE },
      'dragonkin.red':   { url: `${SPRITE_BASE}/dragonkin_red.png`,   ax: 0.5, ay: 0.55, shadow: true, scale: ACTOR_SCALE },
      'dragonkin.blue':  { url: `${SPRITE_BASE}/dragonkin_blue.png`,  ax: 0.5, ay: 0.55, shadow: true, scale: ACTOR_SCALE },
      'dragonkin.black': { url: `${SPRITE_BASE}/dragonkin_black.png`, ax: 0.5, ay: 0.55, shadow: true, scale: ACTOR_SCALE },
      'dragonkin.white': { url: `${SPRITE_BASE}/dragonkin_white.png`, ax: 0.5, ay: 0.55, shadow: true, scale: ACTOR_SCALE },

      'lich':         { url: `${SPRITE_BASE}/lich.png`,               ax: 0.5, ay: 0.55, shadow: true, scale: ACTOR_SCALE },
      'wraith':       { url: `${SPRITE_BASE}/wraith.png`,             ax: 0.5, ay: 0.55, shadow: true, scale: ACTOR_SCALE },

      'window':       { url: `${SPRITE_BASE}/window.png`,          ax: 0.5, ay: 0.5, shadow: false },
      'window.open':  { url: `${SPRITE_BASE}/window_open.png`,     ax: 0.5, ay: 0.5, shadow: false },
      'door':         { url: `${SPRITE_BASE}/door.png`,            ax: 0.5, ay: 0.5, shadow: false },
      'door.open':    { url: `${SPRITE_BASE}/door_open.png`,       ax: 0.5, ay: 0.5, shadow: false },
      'door.wood':    { url: `${SPRITE_BASE}/door_wood.png`,       ax: 0.5, ay: 0.5, shadow: false },
      'door.wood.open': { url: `${SPRITE_BASE}/door_wood_open.png`, ax: 0.5, ay: 0.5, shadow: false },
    };

    // =====================================================================
    // Minimal self-tests (safe in production; they only log if something is off)
    // =====================================================================

    function runSelfTests() {
      try {
        console.assert(typeof modeDelayMs === 'function', 'modeDelayMs should exist');
        console.assert(modeDelayMs(RefreshMode.FAST) === FAST_MS, 'FAST delay should be 5000ms');
        console.assert(modeDelayMs(RefreshMode.S15) === S15_MS, '15s delay should be 15000ms');
        console.assert(modeDelayMs(RefreshMode.S30) === S30_MS, '30s delay should be 30000ms');
        console.assert(modeDelayMs(RefreshMode.S60) === S60_MS, '60s delay should be 60000ms');

        console.assert(coerceActiveActorId(' pc1 ') === 'pc1', 'coerceActiveActorId should trim');
        console.assert(coerceLastAction({ a: 1 }).includes('a'), 'coerceLastAction should stringify objects');
        console.assert(coerceNarration({ n: 1 }).includes('n'), 'coerceNarration should stringify objects');
        console.assert(effectLabel({ name: 'Poisoned' }) === 'Poisoned', 'effectLabel should prefer name');
        console.assert(effectLabel({ label: 'Stunned' }) === 'Stunned', 'effectLabel should prefer label');
        console.assert(effectLabel(7) === '7', 'effectLabel should stringify primitives');

        const n1 = normalizeTextureKind('wood:pine');
        console.assert(n1.base === 'wood' && n1.variant === 'pine' && n1.key === 'wood:pine', 'normalizeTextureKind wood:pine');
        const n2 = normalizeTextureKind('stone.cobble');
        console.assert(n2.base === 'stone' && n2.variant === 'cobble' && n2.key === 'stone:cobble', 'normalizeTextureKind stone.cobble');
        const n3 = normalizeTextureKind('cobblestone');
        console.assert(n3.base === 'stone' && n3.variant === 'cobble', 'normalizeTextureKind cobblestone');

        console.assert(typeof initTextureSelectors === 'function', 'initTextureSelectors should exist');
        console.assert(typeof drawWallOutlinesOnly === 'function', 'drawWallOutlinesOnly should exist');
        console.assert(typeof drawOpenings === 'function', 'drawOpenings should exist');
        console.assert(TEX.enabled === true, 'Textures should default to enabled');
        console.assert(TEX_OVERRIDE_ROOM === '__room__', 'TEX_OVERRIDE_ROOM sentinel value');

        console.assert(!!SPRITE_DEFS['table'], 'SPRITE_DEFS should include table');

        // Opening sprite selection
        console.assert(openingSpriteKey({ kind: 'door.wood', state: 'closed' }) === 'door.wood', 'openingSpriteKey door.wood closed');
        console.assert(openingSpriteKey({ kind: 'door.wood', state: 'open' }) === 'door.wood.open', 'openingSpriteKey door.wood open');
        console.assert(openingSpriteKey({ kind: 'window', state: 'open' }) === 'window.open', 'openingSpriteKey window open');

        // isImgUsable self-test (mock objects)
        console.assert(isImgUsable({ complete: true, naturalWidth: 10, naturalHeight: 10, __broken: false }) === true, 'isImgUsable should accept loaded images');
        console.assert(isImgUsable({ complete: true, naturalWidth: 0, naturalHeight: 10, __broken: false }) === false, 'isImgUsable should reject naturalWidth=0');
        console.assert(isImgUsable({ complete: true, naturalWidth: 10, naturalHeight: 0, __broken: false }) === false, 'isImgUsable should reject naturalHeight=0');
        console.assert(isImgUsable({ complete: true, naturalWidth: 10, naturalHeight: 10, __broken: true }) === false, 'isImgUsable should reject broken images');

        const raw = String(document.getElementById('scene-json')?.textContent || '').trim();
        let parsed = null;
        try { parsed = JSON.parse(raw); } catch (e) { console.assert(false, 'Embedded SCENE JSON should parse: ' + (e?.message || e)); }
        console.assert(parsed && typeof parsed === 'object', 'Embedded SCENE JSON should parse to an object');
        console.assert(typeof parsed.narration === 'string', 'Embedded SCENE JSON should include a narration string');

        const mockImg = { naturalWidth: 512, naturalHeight: 512 };
        const sz0 = spriteCanvasSize({ url: 'x' }, mockImg, 1);
        console.assert(Math.abs(sz0.w - hexHeightPx()) < 0.001, '512px width should map to 1 hex height');
        console.assert(Math.abs(sz0.h - hexHeightPx()) < 0.001, '512px height should map to 1 hex height');

        console.assert(spriteKeyForActor({ side: 'PC', class: 'fighter', gender: 'male' }) === 'fighter.male', 'fighter.male selection');
        console.assert(spriteKeyForActor({ side: 'PC', class: 'wizard', gender: 'female' }) === 'wizard.female', 'wizard.female selection');

        console.assert(entityRotDeg({ rot: 91 }, 0) === 90, 'snap 91‚Üí90');
        console.assert(entityRotDeg({ rot: 269 }, 0) === 270, 'snap 269‚Üí270');
        console.assert(entityRotDeg({ orientation: 'vertical' }, 0) === 90, 'orientation vertical');
        console.assert(entityRotDeg({ rot: 0, rotOffset: 180 }, 0) === 180, 'rotOffset applies');

        const sz1 = spriteCanvasSize({ url: 'x', scale: 2 }, mockImg, 1);
        console.assert(Math.abs(sz1.h - 2 * hexHeightPx()) < 0.01, 'def.scale=2 should double size');
        const sz2 = spriteCanvasSize({ url: 'x' }, mockImg, 0.5);
        console.assert(Math.abs(sz2.h - 0.5 * hexHeightPx()) < 0.01, 'entity scale=0.5 should halve size');
      } catch (_) {}
    }

    // =====================================================================
    // Boot
    // =====================================================================

    (async () => {
      await tryLoadSceneFromApi();

      // Textures are always enabled now.
      TEX.enabled = true;
      initTextureSelectors();

      safeDrawGrid();

      const bid = getBattleIdFromUrl();
      initNotesUi(bid);
      runSelfTests();

      REFRESH.battleId = bid;
      REFRESH.lastChangeAt = Date.now();

      if (REFRESH.battleId) {
        try {
          const { versionKey } = await fetchSceneAndVersionKey(REFRESH.battleId);
          if (versionKey) REFRESH.lastVersionKey = versionKey;
        } catch (_) {}

        let restore = RefreshMode.S60;
        let autoPref = 'auto';
        try {
          autoPref = (localStorage.getItem(`battlemat:refresh:auto:${REFRESH.battleId}`) || 'auto').trim();
          const saved = (localStorage.getItem(`battlemat:refresh:last:${REFRESH.battleId}`) || '').trim();
          if (saved && saved !== RefreshMode.OFF) restore = saved;
        } catch (_) {}

        setRefreshMode(autoPref === 'off' ? RefreshMode.OFF : restore);
      } else {
        setRefreshMode(RefreshMode.OFF);
      }
    })();
  </script>
</body>
</html>
