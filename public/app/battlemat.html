<!doctype html>
<!--
  v5.15 

  Copyright © 2025 Thomas Delvus. All rights reserved.

  This HTML document and its contents (including the code, layout, text, data structures, and embedded/linked assets)
  are protected by copyright law.

  Permission is granted to access and use this file for personal, non-commercial tabletop gameplay and reference.

  You may NOT copy, reproduce, modify, translate, redistribute, publish, sell, sublicense, or incorporate this work
  (in whole or in part) into any software product, service, website, platform, “system,” template library, dataset,
  or AI/training workflow without prior written permission from the copyright holder.

  Unauthorized use is prohibited.

  Refactor goals (v5.01):
  - Keep behavior/inputs the same as v4.125.
  - Centralize “core battlemat” logic up top.
  - Move all procedural/ornamental rendering into a single OPTIONAL “FANCY PACK” block at the end.
    If you delete that block, the mat still runs with simple flat fills (e.g., cobble becomes a plain gray).
-->
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Battlemat</title>
  <style>
    :root {
      --ui-bg: #f4f4f4;
      --panel-bg: #ffffff;
      --panel-border: #e5e5e5;
      --text: #111;
      --muted: #666;
      --btn: #ffffff;
      --btn-border: #d0d0d0;
    }

    html, body { height: 100%; }
    body {
      margin: 0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      background: var(--ui-bg);
      color: var(--text);
    }

    .app {
      height: 100%;
      display: grid;
      grid-template-columns: 1fr 280px;
      gap: 12px;
      padding: 12px;
      box-sizing: border-box;
    }

    .stage {
      background: var(--panel-bg);
      border: 1px solid var(--panel-border);
      border-radius: 12px;
      overflow: hidden;
      display: grid;
      grid-template-rows: 1fr auto;
      min-width: 0;
      min-height: 0;
    }

    .canvasWrap {
      position: relative;
      min-height: 0;
      min-width: 0;
    }

    canvas {
      display: block;
      width: 100%;
      height: 100%;
      background: #fff;
    }

    .controls {
      border-top: 1px solid var(--panel-border);
      padding: 10px;
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
    }

    .controls .spacer { flex: 1; }

    button {
      background: var(--btn);
      border: 1px solid var(--btn-border);
      border-radius: 10px;
      padding: 8px 10px;
      cursor: pointer;
      user-select: none;
    }
    button:active { transform: translateY(1px); }

    input, select {
      border: 1px solid var(--btn-border);
      border-radius: 10px;
      padding: 8px 10px;
      outline: none;
    }

    .sidebar {
      background: var(--panel-bg);
      border: 1px solid var(--panel-border);
      border-radius: 12px;
      overflow: hidden;
      display: grid;
      grid-template-rows: auto 1fr;
    }

    .sidebarHeader {
      padding: 12px;
      border-bottom: 1px solid var(--panel-border);
      display: flex;
      align-items: center;
      justify-content: space-between;
    }

    .pill {
      font-size: 12px;
      color: var(--muted);
      border: 1px solid var(--panel-border);
      background: #fafafa;
      padding: 4px 8px;
      border-radius: 999px;
    }

    .sidebarBody {
      padding: 12px;
      overflow: auto;
    }

    .kvs {
      display: grid;
      grid-template-columns: 1fr auto;
      gap: 6px 10px;
      font-size: 13px;
      color: var(--muted);
    }

    .legend {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      align-items: center;
      font-size: 12px;
      color: var(--muted);
    }
    .sw {
      width: 14px; height: 14px;
      border-radius: 4px;
      border: 1px solid rgba(0,0,0,0.15);
      display: inline-block;
      vertical-align: middle;
      margin-right: 6px;
    }
  </style>
</head>
<body>
  <div class="app">
    <div class="stage">
      <div class="canvasWrap">
        <canvas id="canvas"></canvas>
      </div>
      <div class="controls">
        <button id="btnLeft">←</button>
        <button id="btnUp">↑</button>
        <button id="btnDown">↓</button>
        <button id="btnRight">→</button>

        <span class="spacer"></span>

        <label class="legend" style="margin-right: 8px;">
          <span><span class="sw" style="background:#b67a2c"></span>Door</span>
          <span><span class="sw" style="background:#bfe2ff"></span>Window</span>
          <span><span class="sw" style="background:#666"></span>Wall</span>
        </label>

        <label style="display:flex; align-items:center; gap:6px;">
          <span style="font-size:12px; color:var(--muted);">Floors</span>
          <select id="floorKind" style="min-width: 140px;">
            <option value="">Mixed</option>
            <option value="stone">Stone</option>
            <option value="wood">Wood</option>
            <option value="cobble">Cobble</option>
            <option value="stairs.wood">Stairs</option>
            <option value="none">None</option>
            <option value="fog">Fog</option>
          </select>
        </label>

        <label style="display:flex; align-items:center; gap:6px;">
          <input type="checkbox" id="fogToggle" />
          <span style="font-size:12px; color:var(--muted);">Fog</span>
        </label>

        <label style="display:flex; align-items:center; gap:6px;">
          <span style="font-size:12px; color:var(--muted);">Center on</span>
          <select id="centerOn" style="min-width: 150px;">
            <option value="">None</option>
          </select>
        </label>

        <input id="jumpHex" placeholder="Jump to (e.g., H6)" style="width: 140px;" />
        <button id="btnJump">Jump</button>
        <button id="btnRedraw">Redraw</button>
      </div>
    </div>

    <div class="sidebar">
      <div class="sidebarHeader">v5.15
      </div>
      <div class="sidebarBody">
        <div class="kvs" id="kvs"></div>
        <hr style="border: none; border-top: 1px solid var(--panel-border); margin: 12px 0;" />
        <div style="font-size: 12px; color: var(--muted); line-height: 1.35;">
          Geometry rewrite: rooms → wall centerlines → thickness-aware wall rings.
        </div>
      </div>
    </div>
  </div>

<script>
(() => {
  // =====================================================================================
  // CORE BATTLEMAT
  // =====================================================================================

  // ===== Safety shim =====
  // Some editors/snippets accidentally paste a bare "$1" token into JS. In JS, `$1` is a valid
  // identifier; a stray reference crashes with "ReferenceError: $1 is not defined". Binding it here
  // makes any accidental stray usage a harmless no-op.
  const $1 = undefined;

  // ===== DOM / Canvas =====
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');

  // Offscreen wall layer (we punch openings out of walls here, then composite onto main canvas).
  const wallCanvas = document.createElement('canvas');
  const wallCtx = wallCanvas.getContext('2d');

  // ===== Constants =====
  const GRID = {
    // Flat-top hex geometry: size is center-to-vertex.
    size: 42,
    lineWidth: 2,
    lineAlpha: 0.09,
    labelAlpha: 0.18,
    labelFont: 'bold 12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial',
  };

  const COLORS = {
    wall: '#666',
    door: '#b67a2c',
    window: '#bfe2ff',

    floorStone: 'rgb(223, 208, 165)',
    floorWoodBase: '#d5b58c',
    floorCobbleBase: '#9aa0a6',

    tokenHero: '#4aa3ff',
    tokenEnemy: '#111',
    tokenTextDark: 'rgba(0,0,0,0.72)',
    tokenTextLight: 'rgba(255,255,255,0.88)',

    fogUnseen: 'rgb(128,128,128)',
    fogExplored: 'rgb(170,170,170)',
  };

  const VIEW = {
    // Camera is in hex coords (col,row), row 0 is "row 1" at the bottom.
    camera: { col: 6, row: 6 },
    anchor: { x: 0, y: 0 },
    dx: 0,
    dy: 0,

    // If set, camera will automatically follow that token (by id).
    followTokenId: null,

    // Device pixel ratio (set in resize()).
    dpr: 1,
  };

  const PAN_STEP = 2;

  // ===== Canonical state (demo) =====
  const DEFAULT_STATE = {
    meta: { title: 'Cross Keys Inn — Upper Floor', battleId: 'local', round: 1 },
    view: { camera_hex: 'U16' },

    fog: {
      enabled: true,
      revealWallsInUnseenRooms: true,
      mode: 'room',
      visibleRoomIds: [],
      exploredRoomIds: ['Hallway1','Hallway2','Hallway3','Bedroom2'],
      autoCompute: true,
      autoExplore: true,
      maxDepth: 1,
      unseenAlpha: 0.92,
      exploredAlpha: 0.55,
    },

    rooms: [
      { id: 'HighStreet', corners: ['F50','L50','L1','F1'], thickness: 20, color: '#555', floor: { kind: 'cobble' }, wall: { kind: 'none' } },
      { id: 'KingStreet', corners: ['L12','BE12','BE7','L7'], thickness: 20, color: '#555', floor: { kind: 'cobble' }, wall: { kind: 'none' } },
      { id: 'NextShoppe', corners: ['AJ28','AP28','AP12','AJ12'], thickness: 20, color: '#555', floor: { kind: 'wood' }, wall: { kind: 'brick' } },
      { id: 'NextShoppe2', corners: ['L27','V27','V21','L21'], thickness: 20, color: '#555', floor: { kind: 'wood' }, wall: { kind: 'brick' } },

      { id: '1stFloorStairsDown', corners: ['Z21','AD21','AD19','Z19'], thickness: 20, floor: { kind: 'stairs.wood' }, wall: { kind: 'brick' }, stairsDown: 'W' },

      { id: 'CrossKeysUpperFloor', corners: ['L21','AJ21','AJ12','L12'], thickness: 20, color: '#555', floor: { kind: 'fog' }, wall: { kind: 'brick' } },
      { id: 'Hallway1', corners: ['AD21','AF21','AF12','AD12'], thickness: 20, floor: { kind: 'wood' }, wall: { kind: 'brick' } },
      { id: 'Hallway2', corners: ['R17','AD17','AD15','R15'], thickness: 20, floor: { kind: 'wood' }, wall: { kind: 'brick' } },
      { id: 'Hallway3', corners: ['P21','R21','R12','P12'], thickness: 20, floor: { kind: 'wood' }, wall: { kind: 'brick' } },

      { id: 'Bedroom1', corners: ['L21','P21','P18','L18'], thickness: 20, color: '#555', floor: { kind: 'wood' }, wall: { kind: 'brick' } },
      { id: 'Bedroom2', corners: ['L18','P18','P15','L15'], thickness: 20, color: '#555', floor: { kind: 'wood' }, wall: { kind: 'brick' } },
      { id: 'Bedroom3', corners: ['L15','P15','P12','L12'], thickness: 20, color: '#555', floor: { kind: 'wood' }, wall: { kind: 'brick' } },
      { id: 'Bedroom4', corners: ['R15','X15','X12','R12'], thickness: 20, color: '#555', floor: { kind: 'wood' }, wall: { kind: 'brick' } },
      { id: 'Bedroom5', corners: ['R21','X21','X17','R17'], thickness: 20, color: '#555', floor: { kind: 'wood' }, wall: { kind: 'brick' } },
      { id: 'Bedroom6', corners: ['X19','AD19','AD17','X17'], thickness: 20, color: '#555', floor: { kind: 'wood' }, wall: { kind: 'brick' } },
      { id: 'Bedroom7', corners: ['X15','AD15','AD12','X12'], thickness: 20, color: '#555', floor: { kind: 'wood' }, wall: { kind: 'brick' } },
      { id: 'Bedroom8', corners: ['AF15','AJ15','AJ12','AF12'], thickness: 20, color: '#555', floor: { kind: 'wood' }, wall: { kind: 'brick' } },
      { id: 'Bedroom9', corners: ['AF18','AJ18','AJ15','AF15'], thickness: 20, color: '#555', floor: { kind: 'wood' }, wall: { kind: 'brick' } },
      { id: 'Bedroom10', corners: ['AF21','AJ21','AJ18','AF18'], thickness: 20, color: '#555', floor: { kind: 'wood' }, wall: { kind: 'brick' } },
      { id: 'Room5Closet', corners: ['X21','Z21','Z19','X19'], thickness: 20, color: '#555', floor: { kind: 'wood' }, wall: { kind: 'brick' } },
    ],

    openings: [
      { id: 'door_room1', kind: 'door', hex: 'P19',  orientation: 'v', state: 'closed', opensTo: 'W', hingeEnd: 'N' },
      { id: 'door_room2', kind: 'door', hex: 'P16',  orientation: 'v', state: 'open', opensTo: 'W', hingeEnd: 'N' },
      { id: 'door_room3', kind: 'door', hex: 'P13',  orientation: 'v', state: 'closed', opensTo: 'W', hingeEnd: 'N' },
      { id: 'door_room4', kind: 'door', hex: 'T15',  orientation: 'h', state: 'open', opensTo: 'S', hingeEnd: 'W' },
      { id: 'door_room5', kind: 'door', hex: 'U17',  orientation: 'h', state: 'closed', opensTo: 'N', hingeEnd: 'W' },
      { id: 'door_room5_closet', kind: 'door', hex: 'X20',  orientation: 'v', state: 'open', opensTo: 'W', hingeEnd: 'N' },
      { id: 'door_room6', kind: 'door', hex: 'AA17', orientation: 'h', state: 'closed', opensTo: 'N', hingeEnd: 'E' },
      { id: 'door_room7', kind: 'door', hex: 'AC14', orientation: 'h', state: 'closed', opensTo: 'S', hingeEnd: 'E' },
      { id: 'door_room8', kind: 'door', hex: 'AF13', orientation: 'v', state: 'closed', opensTo: 'E', hingeEnd: 'N' },
      { id: 'door_room9', kind: 'door', hex: 'AF16', orientation: 'v', state: 'closed', opensTo: 'E', hingeEnd: 'N' },
      { id: 'door_room10',kind: 'door', hex: 'AF20', orientation: 'v', state: 'closed', opensTo: 'E', hingeEnd: 'N' },

      // Invisible connectors between wall-less spaces (hallways, etc.).
      // Always considered "see-through" for fog visibility, but not drawn and do not cut walls unless threshold.
      { id: 'thresh_R16',  kind: 'threshold', hex: 'R16',  orientation: 'v', state: 'open', parent: 'Hallway2' },
      { id: 'thresh_AD16', kind: 'threshold', hex: 'AD16', orientation: 'v', state: 'open', parent: 'Hallway2' },
      { id: 'thresh_AD20', kind: 'threshold', hex: 'AD20', orientation: 'v', state: 'open', parent: '1stFloorStairsDown' },

      { id: 'west_window1', kind: 'window', hex: 'L20', orientation: 'v', state: 'closed', opensTo: 'W' },
      { id: 'west_window2', kind: 'window', hex: 'L19', orientation: 'v', state: 'closed', opensTo: 'W' },
      { id: 'west_window3', kind: 'window', hex: 'L17', orientation: 'v', state: 'closed', opensTo: 'W' },
      { id: 'west_window4', kind: 'window', hex: 'L16', orientation: 'v', state: 'closed', opensTo: 'W' },
      { id: 'west_window5', kind: 'window', hex: 'L14', orientation: 'v', state: 'closed', opensTo: 'W' },
      { id: 'west_window6', kind: 'window', hex: 'L13', orientation: 'v', state: 'closed', opensTo: 'W' },

      { id: 'south_window1', kind: 'window', hex: 'M11',  orientation: 'h', state: 'closed', opensTo: 'S' },
      { id: 'south_window2', kind: 'window', hex: 'N12',  orientation: 'h', state: 'closed', opensTo: 'S' },
      { id: 'south_window3', kind: 'window', hex: 'Q11',  orientation: 'h', state: 'closed', opensTo: 'S' },
      { id: 'south_window4', kind: 'window', hex: 'T12',  orientation: 'h', state: 'open',   opensTo: 'S' },
      { id: 'south_window5', kind: 'window', hex: 'U11',  orientation: 'h', state: 'closed', opensTo: 'S' },
      { id: 'south_window6', kind: 'window', hex: 'AA11', orientation: 'h', state: 'closed', opensTo: 'S' },
      { id: 'south_window7', kind: 'window', hex: 'AB12', orientation: 'h', state: 'closed', opensTo: 'S' },
      { id: 'south_window8', kind: 'window', hex: 'AE11', orientation: 'h', state: 'closed', opensTo: 'S' },
      { id: 'south_window9', kind: 'window', hex: 'AH12', orientation: 'h', state: 'closed', opensTo: 'S' },
    ],

    objects: [
      { id: 'bedroom1_bed1', kind: 'bed.single', hex: 'M19', orientation: 'h', head: 'W'},
      { id: 'bedroom1_bed2', kind: 'bed.single', hex: 'M20', orientation: 'h', head: 'W', shift: 'N0.5' },
      { id: 'bedroom2_bed1', kind: 'bed.single', hex: 'M16', orientation: 'h', head: 'W'},
      { id: 'bedroom2_bed2', kind: 'bed.single', hex: 'M17', orientation: 'h', head: 'W', shift: 'N0.5' },
      { id: 'bedroom3_bed1', kind: 'bed.single', hex: 'M13', orientation: 'h', head: 'W'},
      { id: 'bedroom3_bed2', kind: 'bed.single', hex: 'M14', orientation: 'h', head: 'W', shift: 'N0.5' },
      { id: 'bedroom10_bed1', kind: 'bed.single', hex: 'AI19', orientation: 'h', head: 'E'},
      { id: 'bedroom10_bed2', kind: 'bed.single', hex: 'AI20', orientation: 'h', head: 'E', shift: 'N0.5' },
      { id: 'bedroom9_bed1', kind: 'bed.single', hex: 'AI16', orientation: 'h', head: 'E'},
      { id: 'bedroom9_bed2', kind: 'bed.single', hex: 'AI17', orientation: 'h', head: 'E', shift: 'N0.5' },
      { id: 'bedroom8_bed1', kind: 'bed.single', hex: 'AI13', orientation: 'h', head: 'E'},
      { id: 'bedroom8_bed2', kind: 'bed.single', hex: 'AI14', orientation: 'h', head: 'E', shift: 'N0.5' },
      { id: 'bedroom5_bed', kind: 'bed.double', hex: 'S19', orientation: 'h', head: 'W' },
      { id: 'bedroom4_bed', kind: 'bed.double', hex: 'V13', orientation: 'h', head: 'E', shift: 'E0.75'  },
      { id: 'bedroom7_bed', kind: 'bed.double', hex: 'Z13', orientation: 'h', head: 'W', shift: 'W0.75'  },

      { id: 'bedroom4_table', kind:'table.round', hex:'T13' },
      { id: 'bedroom4_table_2', kind:'table.round', hex:'V20' },
      { id:'t_sq', kind:'table.square', hex:'U23', shift:'E0.00' },
      { id:'t_big', kind:'table.round', hexes:['N25','O25','O26'] },
      { id:'t_rect', kind:'table.rect', hexes:['P25','P24'] },
      { id:'chair_u14_sw', kind:'chair', hex:'S14', facing:'SE' },
    ],

    tokens: [
      { id: 'lich', name: 'Lich', side: 'ENEMY', hex: 'U19', label: 'L', init: 15, hp: 135 },
      { id: 'w1',   name: 'Wraith 1', side: 'ENEMY', hex: 'T16', label: 'W1', init: 12, hp: 67 },
      { id: 'w2',   name: 'Wraith 2', side: 'ENEMY', hex: 'Q18', label: 'W2', init: 11, hp: 67 },
      { id: 'w3',   name: 'Wraith 3', side: 'ENEMY', hex: 'N17', label: 'W3', init: 10, hp: 67 },
      { id: 'a',    name: 'Aelar', side: 'PC', hex: 'U14', label: 'A', init: 14, hp: 42, sprite: 'ranger_male' },
      { id: 'b',    name: 'Brunna', side: 'PC', hex: 'U13', label: 'B', init: 13, hp: 55 },
      { id: 'c',    name: 'Caelin', side: 'PC', hex: 'AA20', label: 'C', init: 12, hp: 38 },
    ],
  };

  const getState = () => (window.BATTLE_STATE || DEFAULT_STATE);

  // Computed each redraw (never used as canonical data unless state.fog.autoExplore mutates exploredRoomIds).
  let RENDER_FOG = {
    enabled: false,
    visible: new Set(),
    explored: new Set(),
    unseenAlpha: 0.92,
    exploredAlpha: 0.55,
  };

  // Non-destructive render overrides (UI helpers).
  const RENDER_OVERRIDES = {
    floorKind: '', // '' => use each room's own floor.kind
  };

  // =====================================================================================
  // UTIL / MATH
  // =====================================================================================
  const sqrt3 = Math.sqrt(3);
  const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v));
  const mod = (a, m) => ((a % m) + m) % m;

  // ===== Hex id helpers =====
  function colToLetters(col) {
    let n = col + 1;
    let s = '';
    while (n > 0) {
      const r = (n - 1) % 26;
      s = String.fromCharCode(65 + r) + s;
      n = Math.floor((n - 1) / 26);
    }
    return s;
  }

  function lettersToCol(letters) {
    const u = String(letters).toUpperCase();
    let n = 0;
    for (let i = 0; i < u.length; i++) {
      const c = u.charCodeAt(i);
      if (c < 65 || c > 90) throw new Error('Bad column letters');
      n = n * 26 + (c - 64);
    }
    return n - 1;
  }

  function parseHexId(hex) {
    const m = String(hex).trim().toUpperCase().match(/^([A-Z]+)([0-9]+)$/);
    if (!m) throw new Error('Bad hex: ' + hex);
    return { col: lettersToCol(m[1]), row: parseInt(m[2], 10) - 1 };
  }

  // Non-throwing parser (returns null on bad hex).
  function parseHex(hex) {
    try { return parseHexId(hex); } catch { return null; }
  }

  function hexId(col, row) {
    return colToLetters(col) + String(row + 1);
  }

  // ===== World geometry (flat-top) =====
  function colStep() { return 1.5 * GRID.size; }
  function rowStep() { return sqrt3 * GRID.size; }

  // Row 0 is bottom row ("1"), row increases upward.
  function hexCenterWorld(col, row) {
    const x = col * colStep();
    const y = -(row * rowStep() + (col & 1) * (rowStep() / 2));
    return { x, y };
  }

  // ===== Camera transform =====
  function cameraWorld() { return hexCenterWorld(VIEW.camera.col, VIEW.camera.row); }

  function worldToScreen(p) {
    const cam = cameraWorld();
    return { x: VIEW.anchor.x + (p.x - cam.x) + VIEW.dx, y: VIEW.anchor.y + (p.y - cam.y) + VIEW.dy };
  }

  function screenToWorld(p) {
    const cam = cameraWorld();
    return { x: (p.x - VIEW.anchor.x) + cam.x - VIEW.dx, y: (p.y - VIEW.anchor.y) + cam.y - VIEW.dy };
  }

  // ===== Path helpers =====
  function roundRectPath(targetCtx, x, y, w, h, r) {
    const rr = Math.max(0, Math.min(r, Math.min(Math.abs(w), Math.abs(h)) / 2));
    targetCtx.beginPath();
    targetCtx.moveTo(x + rr, y);
    targetCtx.lineTo(x + w - rr, y);
    targetCtx.quadraticCurveTo(x + w, y, x + w, y + rr);
    targetCtx.lineTo(x + w, y + h - rr);
    targetCtx.quadraticCurveTo(x + w, y + h, x + w - rr, y + h);
    targetCtx.lineTo(x + rr, y + h);
    targetCtx.quadraticCurveTo(x, y + h, x, y + h - rr);
    targetCtx.lineTo(x, y + rr);
    targetCtx.quadraticCurveTo(x, y, x + rr, y);
    targetCtx.closePath();
  }

  // =====================================================================================
  // "PACK" LAYER: simple by default. Optional FANCY PACK at end can overwrite these.
  // =====================================================================================
  const PACK = createBasicPack();

  // Expose a minimal set of core helpers so the OPTIONAL fancy pack can plug in things like sprites
  // without forcing changes throughout the renderer.
  PACK.core = {
    GRID,
    COLORS,
    clamp,
    mod,
    rowStep,
    colStep,
    parseHexId,
    parseHex,
    hexCenterWorld,
    worldToScreen,
    roundRectPath,
    facingToAngleRad,
    findNearestWallSegment,
    openingOrientation,
    normalizeDoorParams,
    normalizeWindowParams,
    // Object helpers (used by optional sprite renderer)
    getObjectShiftPx,
    getObjectOccupiedHexes,
    getScreenPointsForHexes,
    centroidOfPoints,
    boundsOfPoints,
    expandBounds,
  };

  function createBasicPack() {
    const flatFill = (targetCtx, rect, fill) => {
      targetCtx.fillStyle = fill;
      targetCtx.fillRect(rect.x, rect.y, rect.w, rect.h);
    };

    return {
      enabled: false,

      fillBrickRect(targetCtx, rect, color /*, worldX, worldY */) {
        flatFill(targetCtx, rect, color);
      },

      fillCobbleRect(targetCtx, rect /*, opts */) {
        flatFill(targetCtx, rect, COLORS.floorCobbleBase);
      },

      fillWoodRect(targetCtx, rect /*, opts */) {
        flatFill(targetCtx, rect, COLORS.floorWoodBase);
      },

      fillStairsWoodRect(targetCtx, rect /*, opts */) {
        // Cheap fallback: slightly darker wood with a few treads.
        flatFill(targetCtx, rect, '#caa87a');
        targetCtx.save();
        targetCtx.strokeStyle = 'rgba(0,0,0,0.18)';
        targetCtx.lineWidth = 1;
        const pitch = 12;
        for (let y = rect.y; y <= rect.y + rect.h; y += pitch) {
          targetCtx.beginPath();
          targetCtx.moveTo(rect.x, y);
          targetCtx.lineTo(rect.x + rect.w, y);
          targetCtx.stroke();
        }
        targetCtx.restore();
      },

      drawChair(targetCtx, center, facing, style) {
        // Ultra-simple chair marker.
        targetCtx.save();
        targetCtx.translate(center.x, center.y);
        targetCtx.fillStyle = (style && style.fill) ? style.fill : '#8a5a2b';
        targetCtx.strokeStyle = (style && style.stroke) ? style.stroke : 'rgba(0,0,0,0.35)';
        targetCtx.lineWidth = 1;
        roundRectPath(targetCtx, -10, -8, 20, 16, 4);
        targetCtx.fill();
        targetCtx.stroke();
        targetCtx.restore();
      },

      drawBed(targetCtx, rect, opts) {
        targetCtx.save();
        targetCtx.fillStyle = (opts && opts.mattressFill) ? opts.mattressFill : '#9a7b4b';
        targetCtx.fillRect(rect.x, rect.y, rect.w, rect.h);
        targetCtx.strokeStyle = (opts && opts.stroke) ? opts.stroke : 'rgba(0,0,0,0.60)';
        // Match table outline thickness
        targetCtx.lineWidth = 1;
        targetCtx.strokeRect(rect.x + 0.5, rect.y + 0.5, Math.max(0, rect.w - 1), Math.max(0, rect.h - 1));
        targetCtx.restore();
      },

      drawTableRound(targetCtx, center, radius, style) {
        targetCtx.save();
        targetCtx.beginPath();
        targetCtx.arc(center.x, center.y, radius, 0, Math.PI * 2);
        targetCtx.fillStyle = (style && style.fill) ? style.fill : '#9a7b4b';
        targetCtx.fill();
        targetCtx.strokeStyle = (style && style.stroke) ? style.stroke : 'rgba(0,0,0,0.35)';
        targetCtx.lineWidth = 1;
        targetCtx.stroke();
        targetCtx.restore();
      },

      drawTableRect(targetCtx, rect, style) {
        targetCtx.save();
        targetCtx.fillStyle = (style && style.fill) ? style.fill : '#9a7b4b';
        targetCtx.fillRect(rect.x, rect.y, rect.w, rect.h);
        targetCtx.strokeStyle = (style && style.stroke) ? style.stroke : 'rgba(0,0,0,0.35)';
        targetCtx.lineWidth = 1;
        targetCtx.strokeRect(rect.x + 0.5, rect.y + 0.5, Math.max(0, rect.w - 1), Math.max(0, rect.h - 1));
        targetCtx.restore();
      },

      // Optional hooks the fancy pack uses; keep stable.
      mulberry32: null,
      hashStringToSeed: null,
      shadeRgba: null,
      hexToRgbStrict: null,
    };
  }

  // =====================================================================================
  // GRID DRAWING
  // =====================================================================================
  function hexCornersWorld(center) {
    const s = GRID.size;
    const hs = s / 2;
    const hh = (sqrt3 * s) / 2;
    return [
      { x: center.x + s,  y: center.y },
      { x: center.x + hs, y: center.y + hh },
      { x: center.x - hs, y: center.y + hh },
      { x: center.x - s,  y: center.y },
      { x: center.x - hs, y: center.y - hh },
      { x: center.x + hs, y: center.y - hh },
    ];
  }

  function drawHexOutline(col, row) {
    const pts = hexCornersWorld(hexCenterWorld(col, row)).map(worldToScreen);
    ctx.beginPath();
    ctx.moveTo(pts[0].x, pts[0].y);
    for (let i = 1; i < pts.length; i++) ctx.lineTo(pts[i].x, pts[i].y);
    ctx.closePath();
    ctx.stroke();
  }

  function drawHexLabel(col, row) {
    const c = worldToScreen(hexCenterWorld(col, row));
    ctx.fillText(hexId(col, row), c.x, c.y + 30);
  }

  function estimateVisibleRange() {
    const pad = GRID.size * 4;
    const topLeftW = screenToWorld({ x: -pad, y: -pad });
    const botRightW = screenToWorld({ x: canvas.width + pad, y: canvas.height + pad });

    const minCol = Math.floor(Math.min(topLeftW.x, botRightW.x) / colStep()) - 2;
    const maxCol = Math.ceil(Math.max(topLeftW.x, botRightW.x) / colStep()) + 2;

    const minRow = Math.floor(-Math.max(topLeftW.y, botRightW.y) / rowStep()) - 4;
    const maxRow = Math.ceil(-Math.min(topLeftW.y, botRightW.y) / rowStep()) + 4;

    return {
      minCol: Math.max(-10, minCol),
      maxCol: Math.min(400, maxCol),
      minRow: Math.max(-10, minRow),
      maxRow: Math.min(400, maxRow)
    };
  }

  function drawGrid() {
    const range = estimateVisibleRange();

    ctx.save();
    ctx.lineWidth = GRID.lineWidth;
    ctx.strokeStyle = 'rgba(0,0,0,' + GRID.lineAlpha + ')';

    for (let col = range.minCol; col <= range.maxCol; col++) {
      for (let row = range.minRow; row <= range.maxRow; row++) {
        drawHexOutline(col, row);
      }
    }

    ctx.font = GRID.labelFont;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillStyle = 'rgba(0,0,0,' + GRID.labelAlpha + ')';

    for (let col = range.minCol; col <= range.maxCol; col++) {
      for (let row = range.minRow; row <= range.maxRow; row++) {
        drawHexLabel(col, row);
      }
    }

    ctx.restore();
  }

  // =====================================================================================
  // ROOMS / WALLS (geometry)
  // =====================================================================================
  function cornersToBounds(corners) {
    const pts = corners.map(parseHexId);
    const cols = pts.map(p => p.col);
    const rows = pts.map(p => p.row);
    return {
      minCol: Math.min.apply(null, cols),
      maxCol: Math.max.apply(null, cols),
      minRow: Math.min.apply(null, rows),
      maxRow: Math.max.apply(null, rows)
    };
  }

  function cornersToArea(bounds) {
    return (bounds.maxCol - bounds.minCol + 1) * (bounds.maxRow - bounds.minRow + 1);
  }

  function roomToWallBox(room) {
    const thickness = Math.max(1, Number(room.thickness || 30));

    if (!Array.isArray(room.corners) || room.corners.length < 4) {
      throw new Error('Room missing 4 corners');
    }

    // Corner order: [top-left, top-right, bottom-right, bottom-left]
    const p0 = parseHexId(room.corners[0]);
    const p1 = parseHexId(room.corners[1]);
    const p2 = parseHexId(room.corners[2]);
    const p3 = parseHexId(room.corners[3]);

    const c0 = hexCenterWorld(p0.col, p0.row);
    const c1 = hexCenterWorld(p1.col, p1.row);
    const c2 = hexCenterWorld(p2.col, p2.row);
    const c3 = hexCenterWorld(p3.col, p3.row);

    const xL = (c0.x + c3.x) / 2;
    const xR = (c1.x + c2.x) / 2;
    let yTop = (c0.y + c1.y) / 2;
    let yBot = (c2.y + c3.y) / 2;

    // Horizontal wall phase tweak: shift all horizontal room edges 1/4-hex SOUTH so
    // horizontal walls land in the gap between alternating flat tops.
    const yShift = rowStep() / 4;
    yTop += yShift;
    yBot += yShift;

    const b = cornersToBounds(room.corners);

    const halfT = thickness / 2;
    const outer = { x1: xL - halfT, x2: xR + halfT, y1: yTop - halfT, y2: yBot + halfT, thickness: thickness };
    const inner = { x1: outer.x1 + thickness, x2: outer.x2 - thickness, y1: outer.y1 + thickness, y2: outer.y2 - thickness };

    return { bounds: b, thickness, outer, inner, xL, xR, yTop, yBot };
  }

  function roomHasWalls(room) {
    const k = room && room.wall && room.wall.kind ? String(room.wall.kind).toLowerCase() : 'brick';
    if (k === 'none' || k === 'off' || k === 'false') return false;
    if (room && room.drawWalls === false) return false;
    return true;
  }

  function buildWallSegments(rooms) {
    const segs = [];
    for (const r of rooms) {
      if (!roomHasWalls(r)) continue;
      const box = roomToWallBox(r);
      const t = box.thickness;
      segs.push({ orientation: 'h', y: box.yTop, x1: box.xL, x2: box.xR, thickness: t });
      segs.push({ orientation: 'h', y: box.yBot, x1: box.xL, x2: box.xR, thickness: t });
      segs.push({ orientation: 'v', x: box.xL, y1: box.yTop, y2: box.yBot, thickness: t });
      segs.push({ orientation: 'v', x: box.xR, y1: box.yTop, y2: box.yBot, thickness: t });
    }
    return segs;
  }

  function roomFloorRectWorld(room, box) {
    const hasWalls = roomHasWalls(room);
    const src = hasWalls ? box.inner : box.outer;
    return { x1: src.x1, y1: src.y1, x2: src.x2, y2: src.y2 };
  }

  function findRoomById(rooms, id) {
    const target = String(id || '');
    for (const r of (Array.isArray(rooms) ? rooms : [])) {
      if (r && String(r.id) === target) return r;
    }
    return null;
  }

  function findNearestWallSegment(wallSegs, orient, p) {
    const want = (orient === 'h' || orient === 'v') ? orient : 'h';
    const segs = Array.isArray(wallSegs) ? wallSegs : [];

    let best = null;
    let bestD2 = Infinity;

    for (const s of segs) {
      if (!s || s.orientation !== want) continue;

      if (want === 'h') {
        const dy = Math.abs((p && p.y) - s.y);
        let dx = 0;
        if ((p && p.x) < s.x1) dx = s.x1 - (p.x);
        else if ((p && p.x) > s.x2) dx = (p.x) - s.x2;
        const d2 = dx * dx + dy * dy;
        if (d2 < bestD2) { bestD2 = d2; best = s; }
      } else {
        const dx = Math.abs((p && p.x) - s.x);
        let dy = 0;
        if ((p && p.y) < s.y1) dy = s.y1 - (p.y);
        else if ((p && p.y) > s.y2) dy = (p.y) - s.y2;
        const d2 = dx * dx + dy * dy;
        if (d2 < bestD2) { bestD2 = d2; best = s; }
      }
    }

    return best;
  }

  function drawRoomWalls(targetCtx, room) {
    if (!roomHasWalls(room)) return;

    const box = roomToWallBox(room);
    const t = box.thickness;

    const wallKind = room && room.wall && room.wall.kind ? String(room.wall.kind).toLowerCase() : 'brick';
    if (wallKind === 'none') return;

    const wallColor = room && room.color ? String(room.color) : COLORS.wall;

    // Outer and inner in WORLD coords.
    const o = box.outer;
    const i = box.inner;

    // Helper: world rect -> screen rect.
    const toScreenRect = (x1, y1, x2, y2) => {
      const p1 = worldToScreen({ x: x1, y: y1 });
      const p2 = worldToScreen({ x: x2, y: y2 });
      return { x: p1.x, y: p1.y, w: (p2.x - p1.x), h: (p2.y - p1.y) };
    };

    // Wall bands in WORLD coords.
    const bands = [
      { x1: o.x1, y1: o.y1, x2: o.x2, y2: i.y1 }, // top
      { x1: o.x1, y1: i.y2, x2: o.x2, y2: o.y2 }, // bottom
      { x1: o.x1, y1: i.y1, x2: i.x1, y2: i.y2 }, // left
      { x1: i.x2, y1: i.y1, x2: o.x2, y2: i.y2 }, // right
    ];

    for (const b of bands) {
      const r = toScreenRect(b.x1, b.y1, b.x2, b.y2);
      if (r.w <= 0 || r.h <= 0) continue;

      if (wallKind === 'brick') {
        // Brick fill is a PACK function.
        PACK.fillBrickRect(targetCtx, r, wallColor, b.x1, b.y1);
      } else {
        targetCtx.fillStyle = wallColor;
        targetCtx.fillRect(r.x, r.y, r.w, r.h);
      }

      // Subtle edge line.
      targetCtx.strokeStyle = 'rgba(0,0,0,0.08)';
      targetCtx.lineWidth = 1;
      targetCtx.strokeRect(r.x + 0.5, r.y + 0.5, Math.max(0, r.w - 1), Math.max(0, r.h - 1));
    }

    // Corner caps: small squares prevent micro-holes at joins.
    if (t >= 2) {
      const cap = (x1, y1) => {
        const r = toScreenRect(x1, y1, x1 + t, y1 + t);
        if (r.w > 0 && r.h > 0) {
          if (wallKind === 'brick') PACK.fillBrickRect(targetCtx, r, wallColor, x1, y1);
          else { targetCtx.fillStyle = wallColor; targetCtx.fillRect(r.x, r.y, r.w, r.h); }
        }
      };

      cap(o.x1, o.y1);
      cap(o.x2 - t, o.y1);
      cap(o.x1, o.y2 - t);
      cap(o.x2 - t, o.y2 - t);
    }
  }

  // =====================================================================================
  // OPENINGS (doors/windows/thresholds)
  // =====================================================================================
  function openingOrientation(o) {
    if (o && (o.orientation === 'h' || o.orientation === 'v')) return o.orientation;
    const rot = Number((o && o.rot) ? o.rot : 0) % 180;
    return (rot === 90) ? 'h' : 'v';
  }

  function openingKnockoutSpan(opening) {
    const kind = String(opening && opening.kind ? opening.kind : 'door').toLowerCase();
    const orient = openingOrientation(opening);

    if (Number.isFinite(opening && opening.knockoutSpan)) return Number(opening.knockoutSpan);
    if (Number.isFinite(opening && opening.span)) return Number(opening.span);

    if (kind === 'threshold') return (orient === 'v') ? 1.5 : 1.0;
    return 1.0;
  }

  function normalizeDoorParams(opening, orient) {
    let state = String(opening && opening.state ? opening.state : '').toLowerCase();
    if (!state) {
      if (opening && opening.open === true) state = 'open';
      else if (opening && opening.open === false) state = 'closed';
      else state = 'closed';
    }
    if (state !== 'open' && state !== 'closed' && state !== 'ajar') state = 'closed';

    const isV = orient === 'v';

    const validOpensTo = isV ? new Set(['E', 'W']) : new Set(['N', 'S']);
    const validHinge = isV ? new Set(['N', 'S']) : new Set(['W', 'E']);

    let opensTo = String(opening && opening.opensTo ? opening.opensTo : '').toUpperCase();
    if (!validOpensTo.has(opensTo)) opensTo = isV ? 'E' : 'N';

    let hingeEnd = String(opening && opening.hingeEnd ? opening.hingeEnd : '').toUpperCase();
    if (!validHinge.has(hingeEnd)) hingeEnd = isV ? 'N' : 'W';

    let openPct = Number(opening && (opening.openPct ?? opening.openPercent ?? opening.openAmount));
    if (!Number.isFinite(openPct)) {
      openPct = (state === 'open') ? 1 : (state === 'ajar') ? 0.5 : 0;
    }
    openPct = clamp(openPct, 0, 1);

    return { state, opensTo, hingeEnd, openPct };
  }

  function normalizeWindowParams(opening, orient) {
    let state = String(opening && opening.state ? opening.state : '').toLowerCase();
    if (!state) {
      if (opening && opening.open === true) state = 'open';
      else if (opening && opening.open === false) state = 'closed';
      else state = 'closed';
    }
    if (state !== 'open' && state !== 'closed' && state !== 'ajar') state = 'closed';

    const isV = orient === 'v';
    const validOpensTo = isV ? new Set(['E', 'W']) : new Set(['N', 'S']);

    let opensTo = String(opening && opening.opensTo ? opening.opensTo : '').toUpperCase();
    if (!validOpensTo.has(opensTo)) opensTo = isV ? 'W' : 'S';

    let openPct = Number(opening && (opening.openPct ?? opening.openPercent ?? opening.openAmount));
    if (!Number.isFinite(openPct)) {
      openPct = (state === 'open') ? 1 : (state === 'ajar') ? 0.5 : 0;
    }
    openPct = clamp(openPct, 0, 1);

    return { state, opensTo, openPct };
  }

  // =====================================================================================
  // FOG OF WAR (room-based)
  // =====================================================================================
  function normalizeFog(state) {
    const raw = (state && typeof state.fog === 'object' && state.fog) ? state.fog : null;

    const enabled = !!(raw && raw.enabled);
    const mode = raw && raw.mode ? String(raw.mode) : 'room';

    // If true, we still draw unseen rooms (so walls/geometry remain visible) and then cover
    // their floors with a dark fog overlay. If false, unseen rooms are not drawn at all.
    const revealWallsInUnseenRooms = (raw && raw.revealWallsInUnseenRooms === true) ? true : false;

    const maxDepth = Number.isFinite(raw && raw.maxDepth) ? Number(raw.maxDepth) : 1;
    const autoCompute = (raw && raw.autoCompute === false) ? false : true;
    const autoExplore = (raw && raw.autoExplore === false) ? false : true;

    const unseenAlpha = Number.isFinite(raw && raw.unseenAlpha) ? Number(raw.unseenAlpha) : 0.92;
    const exploredAlpha = Number.isFinite(raw && raw.exploredAlpha) ? Number(raw.exploredAlpha) : 0.55;

    const visibleRoomIds = Array.isArray(raw && raw.visibleRoomIds) ? raw.visibleRoomIds.map(x => String(x)) : [];
    const exploredRoomIds = Array.isArray(raw && raw.exploredRoomIds) ? raw.exploredRoomIds.map(x => String(x)) : [];

    return { enabled, mode, maxDepth, autoCompute, autoExplore, unseenAlpha, exploredAlpha, visibleRoomIds, exploredRoomIds, revealWallsInUnseenRooms, raw };
  }

  function buildRoomMeta(rooms) {
    const meta = [];
    for (const r of rooms) {
      if (!r || !r.id || !Array.isArray(r.corners)) continue;
      try {
        const b = cornersToBounds(r.corners);
        meta.push({
          id: String(r.id),
          room: r,
          bounds: b,
          area: cornersToArea(b),
          hasWalls: roomHasWalls(r),
        });
      } catch {
        // ignore malformed rooms
      }
    }
    return meta;
  }

  function pickMostSpecificRoomIdAt(roomMeta, col, row) {
    let best = null;
    let bestArea = Infinity;
    let bestWallRank = Infinity;

    for (const m of roomMeta) {
      const b = m.bounds;
      if (col < b.minCol || col > b.maxCol || row < b.minRow || row > b.maxRow) continue;

      const wallRank = m.hasWalls ? 0 : 1;
      if (m.area < bestArea || (m.area === bestArea && wallRank < bestWallRank)) {
        best = m.id;
        bestArea = m.area;
        bestWallRank = wallRank;
      }
    }

    return best;
  }

  function pickMostSpecificRoomIdForHex(roomMeta, hex) {
    try {
      const p = parseHexId(hex);
      return pickMostSpecificRoomIdAt(roomMeta, p.col, p.row);
    } catch {
      return null;
    }
  }

  function getPlayerTokens(state) {
    const tokens = Array.isArray(state.tokens) ? state.tokens : [];
    return tokens.filter(t => {
      const side = String(t.side || '').toUpperCase();
      return side === 'PC' || side === 'PLAYER';
    });
  }

  function isPlayerToken(t) {
    const side = String(t && t.side ? t.side : '').toUpperCase();
    return side === 'PC' || side === 'PLAYER';
  }

  function openingIsSeeThrough(opening) {
    const kind = String(opening && opening.kind ? opening.kind : 'door').toLowerCase();
    const orient = openingOrientation(opening);

    if (kind === 'threshold' || kind === 'portal' || kind === 'connector') return true;

    if (kind === 'door') {
      const d = normalizeDoorParams(opening, orient);
      return d.openPct > 0.05;
    }

    if (kind === 'window') {
      const w = normalizeWindowParams(opening, orient);
      return w.openPct > 0.05;
    }

    return false;
  }

  function openingTouchingRoomIds(opening, roomMeta) {
    if (!opening || !opening.hex) return { a: null, b: null };
    let p;
    try { p = parseHexId(opening.hex); } catch { return { a: null, b: null }; }

    const orient = openingOrientation(opening);

    let a = null;
    let b = null;
    if (orient === 'v') {
      a = pickMostSpecificRoomIdAt(roomMeta, p.col - 1, p.row);
      b = pickMostSpecificRoomIdAt(roomMeta, p.col + 1, p.row);
    } else {
      a = pickMostSpecificRoomIdAt(roomMeta, p.col, p.row + 1);
      b = pickMostSpecificRoomIdAt(roomMeta, p.col, p.row - 1);
    }

    return { a, b };
  }

  function buildAdjacency(roomMeta, openings) {
    const neighbors = new Map();

    const ensure = (id) => {
      if (!neighbors.has(id)) neighbors.set(id, new Set());
      return neighbors.get(id);
    };

    const addEdge = (a, b) => {
      if (!a || !b || a === b) return;
      ensure(a).add(b);
      ensure(b).add(a);
    };

    for (const m of roomMeta) ensure(m.id);

    // Connect through see-through openings.
    for (const o of openings) {
      if (!o || !o.hex) continue;
      if (!openingIsSeeThrough(o)) continue;

      let p;
      try { p = parseHexId(o.hex); } catch { continue; }
      const orient = openingOrientation(o);

      let a = null;
      let b = null;
      if (orient === 'v') {
        a = pickMostSpecificRoomIdAt(roomMeta, p.col - 1, p.row);
        b = pickMostSpecificRoomIdAt(roomMeta, p.col + 1, p.row);
      } else {
        a = pickMostSpecificRoomIdAt(roomMeta, p.col, p.row + 1);
        b = pickMostSpecificRoomIdAt(roomMeta, p.col, p.row - 1);
      }

      addEdge(a, b);
    }

    return neighbors;
  }

  function computeRenderFog(state, rooms, openings) {
    const fog = normalizeFog(state);
    const roomMeta = buildRoomMeta(rooms);

    if (!fog.enabled || String(fog.mode).toLowerCase() !== 'room') {
      return {
        enabled: false,
        visible: new Set(),
        explored: new Set(),
        unseenAlpha: fog.unseenAlpha,
        exploredAlpha: fog.exploredAlpha,
        revealWallsInUnseenRooms: fog.revealWallsInUnseenRooms,
      };
    }

    let visible = new Set();

    if (!fog.autoCompute && fog.visibleRoomIds.length) {
      visible = new Set(fog.visibleRoomIds);
    } else {
      const players = getPlayerTokens(state);
      const q = [];
      const seed = new Set();

      for (const t of players) {
        const rid = pickMostSpecificRoomIdForHex(roomMeta, t.hex);
        if (rid) seed.add(rid);
      }

      for (const rid of seed) {
        visible.add(rid);
        q.push({ id: rid, depth: 0 });
      }

      const neighbors = buildAdjacency(roomMeta, openings);
      const maxDepth = fog.maxDepth;

      while (q.length) {
        const cur = q.shift();
        if (!cur) break;
        if (cur.depth >= maxDepth) continue;

        const nbs = neighbors.get(cur.id);
        if (!nbs) continue;

        for (const nb of nbs) {
          if (!visible.has(nb)) {
            visible.add(nb);
            q.push({ id: nb, depth: cur.depth + 1 });
          }
        }
      }

      if (fog.raw) fog.raw.visibleRoomIds = Array.from(visible).sort();
    }

    const explored = new Set(fog.exploredRoomIds);
    if (fog.autoExplore) {
      for (const rid of visible) explored.add(rid);
      if (fog.raw) fog.raw.exploredRoomIds = Array.from(explored).sort();
    }

    return { enabled: true, visible, explored, unseenAlpha: fog.unseenAlpha, exploredAlpha: fog.exploredAlpha, revealWallsInUnseenRooms: fog.revealWallsInUnseenRooms };
  }

  function shouldDrawToken(t, rooms) {
    if (!RENDER_FOG || !RENDER_FOG.enabled) return true;
    if (isPlayerToken(t)) return true;

    const rid = pickMostSpecificRoomIdForHex(buildRoomMeta(rooms), t.hex);
    if (!rid) return true;

    return RENDER_FOG.visible.has(rid);
  }

  // =====================================================================================
  // FLOORS
  // =====================================================================================
  function isFogFloorRoom(room) {
    const k = room && room.floor && room.floor.kind ? String(room.floor.kind).toLowerCase() : '';
    return k === 'fog';
  }

  function drawFloorsLayered(roomsToDraw) {
    const fogRooms = [];
    const otherRooms = [];

    for (const r of (Array.isArray(roomsToDraw) ? roomsToDraw : [])) {
      (isFogFloorRoom(r) ? fogRooms : otherRooms).push(r);
    }

    for (const r of fogRooms) drawRoomFloor(r);
    for (const r of otherRooms) drawRoomFloor(r);
  }

  function drawRoomFloor(room) {
    const box = roomToWallBox(room);

    const rawFloorKind = (room.floor && room.floor.kind) ? room.floor.kind : 'stone';
    const floorKind = (RENDER_OVERRIDES.floorKind && String(RENDER_OVERRIDES.floorKind).length)
      ? RENDER_OVERRIDES.floorKind
      : rawFloorKind;

    if (floorKind === 'none') return;

    const f = roomFloorRectWorld(room, box);

    const f1 = worldToScreen({ x: f.x1, y: f.y1 });
    const f2 = worldToScreen({ x: f.x2, y: f.y2 });

    const rect = { x: f1.x, y: f1.y, w: (f2.x - f1.x), h: (f2.y - f1.y) };

    // World anchoring values for patterns.
    const worldX = f.x1;
    const worldY = f.y1;

    // Fog-floor rooms are a base layer for Fog of War. If fog is OFF, skip them.
    if (String(floorKind).toLowerCase() === 'fog') {
      if (!(RENDER_FOG && RENDER_FOG.enabled)) return;
      ctx.fillStyle = COLORS.fogUnseen;
      ctx.fillRect(rect.x, rect.y, rect.w, rect.h);
      return;
    }

    if (floorKind === 'stone') {
      ctx.fillStyle = COLORS.floorStone;
      ctx.fillRect(rect.x, rect.y, rect.w, rect.h);
      return;
    }

    if (floorKind === 'wood') {
      PACK.fillWoodRect(ctx, rect, { baseHex: COLORS.floorWoodBase, alpha: 1.0, worldX, worldY, seed: seedForRoom(room, 'wood') });
      return;
    }

    if (floorKind === 'cobble') {
      PACK.fillCobbleRect(ctx, rect, { baseHex: COLORS.floorCobbleBase, alpha: 1.0, worldX, worldY, seed: seedForRoom(room, 'cobble') });
      return;
    }

    if (floorKind === 'stairs.wood') {
      PACK.fillStairsWoodRect(ctx, rect, { baseHex: COLORS.floorWoodBase, alpha: 1.0, worldX, worldY, seed: seedForRoom(room, 'stairs'), down: room.stairsDown || 'S', treadDepth: 10, treadGap: 1.2 });
      return;
    }

    // Default: wood.
    PACK.fillWoodRect(ctx, rect, { baseHex: COLORS.floorWoodBase, alpha: 1.0, worldX, worldY, seed: seedForRoom(room, 'wood') });
  }

  // =====================================================================================
  // THRESHOLDS + DOOR UNDERLAYS
  // =====================================================================================
  function thresholdKnockoutFromParent(opening, roomsForSizing, wallSegs) {
    const kind = String(opening && opening.kind ? opening.kind : '').toLowerCase();
    if (kind !== 'threshold') return null;

    const parentId = String(opening && opening.parent ? opening.parent : '');
    if (!parentId) return null;

    const parent = findRoomById(roomsForSizing, parentId);
    if (!parent) return null;

    const orient = openingOrientation(opening);

    let p;
    try { p = parseHexId(opening.hex); } catch { return null; }

    const hexWorld = hexCenterWorld(p.col, p.row);
    const box = roomToWallBox(parent);

    const seg = findNearestWallSegment(wallSegs || [], orient, hexWorld);

    // Centerline of the wall we are cutting.
    let cx = hexWorld.x;
    let cy = hexWorld.y;

    if (orient === 'v') {
      // Center vertically on the parent's INNER floor span so junctions read continuous.
      cy = (box.inner.y1 + box.inner.y2) / 2;

      if (seg) cx = seg.x;
      else cx = (Math.abs(hexWorld.x - box.xL) < Math.abs(hexWorld.x - box.xR)) ? box.xL : box.xR;

      return { cx, cy, len: (box.inner.y2 - box.inner.y1), thickness: seg ? seg.thickness : box.thickness };
    }

    // orient === 'h'
    cx = (box.inner.x1 + box.inner.x2) / 2;
    if (seg) cy = seg.y;
    else cy = (Math.abs(hexWorld.y - box.yTop) < Math.abs(hexWorld.y - box.yBot)) ? box.yTop : box.yBot;

    return { cx, cy, len: (box.inner.x2 - box.inner.x1), thickness: seg ? seg.thickness : box.thickness };
  }

  function paintThresholdUnderlay(opening, rooms, wallSegs) {
    const kind = String(opening && opening.kind ? opening.kind : 'door').toLowerCase();
    if (kind !== 'threshold') return;

    const parentId = String(opening && opening.parent ? opening.parent : '');
    if (!parentId) return;

    const parent = findRoomById(rooms, parentId);
    if (!parent) return;

    const spec = thresholdKnockoutFromParent(opening, rooms, wallSegs);
    if (!spec) return;

    const orient = openingOrientation(opening);

    const centerS = worldToScreen({ x: spec.cx, y: spec.cy });
    const cutH = spec.thickness + 6;
    const cutW = spec.len;

    const rect = (orient === 'h')
      ? { x: centerS.x - cutW / 2, y: centerS.y - cutH / 2, w: cutW, h: cutH }
      : { x: centerS.x - cutH / 2, y: centerS.y - cutW / 2, w: cutH, h: cutW };

    const rawFloorKind = (parent.floor && parent.floor.kind) ? String(parent.floor.kind) : 'wood';
    const floorKind = (RENDER_OVERRIDES.floorKind && String(RENDER_OVERRIDES.floorKind).length)
      ? String(RENDER_OVERRIDES.floorKind)
      : rawFloorKind;

    const box = roomToWallBox(parent);
    const f = roomFloorRectWorld(parent, box);

    const worldX = f.x1;
    const worldY = f.y1;
    const seed = seedForRoom(parent, 'floor');

    const fk = String(floorKind).toLowerCase();

    if (fk === 'stone') {
      ctx.fillStyle = COLORS.floorStone;
      ctx.fillRect(rect.x, rect.y, rect.w, rect.h);
    } else if (fk === 'cobble') {
      PACK.fillCobbleRect(ctx, rect, { baseHex: COLORS.floorCobbleBase, alpha: 1.0, worldX, worldY, seed });
    } else if (fk === 'stairs.wood') {
      PACK.fillStairsWoodRect(ctx, rect, { baseHex: COLORS.floorWoodBase, alpha: 1.0, worldX, worldY, seed, down: parent.stairsDown || 'S', treadDepth: 10, treadGap: 1.2 });
    } else if (fk === 'none') {
      ctx.fillStyle = '#f7f1e6';
      ctx.fillRect(rect.x, rect.y, rect.w, rect.h);
    } else {
      PACK.fillWoodRect(ctx, rect, { baseHex: COLORS.floorWoodBase, alpha: 1.0, worldX, worldY, seed });
    }

    // Match the room's current fog state (important because threshold underlays sit inside wall thickness).
    applyFogToUnderlayRect(rect, parentId);
  }

  function resolveDoorUnderlayRoomId(opening, roomMeta, rooms, allowedRoomIds) {
    const kind = String(opening && opening.kind ? opening.kind : 'door').toLowerCase();
    if (kind !== 'door') return null;

    const orient = openingOrientation(opening);
    const d = normalizeDoorParams(opening, orient);

    const { a, b } = openingTouchingRoomIds(opening, roomMeta);

    // Prefer the opensTo side.
    let primary = null;
    let secondary = null;

    if (orient === 'v') {
      primary = (d.opensTo === 'E') ? b : a;
      secondary = (primary === a) ? b : a;
    } else {
      primary = (d.opensTo === 'N') ? a : b;
      secondary = (primary === a) ? b : a;
    }

    const isFogRoom = (rid) => {
      if (!rid) return false;
      const rr = findRoomById(rooms, rid);
      const fk = rr && rr.floor && rr.floor.kind ? String(rr.floor.kind).toLowerCase() : '';
      return fk === 'fog';
    };

    const isAllowed = (rid) => {
      if (!rid) return false;
      if (allowedRoomIds && allowedRoomIds instanceof Set) return allowedRoomIds.has(rid);
      return true;
    };

    // In fog mode, never underlay using an unseen room's floor.
    if (primary && (!isAllowed(primary) || isFogRoom(primary))) {
      if (secondary && isAllowed(secondary) && !isFogRoom(secondary)) return secondary;
      return null;
    }

    if (primary && isAllowed(primary)) return primary;
    if (secondary && isAllowed(secondary) && !isFogRoom(secondary)) return secondary;

    return null;
  }

  function openingCutRectOnScreen(opening, wallSegs) {
    const orient = openingOrientation(opening);

    let p;
    try { p = parseHexId(opening.hex); } catch { return null; }

    const hexWorld = hexCenterWorld(p.col, p.row);
    const seg = findNearestWallSegment(wallSegs || [], orient, hexWorld);

    const baseLen = (GRID.size * 1.2);
    const span = openingKnockoutSpan(opening);
    const w = baseLen * span;

    let cx = hexWorld.x;
    let cy = hexWorld.y;
    let thickness = 28;

    if (seg) {
      thickness = seg.thickness;
      if (orient === 'h') cy = seg.y;
      else cx = seg.x;
    }

    const centerS = worldToScreen({ x: cx, y: cy });
    const cutH = thickness + 3;
    const cutW = w + 2;

    return (orient === 'h')
      ? { x: centerS.x - cutW / 2, y: centerS.y - cutH / 2, w: cutW, h: cutH }
      : { x: centerS.x - cutH / 2, y: centerS.y - cutW / 2, w: cutH, h: cutW };
  }

  function paintDoorUnderlay(opening, rooms, wallSegs, roomMeta, allowedRoomIds) {
    const kind = String(opening && opening.kind ? opening.kind : 'door').toLowerCase();
    if (kind !== 'door') return;

    const rect = openingCutRectOnScreen(opening, wallSegs);
    if (!rect) return;

    const rid = resolveDoorUnderlayRoomId(opening, roomMeta, rooms, allowedRoomIds);

    if (rid) {
      const room = findRoomById(rooms, rid);
      if (!room) return;

      const rawFloorKind = (room.floor && room.floor.kind) ? String(room.floor.kind) : 'wood';
      const floorKind = (RENDER_OVERRIDES.floorKind && String(RENDER_OVERRIDES.floorKind).length)
        ? String(RENDER_OVERRIDES.floorKind)
        : rawFloorKind;

      const box = roomToWallBox(room);
      const f = roomFloorRectWorld(room, box);

      const worldX = f.x1;
      const worldY = f.y1;
      const seed = seedForRoom(room, 'doorUnderlay');

      const fk = String(floorKind).toLowerCase();

      if (fk === 'stone') {
        ctx.fillStyle = COLORS.floorStone;
        ctx.fillRect(rect.x, rect.y, rect.w, rect.h);
      } else if (fk === 'cobble') {
        PACK.fillCobbleRect(ctx, rect, { baseHex: COLORS.floorCobbleBase, alpha: 1.0, worldX, worldY, seed });
      } else if (fk === 'stairs.wood') {
        PACK.fillStairsWoodRect(ctx, rect, { baseHex: COLORS.floorWoodBase, alpha: 1.0, worldX, worldY, seed, down: room.stairsDown || 'S', treadDepth: 10, treadGap: 1.2 });
      } else if (fk === 'none') {
        ctx.fillStyle = '#f7f1e6';
        ctx.fillRect(rect.x, rect.y, rect.w, rect.h);
      } else {
        PACK.fillWoodRect(ctx, rect, { baseHex: COLORS.floorWoodBase, alpha: 1.0, worldX, worldY, seed });
      }
    } else {
      // If both adjacent rooms are unseen, we still need *something* under the punched-out wall.
      // We'll tint it with fog so the doorway doesn't show white gaps.
      if (RENDER_FOG && RENDER_FOG.enabled) {
        ctx.fillStyle = COLORS.fogUnseen;
        ctx.fillRect(rect.x, rect.y, rect.w, rect.h);
      }
    }

    // Match fog state. If rid is null, treat as unseen.
    applyFogToUnderlayRect(rect, rid);
  }

  function cutOpeningHole(targetCtx, opening, wallSegs, roomsForSizing) {
    const kind = String(opening && opening.kind ? opening.kind : 'door').toLowerCase();
    if (kind === 'portal' || kind === 'connector') return;

    const orient = openingOrientation(opening);
    const p = parseHexId(opening.hex);

    const hexWorld = hexCenterWorld(p.col, p.row);

    // Parent-based threshold: punch out the full wall span for the parent hallway edge.
    if (kind === 'threshold') {
      const spec = thresholdKnockoutFromParent(opening, roomsForSizing, wallSegs);
      if (spec) {
        const centerS = worldToScreen({ x: spec.cx, y: spec.cy });

        const cutH = spec.thickness + 6;
        const cutW = spec.len;

        targetCtx.save();
        targetCtx.translate(centerS.x, centerS.y);
        if (orient === 'v') targetCtx.rotate(Math.PI / 2);

        targetCtx.beginPath();
        targetCtx.rect(-cutW / 2, -cutH / 2, cutW, cutH);
        targetCtx.fill();

        targetCtx.restore();
        return;
      }
    }

    const seg = findNearestWallSegment(wallSegs, orient, hexWorld);

    const baseLen = (GRID.size * 1.2);
    const span = openingKnockoutSpan(opening);
    const w = baseLen * span;

    let cx = hexWorld.x;
    let cy = hexWorld.y;
    let thickness = 28;

    if (seg) {
      thickness = seg.thickness;
      if (orient === 'h') cy = seg.y;
      else cx = seg.x;
    }

    const centerS = worldToScreen({ x: cx, y: cy });

    const cutH = thickness + 3;
    const cutW = w + 2;

    // For vertical thresholds: extend extra SOUTH (down-screen), not split north/south.
    let alongWallBias = 0;
    if (kind === 'threshold' && orient === 'v' && span > 1) {
      alongWallBias = ((span - 1) * baseLen) / 2;
    }

    targetCtx.save();
    targetCtx.translate(centerS.x, centerS.y);
    if (orient === 'v') {
      targetCtx.rotate(Math.PI / 2);
      if (alongWallBias) targetCtx.translate(alongWallBias, 0);
    }

    targetCtx.beginPath();
    targetCtx.rect(-cutW / 2, -cutH / 2, cutW, cutH);
    targetCtx.fill();

    targetCtx.restore();
  }

  function drawOpening(opening, wallSegs) {
    const kind = String(opening.kind || 'door').toLowerCase();

    // Invisible connectors: affect fog logic only.
    if (kind === 'threshold' || kind === 'portal' || kind === 'connector') return;

    // Optional sprite override (fancy pack can implement this).
    if (PACK && typeof PACK.drawOpeningSprite === 'function') {
      try {
        if (PACK.drawOpeningSprite(ctx, opening, wallSegs, PACK.core)) return;
      } catch (e) {
        console.warn('[Battlemat] drawOpeningSprite failed:', e);
      }
    }

    const orient = openingOrientation(opening);
    const p = parseHexId(opening.hex);

    const hexWorld = hexCenterWorld(p.col, p.row);
    const seg = findNearestWallSegment(wallSegs, orient, hexWorld);

    const w = GRID.size * 1.2;
    const fallbackH = GRID.size * 0.55;

    let cx = hexWorld.x;
    let cy = hexWorld.y;
    let thickness = 28;

    if (seg) {
      thickness = seg.thickness;
      if (orient === 'h') cy = seg.y;
      else cx = seg.x;
    }

    const centerS = worldToScreen({ x: cx, y: cy });

    ctx.save();
    ctx.translate(centerS.x, centerS.y);
    if (orient === 'v') ctx.rotate(Math.PI / 2);

    const fill = (kind === 'window') ? COLORS.window : COLORS.door;
    const stroke = 'rgba(0,0,0,0.35)';
    const openingHBase = Math.min(thickness * 0.72, fallbackH);
    const openingH = openingHBase * 0.75;

    ctx.lineWidth = 2;

    if (kind === 'door') {
      const d = normalizeDoorParams(opening, orient);

      const hingeSide = ((orient === 'h' && d.hingeEnd === 'W') || (orient === 'v' && d.hingeEnd === 'N')) ? 'left' : 'right';
      const hingeX = (hingeSide === 'left') ? (-w / 2) : (w / 2);

      let desiredY = 1;
      if (orient === 'h') desiredY = (d.opensTo === 'S') ? 1 : -1;
      else desiredY = (d.opensTo === 'W') ? 1 : -1;

      const rotSign = desiredY * (hingeSide === 'left' ? 1 : -1);
      const angle = (Math.PI / 2) * d.openPct * rotSign;

      if (d.openPct <= 0.001) {
        ctx.fillStyle = fill;
        ctx.strokeStyle = stroke;
        ctx.beginPath();
        ctx.rect(-w / 2, -openingH / 2, w, openingH);
        ctx.fill();
        ctx.stroke();
      } else {
        const leafLen = w;
        const leafThick = Math.max(6, openingH * 0.92);

        ctx.save();
        ctx.translate(hingeX, 0);
        ctx.rotate(angle);

        ctx.fillStyle = fill;
        ctx.strokeStyle = stroke;

        const x0 = (hingeSide === 'left') ? 0 : -leafLen;
        ctx.beginPath();
        ctx.rect(x0, -leafThick / 2, leafLen, leafThick);
        ctx.fill();
        ctx.stroke();

        ctx.fillStyle = 'rgba(0,0,0,0.22)';
        ctx.beginPath();
        ctx.arc(0, 0, 2.2, 0, Math.PI * 2);
        ctx.fill();

        ctx.restore();
      }
    } else {
      const wv = normalizeWindowParams(opening, orient);

      if (wv.openPct <= 0.001) {
        ctx.fillStyle = fill;
        ctx.strokeStyle = stroke;

        ctx.beginPath();
        ctx.rect(-w / 2, -openingH / 2, w, openingH);
        ctx.fill();
        ctx.stroke();

        ctx.strokeStyle = 'rgba(0,0,0,0.25)';
        ctx.beginPath();
        ctx.moveTo(0, -openingH / 2 + 2);
        ctx.lineTo(0, openingH / 2 - 2);
        ctx.stroke();
      } else {
        const desiredY = (orient === 'h')
          ? (wv.opensTo === 'S' ? 1 : -1)
          : (wv.opensTo === 'W' ? 1 : -1);

        const maxAngle = (Math.PI / 3);

        const leafLen = w / 2;
        const leafThick = Math.max(5, openingH * 0.88);

        ctx.fillStyle = fill;
        ctx.strokeStyle = stroke;

        {
          const hingeX = -w / 2;
          const rotSign = desiredY * 1;
          const angle = maxAngle * wv.openPct * rotSign;

          ctx.save();
          ctx.translate(hingeX, 0);
          ctx.rotate(angle);
          ctx.beginPath();
          ctx.rect(0, -leafThick / 2, leafLen, leafThick);
          ctx.fill();
          ctx.stroke();

          ctx.fillStyle = 'rgba(0,0,0,0.18)';
          ctx.beginPath();
          ctx.arc(0, 0, 2.1, 0, Math.PI * 2);
          ctx.fill();
          ctx.restore();

          ctx.fillStyle = fill;
          ctx.strokeStyle = stroke;
        }

        {
          const hingeX = w / 2;
          const rotSign = desiredY * -1;
          const angle = maxAngle * wv.openPct * rotSign;

          ctx.save();
          ctx.translate(hingeX, 0);
          ctx.rotate(angle);
          ctx.beginPath();
          ctx.rect(-leafLen, -leafThick / 2, leafLen, leafThick);
          ctx.fill();
          ctx.stroke();

          ctx.fillStyle = 'rgba(0,0,0,0.18)';
          ctx.beginPath();
          ctx.arc(0, 0, 2.1, 0, Math.PI * 2);
          ctx.fill();
          ctx.restore();
        }
      }
    }

    ctx.restore();
  }

  function isRenderableOpening(opening, roomMeta, renderableRoomIds) {
    const kind = String(opening && opening.kind ? opening.kind : 'door').toLowerCase();
    if (kind === 'portal' || kind === 'connector') return false;
    const { a, b } = openingTouchingRoomIds(opening, roomMeta);
    return (a && renderableRoomIds.has(a)) || (b && renderableRoomIds.has(b));
  }

  // =====================================================================================
  // OBJECTS (fallback symbols)
  // =====================================================================================
  function getObjectShiftPx(o) {
    if (!o) return { dx: 0, dy: 0 };

    const hexFlatX = 2 * GRID.size;  // flat-to-flat horizontally
    const hexFlatY = rowStep();      // flat-to-flat vertically

    let dxHex = 0;
    let dyHexNorth = 0;

    if (Number.isFinite(o.dxHex)) dxHex += Number(o.dxHex);
    if (Number.isFinite(o.dyHex)) dyHexNorth += Number(o.dyHex);

    if (o.offsetHex && typeof o.offsetHex === 'object') {
      const oh = o.offsetHex;
      if (Number.isFinite(oh.e)) dxHex += Number(oh.e);
      if (Number.isFinite(oh.w)) dxHex -= Number(oh.w);
      if (Number.isFinite(oh.n)) dyHexNorth += Number(oh.n);
      if (Number.isFinite(oh.s)) dyHexNorth -= Number(oh.s);
    }

    if (typeof o.shift === 'string' && o.shift.trim()) {
      const parts = o.shift.trim().toUpperCase().split(/[ ,]+/).filter(Boolean);
      for (const part of parts) {
        const m = part.match(/^([NSEW])(-?[0-9]+(?:[.][0-9]+)?)$/);
        if (!m) continue;
        const dir = m[1];
        const amt = Number(m[2]);
        if (!Number.isFinite(amt)) continue;
        if (dir === 'E') dxHex += amt;
        else if (dir === 'W') dxHex -= amt;
        else if (dir === 'N') dyHexNorth += amt;
        else if (dir === 'S') dyHexNorth -= amt;
      }
    }

    return {
      dx: dxHex * hexFlatX,
      dy: -dyHexNorth * hexFlatY, // screen Y increases downward
    };
  }

  function getObjectOccupiedHexes(o) {
    if (!o) return [];
    if (Array.isArray(o.hexes) && o.hexes.length) return o.hexes.slice();
    if (typeof o.hex === 'string' && o.hex.trim()) return [o.hex.trim()];
    return [];
  }

  function getScreenPointsForHexes(hexes) {
    const pts = [];
    for (const hx of (hexes || [])) {
      const p = parseHex(hx);
      if (!p) continue;
      pts.push(worldToScreen(hexCenterWorld(p.col, p.row)));
    }
    return pts;
  }

  function centroidOfPoints(pts) {
    if (!pts.length) return { x: 0, y: 0 };
    let sx = 0;
    let sy = 0;
    for (const p of pts) { sx += p.x; sy += p.y; }
    return { x: sx / pts.length, y: sy / pts.length };
  }

  function boundsOfPoints(pts) {
    if (!pts.length) return { minX: 0, minY: 0, maxX: 0, maxY: 0 };
    let minX = pts[0].x, maxX = pts[0].x, minY = pts[0].y, maxY = pts[0].y;
    for (const p of pts) {
      minX = Math.min(minX, p.x);
      maxX = Math.max(maxX, p.x);
      minY = Math.min(minY, p.y);
      maxY = Math.max(maxY, p.y);
    }
    return { minX, minY, maxX, maxY };
  }

  function expandBounds(b, pad) {
    return { minX: b.minX - pad, minY: b.minY - pad, maxX: b.maxX + pad, maxY: b.maxY + pad };
  }

  function facingToAngleRad(facing) {
    // 6-direction chair facing: N, NE, SE, S, SW, NW (60° steps).
    const f = String(facing || 'NE').trim().toUpperCase();

    switch (f) {
      case 'N':  return -Math.PI / 2;
      case 'NE': return -Math.PI / 6;
      case 'SE': return  Math.PI / 6;
      case 'S':  return  Math.PI / 2;
      case 'SW': return  5 * Math.PI / 6;
      case 'NW': return -5 * Math.PI / 6;
      case 'E':  return 0;
      case 'W':  return Math.PI;
      default:   return -Math.PI / 6;
    }
  }

  function objectShouldDraw(o, roomMeta) {
    if (!RENDER_FOG || !RENDER_FOG.enabled) return true;

    const occ = getObjectOccupiedHexes(o);
    if (!occ.length) return true;

    for (const hx of occ) {
      let p;
      try { p = parseHexId(hx); } catch { return true; }

      const rid = pickMostSpecificRoomIdAt(roomMeta, p.col, p.row);
      if (!rid) return true;

      if (RENDER_FOG.visible.has(rid) || RENDER_FOG.explored.has(rid)) return true;
    }

    return false;
  }

  function drawBedSquare(targetCtx, rect, opts = {}) {
    // The basic pack uses a simple fill; fancy pack may override PACK.drawBed.
    PACK.drawBed(targetCtx, rect, opts);

    // Pillows remain in core (so beds still read as "beds" even without fancy pack).
    const head = String(opts.head || 'W').toUpperCase();

    const inset = Math.max(3, Math.min(rect.w, rect.h) * 0.08);
    const pillowThick = Math.max(6, (head === 'W' || head === 'E') ? rect.w * 0.22 : rect.h * 0.22);

    targetCtx.fillStyle = opts.pillowFill ?? '#7a4f22';
    targetCtx.strokeStyle = opts.stroke ?? 'rgba(0,0,0,0.55)';
    targetCtx.lineWidth = 1;

    if (opts.double) {
      const gap = Math.max(3, Math.min(rect.w, rect.h) * 0.06);

      if (head === 'W' || head === 'E') {
        const ph = (rect.h - inset * 2 - gap) / 2;
        const pw = pillowThick;
        const px = (head === 'W') ? (rect.x + inset) : (rect.x + rect.w - inset - pw);
        const py1 = rect.y + inset;
        const py2 = rect.y + inset + ph + gap;
        targetCtx.fillRect(px, py1, pw, ph);
        targetCtx.fillRect(px, py2, pw, ph);
        targetCtx.strokeRect(px + 0.75, py1 + 0.75, Math.max(0, pw - 1.5), Math.max(0, ph - 1.5));
        targetCtx.strokeRect(px + 0.75, py2 + 0.75, Math.max(0, pw - 1.5), Math.max(0, ph - 1.5));
      } else {
        const pw = (rect.w - inset * 2 - gap) / 2;
        const ph = pillowThick;
        const py = (head === 'N') ? (rect.y + inset) : (rect.y + rect.h - inset - ph);
        const px1 = rect.x + inset;
        const px2 = rect.x + inset + pw + gap;
        targetCtx.fillRect(px1, py, pw, ph);
        targetCtx.fillRect(px2, py, pw, ph);
        targetCtx.strokeRect(px1 + 0.75, py + 0.75, Math.max(0, pw - 1.5), Math.max(0, ph - 1.5));
        targetCtx.strokeRect(px2 + 0.75, py + 0.75, Math.max(0, pw - 1.5), Math.max(0, ph - 1.5));
      }
    } else {
      if (head === 'W' || head === 'E') {
        const pw = pillowThick;
        const ph = rect.h - inset * 2;
        const px = (head === 'W') ? (rect.x + inset) : (rect.x + rect.w - inset - pw);
        const py = rect.y + inset;
        targetCtx.fillRect(px, py, pw, ph);
        targetCtx.strokeRect(px + 0.75, py + 0.75, Math.max(0, pw - 1.5), Math.max(0, ph - 1.5));
      } else {
        const pw = rect.w - inset * 2;
        const ph = pillowThick;
        const px = rect.x + inset;
        const py = (head === 'N') ? (rect.y + inset) : (rect.y + rect.h - inset - ph);
        targetCtx.fillRect(px, py, pw, ph);
        targetCtx.strokeRect(px + 0.75, py + 0.75, Math.max(0, pw - 1.5), Math.max(0, ph - 1.5));
      }
    }
  }

  function drawObject(o) {
    if (!o) return;

    // Optional sprite override (fancy pack can implement this).
    if (PACK && typeof PACK.drawObjectSprite === 'function') {
      try {
        if (PACK.drawObjectSprite(ctx, o, PACK.core)) return;
      } catch (e) {
        console.warn('[Battlemat] drawObjectSprite failed:', e);
      }
    }

    const kind = String(o.kind || '').toLowerCase();

    const occHexes = getObjectOccupiedHexes(o);
    if (!occHexes.length) return;

    // Tables (fallback shapes). Uses occHexes for footprint; does NOT require o.hex.
    if (kind === 'table.round' || kind === 'table.square' || kind === 'table.rect') {
      const occCenters = getScreenPointsForHexes(occHexes);
      const baseCenter = centroidOfPoints(occCenters);
      const sh = getObjectShiftPx(o);
      const center = { x: baseCenter.x + sh.dx, y: baseCenter.y + sh.dy };

      const b0 = boundsOfPoints(occCenters);
      const pad = GRID.size * 0.95;
      const b = expandBounds(b0, pad);
      const footRect = { x: b.minX, y: b.minY, w: (b.maxX - b.minX), h: (b.maxY - b.minY) };

      const style = o.style || {};

      if (kind === 'table.round') {
        const r = Math.max(8, Math.min(footRect.w, footRect.h) * 0.42);
        PACK.drawTableRound(ctx, center, r, style);
        return;
      }

      if (kind === 'table.square') {
        const side = Math.max(10, Math.min(footRect.w, footRect.h) * 0.70);
        PACK.drawTableRect(ctx, { x: center.x - side / 2, y: center.y - side / 2, w: side, h: side }, style);
        return;
      }

      // table.rect
      const inset = GRID.size * 0.35;
      const r = {
        x: footRect.x + inset,
        y: footRect.y + inset,
        w: Math.max(6, footRect.w - inset * 2),
        h: Math.max(6, footRect.h - inset * 2),
      };
      PACK.drawTableRect(ctx, r, style);
      return;
    }

    // Chair.
    if (kind === 'chair') {
      let p;
      try { p = parseHexId(o.hex); } catch { return; }

      const cS0 = worldToScreen(hexCenterWorld(p.col, p.row));
      const sh = getObjectShiftPx(o);
      const cS = { x: cS0.x + sh.dx, y: cS0.y + sh.dy };

      const facing = o.facing ?? o.dir ?? o.direction ?? 'E';
      const style = o.style || {};

      // The PACK can choose how fancy chairs are.
      if (PACK.drawChair) PACK.drawChair(ctx, cS, facing, style);
      else {
        // Safety fallback.
        ctx.save();
        ctx.fillStyle = '#8a5a2b';
        ctx.beginPath();
        ctx.arc(cS.x, cS.y, 12, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      }
      return;
    }

    if (kind !== 'bed.single' && kind !== 'bed.double') return;

    let p;
    try { p = parseHexId(o.hex); } catch { return; }

    const cS0 = worldToScreen(hexCenterWorld(p.col, p.row));

    const sh = getObjectShiftPx(o);
    const cS = { x: cS0.x + sh.dx, y: cS0.y + sh.dy };

    const hexFlatX = 2 * GRID.size;
    const hexFlatY = rowStep();

    const lengthFactor = 1.25;
    const widthFactor = (kind === 'bed.double') ? 1.25 : 0.75;

    const orient = (o.orientation === 'v' || o.orientation === 'h') ? o.orientation : 'h';

    const lenPx = (orient === 'h') ? (hexFlatX * lengthFactor) : (hexFlatY * lengthFactor);
    const widPx = (orient === 'h') ? (hexFlatY * widthFactor) : (hexFlatX * widthFactor);

    const rect = {
      x: cS.x - lenPx / 2,
      y: cS.y - widPx / 2,
      w: lenPx,
      h: widPx,
    };

    drawBedSquare(ctx, rect, {
      head: o.head || 'W',
      double: (kind === 'bed.double'),
      mattressFill: '#9a7b4b',
      pillowFill: '#a0733c',
      stroke: 'rgba(0,0,0,0.60)'
    });
  }

  function drawObjects(objects, rooms) {
    const list = Array.isArray(objects) ? objects : [];
    const roomMeta = buildRoomMeta(rooms);

    for (const o of list) {
      if (!objectShouldDraw(o, roomMeta)) continue;
      drawObject(o);
    }
  }

  function drawFogRoomOverlays(rooms) {
    if (!RENDER_FOG || !RENDER_FOG.enabled) return;

    const revealWalls = !!RENDER_FOG.revealWallsInUnseenRooms;

    ctx.save();

    for (const r of (Array.isArray(rooms) ? rooms : [])) {
      if (!r || !r.id) continue;

      const id = String(r.id);

      // Never overlay the base fog-floor rooms.
      const fk = r && r.floor && r.floor.kind ? String(r.floor.kind).toLowerCase() : '';
      if (fk === 'fog') continue;

      const isVisible = RENDER_FOG.visible.has(id);
      const isExplored = RENDER_FOG.explored.has(id);

      if (isVisible) continue;
      if (!revealWalls && !isExplored) continue; // preserve old behavior unless reveal-walls mode is enabled

      const alpha = isExplored ? clamp(RENDER_FOG.exploredAlpha, 0, 1) : clamp(RENDER_FOG.unseenAlpha, 0, 1);
      const fill = isExplored ? COLORS.fogExplored : COLORS.fogUnseen;

      const box = roomToWallBox(r);
      const f = roomFloorRectWorld(r, box);
      const f1 = worldToScreen({ x: f.x1, y: f.y1 });
      const f2 = worldToScreen({ x: f.x2, y: f.y2 });

      const rect = { x: f1.x, y: f1.y, w: (f2.x - f1.x), h: (f2.y - f1.y) };
      if (rect.w <= 0 || rect.h <= 0) continue;

      ctx.globalAlpha = alpha;
      ctx.fillStyle = fill;
      ctx.fillRect(rect.x, rect.y, rect.w, rect.h);
    }

    ctx.restore();
  }

  function applyFogToUnderlayRect(rect, roomId) {
    if (!RENDER_FOG || !RENDER_FOG.enabled) return;
    if (!rect || rect.w <= 0 || rect.h <= 0) return;

    const id = roomId ? String(roomId) : '';
    const isVisible = id && RENDER_FOG.visible.has(id);
    const isExplored = id && RENDER_FOG.explored.has(id);

    if (isVisible) return;

    ctx.save();
    if (isExplored) {
      ctx.globalAlpha = clamp(RENDER_FOG.exploredAlpha, 0, 1);
      ctx.fillStyle = COLORS.fogExplored;
    } else {
      ctx.globalAlpha = clamp(RENDER_FOG.unseenAlpha, 0, 1);
      ctx.fillStyle = COLORS.fogUnseen;
    }
    ctx.fillRect(rect.x, rect.y, rect.w, rect.h);
    ctx.restore();
  }

  // =====================================================================================
  // TOKENS
  // =====================================================================================
  function drawToken(t) {
    // Optional sprite override (fancy pack can implement this).
    if (PACK && typeof PACK.drawTokenSprite === 'function') {
      try {
        if (PACK.drawTokenSprite(ctx, t, PACK.core)) return;
      } catch (e) {
        console.warn('[Battlemat] drawTokenSprite failed:', e);
      }
    }

    const p = parseHexId(t.hex);
    const cS = worldToScreen(hexCenterWorld(p.col, p.row));

    const isEnemy = String(t.side || '').toUpperCase().indexOf('EN') >= 0;
    const r = GRID.size * 0.42;

    ctx.beginPath();
    ctx.arc(cS.x, cS.y, r, 0, Math.PI * 2);
    ctx.fillStyle = isEnemy ? COLORS.tokenEnemy : COLORS.tokenHero;
    ctx.fill();

    ctx.lineWidth = 2;
    ctx.strokeStyle = 'rgba(0,0,0,0.2)';
    ctx.stroke();

    const label = (t.label != null) ? t.label : (t.name ? t.name[0] : '?');
    ctx.font = 'bold 14px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillStyle = isEnemy ? COLORS.tokenTextLight : 'rgba(255,255,255,0.95)';
    ctx.fillText(label, cS.x, cS.y);

    if (t.name) {
      ctx.font = '12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
      ctx.fillStyle = COLORS.tokenTextDark;
      ctx.fillText(t.name, cS.x, cS.y + r + 14);
    }
  }

  // =====================================================================================
  // RENDER PIPELINE
  // =====================================================================================
  function clear() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = '#fff';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
  }

  function redraw() {
    const state = getState();

    if (!canvas.width || !canvas.height || !wallCanvas.width || !wallCanvas.height) {
      console.warn('[Battlemat] redraw skipped: canvas not sized yet');
      return;
    }

    populateCenterOn(state);
    syncFogToggle(state);

    if (VIEW.followTokenId) {
      const tokens = Array.isArray(state.tokens) ? state.tokens : [];
      const t = tokens.find(x => x.id === VIEW.followTokenId);
      if (t && t.hex) {
        try {
          const p = parseHexId(t.hex);
          VIEW.camera.col = p.col;
          VIEW.camera.row = p.row;
        } catch {
          VIEW.followTokenId = null;
          const sel = document.getElementById('centerOn');
          if (sel) sel.value = '';
        }
      }
    }

    clear();

    const rooms = Array.isArray(state.rooms) ? state.rooms : [];
    const openings = Array.isArray(state.openings) ? state.openings : [];
    const objects = Array.isArray(state.objects) ? state.objects : [];
    const tokens = Array.isArray(state.tokens) ? state.tokens : [];

    // Compute Fog of War sets for this frame.
    RENDER_FOG = computeRenderFog(state, rooms, openings);

    // When fog is enabled:
    // - Visible rooms are drawn normally.
    // - Explored-but-not-visible rooms are drawn, then get a "remembered" overlay.
    // - Unseen rooms:
    //    - If fog.revealWallsInUnseenRooms is true: draw them, then cover floors with dark fog (walls stay visible).
    //    - If false: do not draw them at all (the optional fog-floor base rooms can cover the area).
    let roomsToDraw = rooms;
    let openingsToDraw = openings;
    let renderableRoomIds = null;

    if (RENDER_FOG && RENDER_FOG.enabled) {
      const roomMeta = buildRoomMeta(rooms);

      const baseFogRoomIds = new Set();
      for (const r of rooms) {
        const k = r && r.floor && r.floor.kind ? String(r.floor.kind).toLowerCase() : '';
        if (k === 'fog' && r && r.id) baseFogRoomIds.add(String(r.id));
      }

      const revealWalls = !!RENDER_FOG.revealWallsInUnseenRooms;

      if (revealWalls) {
        // Draw all real rooms (skip fog-floor helpers), then overlay fog per-room.
        roomsToDraw = rooms.filter(r => {
          const k = r && r.floor && r.floor.kind ? String(r.floor.kind).toLowerCase() : '';
          return k !== 'fog';
        });

        openingsToDraw = openings.slice();

        // "Renderable" is used mainly for sizing/underlay choices; explored is the safe set.
        renderableRoomIds = new Set([...RENDER_FOG.explored]);
      } else {
        // Old behavior: only render explored rooms (plus base fog rooms).
        renderableRoomIds = new Set([...RENDER_FOG.explored]);

        roomsToDraw = rooms.filter(r => {
          const id = r && r.id ? String(r.id) : '';
          if (!id) return true;
          if (baseFogRoomIds.has(id)) return true;
          return renderableRoomIds.has(id);
        });

        openingsToDraw = openings.filter(o => isRenderableOpening(o, roomMeta, renderableRoomIds));
      }
    }

    // Floors.
    drawFloorsLayered(roomsToDraw);

    // Walls are drawn only for rooms that contribute geometry this frame.
    const revealWallsMode = !!(RENDER_FOG && RENDER_FOG.enabled && RENDER_FOG.revealWallsInUnseenRooms);

    const roomsForWalls = revealWallsMode
      ? rooms.filter(r => roomHasWalls(r))
      : (RENDER_FOG && RENDER_FOG.enabled)
        ? roomsToDraw.filter(r => {
            const k = r && r.floor && r.floor.kind ? String(r.floor.kind).toLowerCase() : '';
            if (k === 'fog') return roomHasWalls(r);
            return true;
          })
        : roomsToDraw;

    const wallSegs = buildWallSegments(roomsForWalls);

    // Floor underlays for openings.
    // - Thresholds: always paint under the wall knockout (so hallway junctions read continuous).
    // - Doors: paint floor underlay for BOTH open and closed doors.
    const roomMetaAll = buildRoomMeta(rooms);
    for (const o of openingsToDraw) {
      paintThresholdUnderlay(o, rooms, wallSegs);
      paintDoorUnderlay(o, rooms, wallSegs, roomMetaAll, (RENDER_FOG && RENDER_FOG.enabled) ? RENDER_FOG.explored : renderableRoomIds);
    }

    // Build walls into offscreen.
    wallCtx.save();
    wallCtx.setTransform(1, 0, 0, 1, 0, 0);
    wallCtx.clearRect(0, 0, wallCanvas.width, wallCanvas.height);
    wallCtx.restore();

    wallCtx.setTransform(VIEW.dpr, 0, 0, VIEW.dpr, 0, 0);

    for (const r of roomsForWalls) drawRoomWalls(wallCtx, r);

    // Punch openings out.
    wallCtx.save();
    wallCtx.globalCompositeOperation = 'destination-out';
    wallCtx.fillStyle = '#000';

    const knockoutAlphaFor = (o) => {
      const k = String(o && o.kind ? o.kind : 'door').toLowerCase();
      if (k === 'portal' || k === 'connector') return 0;
      if (k === 'threshold') return 1;
      return (k === 'window') ? 0.25 : 1;
    };

    for (const o of openingsToDraw) {
      wallCtx.globalAlpha = knockoutAlphaFor(o);
      cutOpeningHole(wallCtx, o, wallSegs, roomsForWalls);
    }

    wallCtx.restore();

    // Composite walls.
    ctx.save();
    ctx.setTransform(1, 0, 0, 1, 0, 0);
    ctx.drawImage(wallCanvas, 0, 0);
    ctx.restore();

    ctx.setTransform(VIEW.dpr, 0, 0, VIEW.dpr, 0, 0);

    // Visible openings.
    for (const o of openingsToDraw) drawOpening(o, wallSegs);

    // Objects.
    drawObjects(objects, rooms);

    // Fog overlays (unseen + remembered/explored).
    drawFogRoomOverlays(rooms);

    // Tokens.
    for (const t of tokens) {
      if (shouldDrawToken(t, rooms)) drawToken(t);
    }

    // Grid.
    drawGrid();

    updateSidebar(state);
  }

  // =====================================================================================
  // UI / SIDEBAR
  // =====================================================================================
  function escapeHtml(s) {
    return String(s)
      .replaceAll('&', '&amp;')
      .replaceAll('<', '&lt;')
      .replaceAll('>', '&gt;')
      .replaceAll('"', '&quot;')
      .replaceAll("'", '&#39;');
  }

  function updateSidebar(state) {
    const kvs = document.getElementById('kvs');
    if (!kvs) return;

    const meta = state.meta || {};
    const rooms = Array.isArray(state.rooms) ? state.rooms.length : 0;
    const openings = Array.isArray(state.openings) ? state.openings.length : 0;
    const objects = Array.isArray(state.objects) ? state.objects.length : 0;
    const tokens = Array.isArray(state.tokens) ? state.tokens.length : 0;

    const camHex = (state.view && state.view.camera_hex) ? state.view.camera_hex : hexId(VIEW.camera.col, VIEW.camera.row);
    const round = Number(meta.round != null ? meta.round : 1);

    const flatToFlatPx = rowStep();

    const fog = normalizeFog(state);
    const fogLabel = fog.enabled
      ? ('ON (' + fog.visibleRoomIds.length + ' vis / ' + fog.exploredRoomIds.length + ' exp)')
      : 'off';

    const lines = [
      ['Round', round],
      ['Camera', camHex],
      ['Rooms', rooms],
      ['Openings', openings],
      ['Objects', objects],
      ['Tokens', tokens],
      ['Fog', fogLabel],
      ['Fog maxDepth', String(fog.maxDepth)],
      ['Hex px (flat↕︎)', flatToFlatPx.toFixed(1)],
      ['Pack', PACK.enabled ? 'Fancy' : 'Basic'],
    ];

    kvs.innerHTML = lines
      .map(([k, v]) => '<div>' + escapeHtml(k) + '</div><div style="color:var(--text); text-align:right;">' + escapeHtml(v) + '</div>')
      .join('');
  }

  function syncFogToggle(state) {
    const el = document.getElementById('fogToggle');
    if (!el) return;
    const enabled = !!(state && state.fog && state.fog.enabled);
    if (el.checked !== enabled) el.checked = enabled;
  }

  function populateCenterOn(state) {
    const sel = document.getElementById('centerOn');
    if (!sel) return;

    const players = getPlayerTokens(state);
    const wanted = VIEW.followTokenId || '';

    const opts = ['<option value="">None</option>'];
    for (const t of players) {
      const label = t.name ? t.name : t.id;
      opts.push('<option value="' + escapeHtml(t.id) + '">' + escapeHtml(label) + '</option>');
    }
    sel.innerHTML = opts.join('');

    sel.value = players.some(t => t.id === wanted) ? wanted : '';
    if (sel.value === '') VIEW.followTokenId = null;
  }

  // =====================================================================================
  // CONTROLS
  // =====================================================================================
  function pan(dc, dr) {
    if (VIEW.followTokenId) {
      VIEW.followTokenId = null;
      const sel = document.getElementById('centerOn');
      if (sel) sel.value = '';
    }
    VIEW.camera.col += dc;
    VIEW.camera.row += dr;
    redraw();
  }

  function setCameraToHex(hex, opts = {}) {
    const manual = (opts.manual !== false);
    const p = parseHexId(hex);
    VIEW.camera.col = p.col;
    VIEW.camera.row = p.row;

    if (manual) {
      VIEW.followTokenId = null;
      const sel = document.getElementById('centerOn');
      if (sel) sel.value = '';
    }

    redraw();
  }

  function wireUI() {
    const req = (id) => {
      const el = document.getElementById(id);
      if (!el) console.warn('[Battlemat] missing control #' + id);
      return el;
    };

    const btnLeft = req('btnLeft');
    const btnRight = req('btnRight');
    const btnUp = req('btnUp');
    const btnDown = req('btnDown');
    const btnRedraw = req('btnRedraw');
    const btnJump = req('btnJump');
    const jumpHex = req('jumpHex');
    const centerOn = req('centerOn');
    const floorKind = document.getElementById('floorKind');
    const fogToggle = document.getElementById('fogToggle');

    if (btnLeft) btnLeft.addEventListener('click', () => pan(-PAN_STEP, 0));
    if (btnRight) btnRight.addEventListener('click', () => pan(PAN_STEP, 0));
    if (btnUp) btnUp.addEventListener('click', () => pan(0, PAN_STEP));
    if (btnDown) btnDown.addEventListener('click', () => pan(0, -PAN_STEP));

    if (btnRedraw) btnRedraw.addEventListener('click', redraw);

    if (centerOn) {
      centerOn.addEventListener('change', (e) => {
        const id = String(e.target.value || '');
        VIEW.followTokenId = id || null;

        if (VIEW.followTokenId) {
          const state = getState();
          const tokens = Array.isArray(state.tokens) ? state.tokens : [];
          const t = tokens.find(x => x.id === VIEW.followTokenId);
          if (t && t.hex) {
            try { setCameraToHex(t.hex, { manual: false }); } catch { /* ignore */ }
          }
        } else {
          redraw();
        }
      });
    }

    if (btnJump) {
      btnJump.addEventListener('click', () => {
        const v = (jumpHex && jumpHex.value) ? jumpHex.value.trim() : '';
        if (!v) return;
        try { setCameraToHex(v); } catch (e) { console.warn(e); }
      });
    }

    if (jumpHex && btnJump) {
      jumpHex.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') btnJump.click();
      });
    }

    if (floorKind) {
      floorKind.addEventListener('change', (e) => {
        const kind = String(e.target.value || '');
        RENDER_OVERRIDES.floorKind = kind;
        redraw();
      });
    }

    if (fogToggle) {
      fogToggle.addEventListener('change', (e) => {
        const state = getState();
        if (!state.fog) state.fog = {};
        state.fog.enabled = !!e.target.checked;
        redraw();
      });
    }

    window.addEventListener('keydown', (e) => {
      if (e.key === 'ArrowLeft') { e.preventDefault(); pan(-PAN_STEP, 0); }
      if (e.key === 'ArrowRight') { e.preventDefault(); pan(PAN_STEP, 0); }
      if (e.key === 'ArrowUp') { e.preventDefault(); pan(0, PAN_STEP); }
      if (e.key === 'ArrowDown') { e.preventDefault(); pan(0, -PAN_STEP); }
    });
  }

  function followCameraTick() {
    const state = getState();
    if (VIEW.followTokenId) {
      const tokens = Array.isArray(state.tokens) ? state.tokens : [];
      const t = tokens.find(x => x.id === VIEW.followTokenId);
      if (t && t.hex) {
        try {
          const p = parseHexId(t.hex);
          if (p.col !== VIEW.camera.col || p.row !== VIEW.camera.row) {
            VIEW.camera.col = p.col;
            VIEW.camera.row = p.row;
            redraw();
          }
        } catch {
          VIEW.followTokenId = null;
          const sel = document.getElementById('centerOn');
          if (sel) sel.value = '';
        }
      } else {
        VIEW.followTokenId = null;
        const sel = document.getElementById('centerOn');
        if (sel) sel.value = '';
      }
    }
    requestAnimationFrame(followCameraTick);
  }

  function resize(opts = {}) {
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    VIEW.dpr = dpr;

    const rect = canvas.getBoundingClientRect();

    canvas.width = Math.floor(rect.width * dpr);
    canvas.height = Math.floor(rect.height * dpr);

    wallCanvas.width = canvas.width;
    wallCanvas.height = canvas.height;

    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    wallCtx.setTransform(dpr, 0, 0, dpr, 0, 0);

    VIEW.anchor.x = rect.width / 2;
    VIEW.anchor.y = rect.height / 2;

    // If called from init() we may want to defer the very first paint.
    if (!opts.skipRedraw) redraw();
  }

  // =====================================================================================
  // SEED HELPERS (work even when fancy pack is removed)
  // =====================================================================================
  function simpleHash32(str) {
    const s = String(str || '');
    let h = 2166136261 >>> 0;
    for (let i = 0; i < s.length; i++) {
      h ^= s.charCodeAt(i);
      h = Math.imul(h, 16777619);
    }
    return h >>> 0;
  }

  function seedForRoom(room, tag) {
    const key = String(tag || '') + ':' + (room && (room.id || JSON.stringify(room.corners || [])));
    // If fancy pack installed, prefer its stable hasher.
    if (typeof PACK.hashStringToSeed === 'function') return PACK.hashStringToSeed(key);
    return simpleHash32(key);
  }

  // =====================================================================================
  // SELF-TESTS
  // =====================================================================================
  function runSelfTests() {
    try {
      if (typeof $1 === 'undefined') throw new Error('$1 defensive binding missing');

      const checkRoundTrip = (letters) => {
        const col = lettersToCol(letters);
        const back = colToLetters(col);
        if (back !== letters) throw new Error('Roundtrip failed: ' + letters + ' -> ' + col + ' -> ' + back);
      };

      checkRoundTrip('A');
      checkRoundTrip('Z');
      checkRoundTrip('AA');
      checkRoundTrip('DZ');

      const p = parseHexId('AA27');
      if (hexId(p.col, p.row) !== 'AA27') throw new Error('parseHexId/hexId mismatch for AA27');

      // parseHex() should be non-throwing.
      {
        const ok = parseHex('B12');
        if (!ok || ok.col !== lettersToCol('B') || ok.row !== 11) throw new Error('parseHex should parse valid ids');
        const bad = parseHex('not-a-hex');
        if (bad !== null) throw new Error('parseHex should return null for invalid ids');
      }

      // facingToAngleRad sanity.
      {
        const eps = 1e-9;
        const near = (a, b) => Math.abs(a - b) < eps;

        if (!near(facingToAngleRad('N'), -Math.PI / 2)) throw new Error('chair angle N');
        if (!near(facingToAngleRad('NE'), -Math.PI / 6)) throw new Error('chair angle NE');
        if (!near(facingToAngleRad('SE'),  Math.PI / 6)) throw new Error('chair angle SE');
        if (!near(facingToAngleRad('S'),   Math.PI / 2)) throw new Error('chair angle S');
        if (!near(facingToAngleRad('SW'),  5 * Math.PI / 6)) throw new Error('chair angle SW');
        if (!near(facingToAngleRad('NW'), -5 * Math.PI / 6)) throw new Error('chair angle NW');
      }

      console.log('[Battlemat] self-tests: OK');
    } catch (e) {
      console.warn('[Battlemat] self-tests: FAIL', e);
    }
  }

  // =====================================================================================
  // INIT
  // =====================================================================================
  function init() {
    const state = getState();
    if (state.view && state.view.camera_hex) {
      try {
        const p = parseHexId(state.view.camera_hex);
        VIEW.camera.col = p.col;
        VIEW.camera.row = p.row;
      } catch {
        // ignore
      }
    }

    // Ensure the floor selector starts in "Mixed" (no override) mode.
    {
      const fk = document.getElementById('floorKind');
      if (fk) fk.value = '';
      RENDER_OVERRIDES.floorKind = '';
    }

    wireUI();

    window.addEventListener('resize', resize);

    // First-load: size canvases, then do a double-refresh on the next frames.
    // This avoids the “basic pack first frame” issue and lets any late-loading assets settle.
    resize({ skipRedraw: true });

    runSelfTests();

    requestAnimationFrame(() => {
      redraw();
      requestAnimationFrame(redraw);
    });

    requestAnimationFrame(followCameraTick);
  }

  // =====================================================================================
  // OPTIONAL FANCY PACK (SAFE TO DELETE)
  // -------------------------------------------------------------------------------------
  // This block overwrites PACK.* with procedural textures and nicer symbols.
  // Remove it and the battlemat still runs (with simple flat fills).
  // =====================================================================================

  (function installFancyPack(PACK) {
    // Mark pack as enabled immediately so first draw uses fancy fills.
    PACK.enabled = true;
    // ---- Deterministic RNG / hashing ----
    function mulberry32(seed) {
      let a = (seed >>> 0) || 0;
      return function() {
        a |= 0;
        a = (a + 0x6D2B79F5) | 0;
        let t = Math.imul(a ^ (a >>> 15), 1 | a);
        t = (t + Math.imul(t ^ (t >>> 7), 61 | t)) ^ t;
        return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
      };
    }

    function hashStringToSeed(s) {
      const str = String(s || '');
      let h = 2166136261 >>> 0;
      for (let i = 0; i < str.length; i++) {
        h ^= str.charCodeAt(i);
        h = Math.imul(h, 16777619);
      }
      return h >>> 0;
    }

    function hexToRgbStrict(hex, fallback = { r: 193, g: 146, b: 86 }) {
      const m = String(hex).trim().match(/^#?([0-9a-fA-F]{6})$/);
      if (!m) return fallback;
      const n = parseInt(m[1], 16);
      return { r: (n >> 16) & 255, g: (n >> 8) & 255, b: n & 255 };
    }

    function shadeRgba(hex, amt, alpha) {
      const rgb = hexToRgbStrict(hex);
      const r = clamp(Math.round(rgb.r + 255 * amt), 0, 255);
      const g = clamp(Math.round(rgb.g + 255 * amt), 0, 255);
      const b = clamp(Math.round(rgb.b + 255 * amt), 0, 255);
      return 'rgba(' + r + ',' + g + ',' + b + ',' + alpha + ')';
    }

    PACK.mulberry32 = mulberry32;
    PACK.hashStringToSeed = hashStringToSeed;
    PACK.shadeRgba = shadeRgba;
    PACK.hexToRgbStrict = hexToRgbStrict;

    // ---- Brick walls (WORLD-anchored) ----
    function fillBrickRectScreenOn(targetCtx, rect, color, worldX = 0, worldY = 0) {
      const brickW = 9;
      const brickH = 4;
      const gap = 1.2;
      const radius = 1.5;
      const strokeW = 0.8;

      const pitchX = brickW + gap;
      const pitchY = brickH + gap;

      const hexToRgb = (hex) => {
        const m = String(hex).trim().match(/^#?([0-9a-fA-F]{6})$/);
        if (!m) return { r: 102, g: 102, b: 102 };
        const n = parseInt(m[1], 16);
        return { r: (n >> 16) & 255, g: (n >> 8) & 255, b: n & 255 };
      };

      const clamp255 = (v) => Math.max(0, Math.min(255, v));

      const shade = (hex, amt) => {
        const rgb = hexToRgb(hex);
        return 'rgb(' +
          clamp255(Math.round(rgb.r + 255 * amt)) + ',' +
          clamp255(Math.round(rgb.g + 255 * amt)) + ',' +
          clamp255(Math.round(rgb.b + 255 * amt)) +
        ')';
      };

      const mortarColor = shade(color, -0.10);
      const brickFill = shade(color, +0.06);

      targetCtx.save();

      targetCtx.beginPath();
      targetCtx.rect(rect.x, rect.y, rect.w, rect.h);
      targetCtx.clip();

      targetCtx.fillStyle = mortarColor;
      targetCtx.fillRect(rect.x, rect.y, rect.w, rect.h);

      const phaseX = mod(worldX, pitchX);
      const phaseY = mod(worldY, pitchY);

      const startY = rect.y - (phaseY + pitchY);

      targetCtx.fillStyle = brickFill;
      targetCtx.strokeStyle = 'rgba(0,0,0,0.14)';
      targetCtx.lineWidth = strokeW;

      const rows = Math.ceil((rect.h + pitchY * 2) / pitchY);
      for (let rr = 0; rr < rows; rr++) {
        const y = startY + rr * pitchY;
        const rowOffset = (rr & 1) ? (pitchX / 2) : 0;

        const startX = rect.x - (phaseX + pitchX) + rowOffset;
        const cols = Math.ceil((rect.w + pitchX * 2) / pitchX);

        for (let cc = 0; cc < cols; cc++) {
          const x = startX + cc * pitchX;
          roundRectPath(targetCtx, x, y, brickW, brickH, radius);
          targetCtx.fill();
          targetCtx.stroke();
        }
      }

      targetCtx.restore();
    }

    // ---- Cobble floors (WORLD-anchored) ----
    function fillCobbleRectScreenOn(targetCtx, rect, opts) {
      const base = (opts && opts.baseHex) ? opts.baseHex : COLORS.floorCobbleBase;
      const alpha = (opts && Number.isFinite(opts.alpha)) ? opts.alpha : 1.0;
      const worldX = (opts && Number.isFinite(opts.worldX)) ? opts.worldX : 0;
      const worldY = (opts && Number.isFinite(opts.worldY)) ? opts.worldY : 0;
      const seed = (opts && Number.isFinite(opts.seed)) ? opts.seed : 12345;

      const stoneMin = (opts && Number.isFinite(opts.stoneMin)) ? opts.stoneMin : 9;
      const stoneMax = (opts && Number.isFinite(opts.stoneMax)) ? opts.stoneMax : 14;
      const gap = (opts && Number.isFinite(opts.gap)) ? opts.gap : 0.35;

      const pitch = stoneMax + gap;

      const mortar = shadeRgba(base, +0.28, alpha);
      const edge = 'rgba(0,0,0,0.10)';

      targetCtx.save();

      targetCtx.beginPath();
      targetCtx.rect(rect.x, rect.y, rect.w, rect.h);
      targetCtx.clip();

      targetCtx.fillStyle = mortar;
      targetCtx.fillRect(rect.x, rect.y, rect.w, rect.h);

      const phaseX = mod(worldX, pitch);
      const phaseY = mod(worldY, pitch);

      const startX = rect.x - (phaseX + pitch);
      const startY = rect.y - (phaseY + pitch);

      const cols = Math.ceil((rect.w + pitch * 2) / pitch);
      const rows = Math.ceil((rect.h + pitch * 2) / pitch);

      targetCtx.strokeStyle = edge;
      targetCtx.lineWidth = 1;

      for (let ry = 0; ry < rows; ry++) {
        for (let cx = 0; cx < cols; cx++) {
          const cellX = startX + cx * pitch;
          const cellY = startY + ry * pitch;

          const cellSeed = (seed + cx * 131 + ry * 977) >>> 0;
          const rnd = mulberry32(cellSeed);

          const w = stoneMin + rnd() * (stoneMax - stoneMin);
          const h = stoneMin + rnd() * (stoneMax - stoneMin);

          const ox = (rnd() - 0.5) * (gap * 1.6);
          const oy = (rnd() - 0.5) * (gap * 1.6);
          const rot = (rnd() - 0.5) * 0.25;

          const x = cellX + (pitch / 2) + ox;
          const y = cellY + (pitch / 2) + oy;

          const shadeAmt = +0.20 + (rnd() - 0.5) * 0.06;
          const fill = shadeRgba(base, shadeAmt, alpha);

          const rr = 3.6 + rnd() * 6.2;

          targetCtx.save();
          targetCtx.translate(x, y);
          targetCtx.rotate(rot);

          targetCtx.fillStyle = fill;
          roundRectPath(targetCtx, -w / 2, -h / 2, w, h, rr);
          targetCtx.fill();
          targetCtx.stroke();

          targetCtx.strokeStyle = 'rgba(255,255,255,0.06)';
          targetCtx.beginPath();
          targetCtx.moveTo(-w / 2 + rr, -h / 2 + 1);
          targetCtx.lineTo(w / 2 - rr, -h / 2 + 1);
          targetCtx.stroke();

          targetCtx.restore();

          targetCtx.strokeStyle = edge;
        }
      }

      targetCtx.restore();
    }

    // ---- Wood planks (WORLD-anchored) ----
    function fillWoodPlanksRectScreenOn(targetCtx, rect, opts) {
      const base = (opts && opts.baseHex) ? opts.baseHex : '#c19256';
      const alpha = (opts && Number.isFinite(opts.alpha)) ? opts.alpha : 1.0;
      const worldX = (opts && Number.isFinite(opts.worldX)) ? opts.worldX : 0;
      const worldY = (opts && Number.isFinite(opts.worldY)) ? opts.worldY : 0;
      const seed = (opts && Number.isFinite(opts.seed)) ? opts.seed : 12345;
      const variant = (opts && Number.isFinite(opts.variant)) ? opts.variant : 3;

      const contrast = 0.04;
      const seamAlpha = 0.06;
      const grainAlpha = 0.04;
      const knotChance = 0.06;

      const plankH = (opts && Number.isFinite(opts.plankH)) ? opts.plankH : 18;
      const gapY = (opts && Number.isFinite(opts.gapY)) ? opts.gapY : 2.2;
      const gapX = (opts && Number.isFinite(opts.gapX)) ? opts.gapX : 1.8;

      const minL = (opts && Number.isFinite(opts.minL)) ? opts.minL : 110;
      const maxL = (opts && Number.isFinite(opts.maxL)) ? opts.maxL : 240;

      const pitchY = plankH + gapY;

      const phaseY = mod(worldY, pitchY);
      const startY = rect.y - (phaseY + pitchY);

      const phasePeriodX = 600;
      const phaseX = mod(worldX, phasePeriodX);

      targetCtx.save();

      targetCtx.beginPath();
      targetCtx.rect(rect.x, rect.y, rect.w, rect.h);
      targetCtx.clip();

      targetCtx.fillStyle = shadeRgba(base, -0.03, alpha);
      targetCtx.fillRect(rect.x, rect.y, rect.w, rect.h);

      const rows = Math.ceil((rect.h + pitchY * 2) / pitchY);

      for (let r = 0; r < rows; r++) {
        const y = startY + r * pitchY;

        const rowSeed = (seed + r * 1013) >>> 0;
        const rrnd = mulberry32(rowSeed);

        const baseOffset = (r & 1) ? (minL * 0.42) : 0;
        const wobble = (rrnd() - 0.5) * 30;
        const rowOffset = baseOffset + wobble + (phaseX * 0.12);

        let x = rect.x - rowOffset;
        const xEnd = rect.x + rect.w + maxL;

        targetCtx.fillStyle = 'rgba(0,0,0,' + seamAlpha + ')';
        targetCtx.fillRect(rect.x, y + plankH, rect.w, gapY);

        while (x < xEnd) {
          const len = Math.floor(minL + rrnd() * (maxL - minL));

          const v = (rrnd() - 0.5) * 2;
          const shadeAmt = v * contrast;

          const px1 = x;
          const px2 = x + len;
          const visX1 = Math.max(px1, rect.x);
          const visX2 = Math.min(px2, rect.x + rect.w);
          const visW = visX2 - visX1;

          if (visW > 0) {
            targetCtx.fillStyle = shadeRgba(base, shadeAmt, alpha);
            targetCtx.fillRect(visX1, y, visW, plankH);

            const grainCount = 1 + Math.floor(rrnd() * 3);
            targetCtx.strokeStyle = 'rgba(0,0,0,' + grainAlpha + ')';
            targetCtx.lineWidth = 1;
            for (let g = 0; g < grainCount; g++) {
              const yy = y + 2 + rrnd() * (plankH - 4);
              const amp = 1.3 + rrnd() * 2.0;
              const freq = 0.008 + rrnd() * 0.01;
              const ph = rrnd() * Math.PI * 2;

              targetCtx.beginPath();
              const gx0 = visX1 - 10;
              const gx1 = visX1 + visW + 10;
              targetCtx.moveTo(gx0, yy);
              const step = 28;
              for (let gx = gx0; gx <= gx1; gx += step) {
                const wob = Math.sin((gx + worldX) * freq + ph) * amp;
                targetCtx.lineTo(gx, yy + wob);
              }
              targetCtx.stroke();
            }

            if (px1 >= rect.x - 1 && px1 <= rect.x + rect.w + 1) {
              targetCtx.fillStyle = 'rgba(0,0,0,' + (seamAlpha * 0.50) + ')';
              targetCtx.fillRect(px1 - (gapX / 2), y + 1, gapX, plankH - 2);
            }

            if (rrnd() < knotChance) {
              const kx = visX1 + rrnd() * visW;
              const ky = y + 3 + rrnd() * (plankH - 6);
              const kr = 2.2 + rrnd() * 4.2;

              targetCtx.fillStyle = 'rgba(0,0,0,0.10)';
              targetCtx.beginPath();
              targetCtx.ellipse(kx, ky, kr * 1.15, kr * 0.85, rrnd() * Math.PI, 0, Math.PI * 2);
              targetCtx.fill();

              targetCtx.strokeStyle = 'rgba(0,0,0,0.10)';
              targetCtx.beginPath();
              targetCtx.ellipse(kx, ky, kr * 0.9, kr * 0.65, rrnd() * Math.PI, 0, Math.PI * 2);
              targetCtx.stroke();
            }

            if (variant >= 3 && rrnd() < 0.06) {
              const sc = 1 + Math.floor(rrnd() * 3);
              targetCtx.strokeStyle = 'rgba(255,255,255,0.10)';
              targetCtx.lineWidth = 1;
              for (let s = 0; s < sc; s++) {
                const sx = visX1 + rrnd() * visW;
                const sy = y + 2 + rrnd() * (plankH - 4);
                const slen = 18 + rrnd() * 40;
                targetCtx.beginPath();
                targetCtx.moveTo(sx, sy);
                targetCtx.lineTo(sx + slen, sy + (rrnd() - 0.5) * 2);
                targetCtx.stroke();
              }
            }
          }

          x += len + gapX;
        }

        if (variant >= 3) {
          targetCtx.fillStyle = 'rgba(255,255,255,0.02)';
          targetCtx.fillRect(rect.x, y, rect.w, 1);
        }
      }

      targetCtx.restore();
    }

    // ---- Stairs (WORLD-anchored) ----
    function fillStairsWoodRectScreenOn(targetCtx, rect, opts) {
      const base = (opts && opts.baseHex) ? opts.baseHex : COLORS.floorWoodBase;
      const alpha = (opts && Number.isFinite(opts.alpha)) ? opts.alpha : 1.0;

      const worldX = (opts && Number.isFinite(opts.worldX)) ? opts.worldX : 0;
      const worldY = (opts && Number.isFinite(opts.worldY)) ? opts.worldY : 0;

      let down = (opts && opts.down) ? String(opts.down).toUpperCase() : 'S';
      if (!['N','S','E','W'].includes(down)) down = 'S';

      const tread = Number.isFinite(opts && opts.tread) ? opts.tread
        : Number.isFinite(opts && opts.treadDepth) ? opts.treadDepth
        : 10;

      const gap = Number.isFinite(opts && opts.gap) ? opts.gap
        : Number.isFinite(opts && opts.treadGap) ? opts.treadGap
        : 2;

      const pitch = tread + gap;

      const minFactor = Number.isFinite(opts && opts.minFactor) ? opts.minFactor : 0.26;
      const maxFactor = Number.isFinite(opts && opts.maxFactor) ? opts.maxFactor : 1.00;

      const endPadRaw = Number.isFinite(opts && opts.endPad) ? opts.endPad : 25;

      const axis = (down === 'E' || down === 'W') ? 'x' : 'y';
      const runLen = (axis === 'x') ? rect.w : rect.h;
      const crossSpan = (axis === 'x') ? rect.h : rect.w;

      const endPad = clamp(endPadRaw, 0, Math.max(0, (runLen / 2) - 1));

      const runStart = (axis === 'x' ? rect.x : rect.y) + endPad;
      const runEnd   = (axis === 'x' ? (rect.x + rect.w) : (rect.y + rect.h)) - endPad;
      const runLenEff = Math.max(1, runEnd - runStart);

      // 0 at UP end, 1 at DOWN end.
      const tDownFromU = (u) => (down === 'E' || down === 'S') ? u : (1 - u);

      targetCtx.save();

      targetCtx.beginPath();
      targetCtx.rect(rect.x, rect.y, rect.w, rect.h);
      targetCtx.clip();

      targetCtx.fillStyle = shadeRgba(base, -0.015, alpha);
      targetCtx.fillRect(rect.x, rect.y, rect.w, rect.h);

      targetCtx.strokeStyle = 'rgba(0,0,0,0.18)';
      targetCtx.lineWidth = 1;
      targetCtx.strokeRect(rect.x + 0.5, rect.y + 0.5, rect.w - 1, rect.h - 1);

      const phase = mod((axis === 'x') ? worldX : worldY, pitch);
      const start = runStart - (phase + pitch);

      const steps = Math.max(1, Math.ceil((runLenEff + pitch * 2) / pitch));

      const stroke = (opts && opts.stroke != null) ? String(opts.stroke) : 'rgba(0,0,0,0.55)';
      const lineWidth = Number.isFinite(opts && opts.lineWidth) ? opts.lineWidth : 1;

      targetCtx.lineWidth = lineWidth;

      for (let i = 0; i < steps; i++) {
        const pos = start + i * pitch;

        // Enforce end landing pad.
        if (pos < runStart) continue;
        if ((pos + tread) > runEnd) continue;

        const treadCenter = pos + tread / 2;
        const u = clamp((treadCenter - runStart) / runLenEff, 0, 1);
        const tDown = tDownFromU(u);

        const factor = maxFactor + (minFactor - maxFactor) * tDown;
        const crossSize = clamp(crossSpan * factor, 2, crossSpan);

        let x, y, w, h;
        if (axis === 'x') {
          x = pos;
          y = rect.y + (rect.h - crossSize) / 2;
          w = tread;
          h = crossSize;
        } else {
          x = rect.x + (rect.w - crossSize) / 2;
          y = pos;
          w = crossSize;
          h = tread;
        }

        const shadeAmt = 0.02 - tDown * 0.08;
        targetCtx.fillStyle = shadeRgba(base, shadeAmt, alpha);
        targetCtx.fillRect(x, y, w, h);

        if (gap > 0.2) {
          targetCtx.fillStyle = 'rgba(0,0,0,0.14)';
          if (axis === 'x') targetCtx.fillRect(x + w, y, Math.min(gap, 3), h);
          else targetCtx.fillRect(x, y + h, w, Math.min(gap, 3));
        }

        targetCtx.strokeStyle = stroke;
        targetCtx.strokeRect(x + 0.5, y + 0.5, Math.max(0, w - 1), Math.max(0, h - 1));

        targetCtx.fillStyle = 'rgba(255,255,255,0.06)';
        if (axis === 'x') targetCtx.fillRect(x + 1, y + 1, Math.max(0, w - 2), 1);
        else targetCtx.fillRect(x + 1, y + 1, 1, Math.max(0, h - 2));
      }

      targetCtx.restore();
    }

    // ---- Chair (nicer) ----
    function drawChairFancy(ctx2, center, facing, opts = {}) {
      const fill = opts.fill ?? '#8a5a2b';
      const stroke = opts.stroke ?? 'rgba(0,0,0,0.35)';
      const accent = opts.accent ?? 'rgba(255,255,255,0.08)';

      const seatW = GRID.size * 0.95;
      const seatH = GRID.size * 0.72;
      const seatR = Math.max(4, seatH * 0.22);

      const backR = Math.max(6, seatH * 0.48);

      const ang = facingToAngleRad(facing);

      ctx2.save();
      ctx2.translate(center.x, center.y);
      ctx2.rotate(ang);

      // Seat
      ctx2.fillStyle = fill;
      ctx2.strokeStyle = stroke;
      ctx2.lineWidth = 1;
      roundRectPath(ctx2, -seatW / 2, -seatH / 2, seatW, seatH, seatR);
      ctx2.fill();
      ctx2.stroke();

      // Front notch
      ctx2.fillStyle = 'rgba(0,0,0,0.10)';
      ctx2.fillRect(seatW * 0.33, -seatH * 0.18, seatW * 0.12, seatH * 0.36);

      // Backrest
      const backInsetX = seatW * 0.06 + backR;

      ctx2.save();
      ctx2.translate(-seatW / 2 + backInsetX, 0);

      ctx2.fillStyle = fill;
      ctx2.beginPath();
      ctx2.moveTo(0, -backR);
      ctx2.arc(0, 0, backR, -Math.PI / 2, Math.PI / 2, true);
      ctx2.closePath();
      ctx2.fill();

      ctx2.strokeStyle = stroke;
      ctx2.lineWidth = 1;
      ctx2.beginPath();
      ctx2.arc(0, 0, backR, -Math.PI / 2, Math.PI / 2, true);
      ctx2.stroke();

      ctx2.strokeStyle = accent;
      ctx2.lineWidth = 2;
      ctx2.beginPath();
      ctx2.arc(0, 0, Math.max(3, backR * 0.72), -Math.PI / 2, Math.PI / 2, true);
      ctx2.stroke();

      ctx2.restore();
      ctx2.restore();
    }

    // ---- Sprites (OPTIONAL) ----
    // If sprites are missing or still loading, we fall back to the core shapes.
    // Base paths tried in order. In most web setups, anything under /public is served at the site root.
    // So "/public/assets/sprites" on disk is typically accessible as "/assets/sprites" in the browser.
    const SPRITE_BASES = (() => {
      const fromWindow = (window.SPRITE_BASE_PATH != null) ? String(window.SPRITE_BASE_PATH) : '';
      const bases = [];
      const push = (p) => {
        const s = String(p || '').trim();
        if (!s) return;
        const norm = s.replace(/\/+$/,'') + '/';
        if (!bases.includes(norm)) bases.push(norm);
      };
      push(fromWindow);
      push('/assets/sprites/');
      push('./assets/sprites/');
      push('./public/assets/sprites/');
      push('./sprites/');
      return bases.length ? bases : ['./sprites/'];
    })();

    const SPRITE_MANIFEST = {
      // Objects / terrain
      barrel: 'barrel.png',
      bedroll: 'bedroll.png',
      bush: 'bush.png',
      campfire: 'campfire.png',
      cart: 'cart.png',
      chest_locked: 'chest_locked.png',
      chest_open: 'chest_open.png',
      crate: 'crate.png',
      fence_rope: 'fence_rope.png',
      fence1: 'fence1.png',
      forest_thick: 'forest_thick.png',
      grass_tall: 'grass_tall.png',
      guardian_of_faith: 'guardian_of_faith.png',
      log_fallen: 'log_fallen.png',
      pillar: 'pillar.png',
      rock: 'rock.png',
      spiritual_weapon: 'spiritual_weapon.png',
      statue_dragonkin: 'statue_dragonkin.png',
      statue_figher: 'statue_figher.png', // (typo preserved from filename)
      statue_fighter: 'statue_figher.png', // alias
      statue_gargoyle: 'statue_gargoyle.png',
      statue_gnome: 'statue_gnome.png',
      wagonwheel_broken: 'wagonwheel_broken.png',
      water_shallow: 'water_shallow.png',
      weapons_rack1: 'weapons_rack1.png',

      // Furniture
      door_wood: 'door_wood.png',
      door_wood_open: 'door_wood_open.png',
      window: 'window.png',
      window_open: 'window_open.png',
      sarcophagus: 'sarcophagus.png',
      table_round: 'table_round.png',

      // PCs / classes
      barbarian_female: 'barbarian_female.png',
      barbarian_male: 'barbarian_male.png',
      bard_female: 'bard_female.png',
      bard_male: 'bard_male.png',
      cleric_female: 'cleric_female.png',
      cleric_male: 'cleric_male.png',
      druid_female: 'druid_female.png',
      druid_male: 'druid_male.png',
      fighter_female: 'fighter_female.png',
      fighter_male: 'fighter_male.png',
      monk_female: 'monk_female.png',
      monk_male: 'monk_male.png',
      paladin_female: 'paladin_female.png',
      paladin_male: 'paladin_male.png',
      ranger_female: 'ranger_female.png',
      ranger_male: 'ranger_male.png',
      rogue_male: 'rogue_male.png',
      rogue_female: 'rouge_female.png', // (typo preserved from filename)
      rouge_female: 'rouge_female.png',
      sorcerer_female: 'sorcerer_female.png',
      sorcerer_male: 'sorcerer_male.png',
      warlock_female: 'warlock_female.png',
      warlock_male: 'warlock_male.png',
      wizard_female: 'wizard_female.png',
      wizard_male: 'wizard_male.png',

      // Monsters
      bear: 'bear.png',
      bugbear: 'bugbear.png',
      dire_wolf: 'dire_wolf.png',
      ghoul: 'ghoul.png',
      giant_rat: 'giant_rat.png',
      giant_spider: 'giant_spider.png',
      goblin: 'goblin.png',
      guard: 'guard.png',
      hobgoblin: 'hobgoblin.png',
      lich: 'lich.png',
      mimic: 'mimic.png',
      ogre: 'ogre.png',
      orc: 'orc.png',
      skeleton: 'skeleton.png',
      skeleton_archer: 'skeleton_archer.png',
      wight: 'wight.png',
      wolf: 'wolf.png',
      wraith: 'wraith.png',
      wraith2: 'wraith2.png',
      zombie: 'zombie.png',
    };

    const SpriteStore = (() => {
      const cache = new Map(); // key -> { img, ok, err }
      const missing = new Set();

      const normalizeKey = (v) => {
        const s = String(v || '').trim().toLowerCase();
        if (!s) return '';
        // Keep letters/numbers, convert everything else to underscores.
        let k = s.replace(/[^a-z0-9]+/g, '_').replace(/^_+|_+$/g, '').replace(/_+/g, '_');
        // Common: "wraith_2" -> "wraith2" (matches your filenames)
        k = k.replace(/_([0-9]+)$/g, '$1');
        return k;
      };

      const hasKey = (k) => !!SPRITE_MANIFEST[String(k || '')];

      const resolveTokenKey = (t) => {
        if (!t) return '';
        const direct = normalizeKey(t.sprite || '');
        if (direct && hasKey(direct)) return direct;

        const byName = normalizeKey(t.name || t.id || '');
        if (byName && hasKey(byName)) return byName;

        // If it's like "wraith1" but only "wraith" exists, fall back to base.
        const m = byName.match(/^([a-z_]+)([0-9]+)$/);
        if (m && hasKey(m[1])) return m[1];

        return '';
      };

      const resolveObjectKey = (o) => {
        if (!o) return '';
        const direct = normalizeKey(o.sprite || '');
        if (direct && hasKey(direct)) return direct;

        // kind like "table.round" -> "table_round"
        const byKind = normalizeKey(String(o.kind || '').replaceAll('.', '_'));
        if (byKind && hasKey(byKind)) return byKind;

        return '';
      };

      const resolveOpeningKey = (o, core) => {
        if (!o) return '';
        const direct = normalizeKey(o.sprite || '');
        if (direct && hasKey(direct)) return direct;

        const kind = String(o.kind || 'door').toLowerCase();
        const orient = core.openingOrientation(o);

        if (kind === 'door') {
          const d = core.normalizeDoorParams(o, orient);
          return (d.openPct > 0.5) ? 'door_wood_open' : 'door_wood';
        }
        if (kind === 'window') {
          const w = core.normalizeWindowParams(o, orient);
          return (w.openPct > 0.5) ? 'window_open' : 'window';
        }

        return '';
      };
      const ensure = (key) => {
        const k = String(key || '');
        if (!k || missing.has(k)) return null;

        const hit = cache.get(k);
        if (hit) return hit.ok ? hit.img : null;

        const filename = SPRITE_MANIFEST[k];
        if (!filename) return null;

        const img = new Image();
        const rec = { img, ok: false, idx: 0 };
        cache.set(k, rec);

        const tryLoad = () => {
          const base = SPRITE_BASES[Math.min(rec.idx, SPRITE_BASES.length - 1)];
          img.src = base + filename;
        };

        img.onload = () => {
          const r = cache.get(k);
          if (r) r.ok = true;
          redraw();
        };

        img.onerror = () => {
          const r = cache.get(k);
          if (!r) return;
          r.idx = (r.idx || 0) + 1;
          if (r.idx < SPRITE_BASES.length) {
            tryLoad();
            return;
          }
          cache.delete(k);
          missing.add(k);
          redraw();
        };

        tryLoad();
        return null; // not ready yet
      };

      const drawCentered = (ctx2, img, cx, cy, w, h, rotRad = 0) => {
        ctx2.save();
        ctx2.translate(cx, cy);
        if (rotRad) ctx2.rotate(rotRad);
        ctx2.imageSmoothingEnabled = true;
        ctx2.drawImage(img, -w / 2, -h / 2, w, h);
        ctx2.restore();
      };

      return {
        normalizeKey,
        resolveTokenKey,
        resolveObjectKey,
        resolveOpeningKey,
        ensure,
        drawCentered,
        hasKey,
      };
    })();

    // Token sprites
    PACK.drawTokenSprite = (ctx2, t, core) => {
      const key = SpriteStore.resolveTokenKey(t);
      if (!key) return false;
      const img = SpriteStore.ensure(key);
      if (!img) return false;

      let p;
      try { p = core.parseHexId(t.hex); } catch { return false; }
      const cS = core.worldToScreen(core.hexCenterWorld(p.col, p.row));

      const size = core.rowStep() * 0.98;
      SpriteStore.drawCentered(ctx2, img, cS.x, cS.y, size, size, 0);

      // Label overlay (keeps your quick-read combat labels)
      const isEnemy = String(t.side || '').toUpperCase().indexOf('EN') >= 0;
      const label = (t.label != null) ? t.label : (t.name ? t.name[0] : '?');

      ctx2.save();
      ctx2.font = 'bold 14px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
      ctx2.textAlign = 'center';
      ctx2.textBaseline = 'middle';
      ctx2.lineWidth = 4;
      ctx2.strokeStyle = 'rgba(0,0,0,0.55)';
      ctx2.fillStyle = isEnemy ? core.COLORS.tokenTextLight : 'rgba(255,255,255,0.95)';
      ctx2.strokeText(label, cS.x, cS.y);
      ctx2.fillText(label, cS.x, cS.y);

      if (t.name) {
        const r = core.GRID.size * 0.42;
        ctx2.font = '12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
        ctx2.lineWidth = 3;
        ctx2.strokeStyle = 'rgba(255,255,255,0.80)';
        ctx2.fillStyle = core.COLORS.tokenTextDark;
        ctx2.strokeText(t.name, cS.x, cS.y + r + 14);
        ctx2.fillText(t.name, cS.x, cS.y + r + 14);
      }
      ctx2.restore();

      return true;
    };

    // Object sprites
    PACK.drawObjectSprite = (ctx2, o, core) => {
      const key = SpriteStore.resolveObjectKey(o);
      if (!key) return false;
      const img = SpriteStore.ensure(key);
      if (!img) return false;

      const occ = core.getObjectOccupiedHexes(o);
      if (!occ.length) return false;

      const pts = core.getScreenPointsForHexes(occ);
      if (!pts.length) return false;

      const sh = core.getObjectShiftPx(o);

      // Single-hex: draw in a square that fits the hex height.
      if (pts.length === 1) {
        const c0 = pts[0];
        const cx = c0.x + sh.dx;
        const cy = c0.y + sh.dy;
        const size = core.rowStep() * 0.98;
        SpriteStore.drawCentered(ctx2, img, cx, cy, size, size, 0);
        return true;
      }

      // Multi-hex: fit sprite to the footprint bounds.
      const b0 = core.boundsOfPoints(pts);
      const pad = core.GRID.size * 0.95;
      const b = core.expandBounds(b0, pad);

      const w = Math.max(4, (b.maxX - b.minX));
      const h = Math.max(4, (b.maxY - b.minY));
      const cx = (b.minX + b.maxX) / 2 + sh.dx;
      const cy = (b.minY + b.maxY) / 2 + sh.dy;

      // Preserve aspect ratio: fit to the smaller dimension.
      const size = Math.min(w, h);
      SpriteStore.drawCentered(ctx2, img, cx, cy, size, size, 0);
      return true;
    };

    // Door / window sprites
    PACK.drawOpeningSprite = (ctx2, opening, wallSegs, core) => {
      const kind = String(opening && opening.kind ? opening.kind : 'door').toLowerCase();
      if (kind !== 'door' && kind !== 'window') return false;

      const key = SpriteStore.resolveOpeningKey(opening, core);
      if (!key) return false;
      const img = SpriteStore.ensure(key);
      if (!img) return false;

      let p;
      try { p = core.parseHexId(opening.hex); } catch { return false; }

      const orient = core.openingOrientation(opening);
      const hexWorld = core.hexCenterWorld(p.col, p.row);
      const seg = core.findNearestWallSegment(wallSegs || [], orient, hexWorld);

      const wAlong = core.GRID.size * 1.2;
      const fallbackH = core.GRID.size * 0.55;

      let cx = hexWorld.x;
      let cy = hexWorld.y;
      let thickness = 28;

      if (seg) {
        thickness = seg.thickness;
        if (orient === 'h') cy = seg.y;
        else cx = seg.x;
      }

      const centerS = core.worldToScreen({ x: cx, y: cy });

      const openingHBase = Math.min(thickness * 0.72, fallbackH);
      const openingH = openingHBase * 0.85;

      const rot = (orient === 'v') ? (Math.PI / 2) : 0;
      SpriteStore.drawCentered(ctx2, img, centerS.x, centerS.y, wAlong, openingH, rot);
      return true;
    };

    // ---- Install overrides ----
    PACK.enabled = true;

    PACK.fillBrickRect = (targetCtx, rect, color, worldX, worldY) => fillBrickRectScreenOn(targetCtx, rect, color, worldX, worldY);

    PACK.fillCobbleRect = (targetCtx, rect, opts) => fillCobbleRectScreenOn(targetCtx, rect, opts);

    PACK.fillWoodRect = (targetCtx, rect, opts) => {
      const o = opts || {};
      fillWoodPlanksRectScreenOn(targetCtx, rect, {
        baseHex: o.baseHex ?? COLORS.floorWoodBase,
        alpha: Number.isFinite(o.alpha) ? o.alpha : 1.0,
        worldX: Number.isFinite(o.worldX) ? o.worldX : 0,
        worldY: Number.isFinite(o.worldY) ? o.worldY : 0,
        seed: Number.isFinite(o.seed) ? o.seed : 12345,
        variant: 3,
        plankH: 18,
        gapY: 2,
        gapX: 2,
      });
    };

    PACK.fillStairsWoodRect = (targetCtx, rect, opts) => fillStairsWoodRectScreenOn(targetCtx, rect, opts || {});

    PACK.drawChair = (targetCtx, center, facing, style) => drawChairFancy(targetCtx, center, facing, style || {});

    // Beds and tables are already decent; keep basic implementations unless you want to enhance later.

  })(PACK);


  // =====================================================================================
  // BOOT (after optional fancy pack)
  // =====================================================================================
  init();
})();
</script>
</body>
</html>
