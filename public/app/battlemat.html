<!doctype html>
<!--
  v4.95

  Copyright © 2025 Thomas Delvus. All rights reserved.

  This HTML document and its contents (including the code, layout, text, data structures, and embedded/linked assets)
  are protected by copyright law.

  Permission is granted to access and use this file for personal, non-commercial tabletop gameplay and reference.

  You may NOT copy, reproduce, modify, translate, redistribute, publish, sell, sublicense, or incorporate this work
  (in whole or in part) into any software product, service, website, platform, “system,” template library, dataset,
  or AI/training workflow without prior written permission from the copyright holder.

  Unauthorized use is prohibited.

  Refactor notes (v4.95):
  - Cleanup-only refactor: remove obsolete/accidental comment artifacts, align version display, and group code by section.
  - No functional changes intended.

  Feature notes (v4.94):
  - Stairs: tread taper symmetric around the midline (even cascade) and add an end landing pad (default 25px).

  Feature notes (v4.91–v4.93):
  - Thresholds: parent-based wall knockout + floor underlay so hallway junctions read as continuous.
  - Stairs: replaced tapered renderer with a simpler tread-rectangle implementation.
  - Defensive: bind a harmless `$1` identifier to avoid rare paste/editor artifacts crashing runtime.
-->
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Battlemat</title>
  <style>
    :root {
      --ui-bg: #f4f4f4;
      --panel-bg: #ffffff;
      --panel-border: #e5e5e5;
      --text: #111;
      --muted: #666;
      --btn: #ffffff;
      --btn-border: #d0d0d0;
    }

    html, body { height: 100%; }
    body {
      margin: 0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      background: var(--ui-bg);
      color: var(--text);
    }

    .app {
      height: 100%;
      display: grid;
      grid-template-columns: 1fr 280px;
      gap: 12px;
      padding: 12px;
      box-sizing: border-box;
    }

    .stage {
      background: var(--panel-bg);
      border: 1px solid var(--panel-border);
      border-radius: 12px;
      overflow: hidden;
      display: grid;
      grid-template-rows: 1fr auto;
      min-width: 0;
      min-height: 0;
    }

    .canvasWrap {
      position: relative;
      min-height: 0;
      min-width: 0;
    }

    canvas {
      display: block;
      width: 100%;
      height: 100%;
      background: #fff;
    }

    .controls {
      border-top: 1px solid var(--panel-border);
      padding: 10px;
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
    }

    .controls .spacer { flex: 1; }

    button {
      background: var(--btn);
      border: 1px solid var(--btn-border);
      border-radius: 10px;
      padding: 8px 10px;
      cursor: pointer;
      user-select: none;
    }
    button:active { transform: translateY(1px); }

    input, select {
      border: 1px solid var(--btn-border);
      border-radius: 10px;
      padding: 8px 10px;
      outline: none;
    }

    .sidebar {
      background: var(--panel-bg);
      border: 1px solid var(--panel-border);
      border-radius: 12px;
      overflow: hidden;
      display: grid;
      grid-template-rows: auto 1fr;
    }

    .sidebarHeader {
      padding: 12px;
      border-bottom: 1px solid var(--panel-border);
      display: flex;
      align-items: center;
      justify-content: space-between;
    }

    .pill {
      font-size: 12px;
      color: var(--muted);
      border: 1px solid var(--panel-border);
      background: #fafafa;
      padding: 4px 8px;
      border-radius: 999px;
    }

    .sidebarBody {
      padding: 12px;
      overflow: auto;
    }

    .kvs {
      display: grid;
      grid-template-columns: 1fr auto;
      gap: 6px 10px;
      font-size: 13px;
      color: var(--muted);
    }

    .legend {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      align-items: center;
      font-size: 12px;
      color: var(--muted);
    }
    .sw {
      width: 14px; height: 14px;
      border-radius: 4px;
      border: 1px solid rgba(0,0,0,0.15);
      display: inline-block;
      vertical-align: middle;
      margin-right: 6px;
    }
  </style>
</head>
<body>
  <div class="app">
    <div class="stage">
      <div class="canvasWrap">
        <canvas id="canvas"></canvas>
      </div>
      <div class="controls">
        <button id="btnLeft">←</button>
        <button id="btnUp">↑</button>
        <button id="btnDown">↓</button>
        <button id="btnRight">→</button>

        <span class="spacer"></span>

        <label class="legend" style="margin-right: 8px;">
          <span><span class="sw" style="background:#b67a2c"></span>Door</span>
          <span><span class="sw" style="background:#bfe2ff"></span>Window</span>
          <span><span class="sw" style="background:#666"></span>Wall</span>
        </label>

        <label style="display:flex; align-items:center; gap:6px;">
          <span style="font-size:12px; color:var(--muted);">Floors</span>
          <select id="floorKind" style="min-width: 140px;">
            <option value="">Mixed</option>
            <option value="stone">Stone</option>
            <option value="wood">Wood</option>
            <option value="cobble">Cobble</option>
            <option value="stairs.wood">Stairs</option>
            <option value="none">None</option>
            <option value="fog">Fog</option>
          </select>
        </label>

        <label style="display:flex; align-items:center; gap:6px;">
          <input type="checkbox" id="fogToggle" />
          <span style="font-size:12px; color:var(--muted);">Fog</span>
        </label>

        <label style="display:flex; align-items:center; gap:6px;">
          <span style="font-size:12px; color:var(--muted);">Center on</span>
          <select id="centerOn" style="min-width: 150px;">
            <option value="">None</option>
          </select>
        </label>

        <input id="jumpHex" placeholder="Jump to (e.g., H6)" style="width: 140px;" />
        <button id="btnJump">Jump</button>
        <button id="btnRedraw">Redraw</button>
      </div>
    </div>

    <div class="sidebar">
      <div class="sidebarHeader">
        <div style="font-weight: 600;">Status</div>
        <div class="pill" id="versionLine">v4.95</div>
      </div>
      <div class="sidebarBody">
        <div class="kvs" id="kvs"></div>
        <hr style="border: none; border-top: 1px solid var(--panel-border); margin: 12px 0;" />
        <div style="font-size: 12px; color: var(--muted); line-height: 1.35;">
          Geometry rewrite: rooms → wall centerlines → thickness-aware wall rings.
        </div>
      </div>
    </div>
  </div>

<script>
(() => {
  // ===== Safety shim =====
  // Some editors/snippets accidentally paste a bare "$1" token into JS. In JS, `$1` is a valid
  // identifier; a stray reference crashes with "ReferenceError: $1 is not defined". Binding it here
  // makes any accidental stray usage a harmless no-op.
  const $1 = undefined;

  // ===== DOM / Canvas =====
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');

  // Offscreen wall layer (we punch openings out of walls here, then composite onto main canvas).
  const wallCanvas = document.createElement('canvas');
  const wallCtx = wallCanvas.getContext('2d');

  // ===== Constants =====
  const GRID = {
    // Flat-top hex geometry: size is center-to-vertex.
    size: 42,
    lineWidth: 2,
    lineAlpha: 0.09,
    labelAlpha: 0.18,
    labelFont: 'bold 12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial',
  };

  const COLORS = {
    wall: '#666',
    door: '#b67a2c',
    window: '#bfe2ff',
    floorStone: 'rgb(223, 208, 165)',
    floorWoodBase: '#d5b58c',
    floorCobbleBase: '#9aa0a6',
    tokenHero: '#4aa3ff',
    tokenEnemy: '#111',
    tokenTextDark: 'rgba(0,0,0,0.72)',
    tokenTextLight: 'rgba(255,255,255,0.88)',

    // Fog (floor replacement)
    fogUnseen: 'rgb(128,128,128)',
    fogExplored: 'rgb(170,170,170)',
  };

  const VIEW = {
    // Camera is in hex coords (col,row), row 0 is "row 1" at the bottom.
    camera: { col: 6, row: 6 },
    anchor: { x: 0, y: 0 },
    dx: 0,
    dy: 0,

    // If set, camera will automatically follow that token (by id).
    followTokenId: null,

    // Device pixel ratio (set in resize()).
    dpr: 1,
  };

  const PAN_STEP = 2;

  // ===== Canonical state (demo) =====
  const DEFAULT_STATE = {
    meta: { title: 'Cross Keys Inn — Upper Floor', battleId: 'local', round: 1 },
    view: { camera_hex: 'U16' },

    // Fog of War (room-based)
    // - visibleRoomIds may be computed locally (autoCompute) or supplied by a rules/DM layer.
    // - exploredRoomIds will auto-accumulate (autoExplore) in this standalone battlemat.
    fog: {
      enabled: true,
      mode: 'room',
      visibleRoomIds: [],
      exploredRoomIds: [],
      autoCompute: true,
      autoExplore: true,
      maxDepth: 1,
      unseenAlpha: 0.92,
      exploredAlpha: 0.55,
    },

    rooms: [
      { id: 'HighStreet', corners: ['F50','L50','L1','F1'], thickness: 20, color: '#555', floor: { kind: 'cobble' }, wall: { kind: 'none' } },
      { id: 'KingStreet', corners: ['L12','BE12','BE7','L7'], thickness: 20, color: '#555', floor: { kind: 'cobble' }, wall: { kind: 'none' } },
      { id: 'NextShoppe', corners: ['AJ28','AP28','AP12','AJ12'], thickness: 20, color: '#555', floor: { kind: 'wood' }, wall: { kind: 'brick' } },
      { id: 'NextShoppe2', corners: ['L27','V27','V21','L21'], thickness: 20, color: '#555', floor: { kind: 'wood' }, wall: { kind: 'brick' } },

      // --- Spaces (hallways / open areas): floors only, no walls ---
      { id: '1stFloorStairsDown', corners: ['Z21','AD21','AD19','Z19'], thickness: 20, floor: { kind: 'stairs.wood' }, wall: { kind: 'brick' }, stairsDown: 'W' },

      { id: 'CrossKeysUpperFloor', corners: ['L21','AJ21','AJ12','L12'], thickness: 20, color: '#555', floor: { kind: 'fog' }, wall: { kind: 'brick' } },
      { id: 'Hallway1', corners: ['AD21','AF21','AF12','AD12'], thickness: 20, floor: { kind: 'wood' }, wall: { kind: 'brick' } },
      { id: 'Hallway2', corners: ['R17','AD17','AD15','R15'], thickness: 20, floor: { kind: 'wood' }, wall: { kind: 'brick' } },
      { id: 'Hallway3', corners: ['P21','R21','R12','P12'], thickness: 20, floor: { kind: 'wood' }, wall: { kind: 'brick' } },

      { id: 'Bedroom1', corners: ['L21','P21','P18','L18'], thickness: 20, color: '#555', floor: { kind: 'wood' }, wall: { kind: 'brick' } },
      { id: 'Bedroom2', corners: ['L18','P18','P15','L15'], thickness: 20, color: '#555', floor: { kind: 'wood' }, wall: { kind: 'brick' } },
      { id: 'Bedroom3', corners: ['L15','P15','P12','L12'], thickness: 20, color: '#555', floor: { kind: 'wood' }, wall: { kind: 'brick' } },
      { id: 'Bedroom4', corners: ['R15','X15','X12','R12'], thickness: 20, color: '#555', floor: { kind: 'wood' }, wall: { kind: 'brick' } },
      { id: 'Bedroom5', corners: ['R21','X21','X17','R17'], thickness: 20, color: '#555', floor: { kind: 'wood' }, wall: { kind: 'brick' } },
      { id: 'Bedroom6', corners: ['X19','AD19','AD17','X17'], thickness: 20, color: '#555', floor: { kind: 'wood' }, wall: { kind: 'brick' } },
      { id: 'Bedroom7', corners: ['X15','AD15','AD12','X12'], thickness: 20, color: '#555', floor: { kind: 'wood' }, wall: { kind: 'brick' } },
      { id: 'Bedroom8', corners: ['AF15','AJ15','AJ12','AF12'], thickness: 20, color: '#555', floor: { kind: 'wood' }, wall: { kind: 'brick' } },
      { id: 'Bedroom9', corners: ['AF18','AJ18','AJ15','AF15'], thickness: 20, color: '#555', floor: { kind: 'wood' }, wall: { kind: 'brick' } },
      { id: 'Bedroom10', corners: ['AF21','AJ21','AJ18','AF18'], thickness: 20, color: '#555', floor: { kind: 'wood' }, wall: { kind: 'brick' } },
      { id: 'Room5Closet', corners: ['X21','Z21','Z19','X19'], thickness: 20, color: '#555', floor: { kind: 'wood' }, wall: { kind: 'brick' } },
    ],

    openings: [
      { id: 'door_room1', kind: 'door', hex: 'P19',  orientation: 'v', state: 'closed', opensTo: 'W', hingeEnd: 'N' },
      { id: 'door_room2', kind: 'door', hex: 'P16',  orientation: 'v', state: 'closed', opensTo: 'W', hingeEnd: 'N' },
      { id: 'door_room3', kind: 'door', hex: 'P13',  orientation: 'v', state: 'closed', opensTo: 'W', hingeEnd: 'N' },
      { id: 'door_room4', kind: 'door', hex: 'T15',  orientation: 'h', state: 'open', opensTo: 'S', hingeEnd: 'W' },
      { id: 'door_room5', kind: 'door', hex: 'U17',  orientation: 'h', state: 'open', opensTo: 'N', hingeEnd: 'W' },
      { id: 'door_room5_closet', kind: 'door', hex: 'X20',  orientation: 'v', state: 'open', opensTo: 'W', hingeEnd: 'N' },
      { id: 'door_room6', kind: 'door', hex: 'AA17', orientation: 'h', state: 'closed', opensTo: 'N', hingeEnd: 'E' },
      { id: 'door_room7', kind: 'door', hex: 'AC14', orientation: 'h', state: 'closed', opensTo: 'S', hingeEnd: 'E' },
      { id: 'door_room8', kind: 'door', hex: 'AF13', orientation: 'v', state: 'closed', opensTo: 'E', hingeEnd: 'N' },
      { id: 'door_room9', kind: 'door', hex: 'AF16', orientation: 'v', state: 'closed', opensTo: 'E', hingeEnd: 'N' },
      { id: 'door_room10',kind: 'door', hex: 'AF20', orientation: 'v', state: 'closed', opensTo: 'E', hingeEnd: 'N' },

      // Invisible connectors between wall-less spaces (hallways, etc.).
      // Always considered "see-through" for fog visibility, but not drawn and do not cut walls unless threshold.
      { id: 'thresh_R16',  kind: 'threshold', hex: 'R16',  orientation: 'v', state: 'open', parent: 'Hallway2' },
      { id: 'thresh_AD16', kind: 'threshold', hex: 'AD16', orientation: 'v', state: 'open', parent: 'Hallway2' },
      { id: 'thresh_AD20', kind: 'threshold', hex: 'AD20', orientation: 'v', state: 'open', parent: '1stFloorStairsDown' },

      { id: 'west_window1', kind: 'window', hex: 'L20', orientation: 'v', state: 'closed', opensTo: 'W' },
      { id: 'west_window2', kind: 'window', hex: 'L19', orientation: 'v', state: 'closed', opensTo: 'W' },
      { id: 'west_window3', kind: 'window', hex: 'L17', orientation: 'v', state: 'closed', opensTo: 'W' },
      { id: 'west_window4', kind: 'window', hex: 'L16', orientation: 'v', state: 'closed', opensTo: 'W' },
      { id: 'west_window5', kind: 'window', hex: 'L14', orientation: 'v', state: 'closed', opensTo: 'W' },
      { id: 'west_window6', kind: 'window', hex: 'L13', orientation: 'v', state: 'closed', opensTo: 'W' },

      { id: 'south_window1', kind: 'window', hex: 'M11',  orientation: 'h', state: 'closed', opensTo: 'S' },
      { id: 'south_window2', kind: 'window', hex: 'N12',  orientation: 'h', state: 'closed', opensTo: 'S' },
      { id: 'south_window3', kind: 'window', hex: 'Q11',  orientation: 'h', state: 'closed', opensTo: 'S' },
      { id: 'south_window4', kind: 'window', hex: 'T12',  orientation: 'h', state: 'open',   opensTo: 'S' },
      { id: 'south_window5', kind: 'window', hex: 'U11',  orientation: 'h', state: 'closed', opensTo: 'S' },
      { id: 'south_window6', kind: 'window', hex: 'AA11', orientation: 'h', state: 'closed', opensTo: 'S' },
      { id: 'south_window7', kind: 'window', hex: 'AB12', orientation: 'h', state: 'closed', opensTo: 'S' },
      { id: 'south_window8', kind: 'window', hex: 'AE11', orientation: 'h', state: 'closed', opensTo: 'S' },
      { id: 'south_window9', kind: 'window', hex: 'AH12', orientation: 'h', state: 'closed', opensTo: 'S' },
    ],

    tokens: [
      { id: 'lich', name: 'Lich', side: 'ENEMY', hex: 'U19', label: 'L', init: 15, hp: 135 },
      { id: 'w1',   name: 'Wraith 1', side: 'ENEMY', hex: 'T16', label: 'W1', init: 12, hp: 67 },
      { id: 'w2',   name: 'Wraith 2', side: 'ENEMY', hex: 'Q18', label: 'W2', init: 11, hp: 67 },
      { id: 'w3',   name: 'Wraith 3', side: 'ENEMY', hex: 'N17', label: 'W3', init: 10, hp: 67 },
      { id: 'a',    name: 'Aelar', side: 'PC', hex: 'V16', label: 'A', init: 14, hp: 42 },
      { id: 'b',    name: 'Brunna', side: 'PC', hex: 'U13', label: 'B', init: 13, hp: 55 },
      { id: 'c',    name: 'Caelin', side: 'PC', hex: 'AA20', label: 'C', init: 12, hp: 38 },
    ],
  };

  const getState = () => (window.BATTLE_STATE || DEFAULT_STATE);

  // Computed each redraw (never used as canonical data unless state.fog.autoExplore mutates exploredRoomIds).
  let RENDER_FOG = {
    enabled: false,
    visible: new Set(),
    explored: new Set(),
    unseenAlpha: 0.92,
    exploredAlpha: 0.55,
  };

  // Non-destructive render overrides (UI helpers).
  const RENDER_OVERRIDES = {
    floorKind: '', // '' => use each room's own floor.kind
  };

  // ===== Math helpers =====
  const sqrt3 = Math.sqrt(3);
  const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v));
  const mod = (a, m) => ((a % m) + m) % m;

  // ===== Hex helpers =====
  function colToLetters(col) {
    let n = col + 1;
    let s = '';
    while (n > 0) {
      const r = (n - 1) % 26;
      s = String.fromCharCode(65 + r) + s;
      n = Math.floor((n - 1) / 26);
    }
    return s;
  }

  function lettersToCol(letters) {
    const u = String(letters).toUpperCase();
    let n = 0;
    for (let i = 0; i < u.length; i++) {
      const c = u.charCodeAt(i);
      if (c < 65 || c > 90) throw new Error('Bad column letters');
      n = n * 26 + (c - 64);
    }
    return n - 1;
  }

  function parseHexId(hex) {
    const m = String(hex).trim().toUpperCase().match(/^([A-Z]+)([0-9]+)$/);
    if (!m) throw new Error('Bad hex: ' + hex);
    return { col: lettersToCol(m[1]), row: parseInt(m[2], 10) - 1 };
  }

  function hexId(col, row) {
    return colToLetters(col) + String(row + 1);
  }

  // ===== Geometry (world coords) =====
  function colStep() { return 1.5 * GRID.size; }
  function rowStep() { return sqrt3 * GRID.size; }

  // Row 0 is bottom row ("1"), row increases upward.
  function hexCenterWorld(col, row) {
    const x = col * colStep();
    const y = -(row * rowStep() + (col & 1) * (rowStep() / 2));
    return { x, y };
  }

  // ===== Camera transform =====
  function cameraWorld() { return hexCenterWorld(VIEW.camera.col, VIEW.camera.row); }

  function worldToScreen(p) {
    const cam = cameraWorld();
    return { x: VIEW.anchor.x + (p.x - cam.x) + VIEW.dx, y: VIEW.anchor.y + (p.y - cam.y) + VIEW.dy };
  }

  function screenToWorld(p) {
    const cam = cameraWorld();
    return { x: (p.x - VIEW.anchor.x) + cam.x - VIEW.dx, y: (p.y - VIEW.anchor.y) + cam.y - VIEW.dy };
  }

  // ===== Path helpers =====
  function roundRectPath(targetCtx, x, y, w, h, r) {
    const rr = Math.max(0, Math.min(r, Math.min(Math.abs(w), Math.abs(h)) / 2));
    targetCtx.beginPath();
    targetCtx.moveTo(x + rr, y);
    targetCtx.lineTo(x + w - rr, y);
    targetCtx.quadraticCurveTo(x + w, y, x + w, y + rr);
    targetCtx.lineTo(x + w, y + h - rr);
    targetCtx.quadraticCurveTo(x + w, y + h, x + w - rr, y + h);
    targetCtx.lineTo(x + rr, y + h);
    targetCtx.quadraticCurveTo(x, y + h, x, y + h - rr);
    targetCtx.lineTo(x, y + rr);
    targetCtx.quadraticCurveTo(x, y, x + rr, y);
    targetCtx.closePath();
  }

  // ===== Grid drawing =====
  function hexCornersWorld(center) {
    const s = GRID.size;
    const hs = s / 2;
    const hh = (sqrt3 * s) / 2;
    return [
      { x: center.x + s,  y: center.y },
      { x: center.x + hs, y: center.y + hh },
      { x: center.x - hs, y: center.y + hh },
      { x: center.x - s,  y: center.y },
      { x: center.x - hs, y: center.y - hh },
      { x: center.x + hs, y: center.y - hh },
    ];
  }

  function drawHexOutline(col, row) {
    const pts = hexCornersWorld(hexCenterWorld(col, row)).map(worldToScreen);
    ctx.beginPath();
    ctx.moveTo(pts[0].x, pts[0].y);
    for (let i = 1; i < pts.length; i++) ctx.lineTo(pts[i].x, pts[i].y);
    ctx.closePath();
    ctx.stroke();
  }

  function drawHexLabel(col, row) {
    const c = worldToScreen(hexCenterWorld(col, row));
    ctx.fillText(hexId(col, row), c.x, c.y + 30);
  }

  // ===== Room geometry =====
  function cornersToBounds(corners) {
    const pts = corners.map(parseHexId);
    const cols = pts.map(p => p.col);
    const rows = pts.map(p => p.row);
    return {
      minCol: Math.min.apply(null, cols),
      maxCol: Math.max.apply(null, cols),
      minRow: Math.min.apply(null, rows),
      maxRow: Math.max.apply(null, rows)
    };
  }

  function roomToWallBox(room) {
    const thickness = Math.max(1, Number(room.thickness || 30));

    if (!Array.isArray(room.corners) || room.corners.length < 4) {
      throw new Error('Room missing 4 corners');
    }

    // Corner order: [top-left, top-right, bottom-right, bottom-left]
    const p0 = parseHexId(room.corners[0]);
    const p1 = parseHexId(room.corners[1]);
    const p2 = parseHexId(room.corners[2]);
    const p3 = parseHexId(room.corners[3]);

    const c0 = hexCenterWorld(p0.col, p0.row);
    const c1 = hexCenterWorld(p1.col, p1.row);
    const c2 = hexCenterWorld(p2.col, p2.row);
    const c3 = hexCenterWorld(p3.col, p3.row);

    const xL = (c0.x + c3.x) / 2;
    const xR = (c1.x + c2.x) / 2;
    let yTop = (c0.y + c1.y) / 2;
    let yBot = (c2.y + c3.y) / 2;

    // Horizontal wall phase tweak: shift all horizontal room edges 1/4-hex SOUTH so
    // horizontal walls land in the gap between alternating flat tops.
    const yShift = rowStep() / 4;
    yTop += yShift;
    yBot += yShift;

    const b = cornersToBounds(room.corners);

    const halfT = thickness / 2;
    const outer = { x1: xL - halfT, x2: xR + halfT, y1: yTop - halfT, y2: yBot + halfT, thickness: thickness };
    const inner = { x1: outer.x1 + thickness, x2: outer.x2 - thickness, y1: outer.y1 + thickness, y2: outer.y2 - thickness };

    return { bounds: b, thickness, outer, inner, xL, xR, yTop, yBot };
  }

  function roomHasWalls(room) {
    const k = room && room.wall && room.wall.kind ? String(room.wall.kind).toLowerCase() : 'brick';
    if (k === 'none' || k === 'off' || k === 'false') return false;
    if (room && room.drawWalls === false) return false;
    return true;
  }

  function buildWallSegments(rooms) {
    const segs = [];
    for (const r of rooms) {
      if (!roomHasWalls(r)) continue;
      const box = roomToWallBox(r);
      const t = box.thickness;
      segs.push({ orientation: 'h', y: box.yTop, x1: box.xL, x2: box.xR, thickness: t });
      segs.push({ orientation: 'h', y: box.yBot, x1: box.xL, x2: box.xR, thickness: t });
      segs.push({ orientation: 'v', x: box.xL, y1: box.yTop, y2: box.yBot, thickness: t });
      segs.push({ orientation: 'v', x: box.xR, y1: box.yTop, y2: box.yBot, thickness: t });
    }
    return segs;
  }

  // ===== Deterministic RNG / hashing =====
  function mulberry32(seed) {
    let a = (seed >>> 0) || 0;
    return function() {
      a |= 0;
      a = (a + 0x6D2B79F5) | 0;
      let t = Math.imul(a ^ (a >>> 15), 1 | a);
      t = (t + Math.imul(t ^ (t >>> 7), 61 | t)) ^ t;
      return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
    };
  }

  function hashStringToSeed(s) {
    const str = String(s || '');
    let h = 2166136261 >>> 0;
    for (let i = 0; i < str.length; i++) {
      h ^= str.charCodeAt(i);
      h = Math.imul(h, 16777619);
    }
    return h >>> 0;
  }

  function hexToRgbStrict(hex, fallback = { r: 193, g: 146, b: 86 }) {
    const m = String(hex).trim().match(/^#?([0-9a-fA-F]{6})$/);
    if (!m) return fallback;
    const n = parseInt(m[1], 16);
    return { r: (n >> 16) & 255, g: (n >> 8) & 255, b: n & 255 };
  }

  function shadeRgba(hex, amt, alpha) {
    const rgb = hexToRgbStrict(hex);
    const r = clamp(Math.round(rgb.r + 255 * amt), 0, 255);
    const g = clamp(Math.round(rgb.g + 255 * amt), 0, 255);
    const b = clamp(Math.round(rgb.b + 255 * amt), 0, 255);
    return 'rgba(' + r + ',' + g + ',' + b + ',' + alpha + ')';
  }

  // ===== Floor patterns =====
  function fillBrickRectScreenOn(targetCtx, rect, color, worldX = 0, worldY = 0) {
    // Chunky masonry, WORLD-anchored.
    const brickW = 9;
    const brickH = 4;
    const gap = 1.2;
    const radius = 1.5;
    const strokeW = 0.8;

    const pitchX = brickW + gap;
    const pitchY = brickH + gap;

    const hexToRgb = (hex) => {
      const m = String(hex).trim().match(/^#?([0-9a-fA-F]{6})$/);
      if (!m) return { r: 102, g: 102, b: 102 };
      const n = parseInt(m[1], 16);
      return { r: (n >> 16) & 255, g: (n >> 8) & 255, b: n & 255 };
    };

    const clamp255 = (v) => Math.max(0, Math.min(255, v));

    const shade = (hex, amt) => {
      const rgb = hexToRgb(hex);
      return 'rgb(' +
        clamp255(Math.round(rgb.r + 255 * amt)) + ',' +
        clamp255(Math.round(rgb.g + 255 * amt)) + ',' +
        clamp255(Math.round(rgb.b + 255 * amt)) +
      ')';
    };

    const mortarColor = shade(color, -0.10);
    const brickFill = shade(color, +0.06);

    targetCtx.save();

    targetCtx.beginPath();
    targetCtx.rect(rect.x, rect.y, rect.w, rect.h);
    targetCtx.clip();

    targetCtx.fillStyle = mortarColor;
    targetCtx.fillRect(rect.x, rect.y, rect.w, rect.h);

    const phaseX = mod(worldX, pitchX);
    const phaseY = mod(worldY, pitchY);

    const startY = rect.y - (phaseY + pitchY);

    targetCtx.fillStyle = brickFill;
    targetCtx.strokeStyle = 'rgba(0,0,0,0.14)';
    targetCtx.lineWidth = strokeW;

    const rows = Math.ceil((rect.h + pitchY * 2) / pitchY);
    for (let rr = 0; rr < rows; rr++) {
      const y = startY + rr * pitchY;
      const rowOffset = (rr & 1) ? (pitchX / 2) : 0;

      const startX = rect.x - (phaseX + pitchX) + rowOffset;
      const cols = Math.ceil((rect.w + pitchX * 2) / pitchX);

      for (let cc = 0; cc < cols; cc++) {
        const x = startX + cc * pitchX;
        roundRectPath(targetCtx, x, y, brickW, brickH, radius);
        targetCtx.fill();
        targetCtx.stroke();
      }
    }

    targetCtx.restore();
  }

  function fillCobbleRectScreenOn(targetCtx, rect, opts) {
    const base = (opts && opts.baseHex) ? opts.baseHex : COLORS.floorCobbleBase;
    const alpha = (opts && Number.isFinite(opts.alpha)) ? opts.alpha : 1.0;
    const worldX = (opts && Number.isFinite(opts.worldX)) ? opts.worldX : 0;
    const worldY = (opts && Number.isFinite(opts.worldY)) ? opts.worldY : 0;
    const seed = (opts && Number.isFinite(opts.seed)) ? opts.seed : 12345;

    const stoneMin = (opts && Number.isFinite(opts.stoneMin)) ? opts.stoneMin : 4;
    const stoneMax = (opts && Number.isFinite(opts.stoneMax)) ? opts.stoneMax : 7;
    const gap = (opts && Number.isFinite(opts.gap)) ? opts.gap : 0.8;

    const pitch = stoneMax + gap;

    const mortar = shadeRgba(base, +0.28, alpha);
    const edge = 'rgba(0,0,0,0.10)';

    targetCtx.save();

    targetCtx.beginPath();
    targetCtx.rect(rect.x, rect.y, rect.w, rect.h);
    targetCtx.clip();

    targetCtx.fillStyle = mortar;
    targetCtx.fillRect(rect.x, rect.y, rect.w, rect.h);

    const phaseX = mod(worldX, pitch);
    const phaseY = mod(worldY, pitch);

    const startX = rect.x - (phaseX + pitch);
    const startY = rect.y - (phaseY + pitch);

    const cols = Math.ceil((rect.w + pitch * 2) / pitch);
    const rows = Math.ceil((rect.h + pitch * 2) / pitch);

    targetCtx.strokeStyle = edge;
    targetCtx.lineWidth = 1;

    for (let ry = 0; ry < rows; ry++) {
      for (let cx = 0; cx < cols; cx++) {
        const cellX = startX + cx * pitch;
        const cellY = startY + ry * pitch;

        const cellSeed = (seed + cx * 131 + ry * 977) >>> 0;
        const rnd = mulberry32(cellSeed);

        const w = stoneMin + rnd() * (stoneMax - stoneMin);
        const h = stoneMin + rnd() * (stoneMax - stoneMin);

        const ox = (rnd() - 0.5) * (gap * 1.6);
        const oy = (rnd() - 0.5) * (gap * 1.6);
        const rot = (rnd() - 0.5) * 0.25;

        const x = cellX + (pitch / 2) + ox;
        const y = cellY + (pitch / 2) + oy;

        const shadeAmt = +0.20 + (rnd() - 0.5) * 0.06;
        const fill = shadeRgba(base, shadeAmt, alpha);

        const rr = 2.2 + rnd() * 3.6;

        targetCtx.save();
        targetCtx.translate(x, y);
        targetCtx.rotate(rot);

        targetCtx.fillStyle = fill;
        roundRectPath(targetCtx, -w / 2, -h / 2, w, h, rr);
        targetCtx.fill();
        targetCtx.stroke();

        targetCtx.strokeStyle = 'rgba(255,255,255,0.06)';
        targetCtx.beginPath();
        targetCtx.moveTo(-w / 2 + rr, -h / 2 + 1);
        targetCtx.lineTo(w / 2 - rr, -h / 2 + 1);
        targetCtx.stroke();

        targetCtx.restore();

        targetCtx.strokeStyle = edge;
      }
    }

    targetCtx.restore();
  }

  function fillWoodPlanksRectScreenOn(targetCtx, rect, opts) {
    const base = (opts && opts.baseHex) ? opts.baseHex : '#c19256';
    const alpha = (opts && Number.isFinite(opts.alpha)) ? opts.alpha : 1.0;
    const worldX = (opts && Number.isFinite(opts.worldX)) ? opts.worldX : 0;
    const worldY = (opts && Number.isFinite(opts.worldY)) ? opts.worldY : 0;
    const seed = (opts && Number.isFinite(opts.seed)) ? opts.seed : 12345;
    const variant = (opts && Number.isFinite(opts.variant)) ? opts.variant : 3;

    const contrast = 0.04;
    const seamAlpha = 0.06;
    const grainAlpha = 0.04;
    const knotChance = 0.06;

    const plankH = (opts && Number.isFinite(opts.plankH)) ? opts.plankH : 18;
    const gapY = (opts && Number.isFinite(opts.gapY)) ? opts.gapY : 2.2;
    const gapX = (opts && Number.isFinite(opts.gapX)) ? opts.gapX : 1.8;

    const minL = (opts && Number.isFinite(opts.minL)) ? opts.minL : 110;
    const maxL = (opts && Number.isFinite(opts.maxL)) ? opts.maxL : 240;

    const pitchY = plankH + gapY;

    const phaseY = mod(worldY, pitchY);
    const startY = rect.y - (phaseY + pitchY);

    const phasePeriodX = 600;
    const phaseX = mod(worldX, phasePeriodX);

    targetCtx.save();

    targetCtx.beginPath();
    targetCtx.rect(rect.x, rect.y, rect.w, rect.h);
    targetCtx.clip();

    targetCtx.fillStyle = shadeRgba(base, -0.03, alpha);
    targetCtx.fillRect(rect.x, rect.y, rect.w, rect.h);

    const rows = Math.ceil((rect.h + pitchY * 2) / pitchY);

    for (let r = 0; r < rows; r++) {
      const y = startY + r * pitchY;

      const rowSeed = (seed + r * 1013) >>> 0;
      const rrnd = mulberry32(rowSeed);

      const baseOffset = (r & 1) ? (minL * 0.42) : 0;
      const wobble = (rrnd() - 0.5) * 30;
      const rowOffset = baseOffset + wobble + (phaseX * 0.12);

      let x = rect.x - rowOffset;
      const xEnd = rect.x + rect.w + maxL;

      targetCtx.fillStyle = 'rgba(0,0,0,' + seamAlpha + ')';
      targetCtx.fillRect(rect.x, y + plankH, rect.w, gapY);

      while (x < xEnd) {
        const len = Math.floor(minL + rrnd() * (maxL - minL));

        const v = (rrnd() - 0.5) * 2;
        const shadeAmt = v * contrast;

        const px1 = x;
        const px2 = x + len;
        const visX1 = Math.max(px1, rect.x);
        const visX2 = Math.min(px2, rect.x + rect.w);
        const visW = visX2 - visX1;

        if (visW > 0) {
          targetCtx.fillStyle = shadeRgba(base, shadeAmt, alpha);
          targetCtx.fillRect(visX1, y, visW, plankH);

          const grainCount = 1 + Math.floor(rrnd() * 3);
          targetCtx.strokeStyle = 'rgba(0,0,0,' + grainAlpha + ')';
          targetCtx.lineWidth = 1;
          for (let g = 0; g < grainCount; g++) {
            const yy = y + 2 + rrnd() * (plankH - 4);
            const amp = 1.3 + rrnd() * 2.0;
            const freq = 0.008 + rrnd() * 0.01;
            const ph = rrnd() * Math.PI * 2;

            targetCtx.beginPath();
            const gx0 = visX1 - 10;
            const gx1 = visX1 + visW + 10;
            targetCtx.moveTo(gx0, yy);
            const step = 28;
            for (let gx = gx0; gx <= gx1; gx += step) {
              const wob = Math.sin((gx + worldX) * freq + ph) * amp;
              targetCtx.lineTo(gx, yy + wob);
            }
            targetCtx.stroke();
          }

          if (px1 >= rect.x - 1 && px1 <= rect.x + rect.w + 1) {
            targetCtx.fillStyle = 'rgba(0,0,0,' + (seamAlpha * 0.50) + ')';
            targetCtx.fillRect(px1 - (gapX / 2), y + 1, gapX, plankH - 2);
          }

          if (rrnd() < knotChance) {
            const kx = visX1 + rrnd() * visW;
            const ky = y + 3 + rrnd() * (plankH - 6);
            const kr = 2.2 + rrnd() * 4.2;

            targetCtx.fillStyle = 'rgba(0,0,0,0.10)';
            targetCtx.beginPath();
            targetCtx.ellipse(kx, ky, kr * 1.15, kr * 0.85, rrnd() * Math.PI, 0, Math.PI * 2);
            targetCtx.fill();

            targetCtx.strokeStyle = 'rgba(0,0,0,0.10)';
            targetCtx.beginPath();
            targetCtx.ellipse(kx, ky, kr * 0.9, kr * 0.65, rrnd() * Math.PI, 0, Math.PI * 2);
            targetCtx.stroke();
          }

          if (variant >= 3 && rrnd() < 0.06) {
            const sc = 1 + Math.floor(rrnd() * 3);
            targetCtx.strokeStyle = 'rgba(255,255,255,0.10)';
            targetCtx.lineWidth = 1;
            for (let s = 0; s < sc; s++) {
              const sx = visX1 + rrnd() * visW;
              const sy = y + 2 + rrnd() * (plankH - 4);
              const slen = 18 + rrnd() * 40;
              targetCtx.beginPath();
              targetCtx.moveTo(sx, sy);
              targetCtx.lineTo(sx + slen, sy + (rrnd() - 0.5) * 2);
              targetCtx.stroke();
            }
          }
        }

        x += len + gapX;
      }

      if (variant >= 3) {
        targetCtx.fillStyle = 'rgba(255,255,255,0.02)';
        targetCtx.fillRect(rect.x, y, rect.w, 1);
      }
    }

    targetCtx.restore();
  }

  function fillStairsWoodRectScreenOn(targetCtx, rect, opts) {
    // Procedural top-down stairs "going down".
    // Treads along the run axis; tread cross-size shrinks toward the down end.
    //  - symmetric taper around the midline
    //  - end landing pad (default 25px)
    //  - WORLD-anchored phase on run axis so it doesn’t “swim” while panning

    const base = (opts && opts.baseHex) ? opts.baseHex : COLORS.floorWoodBase;
    const alpha = (opts && Number.isFinite(opts.alpha)) ? opts.alpha : 1.0;

    const worldX = (opts && Number.isFinite(opts.worldX)) ? opts.worldX : 0;
    const worldY = (opts && Number.isFinite(opts.worldY)) ? opts.worldY : 0;

    let down = (opts && opts.down) ? String(opts.down).toUpperCase() : 'S';
    if (!['N','S','E','W'].includes(down)) down = 'S';

    // Back-compat param names.
    const tread = Number.isFinite(opts && opts.tread) ? opts.tread
      : Number.isFinite(opts && opts.treadDepth) ? opts.treadDepth
      : 10;

    const gap = Number.isFinite(opts && opts.gap) ? opts.gap
      : Number.isFinite(opts && opts.treadGap) ? opts.treadGap
      : 2;

    const pitch = tread + gap;

    const minFactor = Number.isFinite(opts && opts.minFactor) ? opts.minFactor : 0.26;
    const maxFactor = Number.isFinite(opts && opts.maxFactor) ? opts.maxFactor : 1.00;

    const endPadRaw = Number.isFinite(opts && opts.endPad) ? opts.endPad : 25;

    const axis = (down === 'E' || down === 'W') ? 'x' : 'y';
    const runLen = (axis === 'x') ? rect.w : rect.h;
    const crossSpan = (axis === 'x') ? rect.h : rect.w;

    const endPad = clamp(endPadRaw, 0, Math.max(0, (runLen / 2) - 1));

    const runStart = (axis === 'x' ? rect.x : rect.y) + endPad;
    const runEnd   = (axis === 'x' ? (rect.x + rect.w) : (rect.y + rect.h)) - endPad;
    const runLenEff = Math.max(1, runEnd - runStart);

    // 0 at UP end, 1 at DOWN end.
    const tDownFromU = (u) => (down === 'E' || down === 'S') ? u : (1 - u);

    targetCtx.save();

    targetCtx.beginPath();
    targetCtx.rect(rect.x, rect.y, rect.w, rect.h);
    targetCtx.clip();

    targetCtx.fillStyle = shadeRgba(base, -0.015, alpha);
    targetCtx.fillRect(rect.x, rect.y, rect.w, rect.h);

    targetCtx.strokeStyle = 'rgba(0,0,0,0.18)';
    targetCtx.lineWidth = 1;
    targetCtx.strokeRect(rect.x + 0.5, rect.y + 0.5, rect.w - 1, rect.h - 1);

    const phase = mod((axis === 'x') ? worldX : worldY, pitch);
    const start = runStart - (phase + pitch);

    const steps = Math.max(1, Math.ceil((runLenEff + pitch * 2) / pitch));

    const stroke = (opts && opts.stroke != null) ? String(opts.stroke) : 'rgba(0,0,0,0.55)';
    const lineWidth = Number.isFinite(opts && opts.lineWidth) ? opts.lineWidth : 1;

    targetCtx.lineWidth = lineWidth;

    for (let i = 0; i < steps; i++) {
      const pos = start + i * pitch;

      // Enforce end landing pad.
      if (pos < runStart) continue;
      if ((pos + tread) > runEnd) continue;

      const treadCenter = pos + tread / 2;
      const u = clamp((treadCenter - runStart) / runLenEff, 0, 1);
      const tDown = tDownFromU(u);

      const factor = maxFactor + (minFactor - maxFactor) * tDown;
      const crossSize = clamp(crossSpan * factor, 2, crossSpan);

      let x, y, w, h;
      if (axis === 'x') {
        x = pos;
        y = rect.y + (rect.h - crossSize) / 2;
        w = tread;
        h = crossSize;
      } else {
        x = rect.x + (rect.w - crossSize) / 2;
        y = pos;
        w = crossSize;
        h = tread;
      }

      const shadeAmt = 0.02 - tDown * 0.08;
      targetCtx.fillStyle = shadeRgba(base, shadeAmt, alpha);
      targetCtx.fillRect(x, y, w, h);

      if (gap > 0.2) {
        targetCtx.fillStyle = 'rgba(0,0,0,0.14)';
        if (axis === 'x') targetCtx.fillRect(x + w, y, Math.min(gap, 3), h);
        else targetCtx.fillRect(x, y + h, w, Math.min(gap, 3));
      }

      targetCtx.strokeStyle = stroke;
      targetCtx.strokeRect(x + 0.5, y + 0.5, Math.max(0, w - 1), Math.max(0, h - 1));

      targetCtx.fillStyle = 'rgba(255,255,255,0.06)';
      if (axis === 'x') targetCtx.fillRect(x + 1, y + 1, Math.max(0, w - 2), 1);
      else targetCtx.fillRect(x + 1, y + 1, 1, Math.max(0, h - 2));
    }

    targetCtx.restore();
  }

  function roomFloorRectWorld(room, box) {
    const hasWalls = roomHasWalls(room);
    const src = hasWalls ? box.inner : box.outer;
    return { x1: src.x1, y1: src.y1, x2: src.x2, y2: src.y2 };
  }

  // ===== Fog of War (room-based) =====
  function normalizeFog(state) {
    const raw = (state && typeof state.fog === 'object' && state.fog) ? state.fog : null;

    const enabled = !!(raw && raw.enabled);
    const mode = raw && raw.mode ? String(raw.mode) : 'room';

    const maxDepth = Number.isFinite(raw && raw.maxDepth) ? Number(raw.maxDepth) : 1;
    const autoCompute = (raw && raw.autoCompute === false) ? false : true;
    const autoExplore = (raw && raw.autoExplore === false) ? false : true;

    const unseenAlpha = Number.isFinite(raw && raw.unseenAlpha) ? Number(raw.unseenAlpha) : 0.92;
    const exploredAlpha = Number.isFinite(raw && raw.exploredAlpha) ? Number(raw.exploredAlpha) : 0.55;

    const visibleRoomIds = Array.isArray(raw && raw.visibleRoomIds) ? raw.visibleRoomIds.map(x => String(x)) : [];
    const exploredRoomIds = Array.isArray(raw && raw.exploredRoomIds) ? raw.exploredRoomIds.map(x => String(x)) : [];

    return { enabled, mode, maxDepth, autoCompute, autoExplore, unseenAlpha, exploredAlpha, visibleRoomIds, exploredRoomIds, raw };
  }

  function roomAreaFromBounds(b) {
    return (b.maxCol - b.minCol + 1) * (b.maxRow - b.minRow + 1);
  }

  function buildRoomMeta(rooms) {
    const meta = [];
    for (const r of rooms) {
      if (!r || !r.id || !Array.isArray(r.corners)) continue;
      try {
        const b = cornersToBounds(r.corners);
        meta.push({
          id: String(r.id),
          room: r,
          bounds: b,
          area: roomAreaFromBounds(b),
          hasWalls: roomHasWalls(r),
        });
      } catch {
        // ignore malformed rooms
      }
    }
    return meta;
  }

  function pickMostSpecificRoomIdAt(roomMeta, col, row) {
    let best = null;
    let bestArea = Infinity;
    let bestWallRank = Infinity;

    for (const m of roomMeta) {
      const b = m.bounds;
      if (col < b.minCol || col > b.maxCol || row < b.minRow || row > b.maxRow) continue;

      const wallRank = m.hasWalls ? 0 : 1;
      if (m.area < bestArea || (m.area === bestArea && wallRank < bestWallRank)) {
        best = m.id;
        bestArea = m.area;
        bestWallRank = wallRank;
      }
    }

    return best;
  }

  function pickMostSpecificRoomIdForHex(roomMeta, hex) {
    try {
      const p = parseHexId(hex);
      return pickMostSpecificRoomIdAt(roomMeta, p.col, p.row);
    } catch {
      return null;
    }
  }

  function isPlayerToken(t) {
    const side = String(t && t.side ? t.side : '').toUpperCase();
    return side === 'PC' || side === 'PLAYER';
  }

  function getPlayerTokens(state) {
    const tokens = Array.isArray(state.tokens) ? state.tokens : [];
    return tokens.filter(t => {
      const side = String(t.side || '').toUpperCase();
      return side === 'PC' || side === 'PLAYER';
    });
  }

  function openingOrientation(o) {
    if (o && (o.orientation === 'h' || o.orientation === 'v')) return o.orientation;
    const rot = Number((o && o.rot) ? o.rot : 0) % 180;
    return (rot === 90) ? 'h' : 'v';
  }

  function normalizeDoorParams(opening, orient) {
    let state = String(opening && opening.state ? opening.state : '').toLowerCase();
    if (!state) {
      if (opening && opening.open === true) state = 'open';
      else if (opening && opening.open === false) state = 'closed';
      else state = 'closed';
    }
    if (state !== 'open' && state !== 'closed' && state !== 'ajar') state = 'closed';

    const isV = orient === 'v';

    const validOpensTo = isV ? new Set(['E', 'W']) : new Set(['N', 'S']);
    const validHinge = isV ? new Set(['N', 'S']) : new Set(['W', 'E']);

    let opensTo = String(opening && opening.opensTo ? opening.opensTo : '').toUpperCase();
    if (!validOpensTo.has(opensTo)) opensTo = isV ? 'E' : 'N';

    let hingeEnd = String(opening && opening.hingeEnd ? opening.hingeEnd : '').toUpperCase();
    if (!validHinge.has(hingeEnd)) hingeEnd = isV ? 'N' : 'W';

    let openPct = Number(opening && (opening.openPct ?? opening.openPercent ?? opening.openAmount));
    if (!Number.isFinite(openPct)) {
      openPct = (state === 'open') ? 1 : (state === 'ajar') ? 0.5 : 0;
    }
    openPct = clamp(openPct, 0, 1);

    return { state, opensTo, hingeEnd, openPct };
  }

  function normalizeWindowParams(opening, orient) {
    let state = String(opening && opening.state ? opening.state : '').toLowerCase();
    if (!state) {
      if (opening && opening.open === true) state = 'open';
      else if (opening && opening.open === false) state = 'closed';
      else state = 'closed';
    }
    if (state !== 'open' && state !== 'closed' && state !== 'ajar') state = 'closed';

    const isV = orient === 'v';
    const validOpensTo = isV ? new Set(['E', 'W']) : new Set(['N', 'S']);

    let opensTo = String(opening && opening.opensTo ? opening.opensTo : '').toUpperCase();
    if (!validOpensTo.has(opensTo)) opensTo = isV ? 'W' : 'S';

    let openPct = Number(opening && (opening.openPct ?? opening.openPercent ?? opening.openAmount));
    if (!Number.isFinite(openPct)) {
      openPct = (state === 'open') ? 1 : (state === 'ajar') ? 0.5 : 0;
    }
    openPct = clamp(openPct, 0, 1);

    return { state, opensTo, openPct };
  }

  function openingIsSeeThrough(opening) {
    const kind = String(opening && opening.kind ? opening.kind : 'door').toLowerCase();
    const orient = openingOrientation(opening);

    if (kind === 'threshold' || kind === 'portal' || kind === 'connector') return true;

    if (kind === 'door') {
      const d = normalizeDoorParams(opening, orient);
      return d.openPct > 0.05;
    }

    if (kind === 'window') {
      const w = normalizeWindowParams(opening, orient);
      return w.openPct > 0.05;
    }

    return false;
  }

  function openingTouchingRoomIds(opening, roomMeta) {
    if (!opening || !opening.hex) return { a: null, b: null };
    let p;
    try { p = parseHexId(opening.hex); } catch { return { a: null, b: null }; }

    const orient = openingOrientation(opening);

    let a = null;
    let b = null;
    if (orient === 'v') {
      a = pickMostSpecificRoomIdAt(roomMeta, p.col - 1, p.row);
      b = pickMostSpecificRoomIdAt(roomMeta, p.col + 1, p.row);
    } else {
      a = pickMostSpecificRoomIdAt(roomMeta, p.col, p.row + 1);
      b = pickMostSpecificRoomIdAt(roomMeta, p.col, p.row - 1);
    }

    return { a, b };
  }

  function isRenderableOpening(opening, roomMeta, renderableRoomIds) {
    const kind = String(opening && opening.kind ? opening.kind : 'door').toLowerCase();

    if (kind === 'portal' || kind === 'connector') return false;

    const { a, b } = openingTouchingRoomIds(opening, roomMeta);
    return (a && renderableRoomIds.has(a)) || (b && renderableRoomIds.has(b));
  }

  function buildAdjacency(roomMeta, openings) {
    const neighbors = new Map();

    const ensure = (id) => {
      if (!neighbors.has(id)) neighbors.set(id, new Set());
      return neighbors.get(id);
    };

    const addEdge = (a, b) => {
      if (!a || !b || a === b) return;
      ensure(a).add(b);
      ensure(b).add(a);
    };

    for (const m of roomMeta) ensure(m.id);

    // Connect through see-through openings.
    for (const o of openings) {
      if (!o || !o.hex) continue;
      if (!openingIsSeeThrough(o)) continue;

      let p;
      try { p = parseHexId(o.hex); } catch { continue; }
      const orient = openingOrientation(o);

      let a = null;
      let b = null;
      if (orient === 'v') {
        a = pickMostSpecificRoomIdAt(roomMeta, p.col - 1, p.row);
        b = pickMostSpecificRoomIdAt(roomMeta, p.col + 1, p.row);
      } else {
        a = pickMostSpecificRoomIdAt(roomMeta, p.col, p.row + 1);
        b = pickMostSpecificRoomIdAt(roomMeta, p.col, p.row - 1);
      }

      addEdge(a, b);
    }

    return neighbors;
  }

  function computeRenderFog(state, rooms, openings) {
    const fog = normalizeFog(state);
    const roomMeta = buildRoomMeta(rooms);

    if (!fog.enabled || String(fog.mode).toLowerCase() !== 'room') {
      return {
        enabled: false,
        visible: new Set(),
        explored: new Set(),
        unseenAlpha: fog.unseenAlpha,
        exploredAlpha: fog.exploredAlpha,
      };
    }

    let visible = new Set();

    if (!fog.autoCompute && fog.visibleRoomIds.length) {
      visible = new Set(fog.visibleRoomIds);
    } else {
      const players = getPlayerTokens(state);
      const q = [];
      const seed = new Set();

      for (const t of players) {
        const rid = pickMostSpecificRoomIdForHex(roomMeta, t.hex);
        if (rid) seed.add(rid);
      }

      for (const rid of seed) {
        visible.add(rid);
        q.push({ id: rid, depth: 0 });
      }

      const neighbors = buildAdjacency(roomMeta, openings);
      const maxDepth = fog.maxDepth;

      while (q.length) {
        const cur = q.shift();
        if (!cur) break;
        if (cur.depth >= maxDepth) continue;

        const nbs = neighbors.get(cur.id);
        if (!nbs) continue;

        for (const nb of nbs) {
          if (!visible.has(nb)) {
            visible.add(nb);
            q.push({ id: nb, depth: cur.depth + 1 });
          }
        }
      }

      if (fog.raw) fog.raw.visibleRoomIds = Array.from(visible).sort();
    }

    const explored = new Set(fog.exploredRoomIds);
    if (fog.autoExplore) {
      for (const rid of visible) explored.add(rid);
      if (fog.raw) fog.raw.exploredRoomIds = Array.from(explored).sort();
    }

    return { enabled: true, visible, explored, unseenAlpha: fog.unseenAlpha, exploredAlpha: fog.exploredAlpha };
  }

  function shouldDrawToken(t, rooms) {
    if (!RENDER_FOG || !RENDER_FOG.enabled) return true;
    if (isPlayerToken(t)) return true;

    const rid = pickMostSpecificRoomIdForHex(buildRoomMeta(rooms), t.hex);
    if (!rid) return true;

    return RENDER_FOG.visible.has(rid);
  }

  // ===== Floors / Rooms =====
  function isFogFloorRoom(room) {
    const k = room && room.floor && room.floor.kind ? String(room.floor.kind).toLowerCase() : '';
    return k === 'fog';
  }

  function drawFloorsLayered(roomsToDraw) {
    const fogRooms = [];
    const otherRooms = [];

    for (const r of (Array.isArray(roomsToDraw) ? roomsToDraw : [])) {
      (isFogFloorRoom(r) ? fogRooms : otherRooms).push(r);
    }

    for (const r of fogRooms) drawRoomFloor(r);
    for (const r of otherRooms) drawRoomFloor(r);
  }

  function drawRoomFloor(room) {
    const box = roomToWallBox(room);

    const rawFloorKind = (room.floor && room.floor.kind) ? room.floor.kind : 'stone';
    const floorKind = (RENDER_OVERRIDES.floorKind && String(RENDER_OVERRIDES.floorKind).length)
      ? RENDER_OVERRIDES.floorKind
      : rawFloorKind;

    if (floorKind === 'none') return;

    const f = roomFloorRectWorld(room, box);

    const f1 = worldToScreen({ x: f.x1, y: f.y1 });
    const f2 = worldToScreen({ x: f.x2, y: f.y2 });

    const rect = { x: f1.x, y: f1.y, w: (f2.x - f1.x), h: (f2.y - f1.y) };

    // Fog-floor rooms are a base layer for Fog of War. If fog is OFF, skip them.
    if (String(floorKind).toLowerCase() === 'fog') {
      if (!(RENDER_FOG && RENDER_FOG.enabled)) return;
      ctx.fillStyle = COLORS.fogUnseen;
      ctx.fillRect(rect.x, rect.y, rect.w, rect.h);
      return;
    }

    if (floorKind === 'wood') {
      const seed = hashStringToSeed(room.id || JSON.stringify(room.corners || []));
      fillWoodPlanksRectScreenOn(ctx, rect, {
        baseHex: COLORS.floorWoodBase,
        alpha: 1.0,
        worldX: f.x1,
        worldY: f.y1,
        seed,
        variant: 3,
        plankH: 18,
        gapY: 2,
        gapX: 2,
      });
      return;
    }

    if (floorKind === 'cobble') {
      const seed = hashStringToSeed('cobble:' + (room.id || JSON.stringify(room.corners || [])));
      fillCobbleRectScreenOn(ctx, rect, {
        baseHex: COLORS.floorCobbleBase,
        alpha: 1.0,
        worldX: f.x1,
        worldY: f.y1,
        seed,
        stoneMin: 4,
        stoneMax: 7,
        gap: 0.8,
      });
      return;
    }

    if (floorKind === 'stairs.wood') {
      const seed = hashStringToSeed('stairs:' + (room.id || JSON.stringify(room.corners || [])));
      fillStairsWoodRectScreenOn(ctx, rect, {
        baseHex: COLORS.floorWoodBase,
        alpha: 1.0,
        worldX: f.x1,
        worldY: f.y1,
        seed,
        down: room.stairsDown || 'S',
        treadDepth: 10,
        treadGap: 1.2,
      });
      return;
    }

    ctx.fillStyle = COLORS.floorStone;
    ctx.fillRect(rect.x, rect.y, rect.w, rect.h);
  }

  // ===== Walls =====
  function drawRoomWalls(targetCtx, room) {
    if (!roomHasWalls(room)) return;
    const box = roomToWallBox(room);
    const wallColor = room.color || COLORS.wall;

    const o1 = worldToScreen({ x: box.outer.x1, y: box.outer.y1 });
    const o2 = worldToScreen({ x: box.outer.x2, y: box.outer.y2 });

    const t = box.thickness;

    fillBrickRectScreenOn(targetCtx, { x: o1.x, y: o1.y,     w: o2.x - o1.x, h: t }, wallColor, box.outer.x1, box.outer.y1);
    fillBrickRectScreenOn(targetCtx, { x: o1.x, y: o2.y - t, w: o2.x - o1.x, h: t }, wallColor, box.outer.x1, box.outer.y2 - t);
    fillBrickRectScreenOn(targetCtx, { x: o1.x, y: o1.y + t, w: t, h: (o2.y - o1.y) - 2 * t }, wallColor, box.outer.x1, box.outer.y1 + t);
    fillBrickRectScreenOn(targetCtx, { x: o2.x - t, y: o1.y + t, w: t, h: (o2.y - o1.y) - 2 * t }, wallColor, box.outer.x2 - t, box.outer.y1 + t);
  }

  // ===== Openings: placement helpers =====
  function findNearestWallSegment(segs, orient, worldPoint) {
    let best = null;
    let bestD = Infinity;

    for (const s of segs) {
      if (s.orientation !== orient) continue;
      if (orient === 'h') {
        if (worldPoint.x < Math.min(s.x1, s.x2) - 1 || worldPoint.x > Math.max(s.x1, s.x2) + 1) continue;
        const d = Math.abs(worldPoint.y - s.y);
        if (d < bestD) { bestD = d; best = s; }
      } else {
        if (worldPoint.y < Math.min(s.y1, s.y2) - 1 || worldPoint.y > Math.max(s.y1, s.y2) + 1) continue;
        const d = Math.abs(worldPoint.x - s.x);
        if (d < bestD) { bestD = d; best = s; }
      }
    }

    return best;
  }

  function openingKnockoutSpan(opening) {
    const kind = String(opening && opening.kind ? opening.kind : 'door').toLowerCase();
    const orient = openingOrientation(opening);
    if (kind === 'threshold') return (orient === 'v') ? 1.5 : 1.0;
    return 1.0;
  }

  function findRoomById(rooms, id) {
    const want = String(id || '');
    if (!want) return null;
    for (const r of (Array.isArray(rooms) ? rooms : [])) {
      if (r && String(r.id || '') === want) return r;
    }
    return null;
  }

  function thresholdKnockoutFromParent(opening, rooms, wallSegs) {
    const parentId = opening && opening.parent ? String(opening.parent) : '';
    if (!parentId) return null;

    const room = findRoomById(rooms, parentId);
    if (!room) return null;

    let p;
    try { p = parseHexId(opening.hex); } catch { return null; }

    const orient = openingOrientation(opening);
    const hexWorld = hexCenterWorld(p.col, p.row);

    const box = roomToWallBox(room);

    const seg = findNearestWallSegment(wallSegs || [], orient, hexWorld);
    const thickness = seg ? seg.thickness : Math.max(1, Number(room.thickness || 28));

    if (orient === 'v') {
      const dL = Math.abs(hexWorld.x - box.xL);
      const dR = Math.abs(hexWorld.x - box.xR);
      const cx = (dL <= dR) ? box.xL : box.xR;

      const cy = (box.inner.y1 + box.inner.y2) / 2;
      const len = Math.max(6, (box.inner.y2 - box.inner.y1));

      return { orient, cx, cy, len, thickness };
    }

    // orient === 'h'
    const dT = Math.abs(hexWorld.y - box.yTop);
    const dB = Math.abs(hexWorld.y - box.yBot);
    const cy = (dT <= dB) ? box.yTop : box.yBot;

    const cx = (box.inner.x1 + box.inner.x2) / 2;
    const len = Math.max(6, (box.inner.x2 - box.inner.x1));

    return { orient, cx, cy, len, thickness };
  }

  function paintThresholdUnderlay(opening, rooms, wallSegs) {
    const kind = String(opening && opening.kind ? opening.kind : '').toLowerCase();
    if (kind !== 'threshold') return;

    const parentId = opening && opening.parent ? String(opening.parent) : '';
    if (!parentId) return;

    const parentRoom = findRoomById(rooms, parentId);
    if (!parentRoom) return;

    const spec = thresholdKnockoutFromParent(opening, rooms, wallSegs);
    if (!spec) return;

    const orient = openingOrientation(opening);
    const centerS = worldToScreen({ x: spec.cx, y: spec.cy });

    // Must match the knockout rect in cutOpeningHole() so the revealed span reads as continuous floor.
    const cutH = spec.thickness + 6; // pad across thickness only
    const cutW = spec.len;           // no end-padding

    const rect = (orient === 'h')
      ? { x: centerS.x - cutW / 2, y: centerS.y - cutH / 2, w: cutW, h: cutH }
      : { x: centerS.x - cutH / 2, y: centerS.y - cutW / 2, w: cutH, h: cutW };

    const floorKind = (parentRoom.floor && parentRoom.floor.kind) ? String(parentRoom.floor.kind).toLowerCase() : 'wood';

    // Use the parent room’s floor anchoring so patterns line up with the hallway.
    const box = roomToWallBox(parentRoom);
    const f = roomFloorRectWorld(parentRoom, box);
    const worldX = f.x1;
    const worldY = f.y1;
    const seed = hashStringToSeed(parentRoom.id || JSON.stringify(parentRoom.corners || []));

    if (floorKind === 'stone') {
      ctx.fillStyle = COLORS.floorStone;
      ctx.fillRect(rect.x, rect.y, rect.w, rect.h);
      return;
    }

    if (floorKind === 'cobble') {
      fillCobbleRectScreenOn(ctx, rect, {
        baseHex: COLORS.floorCobbleBase,
        alpha: 1.0,
        worldX,
        worldY,
        seed,
        stoneMin: 4,
        stoneMax: 7,
        gap: 0.8,
      });
      return;
    }

    if (floorKind === 'stairs.wood') {
      fillStairsWoodRectScreenOn(ctx, rect, {
        baseHex: COLORS.floorWoodBase,
        alpha: 1.0,
        worldX,
        worldY,
        seed,
        down: parentRoom.stairsDown || 'S',
        treadDepth: 10,
        treadGap: 1.2,
      });
      return;
    }

    if (floorKind === 'none') {
      ctx.fillStyle = '#f7f1e6';
      ctx.fillRect(rect.x, rect.y, rect.w, rect.h);
      return;
    }

    // Default: wood
    fillWoodPlanksRectScreenOn(ctx, rect, {
      baseHex: COLORS.floorWoodBase,
      alpha: 1.0,
      worldX,
      worldY,
      seed,
      variant: 3,
      plankH: 18,
      gapY: 2,
      gapX: 2,
    });
  }

  function cutOpeningHole(targetCtx, opening, wallSegs, roomsForSizing) {
    const kind = String(opening && opening.kind ? opening.kind : 'door').toLowerCase();
    if (kind === 'portal' || kind === 'connector') return;

    const orient = openingOrientation(opening);
    const p = parseHexId(opening.hex);

    const hexWorld = hexCenterWorld(p.col, p.row);

    // Parent-based threshold: punch out the full wall span for the parent hallway edge.
    if (kind === 'threshold') {
      const spec = thresholdKnockoutFromParent(opening, roomsForSizing, wallSegs);
      if (spec) {
        const centerS = worldToScreen({ x: spec.cx, y: spec.cy });

        const cutH = spec.thickness + 6;
        const cutW = spec.len;

        targetCtx.save();
        targetCtx.translate(centerS.x, centerS.y);
        if (orient === 'v') targetCtx.rotate(Math.PI / 2);

        targetCtx.beginPath();
        targetCtx.rect(-cutW / 2, -cutH / 2, cutW, cutH);
        targetCtx.fill();

        targetCtx.restore();
        return;
      }
    }

    const seg = findNearestWallSegment(wallSegs, orient, hexWorld);

    const baseLen = (GRID.size * 1.2);
    const span = openingKnockoutSpan(opening);
    const w = baseLen * span;

    let cx = hexWorld.x;
    let cy = hexWorld.y;
    let thickness = 28;

    if (seg) {
      thickness = seg.thickness;
      if (orient === 'h') cy = seg.y;
      else cx = seg.x;
    }

    const centerS = worldToScreen({ x: cx, y: cy });

    const cutH = thickness + 3;
    const cutW = w + 2;

    // For vertical thresholds: extend extra SOUTH (down-screen), not split north/south.
    let alongWallBias = 0;
    if (kind === 'threshold' && orient === 'v' && span > 1) {
      alongWallBias = ((span - 1) * baseLen) / 2;
    }

    targetCtx.save();
    targetCtx.translate(centerS.x, centerS.y);
    if (orient === 'v') {
      targetCtx.rotate(Math.PI / 2);
      if (alongWallBias) targetCtx.translate(alongWallBias, 0);
    }

    targetCtx.beginPath();
    targetCtx.rect(-cutW / 2, -cutH / 2, cutW, cutH);
    targetCtx.fill();

    targetCtx.restore();
  }

  function drawOpening(opening, wallSegs) {
    const kind = String(opening.kind || 'door').toLowerCase();

    // Invisible connectors: affect fog logic only.
    if (kind === 'threshold' || kind === 'portal' || kind === 'connector') return;

    const orient = openingOrientation(opening);
    const p = parseHexId(opening.hex);

    const hexWorld = hexCenterWorld(p.col, p.row);
    const seg = findNearestWallSegment(wallSegs, orient, hexWorld);

    const w = GRID.size * 1.2;
    const fallbackH = GRID.size * 0.55;

    let cx = hexWorld.x;
    let cy = hexWorld.y;
    let thickness = 28;

    if (seg) {
      thickness = seg.thickness;
      if (orient === 'h') cy = seg.y;
      else cx = seg.x;
    }

    const centerS = worldToScreen({ x: cx, y: cy });

    ctx.save();
    ctx.translate(centerS.x, centerS.y);
    if (orient === 'v') ctx.rotate(Math.PI / 2);

    const fill = (kind === 'window') ? COLORS.window : COLORS.door;
    const stroke = 'rgba(0,0,0,0.35)';
    const openingHBase = Math.min(thickness * 0.72, fallbackH);
    const openingH = openingHBase * 0.75;

    ctx.lineWidth = 2;

    if (kind === 'door') {
      const d = normalizeDoorParams(opening, orient);

      const hingeSide = ((orient === 'h' && d.hingeEnd === 'W') || (orient === 'v' && d.hingeEnd === 'N')) ? 'left' : 'right';
      const hingeX = (hingeSide === 'left') ? (-w / 2) : (w / 2);

      let desiredY = 1;
      if (orient === 'h') desiredY = (d.opensTo === 'S') ? 1 : -1;
      else desiredY = (d.opensTo === 'W') ? 1 : -1;

      const rotSign = desiredY * (hingeSide === 'left' ? 1 : -1);
      const angle = (Math.PI / 2) * d.openPct * rotSign;

      if (d.openPct <= 0.001) {
        ctx.fillStyle = fill;
        ctx.strokeStyle = stroke;
        ctx.beginPath();
        ctx.rect(-w / 2, -openingH / 2, w, openingH);
        ctx.fill();
        ctx.stroke();
      } else {
        const leafLen = w;
        const leafThick = Math.max(6, openingH * 0.92);

        ctx.save();
        ctx.translate(hingeX, 0);
        ctx.rotate(angle);

        ctx.fillStyle = fill;
        ctx.strokeStyle = stroke;

        const x0 = (hingeSide === 'left') ? 0 : -leafLen;
        ctx.beginPath();
        ctx.rect(x0, -leafThick / 2, leafLen, leafThick);
        ctx.fill();
        ctx.stroke();

        ctx.fillStyle = 'rgba(0,0,0,0.22)';
        ctx.beginPath();
        ctx.arc(0, 0, 2.2, 0, Math.PI * 2);
        ctx.fill();

        ctx.restore();
      }
    } else {
      const wv = normalizeWindowParams(opening, orient);

      if (wv.openPct <= 0.001) {
        ctx.fillStyle = fill;
        ctx.strokeStyle = stroke;

        ctx.beginPath();
        ctx.rect(-w / 2, -openingH / 2, w, openingH);
        ctx.fill();
        ctx.stroke();

        ctx.strokeStyle = 'rgba(0,0,0,0.25)';
        ctx.beginPath();
        ctx.moveTo(0, -openingH / 2 + 2);
        ctx.lineTo(0, openingH / 2 - 2);
        ctx.stroke();
      } else {
        const desiredY = (orient === 'h')
          ? (wv.opensTo === 'S' ? 1 : -1)
          : (wv.opensTo === 'W' ? 1 : -1);

        const maxAngle = (Math.PI / 3);

        const leafLen = w / 2;
        const leafThick = Math.max(5, openingH * 0.88);

        ctx.fillStyle = fill;
        ctx.strokeStyle = stroke;

        {
          const hingeX = -w / 2;
          const rotSign = desiredY * 1;
          const angle = maxAngle * wv.openPct * rotSign;

          ctx.save();
          ctx.translate(hingeX, 0);
          ctx.rotate(angle);
          ctx.beginPath();
          ctx.rect(0, -leafThick / 2, leafLen, leafThick);
          ctx.fill();
          ctx.stroke();

          ctx.fillStyle = 'rgba(0,0,0,0.18)';
          ctx.beginPath();
          ctx.arc(0, 0, 2.1, 0, Math.PI * 2);
          ctx.fill();
          ctx.restore();

          ctx.fillStyle = fill;
          ctx.strokeStyle = stroke;
        }

        {
          const hingeX = w / 2;
          const rotSign = desiredY * -1;
          const angle = maxAngle * wv.openPct * rotSign;

          ctx.save();
          ctx.translate(hingeX, 0);
          ctx.rotate(angle);
          ctx.beginPath();
          ctx.rect(-leafLen, -leafThick / 2, leafLen, leafThick);
          ctx.fill();
          ctx.stroke();

          ctx.fillStyle = 'rgba(0,0,0,0.18)';
          ctx.beginPath();
          ctx.arc(0, 0, 2.1, 0, Math.PI * 2);
          ctx.fill();
          ctx.restore();
        }
      }
    }

    ctx.restore();
  }

  // ===== Tokens =====
  function drawToken(t) {
    const p = parseHexId(t.hex);
    const cS = worldToScreen(hexCenterWorld(p.col, p.row));

    const isEnemy = String(t.side || '').toUpperCase().indexOf('EN') >= 0;
    const r = GRID.size * 0.42;

    ctx.beginPath();
    ctx.arc(cS.x, cS.y, r, 0, Math.PI * 2);
    ctx.fillStyle = isEnemy ? COLORS.tokenEnemy : COLORS.tokenHero;
    ctx.fill();

    ctx.lineWidth = 2;
    ctx.strokeStyle = 'rgba(0,0,0,0.2)';
    ctx.stroke();

    const label = (t.label != null) ? t.label : (t.name ? t.name[0] : '?');
    ctx.font = 'bold 14px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillStyle = isEnemy ? COLORS.tokenTextLight : 'rgba(255,255,255,0.95)';
    ctx.fillText(label, cS.x, cS.y);

    if (t.name) {
      ctx.font = '12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
      ctx.fillStyle = COLORS.tokenTextDark;
      ctx.fillText(t.name, cS.x, cS.y + r + 14);
    }
  }

  // ===== Grid range =====
  function estimateVisibleRange() {
    const pad = GRID.size * 4;
    const topLeftW = screenToWorld({ x: -pad, y: -pad });
    const botRightW = screenToWorld({ x: canvas.width + pad, y: canvas.height + pad });

    const minCol = Math.floor(Math.min(topLeftW.x, botRightW.x) / colStep()) - 2;
    const maxCol = Math.ceil(Math.max(topLeftW.x, botRightW.x) / colStep()) + 2;

    const minRow = Math.floor(-Math.max(topLeftW.y, botRightW.y) / rowStep()) - 4;
    const maxRow = Math.ceil(-Math.min(topLeftW.y, botRightW.y) / rowStep()) + 4;

    return {
      minCol: Math.max(-10, minCol),
      maxCol: Math.min(400, maxCol),
      minRow: Math.max(-10, minRow),
      maxRow: Math.min(400, maxRow)
    };
  }

  function drawGrid() {
    const range = estimateVisibleRange();

    ctx.save();
    ctx.lineWidth = GRID.lineWidth;
    ctx.strokeStyle = 'rgba(0,0,0,' + GRID.lineAlpha + ')';

    for (let col = range.minCol; col <= range.maxCol; col++) {
      for (let row = range.minRow; row <= range.maxRow; row++) {
        drawHexOutline(col, row);
      }
    }

    ctx.font = GRID.labelFont;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillStyle = 'rgba(0,0,0,' + GRID.labelAlpha + ')';

    for (let col = range.minCol; col <= range.maxCol; col++) {
      for (let row = range.minRow; row <= range.maxRow; row++) {
        drawHexLabel(col, row);
      }
    }

    ctx.restore();
  }

  // ===== Render pipeline =====
  function clear() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = '#fff';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
  }

  function escapeHtml(s) {
    return String(s)
      .replaceAll('&', '&amp;')
      .replaceAll('<', '&lt;')
      .replaceAll('>', '&gt;')
      .replaceAll('"', '&quot;')
      .replaceAll("'", '&#39;');
  }

  function updateSidebar(state) {
    const kvs = document.getElementById('kvs');
    if (!kvs) return;

    const meta = state.meta || {};
    const rooms = Array.isArray(state.rooms) ? state.rooms.length : 0;
    const openings = Array.isArray(state.openings) ? state.openings.length : 0;
    const tokens = Array.isArray(state.tokens) ? state.tokens.length : 0;

    const camHex = (state.view && state.view.camera_hex) ? state.view.camera_hex : hexId(VIEW.camera.col, VIEW.camera.row);
    const round = Number(meta.round != null ? meta.round : 1);

    const flatToFlatPx = rowStep();

    const fog = normalizeFog(state);
    const fogLabel = fog.enabled
      ? ('ON (' + fog.visibleRoomIds.length + ' vis / ' + fog.exploredRoomIds.length + ' exp)')
      : 'off';

    const lines = [
      ['Round', round],
      ['Camera', camHex],
      ['Rooms', rooms],
      ['Openings', openings],
      ['Tokens', tokens],
      ['Fog', fogLabel],
      ['Fog maxDepth', String(fog.maxDepth)],
      ['Hex px (flat↕︎)', flatToFlatPx.toFixed(1)],
    ];

    kvs.innerHTML = lines
      .map(([k, v]) => '<div>' + escapeHtml(k) + '</div><div style="color:var(--text); text-align:right;">' + escapeHtml(v) + '</div>')
      .join('');
  }

  function syncFogToggle(state) {
    const el = document.getElementById('fogToggle');
    if (!el) return;
    const enabled = !!(state && state.fog && state.fog.enabled);
    if (el.checked !== enabled) el.checked = enabled;
  }

  function populateCenterOn(state) {
    const sel = document.getElementById('centerOn');
    if (!sel) return;

    const players = getPlayerTokens(state);
    const wanted = VIEW.followTokenId || '';

    const opts = ['<option value="">None</option>'];
    for (const t of players) {
      const label = t.name ? t.name : t.id;
      opts.push('<option value="' + escapeHtml(t.id) + '">' + escapeHtml(label) + '</option>');
    }
    sel.innerHTML = opts.join('');

    sel.value = players.some(t => t.id === wanted) ? wanted : '';
    if (sel.value === '') VIEW.followTokenId = null;
  }

  function redraw() {
    const state = getState();

    if (!canvas.width || !canvas.height || !wallCanvas.width || !wallCanvas.height) {
      console.warn('[Battlemat] redraw skipped: canvas not sized yet');
      return;
    }

    populateCenterOn(state);
    syncFogToggle(state);

    if (VIEW.followTokenId) {
      const tokens = Array.isArray(state.tokens) ? state.tokens : [];
      const t = tokens.find(x => x.id === VIEW.followTokenId);
      if (t && t.hex) {
        try {
          const p = parseHexId(t.hex);
          VIEW.camera.col = p.col;
          VIEW.camera.row = p.row;
        } catch {
          VIEW.followTokenId = null;
          const sel = document.getElementById('centerOn');
          if (sel) sel.value = '';
        }
      }
    }

    clear();

    const rooms = Array.isArray(state.rooms) ? state.rooms : [];
    const openings = Array.isArray(state.openings) ? state.openings : [];
    const tokens = Array.isArray(state.tokens) ? state.tokens : [];

    // Compute Fog of War sets for this frame.
    RENDER_FOG = computeRenderFog(state, rooms, openings);

    // When fog is enabled, render ONLY what's in view, plus any base "fog" floor rooms.
    let roomsToDraw = rooms;
    let openingsToDraw = openings;

    if (RENDER_FOG && RENDER_FOG.enabled) {
      const roomMeta = buildRoomMeta(rooms);

      const baseFogRoomIds = new Set();
      for (const r of rooms) {
        const k = r && r.floor && r.floor.kind ? String(r.floor.kind).toLowerCase() : '';
        if (k === 'fog' && r && r.id) baseFogRoomIds.add(String(r.id));
      }

      const geometryRoomIds = new Set([...RENDER_FOG.visible]);

      roomsToDraw = rooms.filter(r => {
        const id = r && r.id ? String(r.id) : '';
        if (!id) return true;
        if (baseFogRoomIds.has(id)) return true;
        return geometryRoomIds.has(id);
      });

      openingsToDraw = openings.filter(o => isRenderableOpening(o, roomMeta, geometryRoomIds));
    }

    // Floors.
    drawFloorsLayered(roomsToDraw);

    // Walls are drawn only for rooms that contribute geometry this frame.
    const roomsForWalls = (RENDER_FOG && RENDER_FOG.enabled)
      ? roomsToDraw.filter(r => {
          const k = r && r.floor && r.floor.kind ? String(r.floor.kind).toLowerCase() : '';
          if (k === 'fog') return roomHasWalls(r);
          return true;
        })
      : roomsToDraw;

    const wallSegs = buildWallSegments(roomsForWalls);

    // Floor underlays for thresholds (to avoid “fog gray” showing through the knockout).
    for (const o of openingsToDraw) paintThresholdUnderlay(o, rooms, wallSegs);

    // Build walls into offscreen.
    wallCtx.save();
    wallCtx.setTransform(1, 0, 0, 1, 0, 0);
    wallCtx.clearRect(0, 0, wallCanvas.width, wallCanvas.height);
    wallCtx.restore();

    wallCtx.setTransform(VIEW.dpr, 0, 0, VIEW.dpr, 0, 0);

    for (const r of roomsForWalls) drawRoomWalls(wallCtx, r);

    // Punch openings out.
    wallCtx.save();
    wallCtx.globalCompositeOperation = 'destination-out';
    wallCtx.fillStyle = '#000';

    const knockoutAlphaFor = (o) => {
      const k = String(o && o.kind ? o.kind : 'door').toLowerCase();
      if (k === 'portal' || k === 'connector') return 0;
      if (k === 'threshold') return 1;
      return (k === 'window') ? 0.25 : 1;
    };

    for (const o of openingsToDraw) {
      wallCtx.globalAlpha = knockoutAlphaFor(o);
      cutOpeningHole(wallCtx, o, wallSegs, roomsForWalls);
    }

    wallCtx.restore();

    // Composite walls.
    ctx.save();
    ctx.setTransform(1, 0, 0, 1, 0, 0);
    ctx.drawImage(wallCanvas, 0, 0);
    ctx.restore();

    ctx.setTransform(VIEW.dpr, 0, 0, VIEW.dpr, 0, 0);

    // Visible openings.
    for (const o of openingsToDraw) drawOpening(o, wallSegs);

    // Tokens.
    for (const t of tokens) {
      if (shouldDrawToken(t, rooms)) drawToken(t);
    }

    // Grid.
    drawGrid();

    updateSidebar(state);
  }

  // ===== Tiny self-tests (console only) =====
  function runSelfTests() {
    try {
      if (typeof $1 === 'undefined') throw new Error('$1 defensive binding missing');

      const checkRoundTrip = (letters) => {
        const col = lettersToCol(letters);
        const back = colToLetters(col);
        if (back !== letters) throw new Error('Roundtrip failed: ' + letters + ' -> ' + col + ' -> ' + back);
      };

      checkRoundTrip('A');
      checkRoundTrip('Z');
      checkRoundTrip('AA');
      checkRoundTrip('DZ');

      const p = parseHexId('AA27');
      if (hexId(p.col, p.row) !== 'AA27') throw new Error('parseHexId/hexId mismatch for AA27');

      const r1 = mulberry32(123);
      const r2 = mulberry32(123);
      if (Math.abs(r1() - r2()) > 1e-12) throw new Error('mulberry32 not deterministic');

      // Adjacency: wall-less spaces must NOT auto-connect by touching bounds.
      {
        const dummyRooms = [
          { id: 'A', corners: ['B3','D3','D1','B1'], thickness: 20, floor: { kind: 'wood' }, wall: { kind: 'none' } },
          { id: 'B', corners: ['D3','F3','F1','D1'], thickness: 20, floor: { kind: 'wood' }, wall: { kind: 'none' } },
        ];
        const rm = buildRoomMeta(dummyRooms);
        const neigh = buildAdjacency(rm, []);
        const aN = neigh.get('A');
        if (aN && aN.has('B')) throw new Error('wall-less spaces should not auto-connect without an opening');
      }

      // Adjacency: a threshold opening SHOULD connect spaces.
      {
        const dummyRooms = [
          { id: 'A', corners: ['B3','D3','D1','B1'], thickness: 20, floor: { kind: 'wood' }, wall: { kind: 'none' } },
          { id: 'B', corners: ['D3','F3','F1','D1'], thickness: 20, floor: { kind: 'wood' }, wall: { kind: 'none' } },
        ];
        const rm = buildRoomMeta(dummyRooms);
        const dummyOpenings = [
          { id: 't', kind: 'threshold', hex: 'D2', orientation: 'v', state: 'open' },
        ];
        const neigh = buildAdjacency(rm, dummyOpenings);
        const aN = neigh.get('A');
        if (!aN || !aN.has('B')) throw new Error('threshold should connect spaces for adjacency');
      }

      // Knockout sizing: vertical thresholds should use a 1.5 span; horizontal should use 1.0.
      {
        const tv = { id: 't', kind: 'threshold', hex: 'D2', orientation: 'v', state: 'open' };
        const th = { id: 't2', kind: 'threshold', hex: 'D2', orientation: 'h', state: 'open' };
        if (Math.abs(openingKnockoutSpan(tv) - 1.5) > 1e-9) throw new Error('vertical threshold knockout span should be 1.5');
        if (Math.abs(openingKnockoutSpan(th) - 1.0) > 1e-9) throw new Error('horizontal threshold knockout span should be 1.0');

        const baseLen = (GRID.size * 1.2);
        const expectedBias = ((1.5 - 1) * baseLen) / 2;
        if (Math.abs(expectedBias - (0.25 * baseLen)) > 1e-9) throw new Error('vertical threshold expected bias math changed');
      }

      // Parent-based thresholds: knockout span should match the parent room's INNER floor span.
      {
        const parentRoom = { id: 'Hall', corners: ['B3','F3','F1','B1'], thickness: 20, floor: { kind: 'wood' }, wall: { kind: 'brick' } };
        const box = roomToWallBox(parentRoom);
        const expectV = (box.inner.y2 - box.inner.y1);
        const expectH = (box.inner.x2 - box.inner.x1);

        const tv = { id: 'tpv', kind: 'threshold', hex: 'B2', orientation: 'v', state: 'open', parent: 'Hall' };
        const th = { id: 'tph', kind: 'threshold', hex: 'D3', orientation: 'h', state: 'open', parent: 'Hall' };

        const sv = thresholdKnockoutFromParent(tv, [parentRoom], []);
        const sh = thresholdKnockoutFromParent(th, [parentRoom], []);

        if (!sv) throw new Error('parent vertical threshold spec missing');
        if (!sh) throw new Error('parent horizontal threshold spec missing');

        if (Math.abs(sv.len - expectV) > 0.001) throw new Error('parent vertical threshold len should equal inner height');
        if (Math.abs(sh.len - expectH) > 0.001) throw new Error('parent horizontal threshold len should equal inner width');
      }

      // Render filter: a door should be considered renderable if at least one side touches a renderable room.
      {
        const dummyRooms = [
          { id: 'Hall', corners: ['B3','D3','D1','B1'], thickness: 20, floor: { kind: 'wood' }, wall: { kind: 'brick' } },
          { id: 'Hidden', corners: ['D3','F3','F1','D1'], thickness: 20, floor: { kind: 'wood' }, wall: { kind: 'brick' } },
        ];
        const rm = buildRoomMeta(dummyRooms);
        const o = { id: 'd', kind: 'door', hex: 'D2', orientation: 'v', state: 'closed' };
        const renderable = new Set(['Hall']);
        if (!isRenderableOpening(o, rm, renderable)) throw new Error('door adjacent to renderable room should be renderable');
      }

      // Fog defaults: when maxDepth is omitted, normalizeFog should default to 1.
      {
        const f = normalizeFog({ fog: { enabled: true, mode: 'room' } });
        if (f.maxDepth !== 1) throw new Error('normalizeFog default maxDepth should be 1');
      }

      // cutOpeningHole smoke test.
      {
        const oc = document.createElement('canvas');
        oc.width = 64; oc.height = 64;
        const octx = oc.getContext('2d');
        VIEW.anchor.x = 0; VIEW.anchor.y = 0; VIEW.camera.col = 0; VIEW.camera.row = 0; VIEW.dx = 0; VIEW.dy = 0;
        cutOpeningHole(octx, { id: 't', kind: 'threshold', hex: 'A1', orientation: 'v', state: 'open' }, []);
      }

      // Stairs fill should not throw.
      {
        const oc = document.createElement('canvas');
        oc.width = 64; oc.height = 64;
        const octx = oc.getContext('2d');

        fillStairsWoodRectScreenOn(octx, { x: 0, y: 0, w: 64, h: 64 }, {
          baseHex: COLORS.floorWoodBase,
          alpha: 1.0,
          worldX: 0,
          worldY: 0,
          tread: 10,
          gap: 2,
          down: 'S'
        });

        fillStairsWoodRectScreenOn(octx, { x: 0, y: 0, w: 64, h: 64 }, {
          baseHex: COLORS.floorWoodBase,
          alpha: 1.0,
          worldX: 13,
          worldY: 29,
          seed: 1,
          treadDepth: 10,
          treadGap: 2,
          down: 'W'
        });
      }

      // Floor ordering: fog-floor rooms must be drawn first.
      {
        const fogRoom = { id: 'Fog', corners: ['B3','F3','F1','B1'], thickness: 20, floor: { kind: 'fog' }, wall: { kind: 'brick' } };
        const stairsRoom = { id: 'Stairs', corners: ['B3','F3','F1','B1'], thickness: 20, floor: { kind: 'stairs.wood' }, wall: { kind: 'brick' } };
        const woodRoom = { id: 'Wood', corners: ['B3','F3','F1','B1'], thickness: 20, floor: { kind: 'wood' }, wall: { kind: 'brick' } };

        const fogRooms = [];
        const otherRooms = [];
        for (const r of [woodRoom, stairsRoom, fogRoom]) (isFogFloorRoom(r) ? fogRooms : otherRooms).push(r);
        const ordered = fogRooms.concat(otherRooms).map(r => r.id);

        if (ordered[0] !== 'Fog') throw new Error('fog floor rooms should be first in floor render order');
      }

      console.log('[Battlemat] self-tests: OK');
    } catch (e) {
      console.warn('[Battlemat] self-tests: FAIL', e);
    }
  }

  // ===== UI =====
  function pan(dc, dr) {
    if (VIEW.followTokenId) {
      VIEW.followTokenId = null;
      const sel = document.getElementById('centerOn');
      if (sel) sel.value = '';
    }
    VIEW.camera.col += dc;
    VIEW.camera.row += dr;
    redraw();
  }

  function setCameraToHex(hex, opts = {}) {
    const manual = (opts.manual !== false);
    const p = parseHexId(hex);
    VIEW.camera.col = p.col;
    VIEW.camera.row = p.row;

    if (manual) {
      VIEW.followTokenId = null;
      const sel = document.getElementById('centerOn');
      if (sel) sel.value = '';
    }

    redraw();
  }

  function wireUI() {
    const req = (id) => {
      const el = document.getElementById(id);
      if (!el) console.warn('[Battlemat] missing control #' + id);
      return el;
    };

    const btnLeft = req('btnLeft');
    const btnRight = req('btnRight');
    const btnUp = req('btnUp');
    const btnDown = req('btnDown');
    const btnRedraw = req('btnRedraw');
    const btnJump = req('btnJump');
    const jumpHex = req('jumpHex');
    const centerOn = req('centerOn');
    const floorKind = document.getElementById('floorKind');
    const fogToggle = document.getElementById('fogToggle');

    if (btnLeft) btnLeft.addEventListener('click', () => pan(-PAN_STEP, 0));
    if (btnRight) btnRight.addEventListener('click', () => pan(PAN_STEP, 0));
    if (btnUp) btnUp.addEventListener('click', () => pan(0, PAN_STEP));
    if (btnDown) btnDown.addEventListener('click', () => pan(0, -PAN_STEP));

    if (btnRedraw) btnRedraw.addEventListener('click', redraw);

    if (centerOn) {
      centerOn.addEventListener('change', (e) => {
        const id = String(e.target.value || '');
        VIEW.followTokenId = id || null;

        if (VIEW.followTokenId) {
          const state = getState();
          const tokens = Array.isArray(state.tokens) ? state.tokens : [];
          const t = tokens.find(x => x.id === VIEW.followTokenId);
          if (t && t.hex) {
            try { setCameraToHex(t.hex, { manual: false }); } catch { /* ignore */ }
          }
        } else {
          redraw();
        }
      });
    }

    if (btnJump) {
      btnJump.addEventListener('click', () => {
        const v = (jumpHex && jumpHex.value) ? jumpHex.value.trim() : '';
        if (!v) return;
        try { setCameraToHex(v); } catch (e) { console.warn(e); }
      });
    }

    if (jumpHex && btnJump) {
      jumpHex.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') btnJump.click();
      });
    }

    if (floorKind) {
      floorKind.addEventListener('change', (e) => {
        const kind = String(e.target.value || '');
        RENDER_OVERRIDES.floorKind = kind;
        redraw();
      });
    }

    if (fogToggle) {
      fogToggle.addEventListener('change', (e) => {
        const state = getState();
        if (!state.fog) state.fog = {};
        state.fog.enabled = !!e.target.checked;
        redraw();
      });
    }

    window.addEventListener('keydown', (e) => {
      if (e.key === 'ArrowLeft') { e.preventDefault(); pan(-PAN_STEP, 0); }
      if (e.key === 'ArrowRight') { e.preventDefault(); pan(PAN_STEP, 0); }
      if (e.key === 'ArrowUp') { e.preventDefault(); pan(0, PAN_STEP); }
      if (e.key === 'ArrowDown') { e.preventDefault(); pan(0, -PAN_STEP); }
    });
  }

  function followCameraTick() {
    const state = getState();
    if (VIEW.followTokenId) {
      const tokens = Array.isArray(state.tokens) ? state.tokens : [];
      const t = tokens.find(x => x.id === VIEW.followTokenId);
      if (t && t.hex) {
        try {
          const p = parseHexId(t.hex);
          if (p.col !== VIEW.camera.col || p.row !== VIEW.camera.row) {
            VIEW.camera.col = p.col;
            VIEW.camera.row = p.row;
            redraw();
          }
        } catch {
          VIEW.followTokenId = null;
          const sel = document.getElementById('centerOn');
          if (sel) sel.value = '';
        }
      } else {
        VIEW.followTokenId = null;
        const sel = document.getElementById('centerOn');
        if (sel) sel.value = '';
      }
    }
    requestAnimationFrame(followCameraTick);
  }

  function resize() {
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    VIEW.dpr = dpr;

    const rect = canvas.getBoundingClientRect();

    canvas.width = Math.floor(rect.width * dpr);
    canvas.height = Math.floor(rect.height * dpr);

    wallCanvas.width = canvas.width;
    wallCanvas.height = canvas.height;

    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    wallCtx.setTransform(dpr, 0, 0, dpr, 0, 0);

    VIEW.anchor.x = rect.width / 2;
    VIEW.anchor.y = rect.height / 2;

    redraw();
  }

  function init() {
    const state = getState();
    if (state.view && state.view.camera_hex) {
      try {
        const p = parseHexId(state.view.camera_hex);
        VIEW.camera.col = p.col;
        VIEW.camera.row = p.row;
      } catch {
        // ignore
      }
    }

    // Ensure the floor selector starts in "Mixed" (no override) mode.
    {
      const fk = document.getElementById('floorKind');
      if (fk) fk.value = '';
      RENDER_OVERRIDES.floorKind = '';
    }

    wireUI();

    window.addEventListener('resize', resize);
    resize();

    runSelfTests();

    requestAnimationFrame(followCameraTick);
  }

  init();
})();
</script>
</body>
</html>
