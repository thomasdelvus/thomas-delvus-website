<!--
DEL VUS BATTLEMAT (Website / API-backed)

- This version does NOT embed a SCENE JSON block.
- It loads state from your API based on URL:
    https://www.delvus.net/play/<battle_id>
  Example:
    https://www.delvus.net/play/27

Expected API:
  GET /api/battle/<battle_id>
Response should include either:
  { state: { ...scene... } }
or
  { state_json: "{...scene...}" }
-->

<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Hex Battlemat</title>
  <style>
    body { margin:0; font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif; background:#f3f3f3; color:#111; }
    header { padding:10px 14px; border-bottom:1px solid rgba(0,0,0,0.12); background:#fff; font-weight:650; }
    main { padding:12px; overflow:hidden; }
    .layout { width:max-content; display:grid; grid-template-columns:940px 340px; gap:12px; align-items:stretch; margin:0 auto; }
    canvas { width:940px; height:750px; background:#d7d7d7; border:1px solid rgba(0,0,0,0.12); }
    aside { background:#fff; border:1px solid rgba(0,0,0,0.12); padding:10px; overflow:hidden; display:grid; grid-template-rows:auto 1fr; gap:10px; }
    .panel-title { display:flex; justify-content:space-between; align-items:baseline; gap:10px; }
    .panel-title h3 { margin:0; font-size:1rem; font-weight:650; }
    .subtle { opacity:.7; font-size:.9rem; white-space:nowrap; }
    .status-wrap { overflow:auto; border:1px solid rgba(0,0,0,0.10); }
    table { width:100%; border-collapse:collapse; font-size:.92rem; }
    thead th { position:sticky; top:0; background:#f6f6f6; text-align:left; font-weight:650; padding:8px 10px; border-bottom:1px solid rgba(0,0,0,0.10); }
    tbody td { padding:8px 10px; border-bottom:1px solid rgba(0,0,0,0.08); vertical-align:top; }
    .chip { display:inline-block; padding:2px 8px; border-radius:999px; margin:2px 6px 0 0; border:1px solid rgba(0,0,0,0.12); background:#f2f2f2; font-size:.82rem; white-space:nowrap; }
    .side-pc  { border-left:4px solid rgba(80,160,220,.85); }
    .side-en  { border-left:4px solid rgba(220,120,80,.85); }
    .side-npc { border-left:4px solid rgba(160,160,160,.85); }
    tr.dead { background:rgba(0,0,0,0.04); color:rgba(0,0,0,0.55); }
    tr.dead .subtle { opacity:.5; }
    tr.dead.side-pc, tr.dead.side-en, tr.dead.side-npc { border-left-color:rgba(120,120,120,.85); }
    .hp { font-variant-numeric:tabular-nums; white-space:nowrap; }

    .legend { margin-top:10px; padding-top:8px; border-top:1px solid rgba(0,0,0,0.12); font-size:.9rem; }
    .legend-title { font-weight:650; margin-bottom:6px; }
    .legend-list { list-style:none; padding:0; margin:0; display:grid; grid-template-columns:1fr 1fr; gap:6px 10px; }
    .legend-swatch {
      display:inline-flex; align-items:center; justify-content:center;
      width:20px; height:20px; margin-right:6px;
      border-radius:3px; vertical-align:middle;
      border:1px solid rgba(0,0,0,0.6);
      font-size:11px; font-weight:700; color:rgba(0,0,0,0.85);
      line-height:1;
    }
    .legend-swatch.door { background:#b07a3f; }
    .legend-swatch.window { background:#cfe6f6; }
    .legend-swatch.table { background:#b07a3f; border-radius:50%; }
    .legend-swatch.pc { background:rgba(80,160,220,0.95); border-radius:50%; }
    .legend-swatch.en { background:rgba(220,120,80,0.95); border-radius:50%; }

    /* Hex-shaped difficult swatch */
    .legend-swatch.hex {
      position:relative; z-index:0;
      border-radius:0;
      clip-path: polygon(25% 6%,75% 6%,100% 50%,75% 94%,25% 94%,0% 50%);
      border:none;
      background:rgba(120,120,120,0.08);
    }
    .legend-swatch.hex::before {
      content:""; position:absolute; inset:0;
      background:rgba(0,0,0,0.45);
      clip-path: inherit;
      transform: scale(1.12);
      z-index:-1;
    }
  </style>
</head>

<body>
  <header>Hex Battlemat</header>

  <main>
    <div class="layout">
      <canvas id="mat" width="940" height="750" aria-label="Hex battlemat"></canvas>

      <aside aria-label="Combat status panel">
        <div class="panel-title">
          <h3>Initiative &amp; Status</h3>
          <div class="subtle" id="roundLine">Loading…</div>
        </div>

        <div class="status-wrap">
          <table aria-label="Combatants">
            <thead>
              <tr>
                <th style="width: 52%">Actor</th>
                <th style="width: 18%">Init</th>
                <th style="width: 30%">HP</th>
              </tr>
            </thead>
            <tbody id="statusBody"></tbody>
          </table>
        </div>

        <div class="legend" aria-label="Map legend">
          <div class="legend-title">Key</div>
          <ul class="legend-list">
            <li><span class="legend-swatch door">D</span> Door</li>
            <li><span class="legend-swatch window">W</span> Window</li>
            <li><span class="legend-swatch table">T</span> Table <span class="subtle">(blocks)</span></li>
            <li><span class="legend-swatch hex">~</span> Difficult terrain</li>
            <li><span class="legend-swatch pc">A</span> Player</li>
            <li><span class="legend-swatch en">W</span> Enemy</li>
          </ul>
        </div>
      </aside>
    </div>
  </main>

  <script>
    // =====================================================================
    // WEBSITE BOOTSTRAP (API-backed SCENE)
    // =====================================================================

    // Extract battle_id from /play/<battle_id>
    function getBattleIdFromUrl() {
      const m = window.location.pathname.match(/\/play\/([^\/?#]+)/i);
      return m ? decodeURIComponent(m[1]) : null;
    }

    async function fetchBattle(battleId) {
      const res = await fetch(`/api/battle/${encodeURIComponent(battleId)}`, { method: 'GET' });
      if (!res.ok) throw new Error(`API ${res.status} ${res.statusText}`);
      return await res.json();
    }

    function coerceSceneFromApi(payload) {
      if (payload && typeof payload.state === 'object' && payload.state) return payload.state;
      if (payload && typeof payload.state_json === 'string' && payload.state_json.trim()) {
        return JSON.parse(payload.state_json);
      }
      throw new Error('API response missing "state" or "state_json".');
    }

    // =====================================================================
    // ENGINE (same rendering behavior, but SCENE comes from API)
    // =====================================================================

    let SCENE = null;

    const cols = 17;        // A..Q
    const rows = 11;        // 1..11
    const size = 34.5;      // hex radius
    const margin = 55;

    const canvas = document.getElementById('mat');
    const ctx = canvas.getContext('2d');
    const SQRT3 = Math.sqrt(3);
    const letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';

    let ROOM_GEOMS = null;
    let SCENE_NORM = null;

    const CONFIG = {
      room: { yInsetFrac: 0.25 },
      labels: { dyFrac: 0.70, fillAlpha: 0.35 },
      opening: { minAcross: 18, acrossMul: 1.05, spanNSMul: 1.5, spanEWMul: 1.0 },
      grid: { baseStrokeW: 1.2, baseStrokeA: 0.07, overlayStrokeW: 1.1, overlayStrokeA: 0.04 }
    };

    function qrToPixel(q, r) {
      const drawR = (rows - 1 - r);
      const columnOffset = (q % 2 === 0) ? 0 : 0.5;
      const x = size * (3/2) * q;
      const y = size * SQRT3 * (drawR + columnOffset);
      return { x: x + margin, y: y + margin };
    }

    function hexCorners(cx, cy) {
      const pts = [];
      for (let i = 0; i < 6; i++) {
        const a = (Math.PI / 180) * (60 * i);
        pts.push({ x: cx + size * Math.cos(a), y: cy + size * Math.sin(a) });
      }
      return pts;
    }

    function drawHexPath(pts) {
      ctx.beginPath();
      ctx.moveTo(pts[0].x, pts[0].y);
      for (let i = 1; i < pts.length; i++) ctx.lineTo(pts[i].x, pts[i].y);
      ctx.closePath();
    }

    function labelFor(q, r) { return `${letters[q]}${r + 1}`; }

    function parseLabel(label) {
      const m = String(label).trim().toUpperCase().match(/^([A-Z])([0-9]{1,2})$/);
      if (!m) return null;
      const q = letters.indexOf(m[1]);
      const r = Number(m[2]) - 1;
      if (q < 0 || q >= cols) return null;
      if (r < 0 || r >= rows) return null;
      return { q, r };
    }

    function labelToPixel(label) {
      const pos = parseLabel(label);
      if (!pos) return null;
      return qrToPixel(pos.q, pos.r);
    }

    function normalizeScene() {
      const src = (typeof SCENE === 'object' && SCENE) ? SCENE : {};
      const warn = (msg, obj) => { try { console.warn(`[Battlemat] ${msg}`, obj ?? ''); } catch (_) {} };

      const roomsIn = Array.isArray(src.rooms) ? src.rooms : [];
      const roomsOut = [];
      const roomIds = new Set();

      for (let i = 0; i < roomsIn.length; i++) {
        const r = roomsIn[i] || {};
        const corners = Array.isArray(r.corners) ? r.corners : null;
        if (!corners || corners.length !== 4) { warn(`Room skipped: corners must be 4 labels`, r); continue; }
        if (corners.map(parseLabel).some(p => !p)) { warn(`Room skipped: invalid corner label(s)`, r); continue; }

        let id = String(r.id || '').trim();
        if (!id) id = `room_${i + 1}`;
        if (roomIds.has(id)) { let k = 2; while (roomIds.has(`${id}_${k}`)) k++; id = `${id}_${k}`; }
        roomIds.add(id);

        roomsOut.push({
          id,
          corners: corners.map(c => String(c).trim().toUpperCase()),
          thickness: Number(r.thickness ?? 18),
          color: String(r.color || '#555')
        });
      }

      const openingsIn = Array.isArray(src.openings) ? src.openings : [];
      const openingsOut = [];
      for (let i = 0; i < openingsIn.length; i++) {
        const o = openingsIn[i] || {};
        const kind = String(o.kind || 'door').toLowerCase();
        if (kind !== 'door' && kind !== 'window') { warn(`Opening skipped: kind must be door/window`, o); continue; }
        const room = String(o.room || '').trim();
        if (!room || !roomIds.has(room)) { warn(`Opening skipped: unknown room id '${room}'`, o); continue; }
        const wall = String(o.wall || '').trim().toUpperCase();
        if (!['N','S','E','W'].includes(wall)) { warn(`Opening skipped: wall must be N/S/E/W`, o); continue; }
        const at = String(o.at || '').trim().toUpperCase();
        if (!parseLabel(at)) { warn(`Opening skipped: invalid at label`, o); continue; }
        const state = String((o.state ?? 'closed')).toLowerCase();
        openingsOut.push({ ...o, kind, room, wall, at, state });
      }

      const objectsIn = Array.isArray(src.objects) ? src.objects : [];
      const objectsOut = [];
      for (let i = 0; i < objectsIn.length; i++) {
        const o = objectsIn[i] || {};
        const kind = String(o.kind || 'object').toLowerCase();
        const blocks = Boolean(o.blocks ?? false);

        let cells = [];
        if (Array.isArray(o.cells) && o.cells.length) cells = o.cells.map(c => String(c).trim().toUpperCase()).filter(Boolean);
        else if (o.at) cells = [String(o.at).trim().toUpperCase()];

        cells = cells.filter(lab => !!parseLabel(lab));
        if (!cells.length) { warn('Object skipped: missing/invalid at/cells', o); continue; }

        objectsOut.push({ ...o, kind, blocks, cells, label: (o.label != null) ? String(o.label) : null, color: (o.color != null) ? String(o.color) : null });
      }

      const actorsIn = Array.isArray(src.actors) ? src.actors : [];
      const actorsOut = [];
      for (let i = 0; i < actorsIn.length; i++) {
        const a = actorsIn[i] || {};
        const at = String(a.at || '').trim().toUpperCase();
        if (!parseLabel(at)) { warn(`Actor skipped: invalid at label`, a); continue; }
        const side = String(a.side || 'NPC').toUpperCase();
        actorsOut.push({ ...a, at, side: (side === 'PC' || side === 'EN') ? side : 'NPC' });
      }

      return { round: Number(src.round ?? 1), rooms: roomsOut, openings: openingsOut, objects: objectsOut, actors: actorsOut };
    }

    function getRoomGeom(room) {
      const c = Array.isArray(room.corners) ? room.corners : null;
      if (!c || c.length !== 4) return null;

      const pTL = labelToPixel(c[0]);
      const pTR = labelToPixel(c[1]);
      const pBR = labelToPixel(c[2]);
      const pBL = labelToPixel(c[3]);
      if (!pTL || !pTR || !pBR || !pBL) return null;

      const hexH = SQRT3 * size;
      const yInset = hexH * CONFIG.room.yInsetFrac;

      return {
        id: String(room.id || ''),
        leftX:  pTL.x,
        rightX: pTR.x,
        topY:   pTL.y + yInset,
        botY:   pBL.y - yInset,
        thickness: Number(room.thickness ?? 18),
        color: String(room.color || 'rgba(0,0,0,0.88)')
      };
    }

    function drawRooms() {
      const rooms = Array.isArray(SCENE_NORM?.rooms) ? SCENE_NORM.rooms : [];
      if (!rooms.length || !ROOM_GEOMS) return;

      for (const room of rooms) {
        const g = ROOM_GEOMS.get(String(room.id || ''));
        if (!g) continue;

        ctx.save();
        ctx.strokeStyle = g.color;
        ctx.lineWidth = g.thickness;
        ctx.lineJoin = 'miter';
        ctx.lineCap = 'butt';

        ctx.beginPath();
        ctx.moveTo(g.leftX,  g.topY);
        ctx.lineTo(g.rightX, g.topY);
        ctx.lineTo(g.rightX, g.botY);
        ctx.lineTo(g.leftX,  g.botY);
        ctx.closePath();
        ctx.stroke();
        ctx.restore();
      }
    }

    function roundRectPath(x, y, w, h, r) {
      const rr = Math.max(0, Math.min(r, Math.min(w, h) / 2));
      ctx.beginPath();
      ctx.moveTo(x + rr, y);
      ctx.arcTo(x + w, y, x + w, y + h, rr);
      ctx.arcTo(x + w, y + h, x, y + h, rr);
      ctx.arcTo(x, y + h, x, y, rr);
      ctx.arcTo(x, y, x + w, y, rr);
      ctx.closePath();
    }

    function objectCentroidPx(cells) {
      let sx = 0, sy = 0, n = 0;
      for (const lab of (cells || [])) {
        const p = labelToPixel(lab);
        if (!p) continue;
        sx += p.x; sy += p.y; n++;
      }
      if (!n) return null;
      return { x: sx / n, y: sy / n };
    }

    function objectBoundsPx(cells) {
      let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
      let n = 0;
      for (const lab of (cells || [])) {
        const p = labelToPixel(lab);
        if (!p) continue;
        minX = Math.min(minX, p.x);
        minY = Math.min(minY, p.y);
        maxX = Math.max(maxX, p.x);
        maxY = Math.max(maxY, p.y);
        n++;
      }
      if (!n) return null;
      return { minX, minY, maxX, maxY };
    }

    function drawObjects() {
      const objs = Array.isArray(SCENE_NORM?.objects) ? SCENE_NORM.objects : [];
      if (!objs.length) return;

      for (const obj of objs) {
        const cells = Array.isArray(obj.cells) ? obj.cells : [];
        if (!cells.length) continue;

        const kind = String(obj.kind || 'object').toLowerCase();
        const glyph = (obj.label != null && String(obj.label).trim()) ? String(obj.label).trim().slice(0, 3) : kind.slice(0,1).toUpperCase();

        // Difficult terrain: per-hex shading + ~ in every cell
        if (kind === 'difficult') {
          const fill = obj.color ? String(obj.color) : 'rgba(120,120,120,0.18)';
          for (const lab of cells) {
            const p = labelToPixel(lab);
            if (!p) continue;
            const pts = hexCorners(p.x, p.y);
            drawHexPath(pts);
            ctx.save();
            ctx.fillStyle = fill;
            ctx.fill();
            ctx.lineWidth = 1;
            ctx.strokeStyle = 'rgba(0,0,0,0.18)';
            ctx.stroke();

            ctx.font = 'bold 12px ui-monospace, system-ui, sans-serif';
            ctx.fillStyle = 'rgba(0,0,0,0.55)';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(glyph, p.x, p.y);
            ctx.restore();
          }
          continue;
        }

        // Tables: round
        if (kind === 'table') {
          const c = objectCentroidPx(cells);
          if (!c) continue;
          const radius = size * 1.25;

          ctx.save();
          ctx.beginPath();
          ctx.arc(c.x, c.y, radius, 0, Math.PI * 2);
          ctx.fillStyle = '#b07a3f';
          ctx.fill();
          ctx.lineWidth = 2;
          ctx.strokeStyle = 'rgba(0,0,0,0.85)';
          ctx.stroke();

          ctx.font = 'bold 14px ui-monospace, system-ui, sans-serif';
          ctx.fillStyle = 'rgba(0,0,0,0.85)';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText(glyph || 'T', c.x, c.y);
          ctx.restore();
          continue;
        }

        // Rect / sarcophagus: rounded rectangle
        if (kind === 'rect' || kind === 'sarcophagus') {
          const c = objectCentroidPx(cells);
          const b = objectBoundsPx(cells);
          if (!c || !b) continue;

          const padX = size * 0.85;
          const padY = size * 0.55;
          const w = (b.maxX - b.minX) + padX * 2;
          const h = (b.maxY - b.minY) + padY * 2;

          const rot = Number(obj.rot ?? 0);
          const radius = Math.max(6, Math.min(size * 0.35, Math.min(w, h) * 0.25));
          const fillRect = obj.color ? String(obj.color) : '#b07a3f';

          ctx.save();
          ctx.translate(c.x, c.y);
          if (rot) ctx.rotate((Math.PI / 180) * rot);

          roundRectPath(-w/2, -h/2, w, h, radius);
          ctx.fillStyle = fillRect;
          ctx.fill();
          ctx.lineWidth = 2;
          ctx.strokeStyle = 'rgba(0,0,0,0.85)';
          ctx.stroke();

          ctx.font = 'bold 14px ui-monospace, system-ui, sans-serif';
          ctx.fillStyle = 'rgba(0,0,0,0.85)';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText(glyph, 0, 0);

          ctx.restore();
          continue;
        }

        // Other objects: simple per-hex shade + first-cell glyph
        const fill = obj.color ? String(obj.color) : (obj.blocks ? 'rgba(0,0,0,0.20)' : 'rgba(0,0,0,0.10)');
        for (let i = 0; i < cells.length; i++) {
          const p = labelToPixel(cells[i]);
          if (!p) continue;
          const pts = hexCorners(p.x, p.y);
          drawHexPath(pts);
          ctx.save();
          ctx.fillStyle = fill;
          ctx.fill();
          ctx.lineWidth = 1;
          ctx.strokeStyle = 'rgba(0,0,0,0.18)';
          ctx.stroke();
          if (i === 0) {
            ctx.font = 'bold 12px ui-monospace, system-ui, sans-serif';
            ctx.fillStyle = 'rgba(0,0,0,0.55)';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(glyph, p.x, p.y);
          }
          ctx.restore();
        }
      }
    }

    function drawOpenings() {
      const openings = Array.isArray(SCENE_NORM?.openings) ? SCENE_NORM.openings : [];
      if (!openings.length || !ROOM_GEOMS) return;

      for (const o of openings) {
        const kind = String(o.kind || 'door').toLowerCase();
        if (kind !== 'door' && kind !== 'window') continue;

        const state = String(o.state ?? 'closed').toLowerCase();
        const g = ROOM_GEOMS.get(String(o.room || ''));
        if (!g) continue;

        const wall = String(o.wall || '').toUpperCase();
        const atPx = labelToPixel(o.at);
        if (!atPx) continue;

        let x = atPx.x, y = atPx.y;
        if (wall === 'N') y = g.topY;
        else if (wall === 'S') y = g.botY;
        else if (wall === 'E') x = g.rightX;
        else if (wall === 'W') x = g.leftX;
        else continue;

        const thicknessAcross = Math.max(CONFIG.opening.minAcross, g.thickness * CONFIG.opening.acrossMul);
        const spanAlong = (wall === 'N' || wall === 'S') ? (CONFIG.opening.spanNSMul * size) : (CONFIG.opening.spanEWMul * SQRT3 * size);
        const rectW = (wall === 'N' || wall === 'S') ? spanAlong : thicknessAcross;
        const rectH = (wall === 'N' || wall === 'S') ? thicknessAcross : spanAlong;

        ctx.save();
        ctx.translate(x, y);

        const isDoor = (kind === 'door');
        const isWindow = (kind === 'window');
        const isOpen = (state === 'open');

        if (isOpen) {
          if (isWindow) { ctx.fillStyle = '#eeeeee'; ctx.strokeStyle = '#eeeeee'; ctx.lineWidth = 1; }
          else { ctx.fillStyle = '#ffffff'; ctx.strokeStyle = '#ffffff'; ctx.lineWidth = 0; }
        } else {
          ctx.fillStyle = isDoor ? '#b07a3f' : '#cfe6f6';
          ctx.strokeStyle = 'rgba(0,0,0,0.6)';
          ctx.lineWidth = 2;
        }

        ctx.beginPath();
        ctx.rect(-rectW/2, -rectH/2, rectW, rectH);
        ctx.fill();
        ctx.stroke();

        if (!isOpen) {
          ctx.font = (Math.max(rectW, rectH) >= 55) ? 'bold 13px ui-monospace, system-ui, sans-serif' : 'bold 12px ui-monospace, system-ui, sans-serif';
          ctx.fillStyle = 'rgba(0,0,0,0.55)';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText(isWindow ? 'W' : 'D', 0, 0);
        }

        ctx.restore();
      }
    }

    function drawToken(q, r, label, side, dead) {
      const { x, y } = qrToPixel(q, r);

      let fill = 'rgba(160,160,160,0.95)';
      if (dead) fill = 'rgba(140,140,140,0.85)';
      else if (side === 'PC') fill = 'rgba(80,160,220,0.95)';
      else if (side === 'EN') fill = 'rgba(220,120,80,0.95)';

      ctx.beginPath();
      ctx.arc(x, y, size * 0.40, 0, Math.PI * 2);
      ctx.fillStyle = fill;
      ctx.fill();

      ctx.lineWidth = 0.75;
      ctx.strokeStyle = 'rgba(0,0,0,0.85)';
      ctx.stroke();

      ctx.font = 'bold 14px ui-monospace, system-ui, sans-serif';
      ctx.fillStyle = dead ? 'rgba(0,0,0,0.35)' : 'rgba(0,0,0,0.72)';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(label, x, y);
    }

    function drawHexOverlay() {
      for (let q = 0; q < cols; q++) {
        for (let r = 0; r < rows; r++) {
          const { x, y } = qrToPixel(q, r);
          const pts = hexCorners(x, y);
          drawHexPath(pts);
          ctx.lineWidth = CONFIG.grid.overlayStrokeW;
          ctx.strokeStyle = `rgba(0,0,0,${CONFIG.grid.overlayStrokeA})`;
          ctx.stroke();
        }
      }
    }

    function drawGrid() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      ctx.fillStyle = '#d7d7d7';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      for (let q = 0; q < cols; q++) {
        for (let r = 0; r < rows; r++) {
          const { x, y } = qrToPixel(q, r);
          const pts = hexCorners(x, y);

          drawHexPath(pts);
          ctx.fillStyle = '#ffffff';
          ctx.fill();

          ctx.lineWidth = CONFIG.grid.baseStrokeW;
          ctx.strokeStyle = `rgba(0,0,0,${CONFIG.grid.baseStrokeA})`;
          ctx.stroke();
        }
      }

      SCENE_NORM = normalizeScene();

      ROOM_GEOMS = new Map();
      for (const room of (SCENE_NORM?.rooms || [])) {
        const g = getRoomGeom(room);
        if (g && g.id) ROOM_GEOMS.set(g.id, g);
      }

      drawRooms();
      drawOpenings();
      drawObjects();
      drawHexOverlay();

      // Labels last
      const LABEL_DY = size * CONFIG.labels.dyFrac;
      ctx.font = '13px "Times New Roman", Georgia, "Century Schoolbook", "Book Antiqua", serif';
      ctx.fillStyle = `rgba(180,150,90,${CONFIG.labels.fillAlpha})`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      for (let q = 0; q < cols; q++) {
        for (let r = 0; r < rows; r++) {
          const { x, y } = qrToPixel(q, r);
          ctx.fillText(labelFor(q, r), x, y + LABEL_DY);
        }
      }

      // Actors
      for (const a of (SCENE_NORM?.actors || [])) {
        const pos = parseLabel(a.at);
        if (!pos) continue;
        const effects = Array.isArray(a.effects) ? a.effects : [];
        const isDead = Number(a.hp ?? 0) <= 0 || effects.includes('dead') || effects.includes('down');
        drawToken(pos.q, pos.r, a.label || a.name?.slice(0, 1) || '?', a.side, isDead);
      }

      renderStatus();
    }

    function renderStatus() {
      const tbody = document.getElementById('statusBody');
      const roundLine = document.getElementById('roundLine');
      if (!tbody || !roundLine) return;

      roundLine.textContent = `Round ${SCENE_NORM?.round ?? '—'}`;

      const actors = Array.isArray(SCENE_NORM?.actors) ? SCENE_NORM.actors.slice() : [];
      actors.sort((a, b) => {
        const ai = Number(a.init ?? 0), bi = Number(b.init ?? 0);
        if (bi !== ai) return bi - ai;
        return String(a.name ?? a.id).localeCompare(String(b.name ?? b.id));
      });

      tbody.innerHTML = '';
      for (const a of actors) {
        const tr = document.createElement('tr');
        const hpVal = Number(a.hp ?? 0);
        const effectsArr = Array.isArray(a.effects) ? a.effects : [];
        const isDead = hpVal <= 0 || effectsArr.includes('dead') || effectsArr.includes('down');

        const side = String(a.side || 'NPC').toUpperCase();
        tr.className = (side === 'PC' ? 'side-pc' : (side === 'EN' ? 'side-en' : 'side-npc')) + (isDead ? ' dead' : '');

        const effects = Array.isArray(a.effects) ? a.effects : [];
        const effectsHtml = effects.length
          ? effects.map(e => `<span class="chip">${escapeHtml(String(e))}</span>`).join('')
          : '';

        tr.innerHTML = `
          <td>
            <div style="display:flex; align-items:baseline; gap:8px; flex-wrap:wrap;">
              <span style="font-weight:650;">${escapeHtml(a.name ?? a.id ?? 'Actor')}</span>
              <span class="subtle">${escapeHtml(a.at ?? '')}</span>
            </div>
            ${effectsHtml ? `<div style="margin-top:4px;">${effectsHtml}</div>` : ''}
          </td>
          <td class="hp">${escapeHtml(String(a.init ?? 0))}</td>
          <td class="hp">${escapeHtml(String(a.hp ?? '—'))} / ${escapeHtml(String(a.maxHp ?? '—'))}</td>
        `;
        tbody.appendChild(tr);
      }
    }

    function escapeHtml(s) {
      return s
        .replaceAll('&', '&amp;')
        .replaceAll('<', '&lt;')
        .replaceAll('>', '&gt;')
        .replaceAll('"', '&quot;')
        .replaceAll("'", '&#39;');
    }

    function safeDrawGrid() {
      try {
        drawGrid();
      } catch (e) {
        console.error('[Battlemat] drawGrid failed:', e);
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = '#d7d7d7';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = 'rgba(0,0,0,0.65)';
        ctx.font = '14px ui-monospace, system-ui, sans-serif';
        ctx.textAlign = 'left';
        ctx.textBaseline = 'top';
        ctx.fillText('Battlemat render error (see console).', 14, 14);
      }
    }

    async function boot() {
      const roundLine = document.getElementById('roundLine');
      try {
        const battleId = getBattleIdFromUrl();
        if (!battleId) {
          if (roundLine) roundLine.textContent = 'No battle_id in URL';
          return;
        }

        if (roundLine) roundLine.textContent = `Loading battle ${battleId}…`;

        const payload = await fetchBattle(battleId);
        SCENE = coerceSceneFromApi(payload);

        safeDrawGrid();
      } catch (err) {
        console.error(err);
        if (roundLine) roundLine.textContent = 'Failed to load battle';
      }
    }

    boot();
  </script>
</body>
</html>
