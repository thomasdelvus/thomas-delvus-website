<!--
Battlemat Core Rewrite
Version: v5.74
-->
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Battlemat Core v5.74</title>
  <style>
    :root{
      --bg:#0f1115;
      --panel:#161a22;
      --panel2:#121621;
      --text:#e9eef7;
      --muted:#9aa6bb;
      --border:rgba(255,255,255,0.12);
      --border2:rgba(255,255,255,0.08);
      --good:#43d17a;
      --bad:#ff5a5a;
    }
    html,body{height:100%;margin:0;}
    body{
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;
      background:var(--bg);
      color:var(--text);
      display:grid;
      grid-template-rows:auto 1fr;
    }
    #topbar{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
      padding:10px 12px;
      background:var(--panel);
      border-bottom:1px solid var(--border2);
    }
    #status{
      display:flex;
      align-items:center;
      gap:10px;
      min-height:26px;
      flex-wrap:wrap;
    }
    .pill{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding:4px 10px;
      border-radius:999px;
      background:rgba(255,255,255,0.08);
      border:1px solid var(--border);
      font-size:12px;
      color:var(--text);
      white-space:nowrap;
    }
    .dot{width:8px;height:8px;border-radius:50%;background:var(--good);box-shadow:0 0 0 2px rgba(67,209,122,0.15);}
    .mini{font-size:12px;color:var(--muted);display:inline-flex;align-items:center;gap:6px;white-space:nowrap;}
    .mini input[type="text"]{
      width:72px;
      padding:4px 8px;
      border-radius:8px;
      border:1px solid var(--border);
      background:rgba(0,0,0,0.25);
      color:var(--text);
      outline:none;
    }
    select{
      padding:4px 8px;
      border-radius:8px;
      border:1px solid var(--border);
      background:rgba(0,0,0,0.25);
      color:var(--text);
      outline:none;
      font-size:12px;
    }
    button{
      padding:6px 10px;
      border-radius:10px;
      border:1px solid var(--border);
      background:rgba(255,255,255,0.08);
      color:var(--text);
      cursor:pointer;
      font-size:12px;
    }
    button:hover{background:rgba(255,255,255,0.12);}
    .sep{width:1px;height:18px;background:var(--border2);margin:0 2px;}

    #controls{
      display:flex;
      align-items:center;
      gap:8px;
      flex-wrap:wrap;
      justify-content:flex-end;
    }

    #layout{
      display:grid;
      grid-template-columns: 1fr 320px;
      gap:12px;
      padding:12px;
      min-height:0;
    }

    #canvasWrap{
      background:#0b0d12;
      border:1px solid var(--border);
      border-radius:12px;
      box-shadow:0 10px 30px rgba(0,0,0,0.35);
      overflow:hidden;
      min-height:0;
    }

    canvas{width:100%;height:100%;display:block;background:#0b0d12;}

    #sidebar{
      background:var(--panel2);
      border:1px solid var(--border);
      border-radius:12px;
      padding:12px;
      overflow:auto;
      min-height:0;
    }

    #sidebar h3{
      margin:0 0 8px 0;
      font-size:13px;
      color:var(--text);
      letter-spacing:0.02em;
    }

    #kvs{
      display:grid;
      grid-template-columns: 1fr auto;
      gap:6px 10px;
      font-size:12px;
      color:var(--muted);
      margin-bottom:12px;
    }

    #turns{
      font-size:12px;
      color:var(--muted);
      display:flex;
      flex-direction:column;
      gap:6px;
      margin-bottom:12px;
    }

    .turnRow{
      display:flex;
      justify-content:space-between;
      gap:10px;
      padding:6px 8px;
      border:1px solid rgba(255,255,255,0.10);
      border-radius:10px;
      background:rgba(255,255,255,0.04);
    }
    .turnRow.active{border-color:rgba(67,209,122,0.35); background:rgba(67,209,122,0.08); color:var(--text);}

    #errorBox{
      border:1px solid rgba(255,90,90,0.35);
      background:rgba(255,90,90,0.08);
      border-radius:12px;
      padding:10px;
      font-size:12px;
      color:var(--text);
      white-space:pre-wrap;
    }

    .dpad{
      display:inline-flex;
      gap:6px;
      align-items:center;
      margin-left:6px;
    }
    .dpad button{padding:6px 8px; border-radius:10px; min-width:34px;}

    @media (max-width: 980px){
      #layout{grid-template-columns:1fr;}
    }
  </style>
</head>
<body>
  <div id="topbar">
    <div id="status">
      <div class="pill" title="Battlemat version" id="versionPill"><span class="dot"></span><span id="versionText">v5.74</span></div>
      <div class="mini" id="battleTitle">Battlemat</div>
      <div class="sep"></div>
      <div class="mini">Floor <select id="floorSelect"></select></div>
      <div class="pill" title="DevicePixelRatio × Supersample">
        DPR <span id="dprText">?</span>
        &nbsp;·&nbsp; SS <span id="ssText">?</span>
      </div>
    </div>

    <div id="controls">
      <label class="mini"><input type="checkbox" id="fogToggle" checked /> Fog</label>
      <label class="mini"><input type="checkbox" id="spriteToggle" checked /> Sprites</label>
      <label class="mini"><input type="checkbox" id="labelBoldToggle" /> Bright Labels</label>

      <div class="mini">SS
        <select id="ssSelect" title="Supersample quality">
          <option value="1">1×</option>
          <option value="2">2×</option>
          <option value="3">3×</option>
        </select>
      </div>

      <div class="mini">Center
        <select id="centerOn" title="Follow a PC token"></select>
      </div>

      <div class="mini">Jump
        <input id="jumpHex" type="text" value="U16" />
        <button id="btnJump">Go</button>
      </div>

      <button id="btnRedraw">Redraw</button>

      <div class="dpad" title="Pan camera">
        <button id="btnLeft">←</button>
        <button id="btnUp">↑</button>
        <button id="btnDown">↓</button>
        <button id="btnRight">→</button>
      </div>
    </div>
  </div>

  <div id="layout">
    <div id="canvasWrap"><canvas id="canvas" aria-label="Battlemat canvas"></canvas></div>
    <div id="sidebar">
      <h3>Status</h3>
      <div id="kvs"></div>

      <h3>Initiative</h3>
      <div id="turns"></div>

      <div id="errorBox" hidden></div>
    </div>
  </div>

  <script>
  // =====================================================================================
  // Battlemat Core Rewrite v5.74
  // Goals: small core renderer (hexes + camera + layers + orientation + fog) + supersample.
  // =====================================================================================

  const VERSION = 'v5.74';

  // ===== DOM =====
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d', { alpha: false, desynchronized: true });

  // Offscreen wall layer (we punch openings out of walls here, then composite onto main canvas)
  const wallCanvas = document.createElement('canvas');
  const wallCtx = wallCanvas.getContext('2d', { alpha: true, desynchronized: true });

  const elVersion = document.getElementById('versionText');
  const elTitle = document.getElementById('battleTitle');
  const elFogToggle = document.getElementById('fogToggle');
  const elSpriteToggle = document.getElementById('spriteToggle');
  const elLabelBoldToggle = document.getElementById('labelBoldToggle');
  const elFloorSelect = document.getElementById('floorSelect');
  const elCenterOn = document.getElementById('centerOn');
  const elJumpHex = document.getElementById('jumpHex');
  const elError = document.getElementById('errorBox');
  const elDpr = document.getElementById('dprText');
  const elSs = document.getElementById('ssText');
  const elSsSelect = document.getElementById('ssSelect');

  if (elVersion) elVersion.textContent = VERSION;

  // ===== Constants =====
  const sqrt3 = Math.sqrt(3);

  const GRID = {
    // Flat-top hex geometry: size is center-to-vertex.
    size: 42,
    lineWidth: 2,
    lineAlpha: 0.10,
    labelAlpha: 0.18,
    labelFont: 'bold 12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial',
  };

  const COLORS = {
    bg: '#0b0d12',
    wall: '#666',
    door: '#b67a2c',
    window: '#bfe2ff',

    floorStone: 'rgb(223, 208, 165)',    floorWood: 'rgb(213, 181, 140)',

    // Placeholder prop colors (used when sprites are off or missing)
    objectWood: 'rgb(176, 126, 80)',
    chestWood:  'rgb(110, 72, 40)',
    stairsWood: 'rgb(140, 98, 64)',

    // Beds (placeholder colors)
    bedFabric: 'rgb(150, 86, 76)',
    bedPillow: 'rgb(135, 78, 69)',

    // Hearth (placeholder color)
    hearth: 'rgb(147, 53, 53)',
    floorCobble: 'rgb(154, 160, 166)',

    tokenHero: '#4aa3ff',
    tokenEnemy: '#111',
    tokenTextDark: 'rgba(0,0,0,0.72)',
    tokenTextLight: 'rgba(255,255,255,0.88)',

    fogUnseen: 'rgb(128,128,128)',
    fogExplored: 'rgb(170,170,170)',
  };
  // NOTE (v5.52): We generally avoid per-kind scaling in objectSizePx because it also changes sprite sizing.
  // Placeholder shapes can have their own internal proportions.
  // Exception: when a kind is intentionally a different physical footprint (e.g. cooking.hearth).
  const OBJECT_KIND_SCALE = {}; // kept for future use, but currently unused

  const VIEW = {
    // Camera is in hex coords (col,row), row 0 is "row 1" at the bottom.
    camera: { col: 6, row: 6 },
    anchor: { x: 0, y: 0 },
    dx: 0,
    dy: 0,

    // Active floor id (single-floor states still work)
    floorId: null,

    // If set, camera will automatically follow that token id (and flip floors when needed)
    followTokenId: null,

    // DevicePixelRatio × supersample scale (set in resize())
    dpr: 1,
  };

  const PAN_STEP = 2;
  const STORAGE_SS = 'battlemat.supersample';

  // ===== Sprites (core, optional) =====
  const SPRITES = {
    basePath: '/assets/sprites/',
    cache: new Map(),
    defs: {
      // Objects
      // Optional sprite-only scaling:
      //   - scale: uniform
      //   - scaleX/scaleY: non-uniform
      // Instance overrides: spriteScale / spriteScaleX / spriteScaleY on the object record.
      'bed':         { file: 'bed.png', rotate: 'deg' },
      'bed.double':  { file: 'bed_double.png', rotate: 'deg' },
      'chair':       { file: 'chair.png', rotate: 'deg' },
      'table.round': { file: 'table_round.png', rotate: 'deg' },
      'table.rect':  { file: 'table_rectangle.png', rotate: 'deg' },
      'chest':       { file: 'chest_closed.png', rotate: 'deg' },
      'hearth':      { file: 'hearth_big.png', rotate: 'deg' },
      'cooking.hearth': { file: 'cooking_hearth.png', rotate: 'deg' },
      'stairs':      { file: 'stairs.png', rotate: 'deg' },

      // Tokens (optional)
      'token.pc':    { file: 'token_pc.png', rotate: 'none' },
      'token.npc':   { file: 'token_npc.png', rotate: 'none' },
    }
  };

  function getSpriteDef(kind) {
    const k = String(kind || '').toLowerCase();
    return SPRITES.defs[k] || null;
  }

  function loadSprite(file) {
    const f = String(file || '').trim();
    if (!f) return null;
    if (SPRITES.cache.has(f)) return SPRITES.cache.get(f);

    const img = new Image();
    img.decoding = 'async';
    img.src = SPRITES.basePath + f;
    SPRITES.cache.set(f, img);
    return img;
  }

  function drawSprite(img, x, y, w, h, rotRad = 0) {
    if (!img || !img.complete || !img.naturalWidth) return false;

    ctx.save();
    ctx.translate(x, y);
    if (rotRad) ctx.rotate(rotRad);
    ctx.drawImage(img, -w / 2, -h / 2, w, h);
    ctx.restore();
    return true;
  }

  // ===== Canonical state (demo) =====
  // If your real page injects state, set window.BATTLE_STATE.
  const DEFAULT_STATE = {
    meta: { title: 'Cross Keys Inn — Demo (upper + ground)', battleId: 'local', round: 1 },

    view: { camera_hex: 'U16', floorId: 'upper' },

    fog: {
      enabled: true,
      mode: 'room',

      // For single-floor states you can use visibleRoomIds/exploredRoomIds.
      // For multi-floor, use visibleRoomIdsByFloor/exploredRoomIdsByFloor.
      visibleRoomIdsByFloor: {
        upper: [],
        ground: [],
      },
      exploredRoomIdsByFloor: {
        upper: ['Hallway1','Hallway2'],
        ground: ['Kitchen'],
      },

      autoCompute: true,
      autoExplore: true,
      maxDepth: 1,
      unseenAlpha: 0.92,
      exploredAlpha: 0.55,
    },

    floors: [
      {
        id: 'upper',
        name: 'Upper',
        rooms: [
          { id: 'CrossKeysUpperFloor', corners: ['L21','AJ21','AJ12','L12'], thickness: 20, floor: { kind: 'fog' }, wall: { kind: 'brick' } },
          { id: 'Hallway1', corners: ['AD21','AF21','AF12','AD12'], thickness: 20, floor: { kind: 'wood' }, wall: { kind: 'brick' } },
          { id: 'Hallway2', corners: ['R17','AD17','AD15','R15'], thickness: 20, floor: { kind: 'wood' }, wall: { kind: 'brick' } },
          { id: 'Hallway3', corners: ['P21','R21','R12','P12'], thickness: 20, floor: { kind: 'wood' }, wall: { kind: 'brick' } },
          { id:'1stFloorStairsDown', corners: ['Z21','AD21','AD19','Z19'], thickness: 20, floor: { kind: 'stairs.wood' }, wall: { kind: 'brick' } },

          { id:'Bedroom1', corners: ['L21','P21','P18','L18'], thickness: 20, floor: { kind: 'wood' }, wall: { kind: 'brick' } },
          { id:'Bedroom2', corners: ['L18','P18','P15','L15'], thickness: 20, floor: { kind: 'wood' }, wall: { kind: 'brick' } },
          { id:'Bedroom3', corners: ['L15','P15','P12','L12'], thickness: 20, floor: { kind: 'wood' }, wall: { kind: 'brick' } },
          { id:'Bedroom4', corners: ['R15','X15','X12','R12'], thickness: 20, floor: { kind: 'wood' }, wall: { kind: 'brick' } },
          { id:'Bedroom5', corners: ['R21','X21','X17','R17'], thickness: 20, floor: { kind: 'wood' }, wall: { kind: 'brick' } },
          { id:'Bedroom5_Closet', corners: ['X21','Z21','Z19','X19'], thickness: 20, color: '#555', floor: { kind: 'wood' }, wall: { kind: 'brick' } },
          { id:'Bedroom6', corners: ['X19','AD19','AD17','X17'], thickness: 20, floor: { kind: 'wood' }, wall: { kind: 'brick' } },
          { id:'Bedroom7', corners: ['X15','AD15','AD12','X12'], thickness: 20, floor: { kind: 'wood' }, wall: { kind: 'brick' } },
          { id:'Bedroom8', corners: ['AF15','AJ15','AJ12','AF12'], thickness: 20, color: '#555', floor: { kind: 'wood' }, wall: { kind: 'brick' } },
          { id:'Bedroom9', corners: ['AF18','AJ18','AJ15','AF15'], thickness: 20, color: '#555', floor: { kind: 'wood' }, wall: { kind: 'brick' } },
          { id:'Bedroom10', corners: ['AF21','AJ21','AJ18','AF18'], thickness: 20, color: '#555', floor: { kind: 'wood' }, wall: { kind: 'brick' } },
        ],
        openings: [
          { id: 'door_room1', kind: 'door', hex: 'P19',  orientation: 'v',  openPct: 1.0, hinge: 'right', swing: 1  },
          { id: 'door_room2', kind: 'door', hex: 'P16',  orientation: 'v',  openPct: 1.0, hinge: 'right', swing: 1 },
          { id: 'door_room3', kind: 'door', hex: 'P13',  orientation: 'v',  openPct: 1.0, hinge: 'right', swing: 1  },
          //{ id: 'door_room4', kind: 'door', hex: 'T15',  orientation: 'h',  openPct: -0.3  },
          { id:'door_room4', kind:'door', hex:'V15', orientation:'h', openPct: 1.0, hinge: 'left', swing: 1 },
          
          { id: 'door_room5', kind: 'door', hex: 'V17',  orientation: 'h',  openPct: 1.0  },
          { id: 'door_room5_closet', kind: 'door', hex: 'X20',  orientation: 'v',  openPct: 1.0  },
          { id: 'door_room6', kind: 'door', hex: 'AB17', orientation: 'h',  openPct: 1.0  },
          { id: 'door_room7', kind: 'door', hex: 'Z15', orientation: 'h',  openPct: 1.0, hinge: 'right', swing: 1   },
          { id: 'door_room8', kind: 'door', hex: 'AF14', orientation: 'v',  openPct: 1.0  },
          { id: 'door_room9', kind: 'door', hex: 'AF17', orientation: 'v',  openPct: 1.0  },
          { id: 'door_room10',kind: 'door', hex: 'AF20', orientation: 'v',  openPct: 1.0  },

          // Portals: movement/transition links between floors (renderer does not draw them)
          { id:'portal_down_AB20', kind:'portal', hex:'AB20', trigger:'enter', to:{ floorId:'ground', hex:'Z20' } },

          { id:'window_bed1', kind:'window', hex:'L20', orientation:'v' },

          { id:'thresh_R16',  kind: 'threshold', hex: 'R16',  orientation: 'v', span: 2.4, parent: 'Hallway2' },
          { id:'thresh_AD16', kind:'threshold', hex:'AD16', orientation:'v', span: 2.4, parent:'Hallway2' },
          { id:'thresh_AD20', kind: 'threshold', hex: 'AD20', orientation: 'v', span: 2.4, parent: '1stFloorStairsDown' },
          
        ],
        objects: [
          { id:'room4_bed', kind: 'bed.double', hex: 'S14', wHex: 1.0, hHex: 1.0, rotDeg: 270, ox: 0.00, oy: -0.00 },
          { id:'room4_chair1', kind: 'chair', hex: 'W14', rotDeg: 60, ox: 0.00, oy: -0.00  },
          { id:'room4_chair2', kind: 'chair', hex: 'W13', rotDeg: 120, ox: 0.00, oy: -0.00  },
          { id:'room4_chair3', kind: 'chair', hex: 'U13', rotDeg: 240, ox: 0.00, oy: -0.00  },
          { id:'room4_chair4', kind: 'chair', hex: 'U14', rotDeg: 300, ox: 0.00, oy: -0.00  },
          { id:'room4_table', kind: 'table.round', hex: 'V13', wHex: 1.1, hHex: 1.1, rotDeg: 0 },
          { id:'room4_chest', kind: 'chest', hex: 'U15', rotDeg: 00, scale: 1.0 },
          { id:'room4_hearth', kind: 'hearth', hex: 'W15', rotDeg: 00, ox: 0.00, oy: -0.30 },
          
          { id:'room5_bed', kind: 'bed.double', hex: 'S20', wHex: 1.0, hHex: 1.0, rotDeg: 270, ox: 0.00, oy: -0.00 },
          { id:'room5_chair1', kind: 'chair', hex: 'W21', rotDeg: 60, ox: 0.00, oy: -0.00  },
          { id:'room5_chair2', kind: 'chair', hex: 'W20', rotDeg: 120, ox: 0.00, oy: -0.00  },
          { id:'room5_chair3', kind: 'chair', hex: 'U20', rotDeg: 240, ox: 0.00, oy: -0.00  },
          { id:'room5_chair4', kind: 'chair', hex: 'U21', rotDeg: 300, ox: 0.00, oy: -0.00  },
          { id:'room5_table', kind: 'table.round', hex: 'V20', wHex: 1.1, hHex: 1.1, rotDeg: 0 },
          { id:'room5_chest', kind: 'chest', hex: 'S18', rotDeg: 00, scale: 1.0 },
          { id:'room5_hearth', kind: 'hearth', hex: 'X18', rotDeg: 90, ox: -0.56, oy: -0.00 },
          

          
          { id:'room6_hearth', kind: 'cooking.hearth', hex: 'X18', wHex: 1.05, rotDeg: 270, ox: 0.94, oy: -0.00 },

          { id:'room7_bed', kind: 'bed.double', hex: 'AC14', wHex: 1.0, hHex: 1.0, rotDeg: 90, ox: 0.00, oy: -0.00, spriteScale:3.0 },
          { id:'room7_chair1', kind: 'chair', hex: 'AA14', rotDeg: 60, ox: 0.00, oy: -0.00  },
          { id:'room7_chair2', kind: 'chair', hex: 'AA13', rotDeg: 120, ox: 0.00, oy: -0.00  },
          { id:'room7_chair3', kind: 'chair', hex: 'Y13', rotDeg: 240, ox: 0.00, oy: -0.00  },
          { id:'room7_chair4', kind: 'chair', hex: 'Y14', rotDeg: 300, ox: 0.00, oy: -0.00  },
          { id:'room7_table', kind: 'table.round', hex: 'Z13', wHex: 1.1, hHex: 1.1, rotDeg: 0 },
          { id:'room7_chest', kind: 'chest', hex: 'AA15', rotDeg: 00, scale: 1.0 },
          { id:'room7_hearth', kind: 'hearth', hex: 'Y15', rotDeg: 00, ox: 0.00, oy: -0.30 },

          { id:'room1_bed1', kind: 'bed', hex: 'M21', wHex: 1.0, hHex: 1.0, rotDeg: 270, ox: 0.00, oy: 0.30, spriteScale:3.0 },
          { id:'room1_bed2', kind: 'bed', hex: 'M19', wHex: 1.0, hHex: 1.0, rotDeg: 270, ox: 0.00, oy: -0.30, spriteScale:3.0 },
          
          { id:'room2_bed1', kind: 'bed', hex: 'M18', wHex: 1.0, hHex: 1.0, rotDeg: 270, ox: 0.00, oy: 0.30, spriteScale:3.0 },
          { id:'room2_bed2', kind: 'bed', hex: 'M16', wHex: 1.0, hHex: 1.0, rotDeg: 270, ox: 0.00, oy: -0.30, spriteScale:3.0 },

          { id:'room3_bed1', kind: 'bed', hex: 'M15', wHex: 1.0, hHex: 1.0, rotDeg: 270, ox: 0.00, oy: 0.30, spriteScale:3.0 },
          { id:'room3_bed2', kind: 'bed', hex: 'M13', wHex: 1.0, hHex: 1.0, rotDeg: 270, ox: 0.00, oy: -0.30, spriteScale:3.0 },

          { id:'room8_bed1', kind: 'bed', hex: 'AI15', wHex: 1.0, hHex: 1.0, rotDeg: 90, ox: 0.00, oy: 0.30 },
          { id:'room8_bed2', kind: 'bed', hex: 'AI13', wHex: 1.0, hHex: 1.0, rotDeg: 90, ox: 0.00, oy: -0.30 },

          { id:'room9_bed1', kind: 'bed', hex: 'AI18', wHex: 1.0, hHex: 1.0, rotDeg: 90, ox: 0.00, oy: 0.30 },
          { id:'room9_bed2', kind: 'bed', hex: 'AI16', wHex: 1.0, hHex: 1.0, rotDeg: 90, ox: 0.00, oy: -0.30 },

          { id:'room10_bed1', kind: 'bed', hex: 'AI21', wHex: 1.0, hHex: 1.0, rotDeg: 90, ox: 0.00, oy: 0.30 },
          { id:'room10_bed2', kind: 'bed', hex: 'AI19', wHex: 1.0, hHex: 1.0, rotDeg: 90, ox: 0.00, oy: -0.30 },
          
          { id:'stairs_down', kind:'stairs', hex:'AB20', wHex: 1.0, hHex: 1.0, rotDeg: 270, ox: 0.0, oy: 0.0 },
        ],
      },
      {
        id: 'ground',
        name: 'Ground',
        rooms: [
          { id: 'CrossKeysGroundFloor', corners: ['M21.5','AJ21','AJ12.5','M13'], thickness: 20, floor: { kind: 'fog' }, wall: { kind: 'brick' } },
          { id: 'Pub', corners: ['M21.5','X21','X12.5','M13'], thickness: 20, floor: { kind: 'wood' }, wall: { kind: 'brick' } },
          { id: 'Kitchen', corners: ['X21','AJ21','AJ12.5','X12.5'], thickness: 20, floor: { kind: 'wood' }, wall: { kind: 'brick' } },

        ],
        openings: [
          { id:'kitchen_door', kind:'door', hex:'X15', orientation:'h', openPct: 0 },

          // Portals: movement/transition links between floors (renderer does not draw them)
          { id:'portal_up_AA21', kind:'portal', hex:'AA21', trigger:'enter', to:{ floorId:'upper', hex:'AC21' } },
          { id:'portal_up_AA20', kind:'portal', hex:'AA20', trigger:'enter', to:{ floorId:'upper', hex:'AC20' } },
        ],
        objects: [
          { kind: 'table.rect', hex: 'P15', wHex: 1.6, hHex: 0.9, rotDeg: 0 },
          { id:'Kitchen_hearth', kind: 'cooking.hearth', hex: 'X18', rotDeg: 270, ox: 0.94, oy: -0.00 },
        ],
      }
    ],

    tokens: [
      { id: 'a', name: 'Aelar', side: 'PC', hex: 'U16', label: 'A', init: 14, hp: 42, floorId: 'upper' },
      { id: 'b', name: 'Bran', side: 'PC', hex: 'S16', label: 'B', init: 12, hp: 35, floorId: 'ground' },
      { id: 'g1', name: 'Goblin 1', side: 'NPC', hex: 'U19', label: 'G1', init: 10, hp: 8, floorId: 'upper' },
      { id: 'g2', name: 'Goblin 2', side: 'NPC', hex: 'V19', label: 'G2', init: 10, hp: 8, floorId: 'upper' },
      { id: 'g3', name: 'Goblin 3', side: 'NPC', hex: 'W19', label: 'G3', init: 10, hp: 8, floorId: 'upper' },
      
    ]
  };

  // ===== Small utilities =====
  const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v));
  const isFiniteNum = (v) => Number.isFinite(Number(v));

  // ===== Hex id helpers =====
  function colToLetters(col) {
    let n = col + 1;
    let s = '';
    while (n > 0) {
      const r = (n - 1) % 26;
      s = String.fromCharCode(65 + r) + s;
      n = Math.floor((n - 1) / 26);
    }
    return s;
  }

  function lettersToCol(letters) {
    const u = String(letters).toUpperCase();
    let n = 0;
    for (let i = 0; i < u.length; i++) {
      const c = u.charCodeAt(i);
      if (c < 65 || c > 90) throw new Error('Bad column letters');
      n = n * 26 + (c - 64);
    }
    return n - 1;
  }

  function parseHexId(hex) {
    // Strict (integer) hex parsing: e.g., "X12".
    // Used for camera, tokens, openings, object placement, etc.
    const m = String(hex).trim().toUpperCase().match(/^([A-Z]+)([0-9]+)$/);
    if (!m) throw new Error('Bad hex: ' + hex);
    return { col: lettersToCol(m[1]), row: parseInt(m[2], 10) - 1 };
  }

  function parseHex(hex) {
    try { return parseHexId(hex); } catch { return null; }
  }

  function parseCornerHexId(hex) {
    // Corner parsing for *walls only*: allows fractional rows like "X12.5".
    // This enables half-row wall joints without changing the integer hex grid.
    const m = String(hex).trim().toUpperCase().match(/^([A-Z]+)([0-9]+(?:\.[0-9]+)?)$/);
    if (!m) throw new Error('Bad corner hex: ' + hex);

    const col = lettersToCol(m[1]);
    const rowNum = parseFloat(m[2]);
    if (!Number.isFinite(rowNum)) throw new Error('Bad corner row: ' + hex);

    // Stored row is 0-based and can be fractional.
    return { col, row: rowNum - 1 };
  }

  function parseCornerHex(hex) {
    try { return parseCornerHexId(hex); } catch { return null; }
  }

  function hexId(col, row) {
    return colToLetters(col) + String(row + 1);
  }

  // ===== World geometry (flat-top) =====
  function colStep() { return 1.5 * GRID.size; }
  function rowStep() { return sqrt3 * GRID.size; }

  // Row 0 is bottom row ("1"), row increases upward.
  function hexCenterWorld(col, row) {
    const x = col * colStep();
    const y = -(row * rowStep() + (col & 1) * (rowStep() / 2));
    return { x, y };
  }

  // ===== Camera transform =====
  function cameraWorld() { return hexCenterWorld(VIEW.camera.col, VIEW.camera.row); }

  function worldToScreen(p) {
    const cam = cameraWorld();
    return { x: VIEW.anchor.x + (p.x - cam.x) + VIEW.dx, y: VIEW.anchor.y + (p.y - cam.y) + VIEW.dy };
  }

  // ===== Floors (multi-floor) =====
  function getFloorsFromState(state) {
    const f = state && state.floors;
    if (Array.isArray(f)) return f;

    if (f && typeof f === 'object') {
      return Object.entries(f).map(([id, data]) => ({ id, ...(data || {}) }));
    }

    // Back-compat: single-floor state
    return [{
      id: (state && state.view && (state.view.floorId || state.view.floor_id || state.view.floor)) ? String(state.view.floorId || state.view.floor_id || state.view.floor) : 'floor1',
      name: 'Floor',
      rooms: Array.isArray(state && state.rooms) ? state.rooms : [],
      openings: Array.isArray(state && state.openings) ? state.openings : [],
      objects: Array.isArray(state && state.objects) ? state.objects : [],
    }];
  }

  function pickActiveFloorId(state, floors) {
    const wanted = state && state.view ? (state.view.floorId || state.view.floor_id || state.view.floor || state.view.level) : null;
    const w = wanted != null ? String(wanted) : '';
    if (w && floors.some(f => String(f.id) === w)) return w;
    return floors.length ? String(floors[0].id) : 'floor1';
  }

  function floorById(floors, id) {
    const target = String(id || '');
    return floors.find(f => String(f.id) === target) || null;
  }

  function entityFloorId(e) {
    if (!e || typeof e !== 'object') return '';
    return String(e.floorId || e.floor_id || e.floor || e.level || e.z || '');
  }

  function tokensOnFloor(state, floorId) {
    const all = Array.isArray(state && state.tokens) ? state.tokens : [];
    return all.filter(t => {
      const fid = entityFloorId(t);
      return fid ? fid === String(floorId) : true;
    });
  }

  // ===== Supersample =====
  let SUPERSAMPLE = 1; // default 1× (user can bump to 2×/3× for extra crispness)

  function readSupersample() {
    const raw = localStorage.getItem(STORAGE_SS);
    const v = parseFloat(raw != null ? raw : '1');
    if (!Number.isFinite(v)) return 1;
    return clamp(v, 1, 3);
  }

  function setSupersample(v) {
    const n = clamp(parseFloat(String(v)), 1, 3);
    localStorage.setItem(STORAGE_SS, String(n));
    SUPERSAMPLE = n;
    if (elSsSelect) elSsSelect.value = String(n);
    resize();
  }

  // ===== State access =====
  function getState() {
    const injected = (window && window.BATTLE_STATE != null) ? window.BATTLE_STATE : null;
    const raw = injected != null ? injected : DEFAULT_STATE;
    if (typeof raw === 'string') {
      try { return JSON.parse(raw); } catch { return DEFAULT_STATE; }
    }
    return raw;
  }

  // ===== Rooms / walls geometry =====
  function roomHasWalls(room) {
    const thick = Number(room && room.thickness != null ? room.thickness : 0);
    const wk = room && room.wall && room.wall.kind ? String(room.wall.kind).toLowerCase() : 'brick';
    return thick > 0 && wk !== 'none';
  }

  function roomToWallBox(room) {
    const corners = Array.isArray(room && room.corners) ? room.corners : [];
    if (corners.length !== 4) throw new Error('Room corners must be [TL, TR, BR, BL]');

    // Corners support fractional rows (e.g. "X12.5") to allow half-row wall joints.
    // This is *walls only*; tokens/objects/openings remain integer-hex.
    const tl = parseCornerHexId(corners[0]);
    const tr = parseCornerHexId(corners[1]);
    const br = parseCornerHexId(corners[2]);
    const bl = parseCornerHexId(corners[3]);

    const pTL = hexCenterWorld(tl.col, tl.row);
    const pTR = hexCenterWorld(tr.col, tr.row);
    const pBR = hexCenterWorld(br.col, br.row);
    const pBL = hexCenterWorld(bl.col, bl.row);

    // These are the *wall centerlines* derived from the room corner points.
    const xL = (pTL.x + pBL.x) / 2;
    const xR = (pTR.x + pBR.x) / 2;
    const yTop = (pTL.y + pTR.y) / 2;
    const yBot = (pBL.y + pBR.y) / 2;

    const thickness = Number(room && room.thickness != null ? room.thickness : 20);
    const t = roomHasWalls(room) ? thickness : 0;

    // New model (v5.36): walls are centered on the centerlines (xL/xR/yTop/yBot).
    // Floors should stop at the *inside edge* of the wall, so we shrink by t/2.
    const half = t / 2;

    const mid = { x1: xL, y1: yTop, x2: xR, y2: yBot };
    const floor = { x1: xL + half, y1: yTop + half, x2: xR - half, y2: yBot - half };

    return { xL, xR, yTop, yBot, thickness: t, mid, floor };
  }

  function roomFloorRectWorld(room, box) {
    // Floors fill the interior of walls. If there are no walls, this is the full mid-rect.
    const src = (roomHasWalls(room) ? box.floor : box.mid);
    return { x1: src.x1, y1: src.y1, x2: src.x2, y2: src.y2 };
  }

  function buildWallSegments(rooms) {
    const segs = [];
    for (const r of (Array.isArray(rooms) ? rooms : [])) {
      if (!r || !roomHasWalls(r)) continue;
      const box = roomToWallBox(r);
      const t = box.thickness;
      const color = (r && r.color) ? String(r.color) : COLORS.wall;

      // Segments are centerlines. We will render them as centered rectangles of thickness t.
      segs.push({ orientation: 'h', y: box.yTop, x1: box.xL, x2: box.xR, thickness: t, color });
      segs.push({ orientation: 'h', y: box.yBot, x1: box.xL, x2: box.xR, thickness: t, color });
      segs.push({ orientation: 'v', x: box.xL, y1: box.yTop, y2: box.yBot, thickness: t, color });
      segs.push({ orientation: 'v', x: box.xR, y1: box.yTop, y2: box.yBot, thickness: t, color });
    }
    return segs;
  }

  function findNearestWallSegment(wallSegs, orient, p) {
    const want = (orient === 'h' || orient === 'v') ? orient : 'h';
    let best = null;
    let bestD2 = Infinity;

    for (const s of (Array.isArray(wallSegs) ? wallSegs : [])) {
      if (!s || s.orientation !== want) continue;

      if (want === 'h') {
        const dy = Math.abs((p && p.y) - s.y);
        let dx = 0;
        if ((p && p.x) < s.x1) dx = s.x1 - (p.x);
        else if ((p && p.x) > s.x2) dx = (p.x) - s.x2;
        const d2 = dx * dx + dy * dy;
        if (d2 < bestD2) { bestD2 = d2; best = s; }
      } else {
        const dx = Math.abs((p && p.x) - s.x);
        let dy = 0;
        if ((p && p.y) < s.y1) dy = s.y1 - (p.y);
        else if ((p && p.y) > s.y2) dy = (p.y) - s.y2;
        const d2 = dx * dx + dy * dy;
        if (d2 < bestD2) { bestD2 = d2; best = s; }
      }
    }

    return best;
  }

  function quant01(v) {
    // Quantize to 0.01 to make floating world coords stable for hashing.
    return Math.round(v * 100) / 100;
  }

  function dedupeWallSegments(segs) {
    const map = new Map();

    for (const s of (Array.isArray(segs) ? segs : [])) {
      if (!s) continue;
      const o = s.orientation;
      if (o === 'h') {
        const y = quant01(s.y);
        const x1 = quant01(Math.min(s.x1, s.x2));
        const x2 = quant01(Math.max(s.x1, s.x2));
        const key = `h|${y}|${x1}|${x2}`;
        const prev = map.get(key);
        if (!prev) {
          map.set(key, { ...s, y, x1, x2 });
        } else {
          // If two rooms share the same wall segment, keep a single segment.
          // Use the maximum thickness (should usually match) and keep the first color.
          prev.thickness = Math.max(prev.thickness, s.thickness);
        }
      } else {
        const x = quant01(s.x);
        const y1 = quant01(Math.min(s.y1, s.y2));
        const y2 = quant01(Math.max(s.y1, s.y2));
        const key = `v|${x}|${y1}|${y2}`;
        const prev = map.get(key);
        if (!prev) {
          map.set(key, { ...s, x, y1, y2 });
        } else {
          prev.thickness = Math.max(prev.thickness, s.thickness);
        }
      }
    }

    return [...map.values()];
  }

  function drawWallSegments(targetCtx, wallSegs) {
    // Solid, uniform walls (no alpha edge/stroke pass).
    for (const s of (Array.isArray(wallSegs) ? wallSegs : [])) {
      if (!s || !s.thickness) continue;

      const t = s.thickness;
      const half = t / 2;
      targetCtx.fillStyle = s.color || COLORS.wall;

      if (s.orientation === 'h') {
        // Extend by half thickness to neatly cover corner joins.
        const x1 = s.x1 - half;
        const x2 = s.x2 + half;
        const y1 = s.y - half;
        const y2 = s.y + half;

        const p1 = worldToScreen({ x: x1, y: y1 });
        const p2 = worldToScreen({ x: x2, y: y2 });
        const w = p2.x - p1.x;
        const h = p2.y - p1.y;
        if (w > 0 && h > 0) targetCtx.fillRect(p1.x, p1.y, w, h);

      } else {
        const x1 = s.x - half;
        const x2 = s.x + half;
        const y1 = s.y1 - half;
        const y2 = s.y2 + half;

        const p1 = worldToScreen({ x: x1, y: y1 });
        const p2 = worldToScreen({ x: x2, y: y2 });
        const w = p2.x - p1.x;
        const h = p2.y - p1.y;
        if (w > 0 && h > 0) targetCtx.fillRect(p1.x, p1.y, w, h);
      }
    }
  }

  // ===== Floor fills =====
  function floorColor(kind) {
    const k = String(kind || 'wood').toLowerCase();
    if (k === 'fog') return COLORS.fogUnseen;
    if (k === 'stone') return COLORS.floorStone;
    if (k === 'cobble') return COLORS.floorCobble;
    if (k.startsWith('stairs')) return COLORS.floorWood;
    return COLORS.floorWood;
  }

  function isFogFloorRoom(room) {
    const k = room && room.floor && room.floor.kind ? String(room.floor.kind).toLowerCase() : '';
    return k === 'fog';
  }

  function drawFloorsLayered(rooms) {
    for (const r of (Array.isArray(rooms) ? rooms : [])) {
      const box = roomToWallBox(r);
      const f = roomFloorRectWorld(r, box);
      const p1 = worldToScreen({ x: f.x1, y: f.y1 });
      const p2 = worldToScreen({ x: f.x2, y: f.y2 });
      const w = p2.x - p1.x;
      const h = p2.y - p1.y;
      if (w <= 0 || h <= 0) continue;

      const fk = (r && r.floor && r.floor.kind) ? r.floor.kind : 'wood';
      ctx.fillStyle = floorColor(fk);
      ctx.fillRect(p1.x, p1.y, w, h);

      // light outline
      ctx.strokeStyle = 'rgba(0,0,0,0.06)';
      ctx.lineWidth = 1;
      ctx.strokeRect(p1.x + 0.5, p1.y + 0.5, Math.max(0, w - 1), Math.max(0, h - 1));
    }
  }

  // ===== Openings =====
  function openingOrientation(opening) {
    const o = opening && opening.orientation ? String(opening.orientation).toLowerCase() : 'h';
    if (o === 'v' || o === 'vert' || o === 'vertical') return 'v';
    return 'h';
  }

  function openingSpan(opening) {
    const s = Number(opening && opening.span != null ? opening.span : 1);
    return clamp(Number.isFinite(s) ? s : 1, 0.5, 4);
  }

  function cutOpeningHole(targetCtx, opening, wallSegs) {
    const kind = String(opening && opening.kind ? opening.kind : 'door').toLowerCase();
    if (kind === 'portal' || kind === 'connector') return;

    const orient = openingOrientation(opening);
    const p = parseHex(opening.hex);
    if (!p) return;

    const hexWorld = hexCenterWorld(p.col, p.row);
    const seg = findNearestWallSegment(wallSegs, orient, hexWorld);

    const baseLen = GRID.size * 1.2;
    const span = openingSpan(opening);
    const len = baseLen * span;

    // IMPORTANT (v5.40): Openings are authored in the *correct hex*.
    // We do NOT "snap" their center to the nearest wall segment, because that can jump to a different
    // segment when fog changes the set of wall segments. We only borrow thickness from the nearest wall.
    const cx = hexWorld.x;
    const cy = hexWorld.y;
    const thickness = seg ? seg.thickness : 28;

    const centerS = worldToScreen({ x: cx, y: cy });
    const cutH = thickness + 4;
    const cutW = len + 4;

    targetCtx.save();
    targetCtx.translate(centerS.x, centerS.y);
    if (orient === 'v') targetCtx.rotate(Math.PI / 2);

    targetCtx.beginPath();
    targetCtx.rect(-cutW / 2, -cutH / 2, cutW, cutH);
    targetCtx.fill();

    targetCtx.restore();
  }

  function drawOpeningMarker(opening, wallSegs) {
    const kind = String(opening && opening.kind ? opening.kind : 'door').toLowerCase();

    // Thresholds are *invisible* seam connectors.
    // They still cut walls (handled in cutOpeningHole), and they still participate in fog visibility.
    // But they should not render as "doors".
    if (kind === 'threshold' || kind === 'portal' || kind === 'connector') return;

    const orient = openingOrientation(opening);
    const p = parseHex(opening.hex);
    if (!p) return;

    const hexWorld = hexCenterWorld(p.col, p.row);
    const seg = findNearestWallSegment(wallSegs, orient, hexWorld);

    // IMPORTANT (v5.40): Do not snap opening position to wall segments (can jump under fog).
    // Use the authored hex center for position; only borrow thickness for styling.
    const cx = hexWorld.x;
    const cy = hexWorld.y;
    const thickness = seg ? seg.thickness : 28;

    const c = worldToScreen({ x: cx, y: cy });
    const len = (GRID.size * 1.2) * openingSpan(opening);
    const openPct = clamp(Number(opening && opening.openPct != null ? opening.openPct : 0), 0, 1);

    ctx.save();
    ctx.translate(c.x, c.y);
    if (orient === 'v') ctx.rotate(Math.PI / 2);

    if (kind === 'window') {
      ctx.strokeStyle = COLORS.window;
      ctx.globalAlpha = 0.85;
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(-len / 2, 0);
      ctx.lineTo(len / 2, 0);
      ctx.stroke();

      ctx.globalAlpha = 0.45;
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(-len / 2, -thickness * 0.25);
      ctx.lineTo(len / 2, -thickness * 0.25);
      ctx.moveTo(-len / 2, thickness * 0.25);
      ctx.lineTo(len / 2, thickness * 0.25);
      ctx.stroke();

      ctx.restore();
      return;
    }
    // Door: closed = bar across; open = a visible "leaf" that swings on a hinge.
    // You can control swing direction with:
    //   - hinge: 'left' | 'right'   (default: 'left')
    //   - swing: -1 | 1             (default: -1, i.e., "up" in local door coordinates)
    ctx.strokeStyle = COLORS.door;
    ctx.lineWidth = 4;
    ctx.globalAlpha = 0.9;

    if (openPct < 0.05) {
      ctx.beginPath();
      ctx.moveTo(-len / 2, 0);
      ctx.lineTo(len / 2, 0);
      ctx.stroke();
    } else {
      const hingeSide = String(opening && opening.hinge != null ? opening.hinge : 'left').toLowerCase();
      const hingeRight = (hingeSide === 'right' || hingeSide === 'r');

      const rawSwing = Number(opening && (opening.swing ?? opening.swingDir ?? opening.polarity));
      const swingSign = (rawSwing === 1 || rawSwing === -1) ? rawSwing : -1;

      // Hinge on left or right edge of the opening.
      const hingeX = hingeRight ? (len / 2) : (-len / 2);
      const hingeY = 0;

      const leafLen = len * 0.80;
      const ang = openPct * (Math.PI / 2); // 0..90deg

      // Leaf extends away from the hinge into the opening.
      const x2 = hingeX + (hingeRight ? -1 : 1) * leafLen * Math.cos(ang);
      const y2 = hingeY + swingSign * leafLen * Math.sin(ang);

      ctx.beginPath();
      ctx.moveTo(hingeX, hingeY);
      ctx.lineTo(x2, y2);
      ctx.stroke();

      // Small hinge dot for readability
      ctx.fillStyle = COLORS.door;
      ctx.globalAlpha = 0.95;
      ctx.beginPath();
      ctx.arc(hingeX, hingeY, 2.2, 0, Math.PI * 2);
      ctx.fill();
    }

    ctx.restore();
  }

  function roomById(rooms, id) {
    const target = String(id || '');
    if (!target) return null;
    return (Array.isArray(rooms) ? rooms : []).find(r => r && String(r.id) === target) || null;
  }

  function roomFloorKind(room) {
    return (room && room.floor && room.floor.kind) ? String(room.floor.kind) : 'wood';
  }

  function thresholdFillColor(opening, rooms, fogEnabled) {
    // Desired behavior:
    // 1) Fog OFF -> always use parent room floor color.
    // 2) Fog ON -> if parent room is visible -> parent floor color; else -> fog color.
    const parentId = opening && opening.parent ? String(opening.parent) : '';
    const parent = parentId ? roomById(rooms, parentId) : null;
    const parentColor = floorColor(roomFloorKind(parent));

    if (!fogEnabled) return parentColor;

    // If fog is on but we don't have a computed visibility set, fall back to fog.
    if (!RENDER_FOG || !RENDER_FOG.enabled) return floorColor('fog');

    if (parentId && RENDER_FOG.visible && RENDER_FOG.visible.has(parentId)) return parentColor;
    return floorColor('fog');
  }

  function drawThresholdSeamFills(openings, rooms, wallSegs, fogEnabled) {
    for (const o of (Array.isArray(openings) ? openings : [])) {
      const kind = String(o && o.kind ? o.kind : '').toLowerCase();
      if (kind !== 'threshold') continue;

      const orient = openingOrientation(o);
      const p = parseHex(o.hex);
      if (!p) continue;

      const hexWorld = hexCenterWorld(p.col, p.row);
      const seg = findNearestWallSegment(wallSegs, orient, hexWorld);

      const baseLen = GRID.size * 1.2;
      const span = openingSpan(o);
      const len = baseLen * span;

      // IMPORTANT (v5.40): Do not snap thresholds to wall segments; they are authored in the correct hex.
      // Only use nearest segment for thickness sizing.
      const cx = hexWorld.x;
      const cy = hexWorld.y;
      const thickness = seg ? seg.thickness : 28;

      const centerS = worldToScreen({ x: cx, y: cy });
      const cutH = thickness + 4;
      const cutW = len + 4;

      ctx.save();
      ctx.translate(centerS.x, centerS.y);
      if (orient === 'v') ctx.rotate(Math.PI / 2);

      ctx.fillStyle = thresholdFillColor(o, rooms, fogEnabled);
      ctx.fillRect(-cutW / 2, -cutH / 2, cutW, cutH);

      ctx.restore();
    }
  }

  // ===== Fog (room-based, per-floor) =====
  function normalizeFog(state, floorId) {
    const raw = (state && state.fog && typeof state.fog === 'object') ? state.fog : {};

    const enabled = !!raw.enabled;
    const autoCompute = raw.autoCompute !== false;
    const autoExplore = raw.autoExplore !== false;
    const maxDepth = clamp(Number.isFinite(Number(raw.maxDepth)) ? Number(raw.maxDepth) : 1, 0, 12);

    const unseenAlpha = clamp(Number.isFinite(Number(raw.unseenAlpha)) ? Number(raw.unseenAlpha) : 0.92, 0, 1);
    const exploredAlpha = clamp(Number.isFinite(Number(raw.exploredAlpha)) ? Number(raw.exploredAlpha) : 0.55, 0, 1);

    const perVis = (raw.visibleRoomIdsByFloor && typeof raw.visibleRoomIdsByFloor === 'object') ? raw.visibleRoomIdsByFloor : null;
    const perExp = (raw.exploredRoomIdsByFloor && typeof raw.exploredRoomIdsByFloor === 'object') ? raw.exploredRoomIdsByFloor : null;

    const getVis = () => {
      if (perVis) return Array.isArray(perVis[floorId]) ? perVis[floorId] : [];
      return Array.isArray(raw.visibleRoomIds) ? raw.visibleRoomIds : [];
    };

    const getExp = () => {
      if (perExp) return Array.isArray(perExp[floorId]) ? perExp[floorId] : [];
      return Array.isArray(raw.exploredRoomIds) ? raw.exploredRoomIds : [];
    };

    const setVis = (ids) => {
      if (perVis) perVis[floorId] = ids;
      else raw.visibleRoomIds = ids;
    };

    const setExp = (ids) => {
      if (perExp) perExp[floorId] = ids;
      else raw.exploredRoomIds = ids;
    };

    return {
      enabled,
      autoCompute,
      autoExplore,
      maxDepth,
      unseenAlpha,
      exploredAlpha,
      get visibleRoomIds() { return getVis(); },
      get exploredRoomIds() { return getExp(); },
      setVisibleRoomIds: setVis,
      setExploredRoomIds: setExp,
    };
  }

  function buildRoomMeta(rooms) {
    const meta = new Map();
    for (const r of (Array.isArray(rooms) ? rooms : [])) {
      if (!r || !r.id) continue;
      const box = roomToWallBox(r);
      const f = roomFloorRectWorld(r, box);
      meta.set(String(r.id), { room: r, floorRect: f });
    }
    return meta;
  }

  function roomContainsWorldPoint(roomRect, p) {
    if (!roomRect) return false;
    return (p.x >= roomRect.x1 && p.x <= roomRect.x2 && p.y >= roomRect.y1 && p.y <= roomRect.y2);
  }

  function pickRoomAtWorldPoint(roomMeta, p) {
    // Pick the smallest area room that contains p.
    let bestId = null;
    let bestArea = Infinity;

    for (const [id, info] of roomMeta.entries()) {
      const r = info.floorRect;
      if (!roomContainsWorldPoint(r, p)) continue;
      const area = Math.abs((r.x2 - r.x1) * (r.y2 - r.y1));
      if (area < bestArea) { bestArea = area; bestId = id; }
    }

    return bestId;
  }

  function openingRoomIds(opening, roomMeta) {
    // Heuristic: sample just "inside" each side of the opening and see which room contains it.
    const orient = openingOrientation(opening);
    const p = parseHex(opening.hex);
    if (!p) return [];

    const hw = hexCenterWorld(p.col, p.row);
    const seg = findNearestWallSegment(buildWallSegments([...roomMeta.values()].map(v => v.room)), orient, hw);

    let cx = hw.x, cy = hw.y;
    let thickness = 28;
    if (seg) {
      thickness = seg.thickness;
      if (orient === 'h') cy = seg.y; else cx = seg.x;
    }

    const eps = Math.max(6, thickness * 0.6);
    const samples = (orient === 'h')
      ? [{ x: cx, y: cy - eps }, { x: cx, y: cy + eps }]
      : [{ x: cx - eps, y: cy }, { x: cx + eps, y: cy }];

    const ids = new Set();
    for (const s of samples) {
      const id = pickRoomAtWorldPoint(roomMeta, s);
      if (id) ids.add(id);
    }
    return [...ids];
  }

  function computeRenderFog(state, floorId, rooms, openings, tokens) {
    const fog = normalizeFog(state, floorId);
    if (!fog.enabled) return null;

    const roomMeta = buildRoomMeta(rooms);

    const explored = new Set((fog.exploredRoomIds || []).map(String));
    const visible = new Set((fog.visibleRoomIds || []).map(String));

    if (!fog.autoCompute) {
      return { enabled: true, explored, visible, maxDepth: fog.maxDepth, exploredAlpha: fog.exploredAlpha, unseenAlpha: fog.unseenAlpha };
    }

    // Start from rooms containing PCs
    const pcs = (Array.isArray(tokens) ? tokens : []).filter(isPlayerToken);
    const start = new Set();
    for (const t of pcs) {
      const hp = parseHex(t.hex);
      if (!hp) continue;
      const world = hexCenterWorld(hp.col, hp.row);
      const rid = pickRoomAtWorldPoint(roomMeta, world);
      if (rid) start.add(rid);
    }

    // Build adjacency from doors/windows/thresholds that are effectively passable for visibility
    const adj = new Map();
    const addEdge = (a, b) => {
      if (!a || !b || a === b) return;
      if (!adj.has(a)) adj.set(a, new Set());
      if (!adj.has(b)) adj.set(b, new Set());
      adj.get(a).add(b);
      adj.get(b).add(a);
    };

    for (const o of (Array.isArray(openings) ? openings : [])) {
      const k = String(o && o.kind ? o.kind : 'door').toLowerCase();
      if (k === 'portal' || k === 'connector') continue;

      // Visibility: thresholds always; doors mostly; windows count but don't auto-explore beyond.
      const openPct = clamp(Number(o && o.openPct != null ? o.openPct : 0), 0, 1);
      const isOpenForSight = (k === 'threshold') || (k === 'window') || (k === 'door' && openPct >= 0.5);
      if (!isOpenForSight) continue;

      const ids = openingRoomIds(o, roomMeta);
      if (ids.length === 2) addEdge(ids[0], ids[1]);
    }

    // BFS out to maxDepth
    const q = [];
    const dist = new Map();

    for (const rid of start) {
      q.push(rid);
      dist.set(rid, 0);
    }

    const vis = new Set();
    while (q.length) {
      const cur = q.shift();
      const d = dist.get(cur) || 0;
      vis.add(cur);
      if (d >= fog.maxDepth) continue;
      const ns = adj.get(cur);
      if (!ns) continue;
      for (const n of ns) {
        if (!dist.has(n)) {
          dist.set(n, d + 1);
          q.push(n);
        }
      }
    }

    if (fog.autoExplore) {
      for (const rid of vis) explored.add(rid);
      fog.setExploredRoomIds([...explored]);
    }

    fog.setVisibleRoomIds([...vis]);

    return { enabled: true, explored, visible: vis, maxDepth: fog.maxDepth, exploredAlpha: fog.exploredAlpha, unseenAlpha: fog.unseenAlpha };
  }

  function drawRememberedRoomOverlays(rooms) {
    if (!RENDER_FOG || !RENDER_FOG.enabled) return;

    ctx.save();
    ctx.globalAlpha = RENDER_FOG.exploredAlpha;
    ctx.fillStyle = COLORS.fogExplored;

    for (const r of (Array.isArray(rooms) ? rooms : [])) {
      if (!r || !r.id) continue;
      if (isFogFloorRoom(r)) continue;

      const id = String(r.id);
      if (!RENDER_FOG.explored.has(id)) continue;
      if (RENDER_FOG.visible.has(id)) continue;

      const box = roomToWallBox(r);
      const f = roomFloorRectWorld(r, box);
      const p1 = worldToScreen({ x: f.x1, y: f.y1 });
      const p2 = worldToScreen({ x: f.x2, y: f.y2 });
      const w = p2.x - p1.x;
      const h = p2.y - p1.y;
      if (w > 0 && h > 0) ctx.fillRect(p1.x, p1.y, w, h);
    }

    ctx.restore();
  }

  // ===== Objects / tokens orientation =====
  function degToRad(deg) {
    return (deg * Math.PI) / 180;
  }

  function facingToDeg(facing) {
    const f = String(facing || '').toUpperCase();
    const map = { N:0, NE:60, E:90, SE:120, S:180, SW:240, W:270, NW:300 };
    return map[f] != null ? map[f] : 0;
  }

  function objectRotationRad(o) {
    if (!o) return 0;
    if (Number.isFinite(o.rotDeg)) return degToRad(Number(o.rotDeg));
    if (Number.isFinite(o.deg)) return degToRad(Number(o.deg));
    if (Number.isFinite(o.rot)) return degToRad(Number(o.rot));
    if (o.facing) return degToRad(facingToDeg(o.facing));
    if (o.orientation && typeof o.orientation === 'number') return degToRad(o.orientation);
    if (o.head) return degToRad(facingToDeg(o.head));
    return 0;
  }

  function objectCenterWorld(o) {
    const p = parseHex(o && o.hex);
    if (!p) return null;

    const base = hexCenterWorld(p.col, p.row);

    // Offsets are expressed in "hex radius" units (GRID.size).
    // Offsets are ABSOLUTE/world-space and do NOT rotate with the object.
    const ox = Number.isFinite(Number(o && (o.ox ?? o.offsetX ?? o.xOffset ?? o.dx))) ? Number(o.ox ?? o.offsetX ?? o.xOffset ?? o.dx) : 0;
    const oy = Number.isFinite(Number(o && (o.oy ?? o.offsetY ?? o.yOffset ?? o.dy))) ? Number(o.oy ?? o.offsetY ?? o.yOffset ?? o.dy) : 0;

    return { x: base.x + ox * GRID.size, y: base.y + oy * GRID.size };
  }

  function objectCenterScreen(o) {
    const w = objectCenterWorld(o);
    if (!w) return null;
    return worldToScreen(w);
  }

  function objectSizePx(o) {
    const base = GRID.size * 1.15;

    const wHex = Number.isFinite(Number(o && o.wHex)) ? Number(o.wHex) : 1;
    const hHex = Number.isFinite(Number(o && o.hHex)) ? Number(o.hHex) : 1;
    const scale = Number.isFinite(Number(o && o.scale)) ? Number(o.scale) : 1;

    // IMPORTANT: this size drives BOTH sprites and placeholder shapes.
    // Keep it data-driven; only special-case kinds that are truly different footprints.
    const kind = String(o && o.kind ? o.kind : '').toLowerCase();
    const kindMul = (kind === 'cooking.hearth') ? 2.2 : 1.0;

    return { w: base * wHex * scale * kindMul, h: base * hHex * scale * kindMul };
  }

  function objectVisible(o, roomMetaAll) {
    if (!RENDER_FOG || !RENDER_FOG.enabled) return true;

    // Hearths: always visible if room is renderable (they're structural)
    const kind = String(o && o.kind ? o.kind : '').toLowerCase();

    const w = objectCenterWorld(o);
    if (!w) return true;

    const rid = pickRoomAtWorldPoint(roomMetaAll, w);
    if (!rid) return true;

    if (kind === 'hearth' || kind === 'cooking.hearth') return RENDER_FOG.explored.has(rid) || RENDER_FOG.visible.has(rid);

    return RENDER_FOG.visible.has(rid) || RENDER_FOG.explored.has(rid);
  }

  function drawObject(o, roomMetaAll) {
    if (!o) return;
    if (!objectVisible(o, roomMetaAll)) return;

    const c = objectCenterScreen(o);
    if (!c) return;

    const { w, h } = objectSizePx(o);
    const rot = objectRotationRad(o);

    const kind = String(o.kind || 'object').toLowerCase();
    // Sprite first (optional)
    // NOTE: sprite-only scale multipliers live on the sprite def and/or the object record.
    // They do NOT affect fallback shapes.
    if (elSpriteToggle && elSpriteToggle.checked) {
      const def = getSpriteDef(kind);
      if (def) {
        const img = loadSprite(def.file);

        // Start with def scaling (defaults to 1)
        let sx = 1, sy = 1;
        if (isFiniteNum(def.scale)) { sx = Number(def.scale); sy = Number(def.scale); }
        if (isFiniteNum(def.scaleX)) sx = Number(def.scaleX);
        if (isFiniteNum(def.scaleY)) sy = Number(def.scaleY);

        // Instance overrides (multiply so you can "nudge" without reauthoring defs)
        if (isFiniteNum(o.spriteScale)) { sx *= Number(o.spriteScale); sy *= Number(o.spriteScale); }
        if (isFiniteNum(o.spriteScaleX)) sx *= Number(o.spriteScaleX);
        if (isFiniteNum(o.spriteScaleY)) sy *= Number(o.spriteScaleY);

        const ok = drawSprite(img, c.x, c.y, w * sx, h * sy, def.rotate === 'deg' ? rot : 0);
        if (ok) return;
      }
    }

    // Placeholder shapes
    ctx.save();
    ctx.translate(c.x, c.y);
    if (rot) ctx.rotate(rot);

    // Default style
    ctx.fillStyle = 'rgba(255,255,255,0.08)';
    ctx.strokeStyle = 'rgba(0,0,0,0.25)';
    ctx.lineWidth = 1;

    if (kind === 'stairs') {
      // Simple stairs placeholder: trapezoid wedge.
      // IMPORTANT: Placeholder-only sizing boost so you don't have to "lie" with wHex/hHex (which would affect sprites).
      const rw = w * 2;
      const rh = h * 4; 
      const topW = rw * 0.4; 

      ctx.fillStyle = COLORS.stairsWood;
      ctx.beginPath();
      // bottom (wide)
      ctx.moveTo(-rw/2,  rh/2);
      ctx.lineTo( rw/2,  rh/2);
      // top (narrow)
      ctx.lineTo( topW/2, -rh/2);
      ctx.lineTo(-topW/2, -rh/2);
      ctx.closePath();
      ctx.fill();

    } else if (kind === 'chest') {
      // Rounded rect + vertical slats
      const rw = w * 0.90, rh = h * 0.70;

      ctx.fillStyle = COLORS.chestWood;
      ctx.strokeStyle = 'rgba(0,0,0,0.22)';
      ctx.lineWidth = 1;

      roundRectPath(ctx, -rw/2, -rh/2, rw, rh, Math.min(10, rh/3));
      ctx.fill();
      ctx.stroke();

      ctx.strokeStyle = 'rgba(0,0,0,0.32)';
      ctx.lineWidth = 2;
      const slats = 4;
      for (let i = 1; i < slats; i++) {
        const x = -rw/2 + (rw * i)/slats;
        ctx.beginPath();
        ctx.moveTo(x, -rh/2);
        ctx.lineTo(x, rh/2);
        ctx.stroke();
      }

    } else if (kind === 'hearth' || kind === 'cooking.hearth') {

      // Hearth: wide rectangle, squared corners (top-down fireplace)
      // Solid color, no outline, no inner opening (clean placeholder).
      const rw = w * 1.15;
      const rh = h * 0.55;

      ctx.fillStyle = COLORS.hearth;
      ctx.fillRect(-rw/2, -rh/2, rw, rh);

    } else if (kind === 'bed' || kind === 'bed.double') {
      // Beds should read as "longer than wide" in default orientation.
      // (Width along X, length along Y in local coordinates.)
      // NOTE: Placeholder-only boost so wHex:1/hHex:1 looks like a bed filling the hex.
      // This does NOT affect sprite sizing.
      const isDouble = (kind === 'bed.double');
      const BOOST = 2.0;
      const widthMul = isDouble ? 1.5 : 1.0;

      const rw = w * 0.70 * BOOST * widthMul;
      const rh = h * 0.95 * BOOST;

      ctx.fillStyle = COLORS.bedFabric;
      roundRectPath(ctx, -rw/2, -rh/2, rw, rh, Math.min(18, rw/3));
      ctx.fill();
      ctx.stroke();

      // Pillow/headboard hint at the "top" end (negative Y)
      ctx.fillStyle = COLORS.bedPillow;
      const pad = Math.max(6, Math.min(14, Math.min(rw, rh) * 0.08));
      const pillowH = Math.max(10, rh * 0.22);
      const innerW = Math.max(0, rw - pad * 2);

      const pillowRadius = Math.min(14, pillowH * 0.5);
      const drawPillow = (x, y, pw) => {
        roundRectPath(ctx, x, y, pw, pillowH, pillowRadius);
        ctx.fill();
      };

      if (!isDouble) {
        drawPillow(-rw/2 + pad, -rh/2 + pad, innerW);
      } else {
        const gap = Math.max(6, Math.min(14, innerW * 0.06));
        const pw = Math.max(0, (innerW - gap) / 2);
        const x0 = -rw/2 + pad;
        const y0 = -rh/2 + pad;
        drawPillow(x0, y0, pw);
        drawPillow(x0 + pw + gap, y0, pw);
      }

    } else if (kind === 'table.round') {


      // True round table (circle)
      const r = Math.min(w, h) * 0.64;
      ctx.fillStyle = COLORS.objectWood;
      ctx.beginPath();
      ctx.arc(0, 0, r, 0, Math.PI * 2);
      ctx.fill();
      ctx.stroke();

    } else if (kind.startsWith('table')) {
      // Rect/square tables
      const rw = w * 0.90, rh = h * 0.55;
      ctx.fillStyle = COLORS.objectWood;
      roundRectPath(ctx, -rw/2, -rh/2, rw, rh, Math.min(10, rh/3));
      ctx.fill();
      ctx.stroke();

    } else if (kind === 'chair') {
      // Simple top-down chair: half-circle back + rectangular seat.
      // Single fill color, no outlines.
      const rw = Math.min(w, h) * 0.65;
      const r = rw / 2;
      const rectH = rw * 0.55;

      // Center the combined shape around (0,0).
      const yShift = -(rectH - r) / 2;

      ctx.fillStyle = COLORS.objectWood;
      ctx.beginPath();
      // Top half-circle (back)
      ctx.moveTo(-rw / 2, yShift);
      ctx.arc(0, yShift, r, Math.PI, 0, false);
      // Seat rectangle
      ctx.lineTo(rw / 2, yShift + rectH);
      ctx.lineTo(-rw / 2, yShift + rectH);
      ctx.closePath();
      ctx.fill();

    } else {

      // Generic rounded marker
      const rw = w * 0.80, rh = h * 0.55;
      roundRectPath(ctx, -rw/2, -rh/2, rw, rh, 10);
      ctx.fill();
      ctx.stroke();
    }

    // Label
    ctx.fillStyle = 'rgba(233,238,247,0.55)';
    ctx.font = '11px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(String(kind).replaceAll('.', ' '), 0, 0);

    ctx.restore();
  }

  function roundRectPath(targetCtx, x, y, w, h, r) {
    const rr = Math.max(0, Math.min(r, Math.min(Math.abs(w), Math.abs(h)) / 2));
    targetCtx.beginPath();
    targetCtx.moveTo(x + rr, y);
    targetCtx.lineTo(x + w - rr, y);
    targetCtx.quadraticCurveTo(x + w, y, x + w, y + rr);
    targetCtx.lineTo(x + w, y + h - rr);
    targetCtx.quadraticCurveTo(x + w, y + h, x + w - rr, y + h);
    targetCtx.lineTo(x + rr, y + h);
    targetCtx.quadraticCurveTo(x, y + h, x, y + h - rr);
    targetCtx.lineTo(x, y + rr);
    targetCtx.quadraticCurveTo(x, y, x + rr, y);
    targetCtx.closePath();
  }

  // ===== Tokens =====
  function isPlayerToken(t) {
    return String(t && t.side ? t.side : '').toUpperCase() === 'PC';
  }

  function tokenVisible(t, roomMetaAll) {
    if (!RENDER_FOG || !RENDER_FOG.enabled) return true;

    // PCs always visible on their floor.
    if (isPlayerToken(t)) return true;

    const p = parseHex(t && t.hex);
    if (!p) return true;
    const w = hexCenterWorld(p.col, p.row);
    const rid = pickRoomAtWorldPoint(roomMetaAll, w);
    if (!rid) return true;

    return RENDER_FOG.visible.has(rid);
  }

  function drawToken(t, roomMetaAll) {
    if (!t || !t.hex) return;
    if (!tokenVisible(t, roomMetaAll)) return;

    const p = parseHexId(t.hex);
    const c = worldToScreen(hexCenterWorld(p.col, p.row));

    const r = GRID.size * 0.40;
    const isPC = isPlayerToken(t);

    // Optional sprite
    if (elSpriteToggle && elSpriteToggle.checked) {
      const def = getSpriteDef(isPC ? 'token.pc' : 'token.npc');
      if (def) {
        const img = loadSprite(def.file);
        const ok = drawSprite(img, c.x, c.y, r * 2.2, r * 2.2, 0);
        if (ok) {
          drawTokenLabel(t, c.x, c.y, isPC);
          return;
        }
      }
    }

    ctx.save();
    ctx.fillStyle = isPC ? COLORS.tokenHero : COLORS.tokenEnemy;
    ctx.beginPath();
    ctx.arc(c.x, c.y, r, 0, Math.PI * 2);
    ctx.fill();

    ctx.strokeStyle = 'rgba(255,255,255,0.15)';
    ctx.lineWidth = 2;
    ctx.stroke();

    drawTokenLabel(t, c.x, c.y, isPC);

    ctx.restore();
  }

  function drawTokenLabel(t, x, y, isPC) {
    const label = (t && t.label) ? String(t.label) : (t && t.name ? String(t.name).slice(0, 2) : '?');

    ctx.fillStyle = isPC ? COLORS.tokenTextDark : COLORS.tokenTextLight;
    ctx.font = 'bold 14px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(label, x, y);
  }

  // ===== Grid =====
  function drawHexOutline(center, size) {
    const pts = [];
    for (let i = 0; i < 6; i++) {
      const a = (Math.PI / 180) * (60 * i);
      pts.push({ x: center.x + size * Math.cos(a), y: center.y + size * Math.sin(a) });
    }

    ctx.beginPath();
    ctx.moveTo(pts[0].x, pts[0].y);
    for (let i = 1; i < pts.length; i++) ctx.lineTo(pts[i].x, pts[i].y);
    ctx.closePath();
    ctx.stroke();
  }

  function drawGrid() {
    const rect = canvas.getBoundingClientRect();
    const w = Math.max(1, rect.width);
    const h = Math.max(1, rect.height);

    const colsR = Math.ceil((w / 2) / colStep()) + 4;
    const rowsR = Math.ceil((h / 2) / rowStep()) + 4;

    const c0 = VIEW.camera.col;
    const r0 = VIEW.camera.row;

    ctx.save();
    ctx.strokeStyle = `rgba(255,255,255,${GRID.lineAlpha})`;
    ctx.lineWidth = GRID.lineWidth;

    for (let dc = -colsR; dc <= colsR; dc++) {
      for (let dr = -rowsR; dr <= rowsR; dr++) {
        const col = c0 + dc;
        const row = r0 + dr;
        const p = worldToScreen(hexCenterWorld(col, row));

        // Quick reject
        if (p.x < -100 || p.x > w + 100 || p.y < -100 || p.y > h + 100) continue;

        drawHexOutline(p, GRID.size);
      }
    }

    // Labels
    const bright = !!(elLabelBoldToggle && elLabelBoldToggle.checked);
    ctx.globalAlpha = bright ? 1 : GRID.labelAlpha;
    ctx.fillStyle = bright ? 'rgba(233,238,247,0.96)' : 'rgba(233,238,247,0.65)';
    ctx.font = bright
      ? '900 14px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial'
      : GRID.labelFont;
    ctx.textAlign = 'left';
    ctx.textBaseline = 'middle';

    if (bright) {
      ctx.lineWidth = 4;
      ctx.strokeStyle = 'rgba(0,0,0,0.70)';
      ctx.lineJoin = 'round';
    }

    for (let dc = -colsR; dc <= colsR; dc++) {
      for (let dr = -rowsR; dr <= rowsR; dr++) {
        const col = c0 + dc;
        const row = r0 + dr;
        const p = worldToScreen(hexCenterWorld(col, row));
        if (p.x < -100 || p.x > w + 100 || p.y < -100 || p.y > h + 100) continue;

        const label = hexId(col, row);
        const lx = p.x - GRID.size * 0.35;
        const ly = p.y + 4;

        if (bright) ctx.strokeText(label, lx, ly);
        ctx.fillText(label, lx, ly);
      }
    }

    ctx.restore();
  }

  // ===== UI rendering =====
  function escapeHtml(s) {
    return String(s)
      .replaceAll('&', '&amp;')
      .replaceAll('<', '&lt;')
      .replaceAll('>', '&gt;')
      .replaceAll('"', '&quot;')
      .replaceAll("'", '&#39;');
  }

  function updateSidebar(state, floor, rooms, openings, objects, tokens) {
    const kvs = document.getElementById('kvs');
    const turns = document.getElementById('turns');
    if (!kvs || !turns) return;

    const meta = state && state.meta ? state.meta : {};
    const round = Number(meta.round != null ? meta.round : 1);

    const camHex = (state && state.view && state.view.camera_hex) ? String(state.view.camera_hex) : hexId(VIEW.camera.col, VIEW.camera.row);

    const fog = normalizeFog(state, VIEW.floorId);
    const fogLabel = fog.enabled
      ? ('ON (' + fog.visibleRoomIds.length + ' vis / ' + fog.exploredRoomIds.length + ' exp)')
      : 'off';

    const lines = [
      ['Version', VERSION],
      ['Battle', meta.battleId != null ? String(meta.battleId) : ''],
      ['Floor', floor && floor.name ? String(floor.name) : String(VIEW.floorId || '')],
      ['Round', String(round)],
      ['Camera', camHex],
      ['Rooms', String(rooms.length)],
      ['Openings', String(openings.length)],
      ['Objects', String(objects.length)],
      ['Tokens', String(tokens.length)],
      ['Fog', fogLabel],
      ['Fog maxDepth', String(fog.maxDepth)],
    ];

    kvs.innerHTML = lines
      .map(([k, v]) => '<div>' + escapeHtml(k) + '</div><div style="color:var(--text); text-align:right;">' + escapeHtml(v) + '</div>')
      .join('');

    // Initiative list: sort by init desc
    const sorted = [...tokens]
      .filter(t => t && t.id)
      .sort((a, b) => (Number(b.init) || 0) - (Number(a.init) || 0));

    const activeId = (state && state.turn && state.turn.activeTokenId) ? String(state.turn.activeTokenId) : '';

    turns.innerHTML = sorted.map(t => {
      const isActive = activeId && String(t.id) === activeId;
      const name = t.name ? String(t.name) : String(t.id);
      const right = (t.hp != null) ? ('HP ' + t.hp) : '';
      return '<div class="turnRow' + (isActive ? ' active' : '') + '">'
        + '<div>' + escapeHtml(name) + ' <span style="opacity:0.65">(' + escapeHtml(String(t.init ?? '')) + ')</span></div>'
        + '<div style="opacity:0.85">' + escapeHtml(right) + '</div>'
        + '</div>';
    }).join('');
  }

  function populateFloorSelect(floors) {
    if (!elFloorSelect) return;

    const opts = floors.map(f => {
      const id = String(f.id);
      const name = f.name ? String(f.name) : id;
      return '<option value="' + escapeHtml(id) + '">' + escapeHtml(name) + '</option>';
    });

    elFloorSelect.innerHTML = opts.join('');
    elFloorSelect.value = String(VIEW.floorId || (floors[0] ? floors[0].id : ''));
  }

  function populateCenterOn(state) {
    if (!elCenterOn) return;

    const tokens = tokensOnFloor(state, VIEW.floorId);
    const pcs = tokens.filter(isPlayerToken);
    const wanted = VIEW.followTokenId || '';

    const opts = ['<option value="">None</option>'];
    for (const t of pcs) {
      const label = t.name ? t.name : t.id;
      opts.push('<option value="' + escapeHtml(t.id) + '">' + escapeHtml(label) + '</option>');
    }

    elCenterOn.innerHTML = opts.join('');
    elCenterOn.value = pcs.some(t => t.id === wanted) ? wanted : '';
    if (elCenterOn.value === '') VIEW.followTokenId = null;
  }

  // ===== Main render =====
  let RENDER_FOG = null;

  function clear() {
    const rect = canvas.getBoundingClientRect();
    const w = Math.max(1, rect.width);
    const h = Math.max(1, rect.height);
    ctx.fillStyle = COLORS.bg;
    ctx.fillRect(0, 0, w, h);
  }

  function redraw() {
    const state = getState();

    if (!canvas.width || !canvas.height || !wallCanvas.width || !wallCanvas.height) return;

    const floors = getFloorsFromState(state);
    const activeFloorId = VIEW.floorId || pickActiveFloorId(state, floors);
    const floor = floorById(floors, activeFloorId) || floors[0];
    VIEW.floorId = floor ? String(floor.id) : activeFloorId;

    // Keep title in sync
    const title = (state.meta && state.meta.title) ? String(state.meta.title) : 'Battlemat';
    elTitle.textContent = title;

    // Follow token: also flips floor if needed
    if (VIEW.followTokenId) {
      const allTokens = Array.isArray(state.tokens) ? state.tokens : [];
      const t = allTokens.find(x => x && x.id === VIEW.followTokenId);
      if (t && t.hex) {
        const fid = entityFloorId(t) || VIEW.floorId;
        if (fid && fid !== VIEW.floorId) {
          setActiveFloor(fid, { fromFollow: true });
          return; // redraw called by setActiveFloor
        }

        const p = parseHexId(t.hex);
        VIEW.camera.col = p.col;
        VIEW.camera.row = p.row;
      } else {
        VIEW.followTokenId = null;
        if (elCenterOn) elCenterOn.value = '';
      }
    }

    // Floor entities
    const rooms = Array.isArray(floor && floor.rooms) ? floor.rooms : [];
    const openings = Array.isArray(floor && floor.openings) ? floor.openings : [];
    const objects = Array.isArray(floor && floor.objects) ? floor.objects : [];
    const tokens = tokensOnFloor(state, VIEW.floorId);

    // Fog toggles
    const fogEnabled = !!elFogToggle.checked;
    if (state.fog && typeof state.fog === 'object') state.fog.enabled = fogEnabled;

    // Build per-frame fog sets
    RENDER_FOG = computeRenderFog(state, VIEW.floorId, rooms, openings, tokens);

    // Room selection
    let roomsToDraw = rooms;
    let openingsToDraw = openings;

    // When fog is OFF, we do NOT draw the large "fog backing" rooms.
    // Those exist only to create a gray base layer for fog-of-war.
    if (!fogEnabled) {
      roomsToDraw = rooms.filter(r => !isFogFloorRoom(r));
    }

    if (RENDER_FOG && RENDER_FOG.enabled) {
      const baseFogRoomIds = new Set();
      for (const r of rooms) {
        if (isFogFloorRoom(r) && r && r.id) baseFogRoomIds.add(String(r.id));
      }

      const renderableRoomIds = new Set([...RENDER_FOG.explored]);
      roomsToDraw = rooms.filter(r => {
        const id = r && r.id ? String(r.id) : '';
        if (!id) return true;
        if (baseFogRoomIds.has(id)) return true;
        return renderableRoomIds.has(id);
      });

      const roomMetaAll = buildRoomMeta(rooms);
      openingsToDraw = openings.filter(o => {
        const ids = openingRoomIds(o, roomMetaAll);
        // If we can determine the sides, only draw openings that touch renderable geometry.
        if (ids.length === 2) return (renderableRoomIds.has(ids[0]) || renderableRoomIds.has(ids[1]));
        return true;
      });
    }

    populateFloorSelect(floors);
    populateCenterOn(state);

    clear();

    // Floors
    drawFloorsLayered(roomsToDraw);

    // Walls
    const roomsForWalls = (RENDER_FOG && RENDER_FOG.enabled)
      ? roomsToDraw.filter(r => (isFogFloorRoom(r) ? roomHasWalls(r) : true))
      : roomsToDraw;

    const wallSegsRaw = buildWallSegments(roomsForWalls);
    const wallSegs = dedupeWallSegments(wallSegsRaw);

    // Threshold seam fills: extend parent room floor color through the wall gap so the corridor looks continuous.
    // This draw happens BEFORE walls are composited.
    drawThresholdSeamFills(openingsToDraw, rooms, wallSegs, fogEnabled);

    wallCtx.save();
    wallCtx.setTransform(1, 0, 0, 1, 0, 0);
    wallCtx.clearRect(0, 0, wallCanvas.width, wallCanvas.height);
    wallCtx.restore();

    wallCtx.setTransform(VIEW.dpr, 0, 0, VIEW.dpr, 0, 0);

    // Draw de-duped wall segments so shared internal walls don't double in thickness.
    drawWallSegments(wallCtx, wallSegs);

    wallCtx.save();
    wallCtx.globalCompositeOperation = 'destination-out';
    wallCtx.fillStyle = '#000';

    for (const o of openingsToDraw) {
      const k = String(o && o.kind ? o.kind : 'door').toLowerCase();
      wallCtx.globalAlpha = (k === 'window') ? 0.25 : 1;
      cutOpeningHole(wallCtx, o, wallSegs);
    }

    wallCtx.restore();

    // Composite walls
    ctx.save();
    ctx.setTransform(1, 0, 0, 1, 0, 0);
    ctx.drawImage(wallCanvas, 0, 0);
    ctx.restore();

    ctx.setTransform(VIEW.dpr, 0, 0, VIEW.dpr, 0, 0);

    // Openings
    for (const o of openingsToDraw) drawOpeningMarker(o, wallSegs);

    // Objects
    const roomMetaAll = buildRoomMeta(rooms);
    for (const o of objects) drawObject(o, roomMetaAll);

    // Remembered overlay
    drawRememberedRoomOverlays(rooms);

    // Tokens
    for (const t of tokens) drawToken(t, roomMetaAll);

    // Grid
    drawGrid();

    // Sidebar
    updateSidebar(state, floor, rooms, openings, objects, tokens);

    // Keep camera_hex in state.view updated for convenience
    if (state.view && typeof state.view === 'object') state.view.camera_hex = hexId(VIEW.camera.col, VIEW.camera.row);
  }

  function safeRedraw() {
    try {
      if (elError) { elError.hidden = true; elError.textContent = ''; }
      redraw();
    } catch (e) {
      console.error('[Battlemat] redraw failed:', e);
      if (elError) {
        elError.hidden = false;
        elError.textContent = String(e && e.stack ? e.stack : e);
      }
    }
  }

  // ===== Controls =====
  function pan(dc, dr) {
    if (VIEW.followTokenId) {
      VIEW.followTokenId = null;
      if (elCenterOn) elCenterOn.value = '';
    }
    VIEW.camera.col += dc;
    VIEW.camera.row += dr;
    safeRedraw();
  }

  function setCameraToHex(hex, opts = {}) {
    const manual = (opts.manual !== false);
    const p = parseHexId(hex);
    VIEW.camera.col = p.col;
    VIEW.camera.row = p.row;

    if (manual) {
      VIEW.followTokenId = null;
      if (elCenterOn) elCenterOn.value = '';
    }

    safeRedraw();
  }

  function setActiveFloor(floorId, opts = {}) {
    const state = getState();
    const floors = getFloorsFromState(state);

    const target = String(floorId || '');
    const f = floorById(floors, target);
    if (!f) return;

    VIEW.floorId = target;

    // Keep canonical hint
    if (state.view && typeof state.view === 'object') state.view.floorId = target;

    // If we're switching manually (not follow), keep camera unless it points nowhere.
    // If the new floor has a PC, prefer that.
    if (!opts.fromFollow) {
      const pcs = tokensOnFloor(state, target).filter(isPlayerToken);
      if (pcs.length && pcs[0].hex) {
        try {
          const p = parseHexId(pcs[0].hex);
          VIEW.camera.col = p.col;
          VIEW.camera.row = p.row;
        } catch {}
      }
    }

    safeRedraw();
  }

  function wireUI() {
    const req = (id) => {
      const el = document.getElementById(id);
      if (!el) console.warn('[Battlemat] missing control #' + id);
      return el;
    };

    const btnLeft = req('btnLeft');
    const btnRight = req('btnRight');
    const btnUp = req('btnUp');
    const btnDown = req('btnDown');
    const btnRedraw = req('btnRedraw');
    const btnJump = req('btnJump');

    if (btnLeft) btnLeft.onclick = () => pan(-PAN_STEP, 0);
    if (btnRight) btnRight.onclick = () => pan(PAN_STEP, 0);
    if (btnUp) btnUp.onclick = () => pan(0, PAN_STEP);
    if (btnDown) btnDown.onclick = () => pan(0, -PAN_STEP);

    if (btnRedraw) btnRedraw.onclick = () => safeRedraw();

    if (btnJump) btnJump.onclick = () => {
      const v = String(elJumpHex.value || '').trim();
      if (!v) return;
      try { setCameraToHex(v, { manual: true }); }
      catch (e) { console.warn('[Battlemat] Bad jump hex:', v, e); }
    };

    if (elFogToggle) elFogToggle.onchange = () => safeRedraw();
    if (elSpriteToggle) elSpriteToggle.onchange = () => safeRedraw();
    if (elLabelBoldToggle) elLabelBoldToggle.onchange = () => safeRedraw();

    if (elFloorSelect) {
      elFloorSelect.onchange = () => setActiveFloor(elFloorSelect.value, { fromFollow: false });
    }

    if (elCenterOn) {
      elCenterOn.onchange = () => {
        const id = String(elCenterOn.value || '');
        VIEW.followTokenId = id || null;
        safeRedraw();
      };
    }

    if (elSsSelect) {
      elSsSelect.onchange = () => setSupersample(elSsSelect.value);
    }

    // Keyboard pan
    window.onkeydown = (ev) => {
      if (ev.target && (ev.target.tagName === 'INPUT' || ev.target.tagName === 'SELECT' || ev.target.isContentEditable)) return;
      const k = ev.key;
      if (k === 'ArrowLeft' || k === 'a' || k === 'A') pan(-PAN_STEP, 0);
      else if (k === 'ArrowRight' || k === 'd' || k === 'D') pan(PAN_STEP, 0);
      else if (k === 'ArrowUp' || k === 'w' || k === 'W') pan(0, PAN_STEP);
      else if (k === 'ArrowDown' || k === 's' || k === 'S') pan(0, -PAN_STEP);
      else if (k === 'r' || k === 'R') safeRedraw();
    };
  }

  // ===== Resize =====
  function resize() {
    SUPERSAMPLE = readSupersample();

    const wrap = document.getElementById('canvasWrap');
    const rect = wrap.getBoundingClientRect();

    const cssW = Math.max(1, Math.floor(rect.width));
    const cssH = Math.max(1, Math.floor(rect.height));

    const dpr = Math.max(1, window.devicePixelRatio || 1);
    const scale = dpr * SUPERSAMPLE;

    VIEW.dpr = scale;
    VIEW.anchor.x = cssW / 2;
    VIEW.anchor.y = cssH / 2;

    if (elDpr) elDpr.textContent = dpr.toFixed(2);
    if (elSs) elSs.textContent = String(SUPERSAMPLE);

    canvas.width = Math.max(1, Math.floor(cssW * scale));
    canvas.height = Math.max(1, Math.floor(cssH * scale));

    wallCanvas.width = canvas.width;
    wallCanvas.height = canvas.height;

    // Draw in CSS pixels
    ctx.setTransform(scale, 0, 0, scale, 0, 0);
    wallCtx.setTransform(scale, 0, 0, scale, 0, 0);

    ctx.imageSmoothingEnabled = true;
    try { ctx.imageSmoothingQuality = 'high'; } catch {}

    safeRedraw();
  }

  // ===== Boot =====
  function init() {
    // Initial view from state
    const state = getState();
    const floors = getFloorsFromState(state);
    VIEW.floorId = pickActiveFloorId(state, floors);

    // Camera hex from state.view
    const camHex = state && state.view && state.view.camera_hex ? String(state.view.camera_hex) : null;
    if (camHex) {
      try {
        const p = parseHexId(camHex);
        VIEW.camera.col = p.col;
        VIEW.camera.row = p.row;
      } catch {}
    } else {
      // fallback: first PC token
      const pc = (Array.isArray(state.tokens) ? state.tokens : []).find(isPlayerToken);
      if (pc && pc.hex) {
        try {
          const p = parseHexId(pc.hex);
          VIEW.camera.col = p.col;
          VIEW.camera.row = p.row;
        } catch {}
      }
    }

    // Sync toggles from state/storage
    if (state.fog && typeof state.fog === 'object') elFogToggle.checked = !!state.fog.enabled;
    elSsSelect.value = String(readSupersample());

    wireUI();

    // Resize observer keeps backing store correct when wrapper resizes.
    const ro = new ResizeObserver(() => resize());
    ro.observe(document.getElementById('canvasWrap'));

    window.addEventListener('resize', resize, { passive: true });

    // Double-refresh first load (prevents "first frame" weirdness if sprites are late)
    resize();
    requestAnimationFrame(() => {
      safeRedraw();
      requestAnimationFrame(safeRedraw);
    });
  }

  init();
  </script>
</body>
</html>
