<!--
BATTLEMAT ENGINE

- Copy this entire file into Canvas verbatim before combat.
- During play, edit ONLY the SCENE block between:
  "EDIT ONLY THIS BLOCK: SCENE" and "END SCENE"
- Never rewrite, refactor, shorten, or regenerate the engine.
-->

<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Hex Battlemat</title>
  <style>
    body {
      margin: 0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      background: #f3f3f3;
      color: #111;
    }

    header {
      padding: 10px 14px;
      border-bottom: 1px solid rgba(0,0,0,0.12);
      background: #fff;
      font-weight: 650;
    }

    main {
      padding: 12px;
      overflow: hidden; /* clip right side on small windows; never scale the mat */
    }

    .layout {
      width: max-content;
      display: grid;
      grid-template-columns: 940px 340px;
      gap: 12px;
      align-items: stretch;
      margin: 0 auto;
    }

    canvas {
      width: 940px;
      height: 750px;
      background: #d7d7d7;
      border: 1px solid rgba(0,0,0,0.12);
    }

    aside {
      background: #fff;
      border: 1px solid rgba(0,0,0,0.12);
      padding: 10px;
      overflow: hidden;
      display: grid;
      grid-template-rows: auto 1fr;
      gap: 10px;
    }

    .panel-title {
      display: flex;
      justify-content: space-between;
      align-items: baseline;
      gap: 10px;
    }

    .panel-title h3 {
      margin: 0;
      font-size: 1rem;
      font-weight: 650;
    }

    .subtle {
      opacity: 0.7;
      font-size: 0.9rem;
      white-space: nowrap;
    }

    .status-wrap {
      overflow: auto;
      border: 1px solid rgba(0,0,0,0.10);
    }

    .legend {
      margin-top: 10px;
      padding-top: 8px;
      border-top: 1px solid rgba(0,0,0,0.12);
      font-size: 0.9rem;
    }

    .legend-title {
      font-weight: 650;
      margin-bottom: 6px;
    }

    .legend-list {
      list-style: none;
      padding: 0;
      margin: 0;
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 6px 10px;
    }

    .legend-swatch {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 20px;
      height: 20px;
      margin-right: 6px;
      border-radius: 3px;
      vertical-align: middle;
      border: 1px solid rgba(0,0,0,0.6);
      font-size: 11px;
      font-weight: 700;
      color: rgba(0,0,0,0.85);
      line-height: 1;
    }

    .legend-swatch.door { background: #b07a3f; }
    .legend-swatch.window { background: #cfe6f6; }
    .legend-swatch.table { background: #b07a3f; border-radius: 50%; }
    .legend-swatch.difficult { background: rgba(120,120,120,0.08); }
    /* Hex-shaped legend swatch (matches battlemat hexes) */
    .legend-swatch.hex {
      position: relative;
      z-index: 0;
      border-radius: 0;
      clip-path: polygon(
        25% 6%,
        75% 6%,
        100% 50%,
        75% 94%,
        25% 94%,
        0% 50%
      );
      border: none;
    }

    /* Border for clipped hex swatch: draw a slightly larger hex behind */
    /* Border for clipped hex swatch: draw a slightly larger hex behind */
    /* Border for clipped hex swatch: subtle outline behind */
    .legend-swatch.hex::before {
      content: "";
      position: absolute;
      inset: 0;
      background: rgba(0,0,0,0.45);
      clip-path: inherit;
      transform: scale(1.12);
      z-index: -1;
    }
    .legend-swatch.pc { background: rgba(80,160,220,0.95); border-radius: 50%; }
    .legend-swatch.en { background: rgba(220,120,80,0.95); border-radius: 50%; }

    table {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.92rem;
    }

    thead th {
      position: sticky;
      top: 0;
      background: #f6f6f6;
      text-align: left;
      font-weight: 650;
      padding: 8px 10px;
      border-bottom: 1px solid rgba(0,0,0,0.10);
    }

    tbody td {
      padding: 8px 10px;
      border-bottom: 1px solid rgba(0,0,0,0.08);
      vertical-align: top;
    }

    .chip {
      display: inline-block;
      padding: 2px 8px;
      border-radius: 999px;
      margin: 2px 6px 0 0;
      border: 1px solid rgba(0,0,0,0.12);
      background: #f2f2f2;
      font-size: 0.82rem;
      white-space: nowrap;
    }

    .side-pc  { border-left: 4px solid rgba(80, 160, 220, 0.85); }
    .side-en  { border-left: 4px solid rgba(220, 120, 80, 0.85); }
    .side-npc { border-left: 4px solid rgba(160, 160, 160, 0.85); }

    /* Dead actors: desaturate row and side bar */
    tr.dead {
      background: rgba(0,0,0,0.04);
      color: rgba(0,0,0,0.55);
    }
    tr.dead .subtle {
      opacity: 0.5;
    }
    tr.dead.side-pc,
    tr.dead.side-en,
    tr.dead.side-npc {
      border-left-color: rgba(120,120,120,0.85);
    }

    .hp {
      font-variant-numeric: tabular-nums;
      white-space: nowrap;
    }
  </style>
</head>
<body>
  <header>Hex Battlemat</header>
<!-- Canvas active: preparing API URL wiring -->

  <main>
    <div class="layout">
      <canvas id="mat" width="940" height="750" aria-label="Hex battlemat"></canvas>

      <aside aria-label="Combat status panel">
        <div class="panel-title">
          <h3>Initiative &amp; Status</h3>
          <div class="subtle" id="roundLine">Round —</div>
        </div>

        <div class="status-wrap">
          <table aria-label="Combatants">
            <thead>
              <tr>
                <th style="width: 52%">Actor</th>
                <th style="width: 18%">Init</th>
                <th style="width: 30%">HP</th>
              </tr>
            </thead>
            <tbody id="statusBody"></tbody>
          </table>
        </div>

        <!-- Legend / Key -->
        <div class="legend" aria-label="Map legend">
          <div class="legend-title">Key</div>
          <ul class="legend-list">
            <li><span class="legend-swatch door">D</span> Door</li>
            <li><span class="legend-swatch window">W</span> Window</li>
            <li><span class="legend-swatch table">T</span> Table <span class="subtle">(blocks)</span></li>
            <li><span class="legend-swatch difficult hex">~</span> Difficult terrain</li>
            <li><span class="legend-swatch pc">A</span> Player</li>
            <li><span class="legend-swatch en">W</span> Enemy</li>
          </ul>
        </div>
      </aside>
    </div>
  </main>

  <!-- ===================== EDIT ONLY THIS BLOCK: SCENE JSON =====================
     - Edit ONLY the JSON inside this tag.
     - Keep it VALID JSON (double quotes, no trailing commas, no comments).
     - If JSON is invalid, the engine will keep showing the last valid scene and print an error.
     ===================== END SCENE JSON =================================== -->
  <script type="application/json" id="scene-json">
{
  "round": 1,
  "rooms": [
    {
      "id": "room1",
      "corners": ["D11", "N11", "N1", "D1"],
      "thickness": 30,
      "color": "#555"
    }
  ],
  "openings": [
    {"id": "win_s_1", "kind": "window", "room": "room1", "wall": "S", "at": "F1", "state": "closed"},
    {"id": "win_s_2", "kind": "window", "room": "room1", "wall": "S", "at": "H1", "state": "closed"},
    {"id": "win_s_3", "kind": "window", "room": "room1", "wall": "S", "at": "J1", "state": "closed"},
    {"id": "win_s_4", "kind": "window", "room": "room1", "wall": "S", "at": "L1", "state": "closed"},

    {"id": "door_e_1", "kind": "door", "room": "room1", "wall": "E", "at": "N6", "state": "closed"},
    {"id": "door_e_2", "kind": "door", "room": "room1", "wall": "E", "at": "N5", "state": "closed"}
  ],
  "objects": [
    {"id": "table1", "kind": "table", "cells": ["I4", "I5", "J5"], "blocks": true, "label": "T"},
    {"id": "sarc1", "kind": "sarcophagus", "cells": ["J8", "K8", "L8"], "blocks": true, "label": "S"},
    {"id": "difficult_1", "kind": "difficult", "cells": ["G2", "H3", "I3"], "blocks": false, "label": "~", "color": "rgba(120,120,120,0.18)"}
  ],
  "actors": [
    {"id": "lich", "name": "Lich", "side": "EN", "init": 15, "hp": 135, "maxHp": 135, "effects": [], "at": "F9", "label": "L"},
    {"id": "wraith1", "name": "Wraith", "side": "EN", "init": 12, "hp": 67, "maxHp": 67, "effects": [], "at": "H7", "label": "W1"},
    {"id": "wraith2", "name": "Wraith", "side": "EN", "init": 11, "hp": 0, "maxHp": 67, "effects": [], "at": "K9", "label": "W2"},
    {"id": "wraith3", "name": "Wraith", "side": "EN", "init": 10, "hp": 67, "maxHp": 67, "effects": [], "at": "E6", "label": "W3"},

    {"id": "pc1", "name": "Aelar", "side": "PC", "init": 14, "hp": 42, "maxHp": 42, "effects": [], "at": "K2", "label": "A"},
    {"id": "pc2", "name": "Brunna", "side": "PC", "init": 13, "hp": 55, "maxHp": 55, "effects": [], "at": "L3", "label": "B"},
    {"id": "pc3", "name": "Caelin", "side": "PC", "init": 12, "hp": 38, "maxHp": 38, "effects": [], "at": "M3", "label": "C"}
  ]
}
  </script>

  <script>
    // =====================================================================
    // ENGINE (do not edit during play)
    // Sections are intentionally bannered so future GPT edits stay scoped.
    // =====================================================================

    // Scene loader state (prevents blank-mat failures from bad edits)
    let SCENE = {};
    let LAST_GOOD_SCENE = null;
    let SCENE_PARSE_ERROR = null;

    function loadSceneFromJsonTag() {
      const el = document.getElementById('scene-json');
      const raw = el ? String(el.textContent || '').trim() : '';
      if (!raw) {
        SCENE_PARSE_ERROR = 'SCENE JSON is empty.';
        return (LAST_GOOD_SCENE || {});
      }
      try {
        const obj = JSON.parse(raw);
        LAST_GOOD_SCENE = obj;
        SCENE_PARSE_ERROR = null;
        return obj;
      } catch (e) {
        SCENE_PARSE_ERROR = `SCENE JSON parse error: ${e && e.message ? e.message : String(e)}`;
        try { console.error('[Battlemat] ' + SCENE_PARSE_ERROR); } catch (_) {}
        return (LAST_GOOD_SCENE || {});
      }
    }
// =====================================================================
    // ENGINE (do not edit during play)
    // Sections are intentionally bannered so future GPT edits stay scoped.
    // =====================================================================

    // ====== GRID CONFIG ======
    const cols = 17;        // A..Q
    const rows = 11;        // 1..11
    const size = 34.5;      // hex radius (center -> corner)
    const margin = 55;

    const canvas = document.getElementById('mat');
    const ctx = canvas.getContext('2d');
    const SQRT3 = Math.sqrt(3);
    const letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';

    // Cached room geometry for a single draw pass
    let ROOM_GEOMS = null;

    // Normalized, validated scene snapshot for a single draw pass
    let SCENE_NORM = null;

    // ====== CONFIG (tweakable constants) ======
    // Centralized "magic numbers" so visual tuning is safe and obvious.
    const CONFIG = {
      room: {
        yInsetFrac: 0.25,      // fraction of hex height to inset top/bottom wall band
      },
      labels: {
        dyFrac: 0.70,          // vertical offset inside each hex
        fillAlpha: 0.35,       // opacity for grid labels
      },
      opening: {
        minAcross: 18,         // minimum thickness across the wall
        acrossMul: 1.05,       // scale relative to wall thickness
        spanNSMul: 1.5,        // span along N/S walls in hex radii
        spanEWMul: 1.0,        // span along E/W walls in (SQRT3 * size)
      },
      grid: {
        baseStrokeW: 1.2,
        baseStrokeA: 0.07,
        overlayStrokeW: 1.1,
        overlayStrokeA: 0.04,
      }
    };

    // ====== COORDINATE SYSTEM & GRID MATH ======
    // r=0 is the bottom. Alternate column offset so A/C/E align; B/D/F align.
    function qrToPixel(q, r) {
      const drawR = (rows - 1 - r);
      const columnOffset = (q % 2 === 0) ? 0 : 0.5;
      const x = size * (3/2) * q;
      const y = size * SQRT3 * (drawR + columnOffset);
      return { x: x + margin, y: y + margin };
    }

    function hexCorners(cx, cy) {
      const pts = [];
      for (let i = 0; i < 6; i++) {
        const a = (Math.PI / 180) * (60 * i);
        pts.push({ x: cx + size * Math.cos(a), y: cy + size * Math.sin(a) });
      }
      return pts;
    }

    function drawHexPath(pts) {
      ctx.beginPath();
      ctx.moveTo(pts[0].x, pts[0].y);
      for (let i = 1; i < pts.length; i++) ctx.lineTo(pts[i].x, pts[i].y);
      ctx.closePath();
    }

    function labelFor(q, r) {
      return `${letters[q]}${r + 1}`;
    }

    function parseLabel(label) {
      const m = String(label).trim().toUpperCase().match(/^([A-Z])([0-9]{1,2})$/);
      if (!m) return null;
      const q = letters.indexOf(m[1]);
      const r = Number(m[2]) - 1;
      if (q < 0 || q >= cols) return null;
      if (r < 0 || r >= rows) return null;
      return { q, r };
    }

    function labelToPixel(label) {
      const pos = parseLabel(label);
      if (!pos) return null;
      return qrToPixel(pos.q, pos.r);
    }

    function normalizeScene() {
      const src = (typeof SCENE === 'object' && SCENE) ? SCENE : {};

      const warn = (msg, obj) => {
        try { console.warn(`[Battlemat] ${msg}`, obj ?? ''); } catch (_) {}
      };

      // ---- Rooms ----
      const roomsIn = Array.isArray(src.rooms) ? src.rooms : [];
      const roomsOut = [];
      const roomIds = new Set();
      for (let i = 0; i < roomsIn.length; i++) {
        const r = roomsIn[i] || {};
        const corners = Array.isArray(r.corners) ? r.corners : null;
        if (!corners || corners.length !== 4) {
          warn(`Room skipped: corners must be 4 labels`, r);
          continue;
        }
        if (corners.map(parseLabel).some(p => !p)) {
          warn(`Room skipped: invalid corner label(s)`, r);
          continue;
        }
        let id = String(r.id || '').trim();
        if (!id) id = `room_${i + 1}`;
        if (roomIds.has(id)) {
          warn(`Room id duplicated; making unique: ${id}`, r);
          let k = 2;
          while (roomIds.has(`${id}_${k}`)) k++;
          id = `${id}_${k}`;
        }
        roomIds.add(id);
        roomsOut.push({
          id,
          corners: corners.map(c => String(c).trim().toUpperCase()),
          thickness: Number(r.thickness ?? 18),
          color: String(r.color || '#555')
        });
      }

      // ---- Openings ----
      const openingsIn = Array.isArray(src.openings) ? src.openings : [];
      const openingsOut = [];
      for (let i = 0; i < openingsIn.length; i++) {
        const o = openingsIn[i] || {};
        const kind = String(o.kind || 'door').toLowerCase();
        if (kind !== 'door' && kind !== 'window') {
          warn(`Opening skipped: kind must be door/window`, o);
          continue;
        }
        const room = String(o.room || '').trim();
        if (!room || !roomIds.has(room)) {
          warn(`Opening skipped: unknown room id '${room}'`, o);
          continue;
        }
        const wall = String(o.wall || '').trim().toUpperCase();
        if (!['N','S','E','W'].includes(wall)) {
          warn(`Opening skipped: wall must be N/S/E/W`, o);
          continue;
        }
        const at = String(o.at || '').trim().toUpperCase();
        if (!parseLabel(at)) {
          warn(`Opening skipped: invalid at label`, o);
          continue;
        }
        const state = String((o.state ?? 'closed')).toLowerCase();
        openingsOut.push({
          ...o,
          kind,
          room,
          wall,
          at,
          state
        });
      }

      // ---- Objects ----
      const objectsIn = Array.isArray(src.objects) ? src.objects : [];
      const objectsOut = [];
      for (let i = 0; i < objectsIn.length; i++) {
        const o = objectsIn[i] || {};
        const kind = String(o.kind || 'object').toLowerCase();
        const blocks = Boolean(o.blocks ?? false);

        let cells = [];
        if (Array.isArray(o.cells) && o.cells.length) {
          cells = o.cells.map(c => String(c).trim().toUpperCase()).filter(Boolean);
        } else if (o.at) {
          cells = [String(o.at).trim().toUpperCase()];
        }

        // Validate cells
        cells = cells.filter(lab => !!parseLabel(lab));
        if (!cells.length) {
          warn('Object skipped: missing/invalid at/cells', o);
          continue;
        }

        objectsOut.push({
          ...o,
          kind,
          blocks,
          cells,
          label: (o.label != null) ? String(o.label) : null,
          color: (o.color != null) ? String(o.color) : null
        });
      }

      // ---- Actors ----
      const actorsIn = Array.isArray(src.actors) ? src.actors : [];
      const actorsOut = [];
      for (let i = 0; i < actorsIn.length; i++) {
        const a = actorsIn[i] || {};
        const at = String(a.at || '').trim().toUpperCase();
        if (!parseLabel(at)) {
          warn(`Actor skipped: invalid at label`, a);
          continue;
        }
        const side = String(a.side || 'NPC').toUpperCase();
        actorsOut.push({
          ...a,
          at,
          side: (side === 'PC' || side === 'EN') ? side : 'NPC'
        });
      }

      return {
        round: Number(src.round ?? 1),
        rooms: roomsOut,
        openings: openingsOut,
        objects: objectsOut,
        actors: actorsOut
      };
    }

    // ====== ROOM GEOMETRY (RECT WALLS) ======
    // Visual wall logic (v1): draw a thick rectangle around a room.
    // Important: the top & bottom edges are shifted by 1/4 hex height so the wall band
    // sits in the "notches" and looks square-ish on a flat-top hex grid.
    function getRoomGeom(room) {
      const c = Array.isArray(room.corners) ? room.corners : null;
      if (!c || c.length !== 4) return null;

      const pTL = labelToPixel(c[0]);
      const pTR = labelToPixel(c[1]);
      const pBR = labelToPixel(c[2]);
      const pBL = labelToPixel(c[3]);
      if (!pTL || !pTR || !pBR || !pBL) return null;

      const hexH = SQRT3 * size;      // point-to-point height
      const yInset = hexH * CONFIG.room.yInsetFrac;     // your "about 1/4 hex" observation

      return {
        id: String(room.id || ''),
        leftX:  pTL.x,
        rightX: pTR.x,
        topY:   pTL.y + yInset,
        botY:   pBL.y - yInset,
        thickness: Number(room.thickness ?? 18),
        color: String(room.color || 'rgba(0,0,0,0.88)')
      };
    }

    // Visual wall logic (v1): draw a thick rectangle around a room.
    // Important: the top & bottom edges are shifted by 1/4 hex height so the wall band
    // sits in the "notches" and looks square-ish on a flat-top hex grid.
    function drawRooms() {
      const rooms = Array.isArray(SCENE_NORM?.rooms) ? SCENE_NORM.rooms : [];
      if (!rooms.length || !ROOM_GEOMS) return;

      for (const room of rooms) {
        const g = ROOM_GEOMS.get(String(room.id || ''));
        if (!g) continue;

        ctx.save();
        ctx.globalAlpha = 1.0; // walls opaque
        ctx.strokeStyle = g.color;
        ctx.lineWidth = g.thickness;
        ctx.lineJoin = 'miter';
        ctx.lineCap = 'butt';

        ctx.beginPath();
        ctx.moveTo(g.leftX,  g.topY);
        ctx.lineTo(g.rightX, g.topY);
        ctx.lineTo(g.rightX, g.botY);
        ctx.lineTo(g.leftX,  g.botY);
        ctx.closePath();
        ctx.stroke();

        ctx.restore();
      }
    }

    // ====== BLOCKING / RULES EXPORTS ======
    // --- Blocking logic (v1) ---
    // Computes a set of hex labels that are considered blocked for movement.
    // Rules:
    // - Room wall perimeters are blocked
    // - Any OPEN door/window removes its hex from blocked (creates a passable gap)
    // - Living actors block their occupied hex
    // - Objects with blocks:true block their occupied hexes
    function roomPerimeterLabels(room) {
      const c = Array.isArray(room.corners) ? room.corners : null;
      if (!c || c.length !== 4) return new Set();
      const tl = parseLabel(c[0]);
      const tr = parseLabel(c[1]);
      const br = parseLabel(c[2]);
      const bl = parseLabel(c[3]);
      if (!tl || !tr || !br || !bl) return new Set();

      const out = new Set();

      // Top edge: TL -> TR
      const qStartT = Math.min(tl.q, tr.q);
      const qEndT   = Math.max(tl.q, tr.q);
      for (let q = qStartT; q <= qEndT; q++) out.add(labelFor(q, tl.r));

      // Bottom edge: BL -> BR
      const qStartB = Math.min(bl.q, br.q);
      const qEndB   = Math.max(bl.q, br.q);
      for (let q = qStartB; q <= qEndB; q++) out.add(labelFor(q, bl.r));

      // Left edge: BL -> TL
      const rStartL = Math.min(bl.r, tl.r);
      const rEndL   = Math.max(bl.r, tl.r);
      for (let r = rStartL; r <= rEndL; r++) out.add(labelFor(tl.q, r));

      // Right edge: BR -> TR
      const rStartR = Math.min(br.r, tr.r);
      const rEndR   = Math.max(br.r, tr.r);
      for (let r = rStartR; r <= rEndR; r++) out.add(labelFor(tr.q, r));

      return out;
    }

    function computeBlockedHexes() {
      const blocked = new Set();

      // 1) Walls: perimeter of each room rectangle in hex-label space
      for (const room of (SCENE_NORM?.rooms || [])) {
        const perim = roomPerimeterLabels(room);
        for (const lab of perim) blocked.add(lab);
      }

      // 2) Open doors/windows: carve out gaps
      for (const o of (SCENE_NORM?.openings || [])) {
        const kind = String(o.kind || 'door').toLowerCase();
        if (kind !== 'door' && kind !== 'window') continue;
        const state = String(o.state ?? 'closed').toLowerCase();
        if (state === 'open') {
          const lab = String(o.at || '').trim().toUpperCase();
          if (lab) blocked.delete(lab);
        }
      }

      // 3) Living actors block their hex
      for (const a of (SCENE_NORM?.actors || [])) {
        const hp = Number(a.hp ?? 0);
        const effects = Array.isArray(a.effects) ? a.effects : [];
        const isDead = hp <= 0 || effects.includes('dead') || effects.includes('down');
        if (isDead) continue;
        const lab = String(a.at || '').trim().toUpperCase();
        if (lab) blocked.add(lab);
      }

      // 4) Blocking objects
      for (const o of (SCENE_NORM?.objects || [])) {
        if (!o || !o.blocks) continue;
        const cells = Array.isArray(o.cells) ? o.cells : [];
        for (const lab of cells) blocked.add(String(lab).trim().toUpperCase());
      }

      return blocked;
    }

    // Expose for GPT/rules checks
    function refreshBlocked() {
      const b = computeBlockedHexes();
      return b;
    }

    // ====== OBJECTS (TABLES/OBSTACLES) ======
    function objectCentroidPx(cells) {
      // Deterministic visual center: average of the pixel centers of occupied hexes.
      let sx = 0, sy = 0, n = 0;
      for (const lab of (cells || [])) {
        const p = labelToPixel(lab);
        if (!p) continue;
        sx += p.x; sy += p.y; n++;
      }
      if (!n) return null;
      return { x: sx / n, y: sy / n };
    }

    function objectBoundsPx(cells) {
      // Bounding box around the pixel centers of occupied hexes.
      let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
      let n = 0;
      for (const lab of (cells || [])) {
        const p = labelToPixel(lab);
        if (!p) continue;
        minX = Math.min(minX, p.x);
        minY = Math.min(minY, p.y);
        maxX = Math.max(maxX, p.x);
        maxY = Math.max(maxY, p.y);
        n++;
      }
      if (!n) return null;
      return { minX, minY, maxX, maxY };
    }

    function roundRectPath(x, y, w, h, r) {
      const rr = Math.max(0, Math.min(r, Math.min(w, h) / 2));
      ctx.beginPath();
      ctx.moveTo(x + rr, y);
      ctx.arcTo(x + w, y, x + w, y + h, rr);
      ctx.arcTo(x + w, y + h, x, y + h, rr);
      ctx.arcTo(x, y + h, x, y, rr);
      ctx.arcTo(x, y, x + w, y, rr);
      ctx.closePath();
    }

    function drawObjects() {
      const objs = Array.isArray(SCENE_NORM?.objects) ? SCENE_NORM.objects : [];
      if (!objs.length) return;

      for (const obj of objs) {
        const cells = Array.isArray(obj.cells) ? obj.cells : [];
        if (!cells.length) continue;

        const blocks = Boolean(obj.blocks);
        const kind = String(obj.kind || 'object').toLowerCase();
        const glyph = (obj.label != null && String(obj.label).trim())
          ? String(obj.label).trim().slice(0, 3)
          : kind.slice(0, 1).toUpperCase();

        // Visual defaults (can be overridden per object)
        const fill = obj.color
          ? String(obj.color)
          : (blocks ? 'rgba(0,0,0,0.20)' : 'rgba(0,0,0,0.10)');

        // 1) Footprint shading (authoritative cells)
        // For shaped blockers, skip hex shading so the top communicates blocking.
        // (Difficult terrain still uses per-hex shading + glyphs.)
        if (kind !== 'table' && kind !== 'rect' && kind !== 'sarcophagus') {
          for (let i = 0; i < cells.length; i++) {
            const lab = String(cells[i]).trim().toUpperCase();
            const p = labelToPixel(lab);
            if (!p) continue;

            const pts = hexCorners(p.x, p.y);
            drawHexPath(pts);
            ctx.save();
            ctx.fillStyle = fill;
            ctx.fill();

            // Outline for readability
            ctx.lineWidth = 1;
            ctx.strokeStyle = 'rgba(0,0,0,0.18)';
            ctx.stroke();

            // Glyphs:
            // - Difficult terrain: mark EVERY cell with "~" for instant readability
            // - Other objects: mark only the first cell
            if (kind === 'difficult' || i === 0) {
              ctx.font = 'bold 12px ui-monospace, system-ui, sans-serif';
              ctx.fillStyle = 'rgba(0,0,0,0.55)';
              ctx.textAlign = 'center';
              ctx.textBaseline = 'middle';
              ctx.fillText(glyph, p.x, p.y);
            }

            ctx.restore();
          }
        }

        // 2) Shape rendering (cosmetic): round tables
        // Tables are rendered as a circle centered on the centroid of their occupied cells.
        if (kind === 'table') {
          const c = objectCentroidPx(cells);
          if (!c) continue;

          // Radius tuned for readability: looks good for 1–4 hex footprints.
          // Render radius: 1.25 hex radius (visual only)
          const radius = size * 1.25;

          ctx.save();
          ctx.beginPath();
          ctx.arc(c.x, c.y, radius, 0, Math.PI * 2);
          // Match table color to door wood for a consistent palette
          ctx.fillStyle = '#b07a3f';
          ctx.fill();

          ctx.lineWidth = 2;
      // Thin black outline for all tokens (PC & Enemy, live or dead)
      ctx.strokeStyle = 'rgba(0,0,0,0.85)';
      ctx.stroke();

          // Label on the table itself (defaults to "T")
          const tLabel = (obj.label != null && String(obj.label).trim()) ? String(obj.label).trim().slice(0, 3) : 'T';
          ctx.font = 'bold 14px ui-monospace, system-ui, sans-serif';
          ctx.fillStyle = 'rgba(0,0,0,0.85)';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText(tLabel, c.x, c.y);

          ctx.restore();
        }

        // 3) Shape rendering (cosmetic): rectangular blockers (benches, sarcophagi, crates)
        // Draw a rounded rectangle around the occupied-cell bounds, centered by their centroid.
        if (kind === 'rect' || kind === 'sarcophagus') {
          const c = objectCentroidPx(cells);
          const b = objectBoundsPx(cells);
          if (!c || !b) continue;

          // Expand bounds to cover the touched hexes (visual only)
          const padX = size * 0.85;
          const padY = size * 0.55;
          const w = (b.maxX - b.minX) + padX * 2;
          const h = (b.maxY - b.minY) + padY * 2;

          const rot = Number(obj.rot ?? 0);
          const radius = Math.max(6, Math.min(size * 0.35, Math.min(w, h) * 0.25));
          const fillRect = obj.color ? String(obj.color) : '#b07a3f';
          const outline = 'rgba(0,0,0,0.85)';
          const labelRect = (obj.label != null && String(obj.label).trim()) ? String(obj.label).trim().slice(0, 3) : (kind === 'sarcophagus' ? 'S' : 'R');

          ctx.save();
          ctx.translate(c.x, c.y);
          if (rot) ctx.rotate((Math.PI / 180) * rot);

          roundRectPath(-w/2, -h/2, w, h, radius);
          ctx.fillStyle = fillRect;
          ctx.fill();
          ctx.lineWidth = 2;
          ctx.strokeStyle = outline;
          ctx.stroke();

          ctx.font = 'bold 14px ui-monospace, system-ui, sans-serif';
          ctx.fillStyle = 'rgba(0,0,0,0.85)';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText(labelRect, 0, 0);

          ctx.restore();
        }
      }
    }

    // ====== OPENINGS (DOORS/WINDOWS) ======
    function drawOpenings() {
      const openings = Array.isArray(SCENE_NORM?.openings) ? SCENE_NORM.openings : [];
      if (!openings.length || !ROOM_GEOMS) return;

      for (const o of openings) {
        const kind = String(o.kind || 'door').toLowerCase();
        if (kind !== 'door' && kind !== 'window') continue;

        const state = String(o.state ?? 'closed').toLowerCase();

        const g = ROOM_GEOMS.get(String(o.room || ''));
        if (!g) continue;

        const wall = String(o.wall || '').toUpperCase();
        const atPx = labelToPixel(o.at);
        if (!atPx) continue;

        // Anchor to the actual wall centerline so we don't need column parity hacks.
        let x = atPx.x;
        let y = atPx.y;
        if (wall === 'N') y = g.topY;
        else if (wall === 'S') y = g.botY;
        else if (wall === 'E') x = g.rightX;
        else if (wall === 'W') x = g.leftX;
        else continue;

        // Door/window marker geometry
        // - thicknessAcross: match wall thickness
        // - spanAlong: match one-hex step along that wall direction
        const thicknessAcross = Number(o.thicknessAcross ?? Math.max(CONFIG.opening.minAcross, g.thickness * CONFIG.opening.acrossMul));
        const spanAlong = (wall === 'N' || wall === 'S')
          ? Number(o.spanAlong ?? (CONFIG.opening.spanNSMul * size))      // one hex step along a north/south wall
          : Number(o.spanAlong ?? (CONFIG.opening.spanEWMul * SQRT3 * size));   // one hex step along an east/west wall

        const rectW = (wall === 'N' || wall === 'S') ? spanAlong : thicknessAcross;
        const rectH = (wall === 'N' || wall === 'S') ? thicknessAcross : spanAlong;

        // Draw a wall-aligned rectangular opening marker.
        ctx.save();
        ctx.translate(x, y);

        // door/window fill
        // - closed door: warm wood + "D"
        // - open door: true white gap (no outline)
        // - closed window: light blue + "W"
        // - open window: very light gray (still visible)
        const isDoor = (kind === 'door');
        const isWindow = (kind === 'window');
        const isOpen = (state === 'open');

        // For open doors OR open windows: draw a visual gap
        if (isOpen) {
          if (isWindow) {
            // Open window: very light gray (wall still exists visually)
            ctx.fillStyle = '#eeeeee';
            ctx.strokeStyle = '#eeeeee';
            ctx.lineWidth = 1;
          } else {
            // Open door: true white gap
            ctx.fillStyle = '#ffffff';
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 0;
          }
        } else {
          // Closed openings
          if (isDoor) {
            ctx.fillStyle = '#b07a3f'; // closed door: warm wood
          } else {
            ctx.fillStyle = '#cfe6f6'; // closed window: light blue
          }
          ctx.strokeStyle = 'rgba(0,0,0,0.6)';
          ctx.lineWidth = 2;
        }

        ctx.beginPath();
        ctx.rect(-rectW/2, -rectH/2, rectW, rectH);
        ctx.fill();
        ctx.stroke();

        // tiny glyph
        ctx.font = 'bold 12px ui-monospace, system-ui, sans-serif';
        // Slightly larger glyph looks better inside rectangles
        if (Math.max(rectW, rectH) >= 55) ctx.font = 'bold 13px ui-monospace, system-ui, sans-serif';
        // Glyph: show label only when CLOSED
        if (!isOpen) {
          ctx.fillStyle = 'rgba(0,0,0,0.55)';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText(isWindow ? 'W' : 'D', 0, 0);
        }

        ctx.restore();
      }
    }

    function drawToken(q, r, label, side, dead) {
      const { x, y } = qrToPixel(q, r);

      // Fill by side (match status panel) — dead overrides
      let fill = 'rgba(160,160,160,0.95)';
      if (dead) fill = 'rgba(140,140,140,0.85)';
      else if (side === 'PC') fill = 'rgba(80,160,220,0.95)';
      else if (side === 'EN') fill = 'rgba(220,120,80,0.95)';

      ctx.beginPath();
      ctx.arc(x, y, size * 0.40, 0, Math.PI * 2);
      ctx.fillStyle = fill;
      ctx.fill();

      ctx.lineWidth = 0.75;
      // Thin black outline for all tokens (PC & Enemy, alive or dead)
      ctx.strokeStyle = 'rgba(0,0,0,0.85)';
      ctx.stroke();

      ctx.font = 'bold 14px ui-monospace, system-ui, sans-serif';
      ctx.fillStyle = dead ? 'rgba(0,0,0,0.35)' : 'rgba(0,0,0,0.72)';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(label, x, y);
    }

    function drawHexOverlay() {
      // Re-stroke hex outlines on top of walls/openings for readability.
      // (We intentionally do NOT redraw labels here.)
      for (let q = 0; q < cols; q++) {
        for (let r = 0; r < rows; r++) {
          const { x, y } = qrToPixel(q, r);
          const pts = hexCorners(x, y);
          drawHexPath(pts);
          ctx.lineWidth = CONFIG.grid.overlayStrokeW;
          ctx.strokeStyle = `rgba(0,0,0,${CONFIG.grid.overlayStrokeA})`;
          ctx.stroke();
        }
      }
    }

    // ====== RENDER PIPELINE ======
    // Stage order matters:
    // 1) base hex fill + base grid
    // 2) cache ROOM_GEOMS
    // 3) rooms/walls
    // 4) openings
    // 5) objects
    // 6) grid overlay
    // 6) labels
    // 7) blocked set export
    // 8) actors
    // 10) status panel
    function drawGrid() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // mat background
      ctx.fillStyle = '#d7d7d7';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // hexes (no labels here; labels are drawn once at the end)
      for (let q = 0; q < cols; q++) {
        for (let r = 0; r < rows; r++) {
          const { x, y } = qrToPixel(q, r);
          const pts = hexCorners(x, y);

          drawHexPath(pts);
          ctx.fillStyle = '#ffffff';
          ctx.fill();

          ctx.lineWidth = CONFIG.grid.baseStrokeW;
          ctx.strokeStyle = `rgba(0,0,0,${CONFIG.grid.baseStrokeA})`;
          ctx.stroke();
        }
      }
      // Load SCENE safely from JSON tag (invalid JSON will keep last-good scene)
      SCENE = loadSceneFromJsonTag();

      // Normalize/validate SCENE once per draw
      SCENE_NORM = normalizeScene();

      // Cache room geometry ONCE per draw
      ROOM_GEOMS = new Map();
      for (const room of (SCENE_NORM?.rooms || [])) {
        const g = getRoomGeom(room);
        if (g && g.id) ROOM_GEOMS.set(g.id, g);
      }

      // rooms/walls (visual only, v1)
      drawRooms();
      // doors/windows (visual only, v1)
      drawOpenings();

      // objects (tables/obstacles)
      drawObjects();

      // hex outlines on top of walls/openings (preview: bring grid to the front)
      drawHexOverlay();

      // Labels: draw ONCE, last, shifted slightly downward within each hex
      const LABEL_DY = size * CONFIG.labels.dyFrac; // lower within each hex (helps readability under walls/tokens)
      ctx.font = '13px "Times New Roman", Georgia, "Century Schoolbook", "Book Antiqua", serif';
      ctx.fillStyle = `rgba(180,150,90,${CONFIG.labels.fillAlpha})`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      for (let q = 0; q < cols; q++) {
        for (let r = 0; r < rows; r++) {
          const { x, y } = qrToPixel(q, r);
          ctx.fillText(labelFor(q, r), x, y + LABEL_DY);
        }
      }

      // refresh blocked set each draw
      refreshBlocked();

      // actors
      for (const a of (SCENE_NORM?.actors || [])) {
        const pos = parseLabel(a.at);
        if (!pos) continue;
        const isDead = Number(a.hp ?? 0) <= 0 || (Array.isArray(a.effects) && (a.effects.includes('dead') || a.effects.includes('down')));
        drawToken(pos.q, pos.r, a.label || a.name?.slice(0, 1) || '?', a.side, isDead);
      }

      renderStatus();
    }

    // ====== STATUS PANEL ======
    function renderStatus() {
      const tbody = document.getElementById('statusBody');
      const roundLine = document.getElementById('roundLine');
      if (!tbody || !roundLine) return;

      if (SCENE_PARSE_ERROR) roundLine.textContent = 'SCENE JSON ERROR';
      else roundLine.textContent = `Round ${SCENE_NORM?.round ?? '—'}`;

      const actors = Array.isArray(SCENE_NORM?.actors) ? SCENE_NORM.actors.slice() : [];
      actors.sort((a, b) => {
        const ai = Number(a.init ?? 0);
        const bi = Number(b.init ?? 0);
        if (bi !== ai) return bi - ai;
        return String(a.name ?? a.id).localeCompare(String(b.name ?? b.id));
      });

      tbody.innerHTML = '';
      for (const a of actors) {
        const tr = document.createElement('tr');
        const hpVal = Number(a.hp ?? 0);
        const effectsArr = Array.isArray(a.effects) ? a.effects : [];
        const isDead = hpVal <= 0 || effectsArr.includes('dead') || effectsArr.includes('down');

        const side = String(a.side || 'NPC').toUpperCase();
        tr.className = (side === 'PC' ? 'side-pc' : (side === 'EN' ? 'side-en' : 'side-npc')) + (isDead ? ' dead' : '');

        const effects = Array.isArray(a.effects) ? a.effects : [];
        const effectsHtml = effects.length
          ? effects.map(e => `<span class="chip">${escapeHtml(String(e))}</span>`).join('')
          : '';

        tr.innerHTML = `
          <td>
            <div style="display:flex; align-items:baseline; gap:8px; flex-wrap:wrap;">
              <span style="font-weight:650;">${escapeHtml(a.name ?? a.id ?? 'Actor')}</span>
              <span class="subtle">${escapeHtml(a.at ?? '')}</span>
            </div>
            ${effectsHtml ? `<div style="margin-top:4px;">${effectsHtml}</div>` : ''}
          </td>
          <td class="hp">${escapeHtml(String(a.init ?? 0))}</td>
          <td class="hp">${escapeHtml(String(a.hp ?? '—'))} / ${escapeHtml(String(a.maxHp ?? '—'))}</td>
        `;

        tbody.appendChild(tr);
      }
    }

    // ====== UTILS ======
    function escapeHtml(s) {
      return s
        .replaceAll('&', '&amp;')
        .replaceAll('<', '&lt;')
        .replaceAll('>', '&gt;')
        .replaceAll('"', '&quot;')
        .replaceAll("'", '&#39;');
    }

    function safeDrawGrid() {
      try {
        drawGrid();
      } catch (e) {
        console.error('[Battlemat] drawGrid failed:', e);
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = '#d7d7d7';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = 'rgba(0,0,0,0.65)';
        ctx.font = '14px ui-monospace, system-ui, sans-serif';
        ctx.textAlign = 'left';
        ctx.textBaseline = 'top';
        ctx.fillText('Battlemat render error (see console).', 14, 14);
      }
    }

    safeDrawGrid();
  </script>
</body>
</html>
