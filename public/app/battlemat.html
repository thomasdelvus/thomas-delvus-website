<!--
Battlemat
Version: set in JS (VERSION)
-->
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Battlemat Core</title>
  <link rel="icon" href="/favicon.svg" type="image/svg+xml" />
  <style>
    :root{
      --bg:#0f1115;
      --panel:#161a22;
      --panel2:#121621;
      --text:#e9eef7;
      --muted:#9aa6bb;
      --border:rgba(255,255,255,0.12);
      --border2:rgba(255,255,255,0.08);
      --good:#43d17a;
      --bad:#ff5a5a;
    }
    html,body{height:100%;margin:0;}
    body{
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;
      background:var(--bg);
      color:var(--text);
      display:grid;
      grid-template-rows:auto 1fr;
    }
    #topbar{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
      padding:10px 12px;
      background:var(--panel);
      border-bottom:1px solid var(--border2);
      flex-wrap:wrap;
    }
    #status{
      display:flex;
      align-items:center;
      gap:10px;
      min-height:26px;
      flex-wrap:wrap;
      flex:1 1 auto;
      min-width:0;
    }
    .pill{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding:4px 10px;
      border-radius:999px;
      background:rgba(255,255,255,0.08);
      border:1px solid var(--border);
      font-size:12px;
      color:var(--text);
      white-space:nowrap;
    }
    .dot{width:8px;height:8px;border-radius:50%;background:var(--good);box-shadow:0 0 0 2px rgba(67,209,122,0.15);}
    .mini{font-size:12px;color:var(--muted);display:inline-flex;align-items:center;gap:6px;white-space:nowrap;}
    .mini input[type="text"]{
      width:72px;
      padding:4px 8px;
      border-radius:8px;
      border:1px solid var(--border);
      background:rgba(0,0,0,0.25);
      color:var(--text);
      outline:none;
    }
    select{
      padding:4px 8px;
      border-radius:8px;
      border:1px solid var(--border);
      background:rgba(0,0,0,0.25);
      color:var(--text);
      outline:none;
      font-size:12px;
    }
    button{
      padding:6px 10px;
      border-radius:10px;
      border:1px solid var(--border);
      background:rgba(255,255,255,0.08);
      color:var(--text);
      cursor:pointer;
      font-size:12px;
    }
    button:hover{background:rgba(255,255,255,0.12);}
    .sep{width:1px;height:18px;background:var(--border2);margin:0 2px;}

    #controls{
      display:flex;
      align-items:center;
      gap:8px;
      flex-wrap:wrap;
      justify-content:flex-end;
    }

    #layout{
      display:grid;
      grid-template-columns: 64px 1fr 320px;
      gap:12px;
      padding:12px;
      min-height:0;
    }

    #toolbox{
      background:var(--panel2);
      border:1px solid var(--border);
      border-radius:12px;
      padding:8px;
      display:flex;
      flex-direction:column;
      gap:8px;
      min-height:0;
    }

    .toolBtn{
      width:100%;
      padding:8px 6px;
      border-radius:10px;
      border:1px solid var(--border);
      background:rgba(255,255,255,0.06);
      color:var(--text);
      cursor:pointer;
      font-size:11px;
    }
    .toolBtn:hover{background:rgba(255,255,255,0.12);}
    .toolBtn.active{background:rgba(67,209,122,0.18); border-color:rgba(67,209,122,0.35);}

    .toolSep{height:1px;background:var(--border2);margin:2px 0;}
    .toolStatus{font-size:11px;color:var(--muted);text-align:center;}
    .toolStatus.ok{color:var(--good);}
    .toolStatus.error{color:var(--bad);}

    #canvasWrap{
      background:#0b0d12;
      border:1px solid var(--border);
      border-radius:12px;
      box-shadow:0 10px 30px rgba(0,0,0,0.35);
      overflow:hidden;
      min-height:0;
    }

    canvas{width:100%;height:100%;display:block;background:#0b0d12;}

    #sidebar{
      background:var(--panel2);
      border:1px solid var(--border);
      border-radius:12px;
      padding:12px;
      overflow:auto;
      min-height:0;
    }

    #sidebar h3{
      margin:0 0 8px 0;
      font-size:13px;
      color:var(--text);
      letter-spacing:0.02em;
    }

    #kvs{
      display:grid;
      grid-template-columns: 1fr auto;
      gap:6px 10px;
      font-size:12px;
      color:var(--muted);
      margin-bottom:12px;
    }

    #turns{
      font-size:12px;
      color:var(--muted);
      display:flex;
      flex-direction:column;
      gap:6px;
      margin-bottom:12px;
    }

    .turnRow{
      display:flex;
      justify-content:space-between;
      gap:10px;
      padding:6px 8px;
      border:1px solid rgba(255,255,255,0.10);
      border-radius:10px;
      background:rgba(255,255,255,0.04);
    }
    .turnRow.active{border-color:rgba(67,209,122,0.35); background:rgba(67,209,122,0.08); color:var(--text);}

    #errorBox{
      border:1px solid rgba(255,90,90,0.35);
      background:rgba(255,90,90,0.08);
      border-radius:12px;
      padding:10px;
      font-size:12px;
      color:var(--text);
      white-space:pre-wrap;
    }

    .dpad{
      display:inline-flex;
      gap:6px;
      align-items:center;
      margin-left:6px;
    }
    .dpad button{padding:6px 8px; border-radius:10px; min-width:34px;}

    @media (max-width: 980px){
      #layout{grid-template-columns:1fr; grid-template-rows:auto 1fr auto;}
      #toolbox{flex-direction:row; flex-wrap:wrap; justify-content:space-between;}
      .toolBtn{width:auto; flex:1 1 auto;}
    }
  </style>
</head>
<body>
  <div id="topbar">
    <div id="status">
      <div class="pill" title="Battlemat version" id="versionPill"><span class="dot"></span><span id="versionText"></span></div>
      <div class="mini">Scene <select id="sceneSelect"></select></div>
      <div class="sep"></div>
      <div class="mini">Floor <select id="floorSelect"></select></div>
      <div class="sep"></div>
      <div class="mini">Source
        <select id="sourceSelect">
          <option value="database" selected>Database</option>
          <option value="file">File</option>
          <option value="embedded">Embedded</option>
        </select>
      </div>
      <div class="mini">Battle ID
        <input id="battleIdInput" type="text" inputmode="numeric" placeholder="id" />
        <button id="battleIdApply" title="Use battle id">Use</button>
      </div>
      <div class="pill" title="DevicePixelRatio × Supersample">
        DPR <span id="dprText">?</span>
        &nbsp;·&nbsp; SS <span id="ssText">?</span>
      </div>
    </div>

    <div id="controls">
      <label class="mini"><input type="checkbox" id="fogToggle" checked /> Fog</label>
      <label class="mini"><input type="checkbox" id="spriteToggle" checked /> Sprites</label>
      <label class="mini"><input type="checkbox" id="labelBoldToggle" /> Bright Labels</label>

      <div class="mini">SS
        <select id="ssSelect" title="Supersample quality">
          <option value="1">1×</option>
          <option value="2">2×</option>
          <option value="3" selected>3×</option>
        </select>
      </div>

      <div class="mini">Center
        <select id="centerOn" title="Follow a PC token"></select>
      </div>

      <div class="mini">Jump
        <input id="jumpHex" type="text" value="U16" />
        <button id="btnJump">Go</button>
      </div>

      <button id="btnRedraw">Redraw</button>

      <div class="dpad" title="Pan camera">
        <button id="btnLeft">←</button>
        <button id="btnUp">↑</button>
        <button id="btnDown">↓</button>
        <button id="btnRight">→</button>
      </div>

      <div class="dpad" title="Zoom">
        <button id="btnZoomOut">−</button>
        <button id="btnZoomIn">+</button>
      </div>
      <div class="mini" title="Map zoom"><span id="zoomText">100%</span></div>
    </div>
  </div>

  <div id="layout">
    <div id="toolbox">
      <button class="toolBtn" id="toolSelect" data-tool="select">Select</button>
      <button class="toolBtn" id="toolRoom" data-tool="room">Room</button>
      <button class="toolBtn" id="toolDoor" data-tool="door">Door</button>
      <button class="toolBtn" id="toolWindow" data-tool="window">Window</button>
      <button class="toolBtn" id="toolDelete" data-tool="delete">Delete</button>
      <div class="toolSep"></div>
      <button class="toolBtn" id="btnSaveDb" title="Save edits to database">Save</button>
      <button class="toolBtn" id="btnUndo" title="Undo last edit">Undo</button>
      <button class="toolBtn" id="btnScanIssues" title="Scan for orphaned or duplicate items">Scan</button>
      <button class="toolBtn" id="btnCleanOrphans" title="Remove orphan openings">Clean</button>
      <div class="toolStatus" id="toolStatus">DB: idle</div>
    </div>
    <div id="canvasWrap"><canvas id="canvas" aria-label="Battlemat canvas"></canvas></div>
    <div id="sidebar">
      <h3>Status</h3>
      <div id="kvs"></div>

      <h3>Initiative</h3>
      <div id="turns"></div>

      <div id="errorBox" hidden></div>
    </div>
  </div>

  <script>
  // =====================================================================================
  // Battlemat Core Rewrite
  // Goals: small core renderer (hexes + camera + layers + orientation + fog) + supersample.
  // =====================================================================================

  const VERSION = 'v6.68';

  // ===== DOM =====
  const getEl = (id) => document.getElementById(id);
  const els = {
    canvas: getEl('canvas'),
    canvasWrap: getEl('canvasWrap'),
    versionText: getEl('versionText'),
    sceneSelect: getEl('sceneSelect'),
    fogToggle: getEl('fogToggle'),
    spriteToggle: getEl('spriteToggle'),
    labelBoldToggle: getEl('labelBoldToggle'),
    floorSelect: getEl('floorSelect'),
    sourceSelect: getEl('sourceSelect'),
    battleIdInput: getEl('battleIdInput'),
    battleIdApply: getEl('battleIdApply'),
    centerOn: getEl('centerOn'),
    jumpHex: getEl('jumpHex'),
    errorBox: getEl('errorBox'),
    dprText: getEl('dprText'),
    ssText: getEl('ssText'),
    ssSelect: getEl('ssSelect'),
    zoomText: getEl('zoomText'),
    kvs: getEl('kvs'),
    turns: getEl('turns'),
    toolSelect: getEl('toolSelect'),
    toolRoom: getEl('toolRoom'),
    toolDoor: getEl('toolDoor'),
    toolWindow: getEl('toolWindow'),
    toolDelete: getEl('toolDelete'),
    btnSaveDb: getEl('btnSaveDb'),
    btnUndo: getEl('btnUndo'),
    btnScanIssues: getEl('btnScanIssues'),
    btnCleanOrphans: getEl('btnCleanOrphans'),
    toolStatus: getEl('toolStatus'),
    btnLeft: getEl('btnLeft'),
    btnRight: getEl('btnRight'),
    btnUp: getEl('btnUp'),
    btnDown: getEl('btnDown'),
    btnZoomOut: getEl('btnZoomOut'),
    btnZoomIn: getEl('btnZoomIn'),
    btnRedraw: getEl('btnRedraw'),
    btnJump: getEl('btnJump'),
  };

  const canvas = els.canvas;
  const ctx = canvas.getContext('2d', { alpha: false, desynchronized: true });

  // Offscreen wall layer (we punch openings out of walls here, then composite onto main canvas)
  const wallCanvas = document.createElement('canvas');
  const wallCtx = wallCanvas.getContext('2d', { alpha: true, desynchronized: true });

  const elVersion = els.versionText;
  const elSceneSelect = els.sceneSelect;
  const elFogToggle = els.fogToggle;
  const elSpriteToggle = els.spriteToggle;
  const elLabelBoldToggle = els.labelBoldToggle;
  const elFloorSelect = els.floorSelect;
  const elSourceSelect = els.sourceSelect;
  const elBattleIdInput = els.battleIdInput;
  const elBattleIdApply = els.battleIdApply;
  const elCenterOn = els.centerOn;
  const elJumpHex = els.jumpHex;
  const elError = els.errorBox;
  const elDpr = els.dprText;
  const elSs = els.ssText;
  const elSsSelect = els.ssSelect;
  const elToolSelect = els.toolSelect;
  const elToolRoom = els.toolRoom;
  const elToolDoor = els.toolDoor;
  const elToolWindow = els.toolWindow;
  const elToolDelete = els.toolDelete;
  const elSaveDb = els.btnSaveDb;
  const elUndo = els.btnUndo;
  const elToolStatus = els.toolStatus;

  if (elVersion) elVersion.textContent = VERSION;
  document.title = 'Battlemat Core ' + VERSION;

  // ===== Constants =====
  const sqrt3 = Math.sqrt(3);

  const GRID = {
    // Flat-top hex geometry: size is center-to-vertex.
    baseSize: 42,
    size: 42,
    lineWidth: 2,
    lineAlpha: 0.10,
    labelAlpha: 0.18,
    labelFont: 'bold 12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial',
  };

  const COLORS = {
    bg: '#0b0d12',
    wall: '#666',
    door: '#b67a2c',
    window: '#bfe2ff',

    floorStone: 'rgb(223, 208, 165)',
    floorWood:  'rgb(213, 181, 140)',

    // Placeholder prop colors (used when sprites are off or missing)
    objectWood: 'rgb(173, 131, 89)',
    chestWood:  'rgb(110, 72, 40)',
    stairsWood: 'rgb(140, 98, 64)',

    // Beds (placeholder colors)
    bedFabric: 'rgb(173, 131, 89)', // match table color
    bedPillow: 'rgb(175, 159, 141)',

    // Hearth (placeholder color)
    hearth: 'rgb(147, 53, 53)',
    floorCobble: 'rgb(154, 160, 166)',

    tokenHero: '#4aa3ff',
    tokenEnemy: '#111',
    tokenTextDark: 'rgba(0,0,0,0.72)',
    tokenTextLight: 'rgba(255,255,255,0.88)',

    fogUnseen: 'rgb(128,128,128)',
    fogExplored: 'rgb(170,170,170)',
  };

  const VIEW = {
    // Camera is in hex coords (col,row), row 0 is "row 1" at the bottom.
    camera: { col: 6, row: 6 },
    anchor: { x: 0, y: 0 },

    // Active floor id (single-floor states still work)
    floorId: null,

    // If set, camera will automatically follow that token id (and flip floors when needed)
    followTokenId: null,

    // DevicePixelRatio × supersample scale (set in resize())
    dpr: 1,
  };

  const PAN_STEP = 2;
  const FILE_STATE_URL = '/app/data.json';
  const STORAGE_PREFIX = (() => {
    const bid = resolveBattleIdFromUrl();
    return bid ? ('battlemat.' + bid + '.') : 'battlemat.';
  })();
  const STORAGE_SS = STORAGE_PREFIX + 'supersample';
  const STORAGE_ZOOM = STORAGE_PREFIX + 'zoom';

  // ===== Remote state (DB/API) =====
  const DEFAULT_POLL_MS = 0;
  let CURRENT_STATE = null;
  let STATE_URL = null;
  let STATE_POLL_TIMER = null;
  let LAST_STATE_JSON = '';
  let LAST_RENDER_SIGNATURE = '';
  let LAST_EDITOR_SIGNATURE = '';
  let SPRITE_LOAD_TICK = 0;
  let SPRITES_ENABLED = true;
  let STATE_SOURCE = 'embedded';

  const EDITOR = {
    tool: 'select',
    preview: null,
    roomStart: null,
    roomPreview: null,
    selectedId: null,
    selectedFloorId: null,
    lastOpenings: null,
    issueMarkers: [],
    deletedOpeningsByFloor: {},
    deletedObjectsByFloor: {},
    deletedRoomsByFloor: {},
    deletedTokens: {},
    undoSnapshot: null,
    undoLock: false,
    saveTimer: null,
    saving: false,
  };

  function getQueryParams(search = window.location.search) {
    const s = String(search || '').trim();
    const out = new Map();
    if (!s || s === '?' || s === '#') return out;
    const q = (s[0] === '?' || s[0] === '#') ? s.slice(1) : s;
    for (const part of q.split('&')) {
      if (!part) continue;
      const [kRaw, vRaw] = part.split('=');
      const k = decodeURIComponent((kRaw || '').replaceAll('+', ' ')).trim();
      const v = decodeURIComponent((vRaw || '').replaceAll('+', ' ')).trim();
      if (k) out.set(k, v);
    }
    return out;
  }

  function getQueryParamsCached() {
    if (!getQueryParamsCached._cached) {
      getQueryParamsCached._cached = getQueryParams();
    }
    return getQueryParamsCached._cached;
  }

  function parseBattleIdFromUrlString(rawUrl) {
    const base = (window && window.location && window.location.href)
      ? window.location.href
      : 'http://localhost/';
    const s = String(rawUrl || '').trim();
    if (!s) return null;

    let u = null;
    try { u = new URL(s, base); } catch { u = null; }

    const search = u ? u.search : '';
    const hash = u ? u.hash : '';
    const path = u ? u.pathname : s;

    let bid = (
      getQueryParams(search).get('battle_id') ||
      getQueryParams(search).get('battleId') ||
      getQueryParams(search).get('battle') ||
      getQueryParams(search).get('id') ||
      ''
    ).trim();
    if (bid) return bid;

    bid = (
      getQueryParams(hash).get('battle_id') ||
      getQueryParams(hash).get('battleId') ||
      getQueryParams(hash).get('battle') ||
      getQueryParams(hash).get('id') ||
      ''
    ).trim();
    if (bid) return bid;

    const playMatch = String(path || '').match(/\/play\/([^\/?#]+)/i);
    if (playMatch && playMatch[1]) {
      try { return decodeURIComponent(playMatch[1]); } catch { return playMatch[1]; }
    }

    const matMatch = String(path || '').match(/\/battlemat\/([^\/?#]+)/i);
    if (matMatch && matMatch[1]) {
      try { return decodeURIComponent(matMatch[1]); } catch { return matMatch[1]; }
    }

    return null;
  }

  function resolveBattleIdHintFromUrl() {
    const qp = getQueryParamsCached();
    let bid = (
      qp.get('battle_id') ||
      qp.get('battleId') ||
      qp.get('battle') ||
      qp.get('id') ||
      ''
    ).trim();
    if (bid) return bid;

    const hp = getQueryParams(window.location.hash);
    bid = (
      hp.get('battle_id') ||
      hp.get('battleId') ||
      hp.get('battle') ||
      hp.get('id') ||
      ''
    ).trim();
    if (bid) return bid;

    // Support pretty URLs like /play/28 (rewrites may keep the path in the address bar).
    const path = (window && window.location && window.location.pathname)
      ? String(window.location.pathname)
      : '';
    const playMatch = path.match(/\/play\/([^\/?#]+)/i);
    if (playMatch && playMatch[1]) {
      try { return decodeURIComponent(playMatch[1]); } catch { return playMatch[1]; }
    }

    const matMatch = path.match(/\/battlemat\/([^\/?#]+)/i);
    if (matMatch && matMatch[1]) {
      try { return decodeURIComponent(matMatch[1]); } catch { return matMatch[1]; }
    }

    const href = (window && window.location && window.location.href)
      ? String(window.location.href)
      : '';
    const hrefPlayMatch = href.match(/\/play\/([^\/?#]+)/i);
    if (hrefPlayMatch && hrefPlayMatch[1]) {
      try { return decodeURIComponent(hrefPlayMatch[1]); } catch { return hrefPlayMatch[1]; }
    }
    const hrefMatMatch = href.match(/\/battlemat\/([^\/?#]+)/i);
    if (hrefMatMatch && hrefMatMatch[1]) {
      try { return decodeURIComponent(hrefMatMatch[1]); } catch { return hrefMatMatch[1]; }
    }

    const ref = (document && document.referrer) ? String(document.referrer) : '';
    if (ref) {
      const refBid = parseBattleIdFromUrlString(ref);
      if (refBid) return refBid;
    }

    return null;
  }

  function shouldRunSelfTests() {
    const qp = getQueryParamsCached();
    if (qp.get('selftest') === '1' || qp.get('selftests') === '1') return true;
    return !!(window && window.BATTLEMAT_SELFTESTS);
  }

  function resolveBattleIdFromUrl() {
    return resolveBattleIdHintFromUrl();
  }

  function resolveStateUrl() {
    const qp = getQueryParamsCached();
    const fromQuery = qp.get('stateUrl') || qp.get('state_url') || qp.get('state') || '';
    const fromWindow = (window && window.BATTLE_STATE_URL) ? String(window.BATTLE_STATE_URL) : '';
    const url = (fromQuery || fromWindow || '').trim();
    if (url) return url;

    // Canonical site routing: /play/27 -> /app/battlemat?battle_id=27
    // We can auto-derive the API URL from battle_id.
    const battleId = resolveBattleIdFromUrl();
    if (battleId) return `/api/battles/${encodeURIComponent(battleId)}`;

    return null;
  }

  function resolvePollMs() {
    const qp = getQueryParamsCached();
    const qv = qp.get('pollMs') || qp.get('poll_ms') || '';
    const wv = (window && window.BATTLE_STATE_POLL_MS != null) ? String(window.BATTLE_STATE_POLL_MS) : '';
    const raw = (qv || wv || '').trim();
    if (raw === '') return DEFAULT_POLL_MS;
    const n = Number(raw);
    if (!Number.isFinite(n)) return DEFAULT_POLL_MS;
    return Math.max(0, Math.floor(n));
  }

  async function fetchStateOnce(url) {
    const u = String(url || '').trim();
    if (!u) return null;

    // Cache-bust so you can serve plain JSON from static hosting or through proxies.
    const sep = u.includes('?') ? '&' : '?';
    const fetchUrl = u + sep + '_ts=' + Date.now();

    const res = await fetch(fetchUrl, {
      method: 'GET',
      cache: 'no-store',
      headers: { 'Accept': 'application/json' },
    });

    if (!res.ok) throw new Error('State fetch failed: ' + res.status + ' ' + res.statusText);

    const txt = await res.text();
    const jsonText = txt.trim();
    if (!jsonText) throw new Error('State fetch returned empty body');

    let parsedOuter;
    try { parsedOuter = JSON.parse(jsonText); }
    catch (e) {
      throw new Error('State fetch returned non-JSON: ' + (e && e.message ? e.message : String(e)));
    }

    // Common DB shape: { ..., state_json: "{...}" }
    if (parsedOuter && typeof parsedOuter === 'object' && parsedOuter.state_json != null) {
      const sj = parsedOuter.state_json;

      if (typeof sj === 'string') {
        const sjText = sj.trim();
        if (!sjText) throw new Error('Battle record has empty state_json');

        let parsedState;
        try { parsedState = JSON.parse(sjText); }
        catch (e) {
          throw new Error('Battle record has invalid state_json JSON: ' + (e && e.message ? e.message : String(e)));
        }

        // Use state_json text for change detection (avoids redrawing if other DB fields change).
        return { parsed: parsedState, jsonText: sjText };
      }

      // state_json provided as object already
      try {
        const stable = JSON.stringify(sj);
        return { parsed: sj, jsonText: stable };
      } catch {
        // Fallback: if it can't stringify, still apply it
        return { parsed: sj, jsonText: '[[state_json_object]]' };
      }
    }

    // If the endpoint returns the scene JSON directly.
    return { parsed: parsedOuter, jsonText };
  }

  let CURRENT_RAW_STATE = null; // last raw payload from DB/API (world wrapper OR legacy)

  function stableJsonTextFor(raw) {
    try { return JSON.stringify(raw); } catch { return '[[unstringifiable_state]]'; }
  }

  function applyViewFromState(state) {
    // If the state specifies a floor/camera, apply it.
    try {
      const st = state;
      const floors = getFloorsFromState(st);
      const fid = pickActiveFloorId(st, floors);
      VIEW.floorId = fid;

      const camHex = st && st.view && st.view.camera_hex ? String(st.view.camera_hex) : null;
      if (camHex) {
        const p = parseHexId(camHex);
        VIEW.camera.col = p.col;
        VIEW.camera.row = p.row;
      }
    } catch {}
  }

  function setCanonicalStateFromRaw(raw, jsonTextHint) {
    clearEditorPendingDeletes();
    CURRENT_RAW_STATE = raw;
    LAST_STATE_JSON = String(jsonTextHint != null ? jsonTextHint : stableJsonTextFor(raw));

    // Normalize (world wrapper -> active record scene; legacy scene -> scene)
    const scene = normalizeStateForRenderer(raw) || FALLBACK_STATE_MIN;
    CURRENT_STATE = scene;

    // Keep VIEW synced to the scene.
    applyViewFromState(scene);
  }

  function applyFetchedState(parsed, jsonText) {
    setCanonicalStateFromRaw(parsed, jsonText);
    STATE_SOURCE = stateSourceFromUrl(STATE_URL);
  }

  function stateSourceFromUrl(url) {
    const u = String(url || '').toLowerCase();
    if (!u) return 'database';
    if (u.includes('/api/battles/') || u.includes('/battles/')) return 'database';
    if (u.endsWith('.json') || u.includes('/data/')) return 'file';
    return 'database';
  }

  function stopStatePolling() {
    if (STATE_POLL_TIMER) clearInterval(STATE_POLL_TIMER);
    STATE_POLL_TIMER = null;
  }

  function resolveFileUrl() {
    const qp = getQueryParamsCached();
    const fromQuery = qp.get('stateUrl') || qp.get('state_url') || qp.get('state') || '';
    if (fromQuery && stateSourceFromUrl(fromQuery) === 'file') return fromQuery;

    const fromWindow = (window && window.BATTLE_STATE_URL) ? String(window.BATTLE_STATE_URL) : '';
    if (fromWindow && stateSourceFromUrl(fromWindow) === 'file') return fromWindow;

    return FILE_STATE_URL;
  }

  function resolveDatabaseUrl() {
    const resolved = resolveStateUrl();
    if (stateSourceFromUrl(resolved) === 'database') return resolved;

    const battleId = resolveBattleIdFromUrl();
    if (battleId) return `/api/battles/${encodeURIComponent(battleId)}`;

    return null;
  }

  async function loadStateFromUrl(url, sourceLabel) {
    const u = String(url || '').trim();
    if (!u) throw new Error('Missing state URL');

    const got = await fetchStateOnce(u);
    if (!got) throw new Error('State fetch returned empty body');

    setCanonicalStateFromRaw(got.parsed, got.jsonText);
    STATE_SOURCE = sourceLabel || stateSourceFromUrl(u);
  }

  function syncSourceSelect() {
    if (!elSourceSelect) return;
    const v = (STATE_SOURCE === 'embedded' || STATE_SOURCE === 'file' || STATE_SOURCE === 'database')
      ? STATE_SOURCE
      : 'database';
    if (document.activeElement !== elSourceSelect) elSourceSelect.value = v;
  }

  function syncBattleIdInput() {
    if (!elBattleIdInput) return;
    const hint = resolveBattleIdHintFromUrl() || '';
    const v = hint || '';
    if (document.activeElement !== elBattleIdInput) {
      elBattleIdInput.value = v;
      if (!v) elBattleIdInput.placeholder = 'id';
    }
  }

  async function applySourceSelection(source) {
    const s = String(source || '').toLowerCase();
    if (elError) { elError.hidden = true; elError.textContent = ''; }
    stopStatePolling();

    if (s === 'embedded') {
      STATE_URL = null;
      const raw = readEmbeddedWorld();
      if (!raw) {
        if (elError) {
          elError.hidden = false;
          elError.textContent = 'Embedded state not available.';
        }
        return;
      }
      setCanonicalStateFromRaw(raw, stableJsonTextFor(raw));
      STATE_SOURCE = 'embedded';
      setToolStatus('DB: not active');
      safeRedraw();
      syncSourceSelect();
      return;
    }

    if (s === 'file') {
      STATE_URL = null;
      try {
        const url = resolveFileUrl();
        await loadStateFromUrl(url, 'file');
        safeRedraw();
        setToolStatus('DB: not active');
      } catch (e) {
        if (elError) {
          elError.hidden = false;
          elError.textContent = 'File state error:' + String.fromCharCode(10) + String(e && e.message ? e.message : e);
        }
      }
      syncSourceSelect();
      return;
    }

    const dbUrl = resolveDatabaseUrl();
    if (!dbUrl) {
      if (elError) {
        elError.hidden = false;
        elError.textContent = 'Database state URL not available.';
      }
      return;
    }

    STATE_URL = dbUrl;
    STATE_SOURCE = 'database';
    startStatePolling();
    setToolStatus('DB: idle');
    syncSourceSelect();
  }

  async function pollStateLoop() {
    if (!STATE_URL) return;

    try {
      const got = await fetchStateOnce(STATE_URL);
      if (!got) return;

      // Only apply when the server payload changes.
      if (got.jsonText !== LAST_STATE_JSON) {
        applyFetchedState(got.parsed, got.jsonText);
        safeRedraw();
      }
    } catch (e) {
      console.warn('[Battlemat] state poll error:', e);
      // Show last error in UI, but don't spam.
      if (elError) {
        elError.hidden = false;
        elError.textContent = 'State fetch error (polling paused):' + String.fromCharCode(10) + String(e && e.stack ? e.stack : e);
      }
      setToolStatus('DB: paused (error)', 'error');
      stopStatePolling();
    }
  }

  function startStatePolling() {
    const pollMs = resolvePollMs();
    if (!STATE_URL) return;

    // Always do one immediate fetch.
    pollStateLoop();

    if (pollMs <= 0) return;
    if (STATE_POLL_TIMER) clearInterval(STATE_POLL_TIMER);
    STATE_POLL_TIMER = setInterval(pollStateLoop, pollMs);
  }

  // ===== Editor helpers =====
  function setToolStatus(text, kind) {
    if (!elToolStatus) return;
    elToolStatus.textContent = String(text || '');
    elToolStatus.classList.remove('ok', 'error');
    if (kind === 'ok') elToolStatus.classList.add('ok');
    if (kind === 'error') elToolStatus.classList.add('error');
  }

  function syncEditorButtons() {
    if (elToolSelect) elToolSelect.classList.toggle('active', EDITOR.tool === 'select');
    if (elToolRoom) elToolRoom.classList.toggle('active', EDITOR.tool === 'room');
    if (elToolDoor) elToolDoor.classList.toggle('active', EDITOR.tool === 'door');
    if (elToolWindow) elToolWindow.classList.toggle('active', EDITOR.tool === 'window');
    if (elToolDelete) elToolDelete.classList.toggle('active', EDITOR.tool === 'delete');
  }

  function setEditorTool(tool) {
    const t = (tool === 'door' || tool === 'window' || tool === 'room' || tool === 'delete' || tool === 'select') ? tool : 'select';
    EDITOR.tool = t;
    EDITOR.preview = null;
    EDITOR.roomStart = null;
    EDITOR.roomPreview = null;
    syncEditorButtons();
    safeRedraw();
  }

  function sanitizeSceneForUndo(scene) {
    const out = cloneDeepSafe(scene);
    delete out.__hydratedObjectsFlat;
    delete out.__activeRecordId;
    delete out.__worldName;
    delete out.objects;
    delete out.rooms;
    delete out.openings;
    return out;
  }

  function captureUndoSnapshot(reason) {
    if (EDITOR.undoLock) return;
    const state = getState();
    if (!state || typeof state !== 'object') return;
    const recordId = state.__activeRecordId ? String(state.__activeRecordId) : '';
    EDITOR.undoSnapshot = {
      recordId,
      scene: sanitizeSceneForUndo(state),
      reason: String(reason || ''),
      ts: Date.now(),
    };
  }

  function beginUndoBatch(reason) {
    if (!EDITOR.undoLock) captureUndoSnapshot(reason);
    EDITOR.undoLock = true;
  }

  function endUndoBatch() {
    EDITOR.undoLock = false;
  }

  function applyUndoSnapshot() {
    const snap = EDITOR.undoSnapshot;
    if (!snap || !snap.scene) {
      setToolStatus('Undo: none', 'error');
      return false;
    }
    const scene = sanitizeSceneForUndo(snap.scene);
    if (snap.recordId && WORLD_STATE && WORLD_STATE.records) {
      WORLD_STATE.records[snap.recordId] = scene;
      if (!WORLD_STATE.active || typeof WORLD_STATE.active !== 'object') WORLD_STATE.active = {};
      WORLD_STATE.active.recordId = snap.recordId;
      if (scene.view && scene.view.floorId) WORLD_STATE.active.floorId = String(scene.view.floorId);
      if (scene.view && scene.view.camera_hex) WORLD_STATE.active.camera_hex = String(scene.view.camera_hex);
      setCanonicalStateFromRaw(WORLD_STATE, stableJsonTextFor(WORLD_STATE));
    } else {
      setCanonicalStateFromRaw(scene, stableJsonTextFor(scene));
    }
    EDITOR.undoSnapshot = null;
    setToolStatus('Undo: ok', 'ok');
    safeRedraw();
    if (STATE_SOURCE === 'database') scheduleDatabaseSave();
    return true;
  }

  function screenToWorld(p) {
    const cam = cameraWorld();
    return { x: cam.x + (p.x - VIEW.anchor.x), y: cam.y + (p.y - VIEW.anchor.y) };
  }

  function eventToWorld(ev) {
    const rect = canvas.getBoundingClientRect();
    const x = ev.clientX - rect.left;
    const y = ev.clientY - rect.top;
    return screenToWorld({ x, y });
  }

  function roundQuarter(v) { return Math.round(v * 4) / 4; }

  function formatStep(v) {
    const s = roundQuarter(v).toFixed(2);
    return s.replace(/\.00$/, '').replace(/(\.\d)0$/, '$1');
  }

  function openingHexFromWorld(world) {
    const size = GRID.size || 1;
    const qf = (2 / 3) * (world.x / size);
    const rf = ((-world.y) / size) / sqrt3 - (qf / 2);
    const q = Math.round(qf);
    const rowf = rf + (q - (q & 1)) / 2;
    const row = roundQuarter(rowf);
    return { col: q, row };
  }

  function openingHexLabelFromCoords(col, row) {
    if (!Number.isFinite(col) || !Number.isFinite(row)) return null;
    const rowNum = row + 1;
    return colToLetters(col) + formatStep(rowNum);
  }

  function wallSegDistance2(seg, p) {
    if (!seg) return Infinity;
    if (seg.orientation === 'h') {
      const dy = Math.abs((p && p.y) - seg.y);
      let dx = 0;
      if ((p && p.x) < seg.x1) dx = seg.x1 - (p.x);
      else if ((p && p.x) > seg.x2) dx = (p.x) - seg.x2;
      return dx * dx + dy * dy;
    }
    const dx = Math.abs((p && p.x) - seg.x);
    let dy = 0;
    if ((p && p.y) < seg.y1) dy = seg.y1 - (p.y);
    else if ((p && p.y) > seg.y2) dy = (p.y) - seg.y2;
    return dx * dx + dy * dy;
  }

  function projectToWall(seg, p) {
    if (!seg) return null;
    if (seg.orientation === 'h') {
      return { x: clamp(p.x, seg.x1, seg.x2), y: seg.y };
    }
    return { x: seg.x, y: clamp(p.y, seg.y1, seg.y2) };
  }

  function pickBestWallSegment(wallSegs, p) {
    const h = findNearestWallSegment(wallSegs, 'h', p);
    const v = findNearestWallSegment(wallSegs, 'v', p);
    const dh = wallSegDistance2(h, p);
    const dv = wallSegDistance2(v, p);
    if (!h && !v) return null;
    return (dh <= dv) ? h : v;
  }

  function getEditorContext() {
    const state = getState();
    const render = buildRenderState(state);
    const rooms = Array.isArray(render.rooms) ? render.rooms : [];
    let openings = Array.isArray(render.floor && render.floor.openings) ? render.floor.openings : [];
    if (render.floor && render.floor.openings !== openings) render.floor.openings = openings;
    const wallSegs = dedupeWallSegments(buildWallSegments(rooms));
    return { state, ...render, openings, wallSegs };
  }

  function computeDoorPlacement(world, ctx) {
    if (!ctx || !ctx.wallSegs || !ctx.wallSegs.length) return null;
    const seg = pickBestWallSegment(ctx.wallSegs, world);
    if (!seg) return null;
    const maxDist = GRID.size * 1.5;
    if (wallSegDistance2(seg, world) > (maxDist * maxDist)) return null;
    const proj = projectToWall(seg, world);
    if (!proj) return null;
    const hex = openingHexFromWorld(proj);
    const label = openingHexLabelFromCoords(hex.col, hex.row);
    if (!label) return null;
    return { hex: label, orientation: seg.orientation };
  }

  function openingWorldCenter(opening, wallSegs) {
    const p = parseOpeningHex(opening && opening.hex);
    if (!p) return null;
    const hexWorld = hexCenterWorld(p.col, p.row);
    const orient = openingOrientation(opening);
    const seg = findNearestWallSegment(wallSegs, orient, hexWorld);
    let cx = hexWorld.x;
    let cy = hexWorld.y;
    if (seg) {
      if (orient === 'h') cy = seg.y;
      else cx = seg.x;
    }
    return { x: cx, y: cy };
  }

  function ensureOpeningId(opening) {
    if (!opening || opening.id) return opening && opening.id;
    opening.id = 'opening_' + Date.now().toString(36) + '_' + Math.floor(Math.random() * 1e4).toString(36);
    return opening.id;
  }

  function findOpeningNear(world, ctx, maxDist) {
    const openings = Array.isArray(ctx && ctx.openings) ? ctx.openings : [];
    const wallSegs = ctx && ctx.wallSegs ? ctx.wallSegs : [];
    const limit = Number.isFinite(maxDist) ? maxDist : (GRID.size * 0.85);
    const limit2 = limit * limit;
    let best = null;
    let bestD2 = Infinity;
    for (const o of openings) {
      const c = openingWorldCenter(o, wallSegs);
      if (!c) continue;
      const dx = c.x - world.x;
      const dy = c.y - world.y;
      const d2 = dx * dx + dy * dy;
      if (d2 <= limit2 && d2 < bestD2) {
        best = o;
        bestD2 = d2;
      }
    }
    return best;
  }

  function findObjectNear(world, ctx, maxDist) {
    const objects = Array.isArray(ctx && ctx.objects) ? ctx.objects : [];
    const limit = Number.isFinite(maxDist) ? maxDist : (GRID.size * 0.9);
    const limit2 = limit * limit;
    let best = null;
    let bestD2 = Infinity;
    for (const o of objects) {
      const c = objectCenterWorld(o);
      if (!c) continue;
      const dx = c.x - world.x;
      const dy = c.y - world.y;
      const d2 = dx * dx + dy * dy;
      if (d2 <= limit2 && d2 < bestD2) {
        best = o;
        bestD2 = d2;
      }
    }
    return best;
  }

  function findTokenNear(world, ctx, maxDist) {
    const tokens = Array.isArray(ctx && ctx.tokens) ? ctx.tokens : [];
    const limit = Number.isFinite(maxDist) ? maxDist : (GRID.size * 0.9);
    const limit2 = limit * limit;
    let best = null;
    let bestD2 = Infinity;
    for (const t of tokens) {
      if (!t || !t.hex) continue;
      const p = parseHexId(t.hex);
      if (!p) continue;
      const c = hexCenterWorld(p.col, p.row);
      const dx = c.x - world.x;
      const dy = c.y - world.y;
      const d2 = dx * dx + dy * dy;
      if (d2 <= limit2 && d2 < bestD2) {
        best = t;
        bestD2 = d2;
      }
    }
    return best;
  }

  function findRoomAtWorld(world, ctx) {
    const rooms = Array.isArray(ctx && ctx.rooms) ? ctx.rooms : [];
    if (!rooms.length) return null;
    let meta = null;
    try {
      meta = buildRoomMeta(rooms);
    } catch {
      meta = null;
    }
    if (!meta) return null;
    const rid = pickRoomAtWorldPoint(meta, world);
    if (!rid) return null;
    return rooms.find(r => r && String(r.id) === String(rid)) || null;
  }

  function roomHexFromWorld(world) {
    const hex = openingHexFromWorld(world);
    if (!hex || !Number.isFinite(hex.col) || !Number.isFinite(hex.row)) return null;
    return { col: hex.col, row: roundQuarter(hex.row) };
  }

  function roomCornersFromHexes(a, b) {
    if (!a || !b) return null;
    const minCol = Math.min(a.col, b.col);
    const maxCol = Math.max(a.col, b.col);
    const minRow = Math.min(a.row, b.row);
    const maxRow = Math.max(a.row, b.row);
    if (!Number.isFinite(minCol) || !Number.isFinite(maxCol) || !Number.isFinite(minRow) || !Number.isFinite(maxRow)) return null;
    if (Math.abs(maxCol - minCol) < 1e-6 || Math.abs(maxRow - minRow) < 1e-6) return null;
    const tl = openingHexLabelFromCoords(minCol, maxRow);
    const tr = openingHexLabelFromCoords(maxCol, maxRow);
    const br = openingHexLabelFromCoords(maxCol, minRow);
    const bl = openingHexLabelFromCoords(minCol, minRow);
    if (!tl || !tr || !br || !bl) return null;
    return [tl, tr, br, bl];
  }

  function roomDefaultsFor(ctx) {
    const rooms = Array.isArray(ctx && ctx.rooms) ? ctx.rooms : [];
    const last = rooms.length ? rooms[rooms.length - 1] : null;
    const thickness = numOr(last && last.thickness, 15);
    const floorKind = (last && last.floor && last.floor.kind) ? String(last.floor.kind) : 'wood';
    const wallKind = (last && last.wall && last.wall.kind) ? String(last.wall.kind) : 'brick';
    return { thickness, floorKind, wallKind };
  }

  function buildRoomPreview(ctx, startHex, endHex) {
    const corners = roomCornersFromHexes(startHex, endHex);
    if (!corners) return null;
    const defaults = roomDefaultsFor(ctx);
    return {
      id: '__preview_room',
      corners,
      thickness: defaults.thickness,
      floor: { kind: defaults.floorKind },
      wall: { kind: defaults.wallKind },
    };
  }

  function addRoomAtCorners(ctx, corners) {
    if (!ctx || !ctx.floor || !Array.isArray(corners) || corners.length !== 4) return null;
    if (!Array.isArray(ctx.floor.rooms)) ctx.floor.rooms = [];
    const defaults = roomDefaultsFor(ctx);
    const room = {
      id: 'room_' + Date.now().toString(36) + '_' + Math.floor(Math.random() * 1e4).toString(36),
      corners: corners.slice(),
      thickness: defaults.thickness,
      floor: { kind: defaults.floorKind },
      wall: { kind: defaults.wallKind },
    };
    ctx.floor.rooms.push(room);
    return room;
  }

  function clearEditorPendingDeletes() {
    EDITOR.deletedOpeningsByFloor = {};
    EDITOR.deletedObjectsByFloor = {};
    EDITOR.deletedRoomsByFloor = {};
    EDITOR.deletedTokens = {};
  }

  function trackOpeningDelete(ctx, opening) {
    const floorId = ctx && ctx.floorId ? String(ctx.floorId) : '';
    const openingId = opening && opening.id ? String(opening.id) : '';
    if (!floorId || !openingId) return;
    if (!EDITOR.deletedOpeningsByFloor || typeof EDITOR.deletedOpeningsByFloor !== 'object') {
      EDITOR.deletedOpeningsByFloor = {};
    }
    const bucket = EDITOR.deletedOpeningsByFloor;
    if (!bucket[floorId]) bucket[floorId] = {};
    bucket[floorId][openingId] = true;
  }

  function trackObjectDelete(ctx, object) {
    const floorId = ctx && ctx.floorId ? String(ctx.floorId) : '';
    const objectId = object && object.id ? String(object.id) : '';
    if (!floorId || !objectId) return;
    if (!EDITOR.deletedObjectsByFloor || typeof EDITOR.deletedObjectsByFloor !== 'object') {
      EDITOR.deletedObjectsByFloor = {};
    }
    const bucket = EDITOR.deletedObjectsByFloor;
    if (!bucket[floorId]) bucket[floorId] = {};
    bucket[floorId][objectId] = true;
  }

  function trackRoomDelete(ctx, room) {
    const floorId = ctx && ctx.floorId ? String(ctx.floorId) : '';
    const roomId = room && room.id ? String(room.id) : '';
    if (!floorId || !roomId) return;
    if (!EDITOR.deletedRoomsByFloor || typeof EDITOR.deletedRoomsByFloor !== 'object') {
      EDITOR.deletedRoomsByFloor = {};
    }
    const bucket = EDITOR.deletedRoomsByFloor;
    if (!bucket[floorId]) bucket[floorId] = {};
    bucket[floorId][roomId] = true;
  }

  function trackTokenDelete(token) {
    const tokenId = token && token.id ? String(token.id) : '';
    if (!tokenId) return;
    if (!EDITOR.deletedTokens || typeof EDITOR.deletedTokens !== 'object') {
      EDITOR.deletedTokens = {};
    }
    EDITOR.deletedTokens[tokenId] = true;
  }

  function setSelectedOpening(opening, floorId) {
    if (!opening) {
      EDITOR.selectedId = null;
      EDITOR.selectedFloorId = null;
      return;
    }
    EDITOR.selectedId = ensureOpeningId(opening);
    EDITOR.selectedFloorId = floorId || null;
  }

  function getSelectedOpening(ctx) {
    if (!ctx || !ctx.openings || !EDITOR.selectedId) return null;
    if (EDITOR.selectedFloorId && ctx.floorId && EDITOR.selectedFloorId !== ctx.floorId) return null;
    return ctx.openings.find(o => o && o.id === EDITOR.selectedId) || null;
  }

  function addDoorAtPlacement(ctx, placement) {
    if (!ctx || !ctx.floor || !placement) return null;
    if (!Array.isArray(ctx.floor.openings)) ctx.floor.openings = [];
    const openings = ctx.floor.openings;
    const existing = openings.find(o => o && o.hex === placement.hex && openingOrientation(o) === placement.orientation);
    if (existing) return existing;
    const opening = {
      id: 'door_' + Date.now().toString(36) + '_' + Math.floor(Math.random() * 1e4).toString(36),
      kind: 'door.wood',
      hex: placement.hex,
      orientation: placement.orientation,
      openPct: 0.0,
    };
    openings.push(opening);
    return opening;
  }

  function addWindowAtPlacement(ctx, placement) {
    if (!ctx || !ctx.floor || !placement) return null;
    if (!Array.isArray(ctx.floor.openings)) ctx.floor.openings = [];
    const openings = ctx.floor.openings;
    const existing = openings.find(o => o && o.hex === placement.hex && openingOrientation(o) === placement.orientation);
    if (existing) return existing;
    const opening = {
      id: 'window_' + Date.now().toString(36) + '_' + Math.floor(Math.random() * 1e4).toString(36),
      kind: 'window',
      hex: placement.hex,
      orientation: placement.orientation,
      openPct: 0.0,
    };
    openings.push(opening);
    return opening;
  }

  function updateOpeningHex(opening, colDelta, rowDelta) {
    const p = parseOpeningHex(opening && opening.hex);
    if (!p) return false;
    const col = p.col + colDelta;
    const row = roundQuarter(p.row + rowDelta);
    const label = openingHexLabelFromCoords(col, row);
    if (!label) return false;
    opening.hex = label;
    return true;
  }

  function removeOpening(ctx, opening) {
    if (!ctx || !opening) return false;
    const openings = Array.isArray(ctx.openings) ? ctx.openings : [];
    const idx = openings.indexOf(opening);
    if (idx < 0) return false;
    captureUndoSnapshot('delete opening');
    openings.splice(idx, 1);
    trackOpeningDelete(ctx, opening);
    if (EDITOR.selectedId === opening.id) {
      setSelectedOpening(null);
    }
    return true;
  }

  function removeObject(ctx, object) {
    if (!ctx || !object) return false;
    const objects = Array.isArray(ctx.objects) ? ctx.objects : [];
    let idx = objects.indexOf(object);
    if (idx < 0 && object.id) {
      idx = objects.findIndex(o => o && o.id === object.id);
    }
    if (idx < 0) return false;
    captureUndoSnapshot('delete object');
    objects.splice(idx, 1);
    trackObjectDelete(ctx, object);
    return true;
  }

  function removeToken(ctx, token) {
    if (!token) return false;
    const state = ctx && ctx.state ? ctx.state : getState();
    const tokens = Array.isArray(state && state.tokens)
      ? state.tokens
      : (Array.isArray(state && state.actors) ? state.actors : null);
    if (!tokens) return false;
    let idx = tokens.indexOf(token);
    if (idx < 0 && token.id) {
      idx = tokens.findIndex(t => t && t.id === token.id);
    }
    if (idx < 0) return false;
    captureUndoSnapshot('delete token');
    tokens.splice(idx, 1);
    trackTokenDelete(token);
    if (token.id && VIEW.followTokenId === token.id) {
      VIEW.followTokenId = null;
      if (elCenterOn) elCenterOn.value = '';
    }
    return true;
  }

  function removeRoom(ctx, room) {
    if (!ctx || !room) return false;
    const rooms = Array.isArray(ctx.rooms) ? ctx.rooms : [];
    let idx = rooms.indexOf(room);
    if (idx < 0 && room.id) {
      idx = rooms.findIndex(r => r && r.id === room.id);
    }
    if (idx < 0) return false;
    captureUndoSnapshot('delete room');
    rooms.splice(idx, 1);
    trackRoomDelete(ctx, room);
    return true;
  }

  function handleEditorKey(ev) {
    if (ev.target && (ev.target.tagName === 'INPUT' || ev.target.tagName === 'SELECT' || ev.target.isContentEditable)) return false;
    const key = ev.key;
    const ctx = getEditorContext();

    if (key === 'Escape') {
      if (EDITOR.tool === 'room' && EDITOR.roomStart) {
        EDITOR.roomStart = null;
        EDITOR.roomPreview = null;
        safeRedraw();
        return true;
      }
      if (EDITOR.tool !== 'select') {
        setEditorTool('select');
        return true;
      }
    }

    const sel = ctx ? getSelectedOpening(ctx) : null;
    if (!sel) return false;

      if (key === 'Delete' || key === 'Backspace') {
        if (removeOpening(ctx, sel)) {
          scheduleDatabaseSave();
          safeRedraw();
        }
        return true;
      }

      if (key === 'r' || key === 'R') {
        captureUndoSnapshot('rotate opening');
        sel.orientation = (openingOrientation(sel) === 'h') ? 'v' : 'h';
        scheduleDatabaseSave();
        safeRedraw();
        return true;
      }

      if (key === 'ArrowLeft') {
        captureUndoSnapshot('move opening');
        if (updateOpeningHex(sel, -1, 0)) {
          scheduleDatabaseSave();
          safeRedraw();
        }
        return true;
      }
      if (key === 'ArrowRight') {
        captureUndoSnapshot('move opening');
        if (updateOpeningHex(sel, 1, 0)) {
          scheduleDatabaseSave();
          safeRedraw();
        }
        return true;
      }
      if (key === 'ArrowUp') {
        captureUndoSnapshot('move opening');
        if (updateOpeningHex(sel, 0, 1)) {
          scheduleDatabaseSave();
          safeRedraw();
        }
        return true;
      }
      if (key === 'ArrowDown') {
        captureUndoSnapshot('move opening');
        if (updateOpeningHex(sel, 0, -1)) {
          scheduleDatabaseSave();
          safeRedraw();
        }
        return true;
      }

    return false;
  }

  function applyPendingOpeningDeletes(out) {
    const pending = EDITOR.deletedOpeningsByFloor;
    if (!pending || !out || !Array.isArray(out.floors)) return;
    for (const floor of out.floors) {
      if (!floor || !floor.id) continue;
      const byId = pending[floor.id];
      if (!byId) continue;
      const ids = Object.keys(byId);
      if (!ids.length) continue;
      const existing = Array.isArray(floor.openings) ? floor.openings : [];
      const filtered = existing.filter(o => !(o && o.id && byId[o.id]));
      for (const id of ids) {
        filtered.push({ id, deleted: true });
      }
      floor.openings = filtered;
    }
  }

  function applyPendingObjectDeletes(out) {
    const pending = EDITOR.deletedObjectsByFloor;
    if (!pending || !out || !Array.isArray(out.floors)) return;
    for (const floor of out.floors) {
      if (!floor || !floor.id) continue;
      const byId = pending[floor.id];
      if (!byId) continue;
      const ids = Object.keys(byId);
      if (!ids.length) continue;
      const existing = Array.isArray(floor.objects) ? floor.objects : [];
      const filtered = existing.filter(o => !(o && o.id && byId[o.id]));
      for (const id of ids) {
        filtered.push({ id, deleted: true });
      }
      floor.objects = filtered;
    }
  }

  function applyPendingRoomDeletes(out) {
    const pending = EDITOR.deletedRoomsByFloor;
    if (!pending || !out || !Array.isArray(out.floors)) return;
    for (const floor of out.floors) {
      if (!floor || !floor.id) continue;
      const byId = pending[floor.id];
      if (!byId) continue;
      const ids = Object.keys(byId);
      if (!ids.length) continue;
      const existing = Array.isArray(floor.rooms) ? floor.rooms : [];
      const filtered = existing.filter(r => !(r && r.id && byId[r.id]));
      for (const id of ids) {
        filtered.push({ id, deleted: true });
      }
      floor.rooms = filtered;
    }
  }

  function applyPendingTokenDeletes(out) {
    const pending = EDITOR.deletedTokens;
    if (!pending || !out) return;
    const ids = Object.keys(pending);
    if (!ids.length) return;
    const existing = Array.isArray(out.tokens) ? out.tokens : [];
    const filtered = existing.filter(t => !(t && t.id && pending[t.id]));
    for (const id of ids) {
      filtered.push({ id, deleted: true });
    }
    out.tokens = filtered;
  }

  function applyPendingDeletes(out) {
    applyPendingOpeningDeletes(out);
    applyPendingObjectDeletes(out);
    applyPendingRoomDeletes(out);
    applyPendingTokenDeletes(out);
  }

  function buildRecordPatchForSave() {
    const state = getState();
    if (!state || typeof state !== 'object') return null;

    const recordId = (state && state.__activeRecordId) ? String(state.__activeRecordId) : '';
    const out = cloneDeepSafe(state);
    applyPendingDeletes(out);
    delete out.__hydratedObjectsFlat;
    delete out.__activeRecordId;
    delete out.__worldName;
    delete out.objects;  // derived flattening (avoid cross-floor pollution)
    delete out.rooms;    // legacy top-level floor mirrors
    delete out.openings; // legacy top-level floor mirrors
    if (recordId) {
      return { records: { [recordId]: out } };
    }
    return out;
  }

  async function saveStateToDatabase() {
    if (STATE_SOURCE !== 'database') {
      setToolStatus('DB: not active', 'error');
      return false;
    }
    const url = resolveDatabaseUrl() || STATE_URL;
    if (!url) {
      setToolStatus('DB: missing battle id', 'error');
      return false;
    }
    const raw = buildRecordPatchForSave();
    if (!raw) {
      setToolStatus('DB: no state', 'error');
      return false;
    }
    EDITOR.saving = true;
    setToolStatus('DB: saving...', null);
    try {
      const res = await fetch(url, {
        method: 'PUT',
        headers: { 'content-type': 'application/json', 'accept': 'application/json' },
        body: JSON.stringify({ state_json: raw }),
      });
      if (!res.ok) throw new Error('DB save failed: ' + res.status + ' ' + res.statusText);
      EDITOR.saving = false;
      clearEditorPendingDeletes();
      setToolStatus('DB: saved', 'ok');
      return true;
    } catch (e) {
      EDITOR.saving = false;
      setToolStatus('DB: save error', 'error');
      if (elError) {
        elError.hidden = false;
        elError.textContent = 'Database save error:' + String.fromCharCode(10) + String(e && e.message ? e.message : e);
      }
      return false;
    }
  }

  function scheduleDatabaseSave() {
    if (STATE_SOURCE !== 'database') {
      setToolStatus('DB: not active', 'error');
      return;
    }
    if (EDITOR.saveTimer) clearTimeout(EDITOR.saveTimer);
    EDITOR.saveTimer = setTimeout(() => {
      EDITOR.saveTimer = null;
      saveStateToDatabase();
    }, 400);
  }

  function resolveSpriteBasePath() {
    try {
      // Resolve relative to the current HTML file so /public/ and root deployments both work.
      return new URL('../assets/sprites/', window.location.href).toString();
    } catch {
      return '/assets/sprites/';
    }
  }

  // ===== Sprites (core, optional) =====
  const SPRITES = {
    basePath: resolveSpriteBasePath(),
    cache: new Map(),
    defs: {
      // Objects
      'bed':         { file: 'bed.png', rotate: 'deg' },
      'bed.double':  { file: 'bed_double.png', rotate: 'deg' },
      'chair':       { file: 'chair.png', rotate: 'deg' },
      'table.round': { file: 'table_round.png', rotate: 'deg' },
      'table.rect':  { file: 'table_rectangle.png', rotate: 'deg' },
      'table.sqr':   { file: 'table_square.png', rotate: 'deg' },
      'chest':       { file: 'chest_closed.png', rotate: 'deg' },
      'hearth':      { file: 'hearth.png', rotate: 'deg' },
      'cooking.hearth': { file: 'cooking_hearth.png', rotate: 'deg' },
      'stairs':      { file: 'stairs.png', rotate: 'deg' },

      // New 1-hex props
      'keg':         { file: 'keg.png', rotate: 'deg' },
      'barrel':      { file: 'barrel.png', rotate: 'deg' },
      'crate':       { file: 'crate.png', rotate: 'deg' },

      // Doors (prefer dot-style kinds, but keep aliases for convenience/compat)
      'door':         { file: 'door_wood.png', rotate: 'none' },
      'door.wood':    { file: 'door_wood.png', rotate: 'none' },
      'door_wood':    { file: 'door_wood.png', rotate: 'none' },
      'bath':        { file: 'bath.png', rotate: 'deg' },

      // Tokens (optional)
      'token.pc':    { file: 'token_pc.png', rotate: 'none' },
      'token.npc':   { file: 'token_npc.png', rotate: 'none' },
    }
  };

  function getSpriteDef(kind) {
    const k = String(kind || '').toLowerCase();
    return SPRITES.defs[k] || null;
  }

  function scheduleSpriteRedraw() {
    // Debounce redraws when multiple images finish loading at once.
    if (scheduleSpriteRedraw._pending) return;
    scheduleSpriteRedraw._pending = true;
    requestAnimationFrame(() => {
      scheduleSpriteRedraw._pending = false;
      SPRITE_LOAD_TICK++;
      if (SPRITES_ENABLED) safeRedraw();
    });
  }

  function loadSprite(file) {
    const f = String(file || '').trim();
    if (!f) return null;

    if (SPRITES.cache.has(f)) return SPRITES.cache.get(f);

    const img = new Image();
    img.decoding = 'async';
    img.addEventListener('load', () => scheduleSpriteRedraw(), { once: true });
    img.addEventListener('error', () => scheduleSpriteRedraw(), { once: true });
    img.src = SPRITES.basePath + f;

    SPRITES.cache.set(f, img);
    return img;
  }

  function drawSpriteImage(img, opts = {}) {
    // Unified sprite draw: fit=contain or stretch, optional anchor and rotation.
    if (!img || !img.complete || !img.naturalWidth || !img.naturalHeight) return false;

    const x = Number(opts.x || 0);
    const y = Number(opts.y || 0);
    const w = Number(opts.w || 0);
    const h = Number(opts.h || 0);
    const fit = String(opts.fit || 'contain').toLowerCase();
    const rotRad = Number(opts.rotRad || 0);
    const ax = clamp(Number(opts.anchorX != null ? opts.anchorX : 0.5), 0, 1);
    const ay = clamp(Number(opts.anchorY != null ? opts.anchorY : 0.5), 0, 1);

    let dw = w;
    let dh = h;

    if (fit === 'contain') {
      const iw = img.naturalWidth;
      const ih = img.naturalHeight;
      const s = Math.min(w / iw, h / ih);
      dw = iw * s;
      dh = ih * s;
    }

    ctx.save();
    ctx.translate(x, y);
    if (rotRad) ctx.rotate(rotRad);
    ctx.drawImage(img, -dw * ax, -dh * ay, dw, dh);
    ctx.restore();
    return true;
  }

  // ===== Repeat textures (optional) =====
  // One texture catalog; per-category scales + aliases.
  const TEXTURES = {
    files: {
      wood_oak:     'wood_oak.png',
      wood_elm:     'wood_elm.png',
      wood_dark:    'wood_dark.png',

      stone_cobble: 'stone_cobble.png',
      stone_gravel: 'stone_gravel.png',

      brick_gray:   'brick_gray.png',
      brick_red:    'brick_red.png',
      brick_dark:   'brick_dark.png',
    },

    scales: {
      wall: {
        wood_oak:     0.50,
        wood_elm:     0.50,
        wood_dark:    0.50,

        stone_cobble: 0.45,
        stone_gravel: 0.55,

        brick_gray:   0.40,
        brick_red:    0.20,
        brick_dark:   0.40,
      },
      floor: {
        wood_oak:     0.50,
        wood_elm:     0.50,
        wood_dark:    0.50,

        stone_cobble: 0.45,
        stone_gravel: 0.55,

        brick_gray:   0.40,
        brick_red:    0.40,
        brick_dark:   0.40,
      },
    },

    aliases: {
      wall: {
        brick:  'brick_gray',
        wood:   'wood_oak',
        cobble: 'stone_cobble',
        stone:  'stone_cobble',
        gravel: 'stone_gravel',
      },
      floor: {
        wood:   'wood_oak',
        stone:  'stone_cobble',
        cobble: 'stone_cobble',
        gravel: 'stone_gravel',
        brick:  'brick_gray',
      },
    },
  };

  function resolveTextureDef(category, kind) {
    const cat = String(category || '').toLowerCase();
    const k0 = String(kind || '').toLowerCase();
    if (!cat || !k0) return null;

    const files = TEXTURES && TEXTURES.files ? TEXTURES.files : null;
    const scales = (TEXTURES && TEXTURES.scales && TEXTURES.scales[cat]) ? TEXTURES.scales[cat] : null;
    const aliases = (TEXTURES && TEXTURES.aliases && TEXTURES.aliases[cat]) ? TEXTURES.aliases[cat] : null;
    if (!files || !scales) return null;

    const key = (k0 in files) ? k0 : (aliases && aliases[k0] ? String(aliases[k0]).toLowerCase() : '');
    if (!key || !(key in files)) return null;

    return { file: files[key], scale: (key in scales) ? Number(scales[key]) : 1 };
  }

  const PATTERN_CACHE = new Map();

  const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v));
  const isFiniteNum = (v) => Number.isFinite(Number(v));

  // Snap CSS-space coords to the device-pixel grid to avoid 1px seams at high zoom.
  // VIEW.dpr is devicePixelRatio × supersample, so snapping to 1/VIEW.dpr lines up with the backing store.
  function snapCss(v) {
    const d = Number(VIEW && VIEW.dpr) || 1;
    return Math.round(Number(v) * d) / d;
  }

  function snappedRectFromCenter(centerS, w, h) {
    const x1 = snapCss(centerS.x - w / 2);
    const y1 = snapCss(centerS.y - h / 2);
    const x2 = snapCss(centerS.x + w / 2);
    const y2 = snapCss(centerS.y + h / 2);
    return { x: x1, y: y1, w: Math.max(0, x2 - x1), h: Math.max(0, y2 - y1) };
  }

  // ===== Supersample + Zoom =====
  let SUPERSAMPLE = 3;
  let ZOOM = 1;

  function effectivePatternScale(defScale) {
    // Patterns should zoom with the map so tiles stay visually consistent.
    return clamp((Number(defScale) || 1) * (Number(ZOOM) || 1), 0.02, 10);
  }

  function getRepeatPatternForCtx(targetCtx, tex) {
    const file = (typeof tex === 'string') ? tex : (tex && tex.file);
    const defScale = (tex && typeof tex === 'object' && isFiniteNum(tex.scale)) ? Number(tex.scale) : 1;

    const f = String(file || '').trim();
    if (!f) return null;

    const ctxKey = (targetCtx === wallCtx) ? 'wall' : 'main';
    const effScale = effectivePatternScale(defScale);
    const key = ctxKey + '|' + f + '|s=' + String(effScale.toFixed(4));

    const cached = PATTERN_CACHE.get(key);
    if (cached && cached.pattern) return cached.pattern;

    const img = loadSprite(f);
    if (!img || !img.complete || !img.naturalWidth || !img.naturalHeight) return null;

    const pat = targetCtx.createPattern(img, 'repeat');
    if (!pat) return null;

    if (typeof pat.setTransform === 'function') {
      pat.setTransform(new DOMMatrix([effScale, 0, 0, effScale, 0, 0]));
      PATTERN_CACHE.set(key, { pattern: pat });
      return pat;
    }

    // Fallback: pre-scale into an offscreen tile canvas, then pattern that.
    const tw = Math.max(1, Math.round(img.naturalWidth * effScale));
    const th = Math.max(1, Math.round(img.naturalHeight * effScale));
    const tile = document.createElement('canvas');
    tile.width = tw;
    tile.height = th;
    const tctx = tile.getContext('2d');
    tctx.imageSmoothingEnabled = true;
    try { tctx.imageSmoothingQuality = 'high'; } catch {}
    tctx.drawImage(img, 0, 0, tw, th);

    const pat2 = targetCtx.createPattern(tile, 'repeat');
    if (!pat2) return null;

    PATTERN_CACHE.set(key, { pattern: pat2 });
    return pat2;
  }

  function readSupersample() {
    const raw = localStorage.getItem(STORAGE_SS);
    const v = parseFloat(raw != null ? raw : '3');
    if (!Number.isFinite(v)) return 3;
    return clamp(v, 1, 3);
  }

  function setSupersample(v) {
    const n = clamp(parseFloat(String(v)), 1, 3);
    localStorage.setItem(STORAGE_SS, String(n));
    SUPERSAMPLE = n;
    PATTERN_CACHE.clear();
    if (elSsSelect) elSsSelect.value = String(n);
    resize();
  }

  function readZoom() {
    const raw = localStorage.getItem(STORAGE_ZOOM);
    const v = parseFloat(raw != null ? raw : '1');
    if (!Number.isFinite(v)) return 1;
    return clamp(v, 0.60, 2.25);
  }

  function applyZoom() {
    GRID.size = GRID.baseSize * ZOOM;
  }

  function syncZoomUI() {
    const el = els.zoomText;
    if (el) el.textContent = Math.round(ZOOM * 100) + '%';
  }

  function setZoom(v, opts = {}) {
    const n = clamp(parseFloat(String(v)), 0.60, 2.25);
    ZOOM = n;
    applyZoom();
    PATTERN_CACHE.clear();
    if (opts.persist !== false) localStorage.setItem(STORAGE_ZOOM, String(n));
    syncZoomUI();
    safeRedraw();
  }

  // ===== Canonical state (demo) =====
  // PHASE 1 of "World Record" support:
  // - We now support *either* a legacy battlemat state OR a world-record wrapper.
  // - World-record wrapper format:
  //     { world, version, meta, active:{recordId,floorId,camera_hex}, records:{[recordId]:<sceneState>}, links:[] }
  // - The renderer continues to run on a *sceneState* (floors/openings/objects/tokens).
  // - normalizeStateForRenderer() extracts the active scene and hydrates it for the current renderer.
  //
  // NOTE: Embedded data is intentionally JSON (not JS object-literal) so you can copy/paste into state_json.
  // Keep it JSON-valid: double quotes only, no comments, no trailing commas.

const EMBEDDED_WORLD_JSON = `{
  "world": "Saffrondale",
  "version": 1,
  "meta": { "scale": "1 hex = 5 ft", "fogMode": "room" },
  "active": { "recordId": "CrossKeysInn", "floorId": "ground", "camera_hex": "U16" },
  "records": {
    "CrossKeysInn": {
      "meta": { "title": "Cross Keys Inn - Base", "battleId": "local", "round": 1 },
      "view": { "camera_hex": "U16", "floorId": "ground" },
      "fog": {
        "enabled": true,
        "mode": "room",
        "visibleRoomIdsByFloor": { "upper": [], "ground": [], "basement": [] },
        "exploredRoomIdsByFloor": { "upper": [], "ground": [], "basement": [] },
        "autoCompute": true,
        "autoExplore": true,
        "maxDepth": 1,
        "unseenAlpha": 0.92,
        "exploredAlpha": 0.55
      },
      "floors": [
        {
          "id": "upper",
          "name": "Upper",
          "rooms": [
            { "id": "CrossKeysUpperFloor", "buildingId": "CrossKeysInn", "corners": ["L21", "AJ21", "AJ12", "L12"], "thickness": 15, "floor": { "kind": "fog" }, "wall": { "kind": "wood_dark" } }
          ],
          "openings": [],
          "objects": []
        },
        {
          "id": "ground",
          "name": "Ground",
          "rooms": [
            { "id": "CrossKeysGroundFloor", "buildingId": "CrossKeysInn", "corners": ["M21.5", "AJ21", "AJ12.5", "M13"], "thickness": 15, "floor": { "kind": "fog" }, "wall": { "kind": "brick" } }
          ],
          "openings": [
            { "id": "door_front", "kind": "door.wood", "hex": "M17", "orientation": "v", "openPct": 0.0 }
          ],
          "objects": []
        },
        {
          "id": "basement",
          "name": "Basement",
          "rooms": [
            { "id": "BasementRoom", "buildingId": "CrossKeysInn", "corners": ["P18", "W18", "W14", "P14"], "thickness": 15, "floor": { "kind": "stone" }, "wall": { "kind": "brick" } }
          ],
          "openings": [],
          "objects": []
        }
      ],
      "tokens": []
    }
  },
  "links": []
}`;

  let WORLD_STATE = null; // holds the last parsed *world record* (if provided)

  const FALLBACK_STATE_MIN = {
    meta: { title: 'Fallback', battleId: 'local', round: 1 },
    floors: [],
    tokens: []
  };

  function cloneDeepSafe(obj) {
    if (obj == null) return obj;
    if (typeof structuredClone === 'function') return structuredClone(obj);
    return JSON.parse(JSON.stringify(obj));
  }

  // ===== Data normalization =====
  function numOr(v, d = 0) {
    const n = Number(v);
    return Number.isFinite(n) ? n : d;
  }

  function normStr(v, d = '') {
    const s = (v == null) ? '' : String(v);
    return s.trim() || d;
  }

  function normKind(v, d = '') {
    return normStr(v, d).toLowerCase();
  }

  function normOrient(v) {
    const o = normKind(v, 'h');
    return (o === 'v' || o === 'vert' || o === 'vertical') ? 'v' : 'h';
  }

  function normDoorKind(kind) {
    const k = normKind(kind, 'door');
    // Unify common door aliases.
    if (k === 'door_wood' || k === 'doorwood' || k === 'door.wood' || k === 'door-wood') return 'door.wood';
    if (k === 'door_stone' || k === 'doorstone' || k === 'door.stone' || k === 'door-stone') return 'door.stone';
    if (k.startsWith('door.') || k.startsWith('door_') || k === 'door') return k;
    return k;
  }

  function normalizeRooms(list) {
    const rooms = Array.isArray(list) ? list : [];
    for (const r of rooms) {
      if (!r || typeof r !== 'object') continue;
      if (r.id != null) r.id = String(r.id);
      if (Array.isArray(r.corners)) r.corners = r.corners.map(c => String(c));
      r.thickness = numOr(r.thickness, numOr(r.wallThickness, 15));
      if (!r.floor || typeof r.floor !== 'object') r.floor = {};
      if (!r.wall || typeof r.wall !== 'object') r.wall = {};
      r.floor.kind = normKind(r.floor.kind, normKind(r.floor.type, 'wood'));
      r.wall.kind = normKind(r.wall.kind, normKind(r.wall.type, 'brick'));
    }
    return rooms;
  }

  function normalizeOpenings(list) {
    const openings = Array.isArray(list) ? list : [];
    for (const o of openings) {
      if (!o || typeof o !== 'object') continue;
      if (o.id != null) o.id = String(o.id);
      o.hex = normStr(o.hex);
      o.orientation = normOrient(o.orientation);

      const k0 = normKind(o.kind, 'door');
      o.kind = (k0 === 'door' || k0.startsWith('door') || k0.startsWith('door_') || k0.startsWith('door.'))
        ? normDoorKind(k0)
        : k0;

      if (o.openPct == null && o.open != null) o.openPct = o.open;
      if (o.openPct == null && o.open_pct != null) o.openPct = o.open_pct;
      o.openPct = clamp(numOr(o.openPct, 0), 0, 1);

      if (o.span != null) o.span = clamp(numOr(o.span, 1), 0.5, 4);
      if (o.spriteScale != null) o.spriteScale = numOr(o.spriteScale, 1);
      if (o.spriteScaleX != null) o.spriteScaleX = numOr(o.spriteScaleX, 1);
      if (o.spriteScaleY != null) o.spriteScaleY = numOr(o.spriteScaleY, 1);

      if (o.parent != null) o.parent = String(o.parent);
      if (o.hinge != null) o.hinge = String(o.hinge);
      if (o.swing != null) o.swing = numOr(o.swing, o.swing);
    }
    return openings;
  }

  function normalizeObjects(list, floorIdFallback = null) {
    const objects = Array.isArray(list) ? list : [];
    for (const o of objects) {
      if (!o || typeof o !== 'object') continue;
      if (o.id != null) o.id = String(o.id);
      o.kind = normKind(o.kind, 'object');
      o.hex = normStr(o.hex);

      if (o.floorId == null && o.floor_id != null) o.floorId = o.floor_id;
      if (o.floorId == null && floorIdFallback != null) o.floorId = String(floorIdFallback);
      if (o.floorId != null) o.floorId = String(o.floorId);

      if (o.ox != null) o.ox = numOr(o.ox, 0);
      if (o.oy != null) o.oy = numOr(o.oy, 0);
      if (o.rotDeg != null) o.rotDeg = numOr(o.rotDeg, 0);

      if (o.spriteScale != null) o.spriteScale = numOr(o.spriteScale, 1);
      if (o.spriteScaleX != null) o.spriteScaleX = numOr(o.spriteScaleX, 1);
      if (o.spriteScaleY != null) o.spriteScaleY = numOr(o.spriteScaleY, 1);
    }
    return objects;
  }

  function normalizeTokens(list, floorIdFallback = null) {
    const tokens = Array.isArray(list) ? list : [];
    for (const t of tokens) {
      if (!t || typeof t !== 'object') continue;
      if (t.id != null) t.id = String(t.id);
      t.hex = normStr(t.hex);

      const side = normStr(t.side ?? t.team ?? t.faction, 'NPC').toUpperCase();
      t.side = (side === 'PC' || side === 'NPC') ? side : 'NPC';

      if (t.floorId == null && t.floor_id != null) t.floorId = t.floor_id;
      if (t.floorId == null && floorIdFallback != null) t.floorId = String(floorIdFallback);
      if (t.floorId != null) t.floorId = String(t.floorId);

      if (t.init != null) t.init = numOr(t.init, 0);
      if (t.hp != null) t.hp = numOr(t.hp, t.hp);

      if (t.label != null) t.label = String(t.label);
      if (t.name != null) t.name = String(t.name);
    }
    return tokens;
  }

  function normalizeSceneShape(scene) {
    if (!scene || typeof scene !== 'object') return null;

    if (!scene.meta || typeof scene.meta !== 'object') scene.meta = {};
    if (!scene.view || typeof scene.view !== 'object') scene.view = {};

    // Normalize floors into an array. If we only have legacy top-level rooms/openings/objects,
    // fold them into a single floor.
    let floors = null;

    if (Array.isArray(scene.floors)) {
      floors = scene.floors;
    } else if (scene.floors && typeof scene.floors === 'object') {
      floors = Object.entries(scene.floors).map(([id, data]) => ({ id, ...(data || {}) }));
      scene.floors = floors;
    } else {
      const fid = String(scene.view.floorId || scene.view.floor_id || scene.view.floor || 'floor1');
      floors = [{
        id: fid,
        name: 'Floor',
        rooms: Array.isArray(scene.rooms) ? scene.rooms : [],
        openings: Array.isArray(scene.openings) ? scene.openings : [],
        objects: Array.isArray(scene.objects) ? scene.objects : [],
      }];
      scene.floors = floors;
    }

    // Ensure view.floorId is set to a valid floor id.
    const firstId = floors && floors.length ? String(floors[0].id ?? 'floor1') : 'floor1';
    const wanted = String(scene.view.floorId || scene.view.floor_id || scene.view.floor || '') || '';
    const ok = wanted && floors.some(f => String(f && f.id) === wanted);
    scene.view.floorId = ok ? wanted : firstId;

    // Normalize per-floor arrays.
    for (const f of floors) {
      if (!f || typeof f !== 'object') continue;
      if (f.id == null) f.id = firstId;
      f.id = String(f.id);
      if (f.name != null) f.name = String(f.name);

      f.rooms = normalizeRooms(f.rooms);
      f.openings = normalizeOpenings(f.openings);
      f.objects = normalizeObjects(f.objects, f.id);
    }

    // Normalize tokens.
    const tok = (scene.tokens != null) ? scene.tokens : (scene.actors != null ? scene.actors : []);
    scene.tokens = normalizeTokens(tok, scene.view.floorId);

    // Keep legacy top-level lists present but consistent (for compatibility).
    scene.rooms = floors[0] ? floors[0].rooms : [];
    scene.openings = floors[0] ? floors[0].openings : [];

    return scene;
  }

  function hydrateSceneForRenderer(scene) {
    if (!scene || typeof scene !== 'object') return null;

    // Prevent double-hydration if we normalize the same object more than once.
    // We keep this marker internal; it's only used in-memory.
    if (scene.__hydratedObjectsFlat) return scene;

    // Normalize shape + fields before we derive any compatibility views.
    normalizeSceneShape(scene);

    // If objects are stored per-floor, also expose a top-level flattened list so older rendering paths continue to work.
    // Always rebuild the flattened list so we never accidentally duplicate entries.
    scene.objects = [];

    if (Array.isArray(scene.floors)) {
      for (const f of scene.floors) {
        if (!f || typeof f !== 'object') continue;
        const fid = f.id;
        if (Array.isArray(f.objects) && f.objects.length) {
          for (const o of f.objects) {
            if (!o || typeof o !== 'object') continue;
            if (!('floorId' in o) && fid) o.floorId = fid;
            scene.objects.push(o);
          }
        }
      }
    }

    scene.__hydratedObjectsFlat = true;
    return scene;
  }

  function normalizeStateForRenderer(rawState) {
    if (!rawState || typeof rawState !== 'object') return null;

    // World-record wrapper
    if (rawState.records && rawState.active && rawState.active.recordId) {
      WORLD_STATE = rawState;
      const recordId = rawState.active.recordId;
      const rec = rawState.records ? rawState.records[recordId] : null;
      if (!rec) {
        console.warn('[Battlemat] World record missing active record:', recordId);
        return null;
      }

      const scene = cloneDeepSafe(rec);
      if (!scene.view || typeof scene.view !== 'object') scene.view = {};

      // Active pointer overrides scene view (camera/floor)
      if (rawState.active.camera_hex) scene.view.camera_hex = rawState.active.camera_hex;
      if (rawState.active.floorId) scene.view.floorId = rawState.active.floorId;

      // Carry through helpful context for UI/debugging (non-canonical for now)
      scene.__activeRecordId = recordId;
      scene.__worldName = rawState.world || null;

      return hydrateSceneForRenderer(scene);
    }

    // Legacy battlemat state
    WORLD_STATE = null;
    return hydrateSceneForRenderer(cloneDeepSafe(rawState));
  }

  function readEmbeddedWorld() {
    try {
      const parsed = JSON.parse(EMBEDDED_WORLD_JSON);
      STATE_SOURCE = 'embedded';
      return parsed;
    } catch (e) {
      console.warn('[Battlemat] Embedded world JSON parse failed:', e);
      return null;
    }
  }

  // PHASE 2: Allow the host page (or a future DB bootstrap) to provide state_json up-front.
  // If present, it should be either:
  //   - a JSON string (world-record wrapper OR legacy scene state), OR
  //   - a parsed object (same)
  // We intentionally support multiple variable names to make integration easy.
  function readBootstrapState() {
    const injected =
      (typeof window !== 'undefined' && (window.__BATTLEMAT_BOOTSTRAP_STATE_JSON ?? window.BATTLEMAT_BOOTSTRAP_STATE_JSON)) ||
      null;

    if (!injected) return readEmbeddedWorld();

    try {
      if (typeof injected === 'string') {
        STATE_SOURCE = 'file';
        return JSON.parse(injected);
      }
      if (typeof injected === 'object') {
        STATE_SOURCE = 'file';
        return injected;
      }
    } catch (e) {
      console.warn('[Battlemat] Bootstrap state parse failed; falling back to embedded demo:', e);
      return readEmbeddedWorld();
    }

    console.warn('[Battlemat] Bootstrap state was neither string nor object; falling back to embedded demo.');
    return readEmbeddedWorld();
  }

  // This is the in-page demo default. It is parsed from JSON so it matches state_json storage.
  const DEFAULT_STATE = normalizeStateForRenderer(readBootstrapState()) || FALLBACK_STATE_MIN;

  // Debug helper: lets you easily copy the canonical "raw" JSON (world wrapper if present).
  // Note: This returns the last parsed WORLD_STATE if you loaded a world wrapper; otherwise it returns DEFAULT_STATE.
  if (typeof window !== 'undefined') {
  window.BattlematExportRawState = function () {
    const raw = WORLD_STATE || DEFAULT_STATE;
    return JSON.stringify(raw, null, 2);
  };

  function scanCollectionIds(items, label, recordId, floorId, issues) {
    const counts = new Map();
    for (const item of (Array.isArray(items) ? items : [])) {
      const id = item && item.id != null ? String(item.id) : '';
      if (!id) {
        issues.push({ type: 'missing_id', label, recordId, floorId, id: '', detail: '' });
        continue;
      }
      counts.set(id, (counts.get(id) || 0) + 1);
    }
    for (const [id, count] of counts.entries()) {
      if (count > 1) {
        issues.push({ type: 'duplicate_id', label, recordId, floorId, id, detail: 'count=' + count });
      }
    }
  }

  function scanSceneIssues(scene, recordId) {
    const issues = [];
    const floors = getFloorsFromState(scene);
    const floorIds = floors.map(f => (f && f.id != null) ? String(f.id) : '');
    const floorSet = new Set(floorIds.filter(Boolean));

    const tokens = getTokensArray(scene);
    scanCollectionIds(tokens, 'token', recordId, '', issues);
    for (const t of tokens) {
      if (!t || !t.hex) continue;
      const p = parseHex(t.hex);
      if (!p) {
        issues.push({ type: 'bad_hex', label: 'token', recordId, floorId: entityFloorId(t), id: String(t.id || ''), detail: String(t.hex || '') });
      }
      const fid = entityFloorId(t);
      if (fid && !floorSet.has(String(fid))) {
        issues.push({ type: 'unknown_floor', label: 'token', recordId, floorId: String(fid), id: String(t.id || ''), detail: 'floorId not found' });
      }
    }

    for (const floor of floors) {
      const floorId = floor && floor.id != null ? String(floor.id) : '';
      const rooms = Array.isArray(floor && floor.rooms) ? floor.rooms : [];
      const openings = Array.isArray(floor && floor.openings) ? floor.openings : [];
      const objects = Array.isArray(floor && floor.objects) ? floor.objects : [];

      scanCollectionIds(rooms, 'room', recordId, floorId, issues);
      scanCollectionIds(openings, 'opening', recordId, floorId, issues);
      scanCollectionIds(objects, 'object', recordId, floorId, issues);

      for (const r of rooms) {
        const corners = Array.isArray(r && r.corners) ? r.corners : null;
        if (!corners || corners.length !== 4) {
          issues.push({ type: 'bad_corners', label: 'room', recordId, floorId, id: String(r && r.id || ''), detail: 'corners=' + (corners ? corners.length : 0) });
          continue;
        }
        for (const c of corners) {
          try { parseCornerHexId(c); } catch (e) {
            issues.push({ type: 'bad_corner_hex', label: 'room', recordId, floorId, id: String(r && r.id || ''), detail: String(c) });
          }
        }
      }

      const roomMeta = buildRoomMeta(rooms);
      for (const o of openings) {
        const p = parseOpeningHex(o && o.hex);
        if (!p) {
          issues.push({ type: 'bad_hex', label: 'opening', recordId, floorId, id: String(o && o.id || ''), detail: String(o && o.hex || '') });
          continue;
        }
        const ids = openingRoomIds(o, roomMeta);
        if (!ids.length) {
          issues.push({ type: 'orphan_opening', label: 'opening', recordId, floorId, id: String(o && o.id || ''), detail: String(o && o.hex || '') });
        }
      }

      for (const o of objects) {
        const p = parseObjectHex(o && o.hex);
        if (!p) {
          issues.push({ type: 'bad_hex', label: 'object', recordId, floorId, id: String(o && o.id || ''), detail: String(o && o.hex || '') });
        }
      }
    }

    return { recordId, issues };
  }

  function scanRawStateIssues(raw) {
    const report = { issues: [], records: [] };
    const w = (raw && raw.records && raw.active) ? raw : null;
    if (w) {
      const recordIds = Object.keys(w.records || {});
      for (const rid of recordIds) {
        const rec = w.records[rid];
        const res = scanSceneIssues(rec, String(rid));
        report.records.push(res);
        report.issues.push(...res.issues);
      }
    } else {
      const res = scanSceneIssues(raw, 'Scene');
      report.records.push(res);
      report.issues.push(...res.issues);
    }
    report.summary = {
      total: report.issues.length,
      duplicate_id: report.issues.filter(i => i.type === 'duplicate_id').length,
      missing_id: report.issues.filter(i => i.type === 'missing_id').length,
      bad_hex: report.issues.filter(i => i.type === 'bad_hex').length,
      orphan_opening: report.issues.filter(i => i.type === 'orphan_opening').length,
      bad_corners: report.issues.filter(i => i.type === 'bad_corners').length,
      bad_corner_hex: report.issues.filter(i => i.type === 'bad_corner_hex').length,
      unknown_floor: report.issues.filter(i => i.type === 'unknown_floor').length,
    };
    return report;
  }

  function cleanOrphanOpeningsInScene(scene) {
    const removed = [];
    const floors = getFloorsFromState(scene);
    beginUndoBatch('clean orphans');
    for (const floor of floors) {
      const floorId = floor && floor.id != null ? String(floor.id) : '';
      const rooms = Array.isArray(floor && floor.rooms) ? floor.rooms : [];
      const openings = Array.isArray(floor && floor.openings) ? floor.openings : [];
      if (!openings.length) continue;
      const roomMeta = buildRoomMeta(rooms);
      for (let i = openings.length - 1; i >= 0; i -= 1) {
        const o = openings[i];
        const ids = openingRoomIds(o, roomMeta);
        if (!ids.length) {
          const ctx = { openings, floorId };
          if (removeOpening(ctx, o)) {
            removed.push({ floorId, id: String(o && o.id || ''), hex: String(o && o.hex || '') });
          }
        }
      }
    }
    endUndoBatch();
    return removed;
  }

  function findDuplicateIds(items) {
    const counts = new Map();
    for (const item of (Array.isArray(items) ? items : [])) {
      const id = item && item.id != null ? String(item.id) : '';
      if (!id) continue;
      counts.set(id, (counts.get(id) || 0) + 1);
    }
    const dups = new Set();
    for (const [id, count] of counts.entries()) {
      if (count > 1) dups.add(id);
    }
    return dups;
  }

  function buildIssueMarkersForContext(ctx) {
    const markers = [];
    const seen = new Set();
    if (!ctx) return markers;
    const floorId = ctx.floorId;
    const rooms = Array.isArray(ctx.rooms) ? ctx.rooms : [];
    const openings = Array.isArray(ctx.openings) ? ctx.openings : [];
    const objects = Array.isArray(ctx.objects) ? ctx.objects : [];
    const tokens = Array.isArray(ctx.tokens) ? ctx.tokens : [];

    const dupRooms = findDuplicateIds(rooms);
    const dupOpenings = findDuplicateIds(openings);
    const dupObjects = findDuplicateIds(objects);
    const dupTokens = findDuplicateIds(tokens);

    const addMarker = (m) => {
      const key = [
        m.kind || '',
        m.floorId || '',
        m.id || '',
        m.hex || '',
        Array.isArray(m.corners) ? m.corners.join(',') : ''
      ].join('|');
      if (seen.has(key)) return;
      m.key = key;
      markers.push(m);
      seen.add(key);
    };

    const roomMeta = buildRoomMeta(rooms);

    for (let i = 0; i < rooms.length; i++) {
      const r = rooms[i];
      const id = r && r.id != null ? String(r.id) : '';
      if (!id) {
        addMarker({ kind: 'room', floorId, id: '__missing_' + i, corners: r && r.corners ? r.corners.slice() : null, thickness: r && r.thickness, reason: 'missing_id' });
      } else if (dupRooms.has(id)) {
        addMarker({ kind: 'room', floorId, id, corners: r && r.corners ? r.corners.slice() : null, thickness: r && r.thickness, reason: 'duplicate_id' });
      }
    }

    for (let i = 0; i < openings.length; i++) {
      const o = openings[i];
      const id = o && o.id != null ? String(o.id) : '';
      const hex = o && o.hex ? String(o.hex) : '';
      const orient = o && o.orientation ? String(o.orientation) : 'h';
      const ids = openingRoomIds(o, roomMeta);
      if (!id) {
        addMarker({ kind: 'opening', floorId, id: '__missing_' + i, hex, orientation: orient, reason: 'missing_id' });
      } else if (dupOpenings.has(id)) {
        addMarker({ kind: 'opening', floorId, id, hex, orientation: orient, reason: 'duplicate_id' });
      }
      if (!ids.length) {
        addMarker({ kind: 'opening', floorId, id: id || ('__orphan_' + i), hex, orientation: orient, reason: 'orphan' });
      }
    }

    for (let i = 0; i < objects.length; i++) {
      const o = objects[i];
      const id = o && o.id != null ? String(o.id) : '';
      const hex = o && o.hex ? String(o.hex) : '';
      const ox = o && o.ox != null ? Number(o.ox) : undefined;
      const oy = o && o.oy != null ? Number(o.oy) : undefined;
      if (!id) {
        addMarker({ kind: 'object', floorId, id: '__missing_' + i, hex, ox, oy, reason: 'missing_id' });
      } else if (dupObjects.has(id)) {
        addMarker({ kind: 'object', floorId, id, hex, ox, oy, reason: 'duplicate_id' });
      }
    }

    for (let i = 0; i < tokens.length; i++) {
      const t = tokens[i];
      const id = t && t.id != null ? String(t.id) : '';
      const hex = t && t.hex ? String(t.hex) : '';
      if (!id) {
        addMarker({ kind: 'token', floorId, id: '__missing_' + i, hex, reason: 'missing_id' });
      } else if (dupTokens.has(id)) {
        addMarker({ kind: 'token', floorId, id, hex, reason: 'duplicate_id' });
      }
    }

    return markers;
  }

  function setIssueMarkers(markers) {
    EDITOR.issueMarkers = Array.isArray(markers) ? markers : [];
    safeRedraw();
  }

  window.BattlematScanIssues = function (opts = {}) {
    const raw = CURRENT_RAW_STATE || WORLD_STATE || DEFAULT_STATE;
    const report = scanRawStateIssues(raw);
    const ctx = getEditorContext();
    const markers = buildIssueMarkersForContext(ctx);
    setIssueMarkers(markers);
    if (!opts || !opts.silent) {
      const label = report.summary ? ('Issues: ' + report.summary.total) : 'Issues: ?';
      setToolStatus(label, report.summary && report.summary.total ? 'error' : 'ok');
    }
    if (!opts || !opts.silent) {
      console.group('[Battlemat] scan issues');
      console.log('Summary:', report.summary);
      if (report.issues.length) console.table(report.issues);
      console.groupEnd();
    }
    return report;
  };

  window.BattlematClearIssues = function () {
    setIssueMarkers([]);
    setToolStatus('Issues: 0', 'ok');
  };

  window.BattlematCleanOrphanOpenings = function () {
    const scene = getState();
    const removed = cleanOrphanOpeningsInScene(scene);
    if (removed.length) {
      scheduleDatabaseSave();
    }
    console.log('[Battlemat] orphan openings removed:', removed.length);
    if (removed.length) console.table(removed);
    window.BattlematScanIssues({ silent: true });
    return removed;
  };
  }
  function parseMaybeJson(rawOrJson) {
    if (rawOrJson == null) return null;
    if (typeof rawOrJson === 'string') {
      try { return JSON.parse(rawOrJson); } catch { return null; }
    }
    if (typeof rawOrJson === 'object') return rawOrJson;
    return null;
  }

  function cameraHexFromView() {
    try {
      return colToLetters(VIEW.camera.col) + String((Math.round(VIEW.camera.row) + 1));
    } catch {
      return null;
    }
  }

  function ensureWorldWrapper(recordId) {
    const rid = String(recordId || 'Scene').trim() || 'Scene';
    if (WORLD_STATE && WORLD_STATE.records && WORLD_STATE.active) return WORLD_STATE;

    const scene = cloneDeepSafe(CURRENT_STATE || DEFAULT_STATE || FALLBACK_STATE_MIN);
    const floorId =
      VIEW.floorId ||
      (scene.view && scene.view.floorId) ||
      (Array.isArray(scene.floors) && scene.floors[0] ? scene.floors[0].id : null) ||
      null;

    const camHex = cameraHexFromView() || (scene.view && scene.view.camera_hex) || null;

    WORLD_STATE = {
      world: (scene.__worldName || 'World'),
      version: 1,
      meta: { scale: '1 hex = 5 ft' },
      active: { recordId: rid, floorId, camera_hex: camHex },
      records: { [rid]: scene },
      links: []
    };

    return WORLD_STATE;
  }

  function parsePathParts(path) {
    if (Array.isArray(path)) return path.slice();
    const s = String(path || '').trim();
    if (!s) return [];

    const out = [];
    let i = 0;

    while (i < s.length) {
      const ch = s[i];

      if (ch === '.') { i++; continue; }

      if (ch === '[') {
        i++;
        let numStr = '';
        while (i < s.length && s[i] !== ']') {
          numStr += s[i];
          i++;
        }
        i++; // skip ]
        const n = Number(numStr);
        if (!Number.isFinite(n)) throw new Error('Bad array index in path: ' + numStr);
        out.push(n);
        continue;
      }

      // plain token
      let tok = '';
      while (i < s.length) {
        const c = s[i];
        if (c === '.' || c === '[') break;
        tok += c;
        i++;
      }
      tok = tok.trim();
      if (tok) out.push(tok);
    }

    return out;
  }

  function getContainerForSet(root, parts) {
    let cur = root;

    for (let i = 0; i < parts.length - 1; i++) {
      const k = parts[i];
      const nextK = parts[i + 1];
      const nextIsIndex = typeof nextK === 'number';

      if (typeof k === 'number') {
        if (!Array.isArray(cur)) throw new Error('Path expects array at segment ' + i);
        if (cur[k] == null) cur[k] = nextIsIndex ? [] : {};
        cur = cur[k];
      } else {
        if (cur[k] == null) cur[k] = nextIsIndex ? [] : {};
        cur = cur[k];
      }
    }

    return cur;
  }

  function applyOnePatch(root, patch) {
    const op = String(patch && (patch.op || 'set')).toLowerCase();
    const parts = parsePathParts(patch && (patch.pathParts || patch.path));
    if (!parts.length) throw new Error('Patch missing path');

    const parent = getContainerForSet(root, parts);
    const key = parts[parts.length - 1];

    if (op === 'delete' || op === 'del' || op === 'remove') {
      if (typeof key === 'number') {
        if (!Array.isArray(parent)) throw new Error('Delete expects array at leaf');
        parent.splice(key, 1);
      } else {
        delete parent[key];
      }
      return;
    }

    if (op === 'merge') {
      const val = patch && patch.value;
      const curVal = (typeof key === 'number') ? parent[key] : parent[key];

      if (val && typeof val === 'object' && !Array.isArray(val) &&
          curVal && typeof curVal === 'object' && !Array.isArray(curVal)) {
        Object.assign(curVal, val);
      } else {
        if (typeof key === 'number') {
          if (!Array.isArray(parent)) throw new Error('Set expects array at leaf');
          parent[key] = val;
        } else {
          parent[key] = val;
        }
      }
      return;
    }

    // default: set
    if (typeof key === 'number') {
      if (!Array.isArray(parent)) throw new Error('Set expects array at leaf');
      parent[key] = patch.value;
    } else {
      parent[key] = patch.value;
    }
  }

  function refreshFromWorld() {
    if (WORLD_STATE && WORLD_STATE.records && WORLD_STATE.active && WORLD_STATE.active.recordId) {
      setCanonicalStateFromRaw(WORLD_STATE, stableJsonTextFor(WORLD_STATE));
      return;
    }
    if (CURRENT_RAW_STATE) {
      setCanonicalStateFromRaw(CURRENT_RAW_STATE, LAST_STATE_JSON);
      return;
    }
    CURRENT_STATE = DEFAULT_STATE;
    applyViewFromState(CURRENT_STATE);
  }

  window.BattlematGetWorld = function () {
    return WORLD_STATE ? cloneDeepSafe(WORLD_STATE) : null;
  };

  window.BattlematGetWorldJson = function () {
    return WORLD_STATE ? JSON.stringify(WORLD_STATE, null, 2) : null;
  };

  window.BattlematSetWorldState = function (rawOrJson) {
    const parsed = parseMaybeJson(rawOrJson);
    if (!parsed) throw new Error('BattlematSetWorldState: invalid JSON');
    setCanonicalStateFromRaw(parsed, (typeof rawOrJson === 'string') ? rawOrJson : null);
    safeRedraw();
    return true;
  };

  window.BattlematEnsureWorld = function (recordId) {
    ensureWorldWrapper(recordId || 'Scene');
    refreshFromWorld();
    safeRedraw();
    return true;
  };

  window.BattlematSetActive = function (recordId, floorId, camera_hex) {
    const w = ensureWorldWrapper();
    const rid = String(recordId || '').trim();
    if (!rid) throw new Error('BattlematSetActive: recordId required');
    if (!w.records || !w.records[rid]) throw new Error('BattlematSetActive: unknown recordId ' + rid);

    if (!w.active || typeof w.active !== 'object') w.active = { recordId: rid };
    w.active.recordId = rid;
    if (floorId != null) w.active.floorId = String(floorId);
    if (camera_hex != null) w.active.camera_hex = String(camera_hex);

    refreshFromWorld();
    safeRedraw();
    return true;
  };

  window.BattlematApplyPatches = function (patches) {
    const w = ensureWorldWrapper();
    const list = Array.isArray(patches) ? patches : [patches];
    for (const p of list) applyOnePatch(w, p);
    refreshFromWorld();
    safeRedraw();
    return true;
  };

  // ===== State access =====
  function getState() {
    // 1) If we have a fetched state, use it.
    if (CURRENT_STATE && typeof CURRENT_STATE === 'object') return CURRENT_STATE;

    // 2) Otherwise fall back to injected state.
    const injected = (window && window.BATTLE_STATE != null) ? window.BATTLE_STATE : null;
    const raw = injected != null ? injected : DEFAULT_STATE;
    if (injected != null) STATE_SOURCE = 'file';
    if (typeof raw === 'string') {
      try { return JSON.parse(raw); } catch { return DEFAULT_STATE; }
    }
    return raw;
  }


  // ===== State compatibility helpers =====
  // v6.20+: tolerate older schema variants while keeping the renderer deterministic.
  function getTokensArray(state) {
    const s = (state && typeof state === 'object') ? state : null;
    const arr = s && (s.tokens != null ? s.tokens : s.actors);
    return Array.isArray(arr) ? arr : [];
  }

  function getMeta(state) {
    const s = (state && typeof state === 'object') ? state : null;
    return (s && s.meta && typeof s.meta === 'object') ? s.meta : {};
  }

  function getLastAction(state) {
    const s = (state && typeof state === 'object') ? state : null;
    if (!s) return '';
    if (s.last_action != null && s.last_action !== '') return String(s.last_action);
    if (s.lastAction != null && s.lastAction !== '') {
      const v = String(s.lastAction);
      s.last_action = v;
      return v;
    }
    return '';
  }

  function getNarration(state) {
    const s = (state && typeof state === 'object') ? state : null;
    if (!s) return '';
    if (s.narration != null && s.narration !== '') return String(s.narration);
    if (s.narrative != null && s.narrative !== '') {
      const v = String(s.narrative);
      s.narration = v;
      return v;
    }
    return '';
  }

  function renderSignatureFor(state, opts = {}) {
    const s = (state && typeof state === 'object') ? state : {};
    const {
      narration,
      narrative,
      narrationText,
      last_action,
      lastAction,
      lastActionText,
      ...rest
    } = s;

    const sig = {
      ...rest,
      __render: {
        view: { floorId: VIEW.floorId, camera: VIEW.camera },
        zoom: ZOOM,
        supersample: SUPERSAMPLE,
        ui: {
          fog: !!opts.fogEnabled,
          sprites: !!opts.spritesEnabled,
          labels: !!opts.labelsEnabled,
        },
        spritesLoaded: SPRITE_LOAD_TICK,
      },
    };

    return stableJsonTextFor(sig);
  }

  function editorSignatureFor() {
    const preview = (EDITOR.preview && EDITOR.preview.opening)
      ? { floorId: EDITOR.preview.floorId || null, hex: EDITOR.preview.opening.hex, orientation: EDITOR.preview.opening.orientation }
      : null;
    const roomPreview = (EDITOR.roomPreview && EDITOR.roomPreview.room && Array.isArray(EDITOR.roomPreview.room.corners))
      ? { floorId: EDITOR.roomPreview.floorId || null, corners: EDITOR.roomPreview.room.corners }
      : null;
    const roomStart = EDITOR.roomStart
      ? { floorId: EDITOR.roomStart.floorId || null, col: EDITOR.roomStart.col, row: EDITOR.roomStart.row }
      : null;
    const selected = (EDITOR.selectedId && EDITOR.selectedFloorId)
      ? { id: EDITOR.selectedId, floorId: EDITOR.selectedFloorId }
      : null;
    const issues = Array.isArray(EDITOR.issueMarkers)
      ? EDITOR.issueMarkers.map(m => String(m && m.key != null ? m.key : '')).filter(Boolean)
      : [];
    return stableJsonTextFor({
      tool: EDITOR.tool,
      preview,
      roomPreview,
      roomStart,
      selected,
      issues,
    });
  }

  // ===== Hex id helpers =====
  function colToLetters(col) {
    let n = col + 1;
    let s = '';
    while (n > 0) {
      const r = (n - 1) % 26;
      s = String.fromCharCode(65 + r) + s;
      n = Math.floor((n - 1) / 26);
    }
    return s;
  }

  function lettersToCol(letters) {
    const u = String(letters).toUpperCase();
    let n = 0;
    for (let i = 0; i < u.length; i++) {
      const c = u.charCodeAt(i);
      if (c < 65 || c > 90) throw new Error('Bad column letters');
      n = n * 26 + (c - 64);
    }
    return n - 1;
  }

  function parseHexId(hex) {
    const m = String(hex).trim().toUpperCase().match(/^([A-Z]+)([0-9]+)$/);
    if (!m) throw new Error('Bad hex: ' + hex);
    return { col: lettersToCol(m[1]), row: parseInt(m[2], 10) - 1 };
  }

  function parseHex(hex) {
    try { return parseHexId(hex); } catch { return null; }
  }


  // Openings (doors/windows/thresholds) may use quarter-step rows (e.g. AD20.25)
  // to support odd hall geometries. Corners already allow arbitrary decimals.
  function isQuarterStep(n) {
    const v = Number(n);
    if (!Number.isFinite(v)) return false;
    return Math.abs(v * 4 - Math.round(v * 4)) < 1e-6;
  }

  function parseOpeningHexId(hex) {
    const m = String(hex).trim().toUpperCase().match(/^([A-Z]+)([0-9]+(?:\.[0-9]+)?)$/);
    if (!m) throw new Error('Bad opening hex: ' + hex);

    const col = lettersToCol(m[1]);
    const rowNum = parseFloat(m[2]);
    if (!isQuarterStep(rowNum)) throw new Error('Opening hex must be in 0.25 steps (e.g. 20, 20.25, 20.5, 20.75): ' + hex);

    return { col, row: rowNum - 1 };
  }

  function parseOpeningHex(hex) {
    try { return parseOpeningHexId(hex); } catch { return null; }
  }

  // Objects can optionally sit on half/quarter rows too (e.g. O20.5), which is handy for
  // 1/2-hex placement without needing ox/oy micro-adjustments.
  function parseObjectHexId(hex) {
    const m = String(hex).trim().toUpperCase().match(/^([A-Z]+)([0-9]+(?:\.[0-9]+)?)$/);
    if (!m) throw new Error('Bad object hex: ' + hex);

    const col = lettersToCol(m[1]);
    const rowNum = parseFloat(m[2]);
    if (!isQuarterStep(rowNum)) throw new Error('Object hex must be in 0.25 steps (e.g. 20, 20.25, 20.5, 20.75): ' + hex);

    return { col, row: rowNum - 1 };
  }

  function parseObjectHex(hex) {
    try { return parseObjectHexId(hex); } catch { return null; }
  }

  function parseCornerHexId(hex) {
    const m = String(hex).trim().toUpperCase().match(/^([A-Z]+)([0-9]+(?:\.[0-9]+)?)$/);
    if (!m) throw new Error('Bad corner hex: ' + hex);

    const col = lettersToCol(m[1]);
    const rowNum = parseFloat(m[2]);
    if (!Number.isFinite(rowNum)) throw new Error('Bad corner row: ' + hex);

    return { col, row: rowNum - 1 };
  }

  function hexId(col, row) {
    return colToLetters(col) + String(row + 1);
  }

  // ===== World geometry (flat-top) =====
  function colStep() { return 1.5 * GRID.size; }
  function rowStep() { return sqrt3 * GRID.size; }

  // Row 0 is bottom row ("1"), row increases upward.
  function hexCenterWorld(col, row) {
    const x = col * colStep();
    const y = -(row * rowStep() + (col & 1) * (rowStep() / 2));
    return { x, y };
  }

  // ===== Camera transform =====
  function cameraWorld() { return hexCenterWorld(VIEW.camera.col, VIEW.camera.row); }

  function worldToScreen(p) {
    const cam = cameraWorld();
    return { x: VIEW.anchor.x + (p.x - cam.x), y: VIEW.anchor.y + (p.y - cam.y) };
  }

  // ===== Floors (multi-floor) =====
  function getFloorsFromState(state) {
    const f = state && state.floors;
    if (Array.isArray(f)) return f;

    if (f && typeof f === 'object') {
      return Object.entries(f).map(([id, data]) => ({ id, ...(data || {}) }));
    }

    return [{
      id: (state && state.view && (state.view.floorId || state.view.floor_id || state.view.floor)) ? String(state.view.floorId || state.view.floor_id || state.view.floor) : 'floor1',
      name: 'Floor',
      rooms: Array.isArray(state && state.rooms) ? state.rooms : [],
      openings: Array.isArray(state && state.openings) ? state.openings : [],
      objects: Array.isArray(state && state.objects) ? state.objects : [],
    }];
  }

  function pickActiveFloorId(state, floors) {
    const wanted = state && state.view ? (state.view.floorId || state.view.floor_id || state.view.floor || state.view.level) : null;
    const w = wanted != null ? String(wanted) : '';
    if (w && floors.some(f => String(f.id) === w)) return w;
    return floors.length ? String(floors[0].id) : 'floor1';
  }

  function floorById(floors, id) {
    const target = String(id || '');
    return floors.find(f => String(f.id) === target) || null;
  }

  function entityFloorId(e) {
    if (!e || typeof e !== 'object') return '';
    return String(e.floorId || e.floor_id || e.floor || e.level || e.z || '');
  }

  function tokensOnFloor(state, floorId) {
    const all = getTokensArray(state);
    return all.filter(t => {
      const fid = entityFloorId(t);
      return fid ? fid === String(floorId) : true;
    });
  }

  // ===== Rooms / walls geometry =====
  function roomWallKind(room) {
    const w = (room && room.wall && typeof room.wall === 'object') ? room.wall : null;
    const k = (w && w.kind != null) ? String(w.kind) : '';
    const t = (w && w.type != null) ? String(w.type) : '';
    return String((k || t || 'brick')).toLowerCase();
  }

  function roomHasWalls(room) {
    const thick = Number(room && room.thickness != null ? room.thickness : 0);
    const wk = roomWallKind(room);
    return thick > 0 && wk !== 'none';
  }

  function roomToWallBox(room) {
    const corners = Array.isArray(room && room.corners) ? room.corners : [];
    if (corners.length !== 4) throw new Error('Room corners must be [TL, TR, BR, BL]');

    const tl = parseCornerHexId(corners[0]);
    const tr = parseCornerHexId(corners[1]);
    const br = parseCornerHexId(corners[2]);
    const bl = parseCornerHexId(corners[3]);

    const pTL = hexCenterWorld(tl.col, tl.row);
    const pTR = hexCenterWorld(tr.col, tr.row);
    const pBR = hexCenterWorld(br.col, br.row);
    const pBL = hexCenterWorld(bl.col, bl.row);

    const xL = (pTL.x + pBL.x) / 2;
    const xR = (pTR.x + pBR.x) / 2;
    const yTop = (pTL.y + pTR.y) / 2;
    const yBot = (pBL.y + pBR.y) / 2;

    const thicknessBase = Number(room && room.thickness != null ? room.thickness : 20);
    // room.thickness is specified at 100% zoom; scale by ZOOM so walls stay proportional.
    const thickness = thicknessBase * (Number(ZOOM) || 1);

    const t = roomHasWalls(room) ? thickness : 0;

    const half = t / 2;

    const mid = { x1: xL, y1: yTop, x2: xR, y2: yBot };
    const floor = { x1: xL + half, y1: yTop + half, x2: xR - half, y2: yBot - half };

    return { xL, xR, yTop, yBot, thickness: t, mid, floor };
  }

  function roomFloorRectWorld(room, box) {
    const src = (roomHasWalls(room) ? box.floor : box.mid);
    return { x1: src.x1, y1: src.y1, x2: src.x2, y2: src.y2 };
  }

  function buildWallSegments(rooms) {
    const segs = [];
    for (const r of (Array.isArray(rooms) ? rooms : [])) {
      if (!r || !roomHasWalls(r)) continue;
      const box = roomToWallBox(r);
      const t = box.thickness;

      const color = (r && r.color) ? String(r.color) : COLORS.wall;
      const wallKind = roomWallKind(r);

      segs.push({ orientation: 'h', y: box.yTop, x1: box.xL, x2: box.xR, thickness: t, color, wallKind });
      segs.push({ orientation: 'h', y: box.yBot, x1: box.xL, x2: box.xR, thickness: t, color, wallKind });
      segs.push({ orientation: 'v', x: box.xL, y1: box.yTop, y2: box.yBot, thickness: t, color, wallKind });
      segs.push({ orientation: 'v', x: box.xR, y1: box.yTop, y2: box.yBot, thickness: t, color, wallKind });
    }
    return segs;
  }

  function findNearestWallSegment(wallSegs, orient, p) {
    const want = (orient === 'h' || orient === 'v') ? orient : 'h';
    let best = null;
    let bestD2 = Infinity;

    for (const s of (Array.isArray(wallSegs) ? wallSegs : [])) {
      if (!s || s.orientation !== want) continue;

      if (want === 'h') {
        const dy = Math.abs((p && p.y) - s.y);
        let dx = 0;
        if ((p && p.x) < s.x1) dx = s.x1 - (p.x);
        else if ((p && p.x) > s.x2) dx = (p.x) - s.x2;
        const d2 = dx * dx + dy * dy;
        if (d2 < bestD2) { bestD2 = d2; best = s; }
      } else {
        const dx = Math.abs((p && p.x) - s.x);
        let dy = 0;
        if ((p && p.y) < s.y1) dy = s.y1 - (p.y);
        else if ((p && p.y) > s.y2) dy = (p.y) - s.y2;
        const d2 = dx * dx + dy * dy;
        if (d2 < bestD2) { bestD2 = d2; best = s; }
      }
    }

    return best;
  }

  function quant01(v) { return Math.round(v * 100) / 100; }

  function dedupeWallSegments(segs) {
    const map = new Map();

    for (const s of (Array.isArray(segs) ? segs : [])) {
      if (!s) continue;
      const o = s.orientation;
      if (o === 'h') {
        const y = quant01(s.y);
        const x1 = quant01(Math.min(s.x1, s.x2));
        const x2 = quant01(Math.max(s.x1, s.x2));
        const key = `h|${y}|${x1}|${x2}`;
        const prev = map.get(key);
        if (!prev) map.set(key, { ...s, y, x1, x2 });
        else prev.thickness = Math.max(prev.thickness, s.thickness);
      } else {
        const x = quant01(s.x);
        const y1 = quant01(Math.min(s.y1, s.y2));
        const y2 = quant01(Math.max(s.y1, s.y2));
        const key = `v|${x}|${y1}|${y2}`;
        const prev = map.get(key);
        if (!prev) map.set(key, { ...s, x, y1, y2 });
        else prev.thickness = Math.max(prev.thickness, s.thickness);
      }
    }

    return [...map.values()];
  }

  function drawWallSegments(targetCtx, wallSegs) {
    const wantTextures = !!(elSpriteToggle && elSpriteToggle.checked);

    for (const s of (Array.isArray(wallSegs) ? wallSegs : [])) {
      if (!s || !s.thickness) continue;

      const t = s.thickness;
      const half = t / 2;

      let fill = s.color || COLORS.wall;
      if (wantTextures) {
        const def = resolveTextureDef('wall', s.wallKind);
        if (def) {
          const pat = getRepeatPatternForCtx(targetCtx, def);
          if (pat) fill = pat;
        }
      }
      targetCtx.fillStyle = fill;

      if (s.orientation === 'h') {
        const x1 = s.x1 - half;
        const x2 = s.x2 + half;
        const y1 = s.y - half;
        const y2 = s.y + half;

        const p1 = worldToScreen({ x: x1, y: y1 });
        const p2 = worldToScreen({ x: x2, y: y2 });
        const w = p2.x - p1.x;
        const h = p2.y - p1.y;
        if (w > 0 && h > 0) targetCtx.fillRect(p1.x, p1.y, w, h);
      } else {
        const x1 = s.x - half;
        const x2 = s.x + half;
        const y1 = s.y1 - half;
        const y2 = s.y2 + half;

        const p1 = worldToScreen({ x: x1, y: y1 });
        const p2 = worldToScreen({ x: x2, y: y2 });
        const w = p2.x - p1.x;
        const h = p2.y - p1.y;
        if (w > 0 && h > 0) targetCtx.fillRect(p1.x, p1.y, w, h);
      }
    }
  }

  // ===== Floor fills =====
  function floorBaseColor(kind) {
    const k = String(kind || 'wood').toLowerCase();
    if (k === 'fog') return COLORS.fogUnseen;
    if (k === 'stone') return COLORS.floorStone;
    if (k === 'cobble') return COLORS.floorCobble;
    if (k.startsWith('stairs')) return COLORS.floorWood;
    return COLORS.floorWood;
  }

  function getFloorFillStyle(kind, wantTextures, targetCtx = ctx) {
    const fk = String(kind || 'wood').toLowerCase();
    if (!wantTextures) return floorBaseColor(fk);
    const def = resolveTextureDef('floor', fk);
    if (!def) return floorBaseColor(fk);
    const pat = getRepeatPatternForCtx(targetCtx, def);
    return pat || floorBaseColor(fk);
  }

  function isFogFloorRoom(room) {
    const k = room && room.floor && room.floor.kind ? String(room.floor.kind).toLowerCase() : '';
    return k === 'fog';
  }

  function drawFloorsLayered(rooms) {
    const wantTextures = !!(elSpriteToggle && elSpriteToggle.checked);

    for (const r of (Array.isArray(rooms) ? rooms : [])) {
      const box = roomToWallBox(r);
      const f = roomFloorRectWorld(r, box);
      const p1 = worldToScreen({ x: f.x1, y: f.y1 });
      const p2 = worldToScreen({ x: f.x2, y: f.y2 });
      const w = p2.x - p1.x;
      const h = p2.y - p1.y;
      if (w <= 0 || h <= 0) continue;

      const fk = (r && r.floor && r.floor.kind) ? String(r.floor.kind).toLowerCase() : 'wood';
      ctx.fillStyle = getFloorFillStyle(fk, wantTextures, ctx);
      ctx.fillRect(p1.x, p1.y, w, h);
    }
  }

  // ===== Openings =====
  function openingOrientation(opening) {
    const o = opening && opening.orientation ? String(opening.orientation).toLowerCase() : 'h';
    if (o === 'v' || o === 'vert' || o === 'vertical') return 'v';
    return 'h';
  }

  function openingSpan(opening) {
    const s = Number(opening && opening.span != null ? opening.span : 1);
    return clamp(Number.isFinite(s) ? s : 1, 0.5, 4);
  }

  function isDoorKind(kind) {
    const k = String(kind || '').toLowerCase();
    return (k === 'door' || k.startsWith('door_') || k.startsWith('door.'));
  }

  // Pixel padding applied to wall cutouts / seam fills.
  // To avoid 1px seams at certain zoom levels, we apply a small buffer.
  // For thresholds, we ONLY buffer in the axis perpendicular to the opening orientation:
  //   - vertical threshold (orientation 'v') => widen horizontally (+4px)
  //   - horizontal threshold (orientation 'h') => widen vertically (+4px)
  // This keeps the threshold span aligned to the parent floor, while still covering subpixel seams.
  function openingPadAxes(opening) {
    const kind = String(opening && opening.kind ? opening.kind : 'door').toLowerCase();
    const orient = openingOrientation(opening);

    // No padding needed for portals (they don't cut walls/floors).
    if (kind === 'portal' || kind === 'connector') return { x: 0, y: 0 };

    // Scale padding with backing-store resolution (DPR × supersample) to prevent 1px seams
    // at high zoom levels.
    const d = Number(VIEW && VIEW.dpr) || 1;
    const pad = clamp(Math.ceil(2 * d), 4, 12);

    // Thresholds: buffer only perpendicular to the opening orientation.
    if (kind === 'threshold') {
      return (orient === 'v') ? { x: pad, y: 0 } : { x: 0, y: pad };
    }

    // Doors/windows: small buffer in both axes helps hide seams.
    return { x: pad, y: pad };
  }

  // Opening length in world-units (CSS px). For thresholds, we auto-size to the parent room's
  // interior span so the knockout matches the parent floor space exactly.
  function openingLengthWorld(opening, rooms) {
    const kind = String(opening && opening.kind ? opening.kind : 'door').toLowerCase();
    const orient = openingOrientation(opening);

    if (kind === 'threshold') {
      const parentId = (opening && opening.parent != null) ? String(opening.parent) : '';
      const parent = parentId ? roomById(rooms, parentId) : null;
      if (parent) {
        const box = roomToWallBox(parent);
        const fr = roomFloorRectWorld(parent, box);
        const worldLen = (orient === 'h') ? Math.abs(fr.x2 - fr.x1) : Math.abs(fr.y2 - fr.y1);
        // Guardrails: never return something absurdly tiny.
        return Math.max(worldLen, GRID.size * 0.6);
      }
      // If no parent is provided/found, fall back to span sizing.
    }

    const baseLen = GRID.size * 1.2;
    const span = openingSpan(opening);
    return baseLen * span;
  }

  function cutOpeningHole(targetCtx, opening, wallSegs, rooms) {
    const kind = String(opening && opening.kind ? opening.kind : 'door').toLowerCase();
    if (kind === 'portal' || kind === 'connector') return;

    const orient = openingOrientation(opening);
    const p = parseOpeningHex(opening.hex);
    if (!p) return;

    const hexWorld = hexCenterWorld(p.col, p.row);
    const seg = findNearestWallSegment(wallSegs, orient, hexWorld);

    // Important: snap the cutout centerline onto the actual wall segment axis.
    // At extreme zoom levels, tiny float/quantization differences can otherwise mean
    // the cutout misses the wall by ~<1px, making the "knockout" look like it vanished.
    let cx = hexWorld.x;
    let cy = hexWorld.y;
    if (seg) {
      if (orient === 'h' && Number.isFinite(seg.y)) cy = seg.y;
      if (orient === 'v' && Number.isFinite(seg.x)) cx = seg.x;
    }

    const len = openingLengthWorld(opening, rooms);
    const thickness = seg ? seg.thickness : 28;

    const centerS = worldToScreen({ x: cx, y: cy });
    const pad = openingPadAxes(opening);

    // Axis-aligned screen rect (no rotation) so this matches seam fills exactly.
    // Base rect dimensions depend on orientation, then we apply axis-specific padding.
    const baseW = (orient === 'v') ? thickness : len;
    const baseH = (orient === 'v') ? len : thickness;
    const w = baseW + (pad.x || 0);
    const h = baseH + (pad.y || 0);

    const rr = snappedRectFromCenter(centerS, w, h);
    if (rr.w > 0 && rr.h > 0) targetCtx.fillRect(rr.x, rr.y, rr.w, rr.h);
  }

  function drawOpeningMarker(opening, wallSegs) {
    const kind = String(opening && opening.kind ? opening.kind : 'door').toLowerCase();
    if (kind === 'threshold' || kind === 'portal' || kind === 'connector') return;

    const orient = openingOrientation(opening);
    const p = parseOpeningHex(opening.hex);
    if (!p) return;

    const hexWorld = hexCenterWorld(p.col, p.row);
    const seg = findNearestWallSegment(wallSegs, orient, hexWorld);

    // Keep the marker aligned to the wall segment axis (same reason as cutOpeningHole).
    let cx = hexWorld.x;
    let cy = hexWorld.y;
    if (seg) {
      if (orient === 'h' && Number.isFinite(seg.y)) cy = seg.y;
      if (orient === 'v' && Number.isFinite(seg.x)) cx = seg.x;
    }

    const thickness = seg ? seg.thickness : 28;

    const c = worldToScreen({ x: cx, y: cy });
    const len = (GRID.size * 1.2) * openingSpan(opening);
    const openPct = clamp(Number(opening && opening.openPct != null ? opening.openPct : 0), 0, 1);

    ctx.save();
    ctx.translate(c.x, c.y);
    if (orient === 'v') ctx.rotate(Math.PI / 2);

    if (kind === 'window') {
      ctx.strokeStyle = COLORS.window;
      ctx.globalAlpha = 0.85;
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(-len / 2, 0);
      ctx.lineTo(len / 2, 0);
      ctx.stroke();

      ctx.globalAlpha = 0.45;
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(-len / 2, -thickness * 0.25);
      ctx.lineTo(len / 2, -thickness * 0.25);
      ctx.moveTo(-len / 2, thickness * 0.25);
      ctx.lineTo(len / 2, thickness * 0.25);
      ctx.stroke();

      ctx.restore();
      return;
    }

    // Door sprites (e.g. kind: 'door_wood')
    if (isDoorKind(kind) && SPRITES_ENABLED) {
      const def = getSpriteDef(kind);
      if (def) {
        const img = loadSprite(def.file);
        if (img && img.complete && img.naturalWidth && img.naturalHeight) {
          const hingeSide = String(opening && opening.hinge != null ? opening.hinge : 'left').toLowerCase();
          const hingeRight = (hingeSide === 'right' || hingeSide === 'r');

          const rawSwing = Number(opening && (opening.swing ?? opening.swingDir ?? opening.polarity));
          const swingSign = (rawSwing === 1 || rawSwing === -1) ? rawSwing : -1;

          const hingeX = hingeRight ? (len / 2) : (-len / 2);
          const hingeY = 0;

          const leafLen = len * 0.80;
          const boxW = leafLen;
          const boxH = thickness * 1.25;

          // Allow door openings to scale their sprite just like objects do.
          // (e.g. { kind:'door.wood', ..., spriteScale: 1.3 })
          let sx = 1, sy = 1;
          if (isFiniteNum(def.scale)) { sx *= Number(def.scale); sy *= Number(def.scale); }
          if (isFiniteNum(def.scaleX)) sx *= Number(def.scaleX);
          if (isFiniteNum(def.scaleY)) sy *= Number(def.scaleY);
          if (isFiniteNum(opening.spriteScale)) { sx *= Number(opening.spriteScale); sy *= Number(opening.spriteScale); }
          if (isFiniteNum(opening.spriteScaleX)) sx *= Number(opening.spriteScaleX);
          if (isFiniteNum(opening.spriteScaleY)) sy *= Number(opening.spriteScaleY);

          const ang = openPct * (Math.PI / 2);

          ctx.save();
          ctx.translate(hingeX, hingeY);
          ctx.rotate((hingeRight ? -1 : 1) * swingSign * ang);

          const ok = drawSpriteImage(img, {
            x: 0,
            y: 0,
            w: boxW * sx,
            h: boxH * sy,
            fit: 'contain',
            anchorX: hingeRight ? 1 : 0,
            anchorY: 0.5,
          });
          ctx.restore();

          if (ok) {
            ctx.restore();
            return;
          }
        }
      }
    }

    ctx.strokeStyle = COLORS.door;
    ctx.lineWidth = 4;
    ctx.globalAlpha = 0.9;

    if (openPct < 0.05) {
      ctx.beginPath();
      ctx.moveTo(-len / 2, 0);
      ctx.lineTo(len / 2, 0);
      ctx.stroke();
    } else {
      const hingeSide = String(opening && opening.hinge != null ? opening.hinge : 'left').toLowerCase();
      const hingeRight = (hingeSide === 'right' || hingeSide === 'r');

      const rawSwing = Number(opening && (opening.swing ?? opening.swingDir ?? opening.polarity));
      const swingSign = (rawSwing === 1 || rawSwing === -1) ? rawSwing : -1;

      const hingeX = hingeRight ? (len / 2) : (-len / 2);
      const hingeY = 0;

      const leafLen = len * 0.80;
      const ang = openPct * (Math.PI / 2);

      const x2 = hingeX + (hingeRight ? -1 : 1) * leafLen * Math.cos(ang);
      const y2 = hingeY + swingSign * leafLen * Math.sin(ang);

      ctx.beginPath();
      ctx.moveTo(hingeX, hingeY);
      ctx.lineTo(x2, y2);
      ctx.stroke();

      ctx.fillStyle = COLORS.door;
      ctx.globalAlpha = 0.95;
      ctx.beginPath();
      ctx.arc(hingeX, hingeY, 2.2, 0, Math.PI * 2);
      ctx.fill();
    }

    ctx.restore();
  }

  function drawOpeningOverlay(opening, wallSegs, opts = {}) {
    const o = opening || {};
    const orient = openingOrientation(o);
    const p = parseOpeningHex(o.hex);
    if (!p) return;

    const hexWorld = hexCenterWorld(p.col, p.row);
    const seg = findNearestWallSegment(wallSegs, orient, hexWorld);
    let cx = hexWorld.x;
    let cy = hexWorld.y;
    if (seg) {
      if (orient === 'h') cy = seg.y;
      else cx = seg.x;
    }

    const len = (GRID.size * 1.2) * openingSpan(o);
    const half = len / 2;
    const centerS = worldToScreen({ x: cx, y: cy });

    ctx.save();
    ctx.globalAlpha = 0.85;
    ctx.strokeStyle = opts.strokeStyle || 'rgba(67,209,122,0.9)';
    ctx.lineWidth = Number.isFinite(opts.lineWidth) ? opts.lineWidth : 3;
    if (opts.dash) ctx.setLineDash(opts.dash);
    ctx.beginPath();
    if (orient === 'h') {
      ctx.moveTo(centerS.x - half, centerS.y);
      ctx.lineTo(centerS.x + half, centerS.y);
    } else {
      ctx.moveTo(centerS.x, centerS.y - half);
      ctx.lineTo(centerS.x, centerS.y + half);
    }
    ctx.stroke();
    ctx.restore();
  }

  function drawRoomOverlay(room, opts = {}) {
    if (!room || !room.corners) return;
    let box = null;
    try {
      box = roomToWallBox(room);
    } catch {
      return;
    }
    const rect = roomFloorRectWorld(room, box);
    const p1 = worldToScreen({ x: rect.x1, y: rect.y1 });
    const p2 = worldToScreen({ x: rect.x2, y: rect.y2 });
    const x = Math.min(p1.x, p2.x);
    const y = Math.min(p1.y, p2.y);
    const w = Math.abs(p2.x - p1.x);
    const h = Math.abs(p2.y - p1.y);
    ctx.save();
    ctx.globalAlpha = 0.85;
    ctx.strokeStyle = opts.strokeStyle || 'rgba(67,209,122,0.9)';
    ctx.lineWidth = Number.isFinite(opts.lineWidth) ? opts.lineWidth : 3;
    if (opts.dash) ctx.setLineDash(opts.dash);
    ctx.strokeRect(x, y, w, h);
    ctx.restore();
  }

  function drawIssueRing(world, radius, opts = {}) {
    if (!world) return;
    const center = worldToScreen(world);
    const r = Number.isFinite(radius) ? radius : (GRID.size * 0.5);
    ctx.save();
    ctx.globalAlpha = Number.isFinite(opts.alpha) ? opts.alpha : 0.9;
    ctx.strokeStyle = opts.strokeStyle || 'rgba(255,80,80,0.95)';
    ctx.lineWidth = Number.isFinite(opts.lineWidth) ? opts.lineWidth : 3;
    if (opts.dash) ctx.setLineDash(opts.dash);
    ctx.beginPath();
    ctx.arc(center.x, center.y, r, 0, Math.PI * 2);
    ctx.stroke();
    ctx.restore();
  }

  function drawIssueMarker(marker, wallSegs) {
    if (!marker) return;
    const kind = String(marker.kind || '').toLowerCase();
    if (kind === 'opening') {
      const p = parseOpeningHex(marker.hex);
      if (!p) return;
      const hexWorld = hexCenterWorld(p.col, p.row);
      const orient = marker.orientation || 'h';
      const seg = findNearestWallSegment(wallSegs, orient, hexWorld);
      let cx = hexWorld.x;
      let cy = hexWorld.y;
      if (seg) {
        if (orient === 'h' && Number.isFinite(seg.y)) cy = seg.y;
        if (orient === 'v' && Number.isFinite(seg.x)) cx = seg.x;
      }
      drawIssueRing({ x: cx, y: cy }, GRID.size * 0.45);
      return;
    }
    if (kind === 'object') {
      const p = parseObjectHex(marker.hex);
      if (!p) return;
      const world = objectCenterWorld({ hex: marker.hex, ox: marker.ox, oy: marker.oy });
      if (!world) return;
      drawIssueRing(world, GRID.size * 0.45);
      return;
    }
    if (kind === 'token') {
      const p = parseHex(marker.hex);
      if (!p) return;
      drawIssueRing(hexCenterWorld(p.col, p.row), GRID.size * 0.5);
      return;
    }
    if (kind === 'room') {
      if (!Array.isArray(marker.corners)) return;
      const room = { corners: marker.corners, thickness: marker.thickness || 0, wall: { kind: 'none' } };
      let box = null;
      try { box = roomToWallBox(room); } catch { box = null; }
      if (!box) return;
      const rect = roomFloorRectWorld(room, box);
      const cx = (rect.x1 + rect.x2) / 2;
      const cy = (rect.y1 + rect.y2) / 2;
      const radius = Math.max(GRID.size * 0.6, Math.min(Math.abs(rect.x2 - rect.x1), Math.abs(rect.y2 - rect.y1)) * 0.35);
      drawIssueRing({ x: cx, y: cy }, radius, { dash: [6, 4], lineWidth: 2.5 });
    }
  }

  function drawHexHighlight(col, row, opts = {}) {
    if (!Number.isFinite(col) || !Number.isFinite(row)) return;
    const center = worldToScreen(hexCenterWorld(col, row));
    const r = GRID.size;
    const h = (Math.sqrt(3) / 2) * r;
    const points = [
      { x: center.x + r, y: center.y },
      { x: center.x + r / 2, y: center.y + h },
      { x: center.x - r / 2, y: center.y + h },
      { x: center.x - r, y: center.y },
      { x: center.x - r / 2, y: center.y - h },
      { x: center.x + r / 2, y: center.y - h },
    ];
    ctx.save();
    ctx.globalAlpha = Number.isFinite(opts.alpha) ? opts.alpha : 0.5;
    ctx.strokeStyle = opts.strokeStyle || 'rgba(67,209,122,0.9)';
    ctx.fillStyle = opts.fillStyle || 'rgba(67,209,122,0.12)';
    ctx.lineWidth = Number.isFinite(opts.lineWidth) ? opts.lineWidth : 2.5;
    if (opts.dash) ctx.setLineDash(opts.dash);
    ctx.beginPath();
    ctx.moveTo(points[0].x, points[0].y);
    for (let i = 1; i < points.length; i++) ctx.lineTo(points[i].x, points[i].y);
    ctx.closePath();
    if (opts.fill !== false) ctx.fill();
    ctx.stroke();
    ctx.restore();
  }

  function drawEditorOverlays(wallSegs) {
    if (EDITOR.preview && EDITOR.preview.floorId === VIEW.floorId && (EDITOR.tool === 'door' || EDITOR.tool === 'window')) {
      drawOpeningOverlay(EDITOR.preview.opening, wallSegs, { dash: [6, 4] });
    }

    if (EDITOR.roomPreview && EDITOR.roomPreview.floorId === VIEW.floorId && EDITOR.tool === 'room') {
      drawRoomOverlay(EDITOR.roomPreview.room, { dash: [6, 4] });
    }
    if (EDITOR.tool === 'room' && EDITOR.roomStart && EDITOR.roomStart.floorId === VIEW.floorId) {
      drawHexHighlight(EDITOR.roomStart.col, EDITOR.roomStart.row, { fill: true, alpha: 0.55 });
    }

    const markers = Array.isArray(EDITOR.issueMarkers) ? EDITOR.issueMarkers : [];
    for (const m of markers) {
      if (!m || (m.floorId && String(m.floorId) !== String(VIEW.floorId))) continue;
      drawIssueMarker(m, wallSegs);
    }

    const openings = Array.isArray(EDITOR.lastOpenings) ? EDITOR.lastOpenings : [];
    if (EDITOR.selectedId && EDITOR.selectedFloorId === VIEW.floorId) {
      const sel = openings.find(o => o && o.id === EDITOR.selectedId);
      if (sel) drawOpeningOverlay(sel, wallSegs, { lineWidth: 4 });
    }
  }

  function roomById(rooms, id) {
    const target = String(id || '');
    if (!target) return null;
    return (Array.isArray(rooms) ? rooms : []).find(r => r && String(r.id) === target) || null;
  }

  function roomFloorKind(room) {
    return (room && room.floor && room.floor.kind) ? String(room.floor.kind) : 'wood';
  }


  function buildRoomMeta(rooms) {
    const meta = new Map();
    for (const r of (Array.isArray(rooms) ? rooms : [])) {
      if (!r || !r.id) continue;
      const box = roomToWallBox(r);
      const f = roomFloorRectWorld(r, box);
      meta.set(String(r.id), { room: r, floorRect: f });
    }
    // Keep a global copy for any code paths that expect `roomMetaAll` to exist.
    roomMetaAll = meta;
    return meta;
  }

  function roomContainsWorldPoint(roomRect, p) {
    if (!roomRect) return false;
    return (p.x >= roomRect.x1 && p.x <= roomRect.x2 && p.y >= roomRect.y1 && p.y <= roomRect.y2);
  }

  function pickRoomAtWorldPoint(roomMeta, p) {
    let bestId = null;
    let bestArea = Infinity;

    for (const [id, info] of roomMeta.entries()) {
      const r = info.floorRect;
      if (!roomContainsWorldPoint(r, p)) continue;
      const area = Math.abs((r.x2 - r.x1) * (r.y2 - r.y1));
      if (area < bestArea) { bestArea = area; bestId = id; }
    }

    return bestId;
  }

  function openingRoomIds(opening, roomMeta, wallSegs = null) {
    const orient = openingOrientation(opening);
    const p = parseOpeningHex(opening.hex);
    if (!p) return [];

    const hw = hexCenterWorld(p.col, p.row);

    // If we have wall segments, sample thickness from the nearest wall. Otherwise default.
    const seg = (wallSegs && Array.isArray(wallSegs))
      ? findNearestWallSegment(wallSegs, orient, hw)
      : null;

    let thickness = 28;
    if (seg && seg.thickness) thickness = seg.thickness;

    const cx = hw.x, cy = hw.y;
    const eps = Math.max(6, thickness * 0.6);
    const samples = (orient === 'h')
      ? [{ x: cx, y: cy - eps }, { x: cx, y: cy + eps }]
      : [{ x: cx - eps, y: cy }, { x: cx + eps, y: cy }];

    const ids = new Set();
    for (const s of samples) {
      const id = pickRoomAtWorldPoint(roomMeta, s);
      if (id) ids.add(id);
    }
    return [...ids];
  }

  let RENDER_FOG = null;
  // Cached per-redraw room metadata (Map roomId -> {room,floorRect}).
  // Some call-sites pass `roomMetaAll` by name; keep a global to avoid ReferenceErrors.
  var roomMetaAll = null;

  function openingPreferredRoomId(opening, roomMetaAll) {
    const parentId = opening && opening.parent ? String(opening.parent) : '';
    if (parentId) return parentId;

    const ids = openingRoomIds(opening, roomMetaAll);
    if (!ids.length) return '';

    if (RENDER_FOG && RENDER_FOG.enabled) {
      for (const id of ids) if (RENDER_FOG.visible && RENDER_FOG.visible.has(id)) return id;
      for (const id of ids) if (RENDER_FOG.explored && RENDER_FOG.explored.has(id)) return id;
    }
    return String(ids[0] || '');
  }

  function openingKnockoutFill(opening, rooms, roomMetaAll, fogEnabled, wantTextures) {
    const rid = openingPreferredRoomId(opening, roomMetaAll);
    const room = rid ? roomById(rooms, rid) : null;
    const fk = room ? roomFloorKind(room) : 'wood';

    if (!fogEnabled) return getFloorFillStyle(fk, wantTextures, ctx);

    if (RENDER_FOG && RENDER_FOG.enabled && rid && RENDER_FOG.visible && RENDER_FOG.visible.has(rid)) {
      return getFloorFillStyle(fk, wantTextures, ctx);
    }

    return floorBaseColor('fog');
  }

  function drawOpeningSeamFills(openings, rooms, roomMetaAll, wallSegs, fogEnabled) {
    const wantTextures = !!(elSpriteToggle && elSpriteToggle.checked);

    for (const o of (Array.isArray(openings) ? openings : [])) {
      const kind = String(o && o.kind ? o.kind : '').toLowerCase();
      const isDoor = isDoorKind(kind);
      if (kind !== 'threshold' && !isDoor && kind !== 'portal') continue;

      const orient = openingOrientation(o);
      const p = parseOpeningHex(o.hex);
      if (!p) continue;

      const hexWorld = hexCenterWorld(p.col, p.row);
      const seg = findNearestWallSegment(wallSegs, orient, hexWorld);

      // Snap onto the wall axis so seam fills always overlap the wall cutout.
      let cx = hexWorld.x;
      let cy = hexWorld.y;
      if (seg) {
        if (orient === 'h' && Number.isFinite(seg.y)) cy = seg.y;
        if (orient === 'v' && Number.isFinite(seg.x)) cx = seg.x;
      }

      const len = openingLengthWorld(o, rooms);
      const thickness = seg ? seg.thickness : 28;

      const centerS = worldToScreen({ x: cx, y: cy });
      const pad = openingPadAxes(o);

      // Axis-aligned screen-space rect so patterns stay aligned with the floor.
      const baseW = (orient === 'v') ? thickness : len;
      const baseH = (orient === 'v') ? len : thickness;
      const w = baseW + (pad.x || 0);
      const h = baseH + (pad.y || 0);

      ctx.save();
      ctx.fillStyle = openingKnockoutFill(o, rooms, roomMetaAll, fogEnabled, wantTextures);
      const rr = snappedRectFromCenter(centerS, w, h);
      ctx.fillRect(rr.x, rr.y, rr.w, rr.h);
      ctx.restore();
    }
  }

  // ===== Fog (room-based, per-floor) =====
  function normalizeFog(state, floorId) {
    const raw = (state && state.fog && typeof state.fog === 'object') ? state.fog : {};

    const enabled = !!raw.enabled;
    const autoCompute = raw.autoCompute !== false;
    const autoExplore = raw.autoExplore !== false;
    const maxDepth = clamp(Number.isFinite(Number(raw.maxDepth)) ? Number(raw.maxDepth) : 1, 0, 12);

    const unseenAlpha = clamp(Number.isFinite(Number(raw.unseenAlpha)) ? Number(raw.unseenAlpha) : 0.92, 0, 1);
    const exploredAlpha = clamp(Number.isFinite(Number(raw.exploredAlpha)) ? Number(raw.exploredAlpha) : 0.55, 0, 1);

    const perVis = (raw.visibleRoomIdsByFloor && typeof raw.visibleRoomIdsByFloor === 'object') ? raw.visibleRoomIdsByFloor : null;
    const perExp = (raw.exploredRoomIdsByFloor && typeof raw.exploredRoomIdsByFloor === 'object') ? raw.exploredRoomIdsByFloor : null;

    const getVis = () => {
      if (perVis) return Array.isArray(perVis[floorId]) ? perVis[floorId] : [];
      return Array.isArray(raw.visibleRoomIds) ? raw.visibleRoomIds : [];
    };

    const getExp = () => {
      if (perExp) return Array.isArray(perExp[floorId]) ? perExp[floorId] : [];
      return Array.isArray(raw.exploredRoomIds) ? raw.exploredRoomIds : [];
    };

    const setVis = (ids) => {
      if (perVis) perVis[floorId] = ids;
      else raw.visibleRoomIds = ids;
    };

    const setExp = (ids) => {
      if (perExp) perExp[floorId] = ids;
      else raw.exploredRoomIds = ids;
    };

    return {
      enabled,
      autoCompute,
      autoExplore,
      maxDepth,
      unseenAlpha,
      exploredAlpha,
      get visibleRoomIds() { return getVis(); },
      get exploredRoomIds() { return getExp(); },
      setVisibleRoomIds: setVis,
      setExploredRoomIds: setExp,
    };
  }

  function isPlayerToken(t) {
    return String(t && t.side ? t.side : '').toUpperCase() === 'PC';
  }

  function computeRenderFog(state, floorId, rooms, openings, tokens) {
    const fog = normalizeFog(state, floorId);
    if (!fog.enabled) return null;

    const roomMeta = buildRoomMeta(rooms);

    const explored = new Set((fog.exploredRoomIds || []).map(String));
    const visible = new Set((fog.visibleRoomIds || []).map(String));

    if (!fog.autoCompute) {
      return { enabled: true, explored, visible, maxDepth: fog.maxDepth, exploredAlpha: fog.exploredAlpha, unseenAlpha: fog.unseenAlpha };
    }

    const pcs = (Array.isArray(tokens) ? tokens : []).filter(isPlayerToken);
    const start = new Set();
    for (const t of pcs) {
      const hp = parseHex(t.hex);
      if (!hp) continue;
      const world = hexCenterWorld(hp.col, hp.row);
      const rid = pickRoomAtWorldPoint(roomMeta, world);
      if (rid) start.add(rid);
    }

    const adj = new Map();
    const addEdge = (a, b) => {
      if (!a || !b || a === b) return;
      if (!adj.has(a)) adj.set(a, new Set());
      if (!adj.has(b)) adj.set(b, new Set());
      adj.get(a).add(b);
      adj.get(b).add(a);
    };

    for (const o of (Array.isArray(openings) ? openings : [])) {
      const k = String(o && o.kind ? o.kind : 'door').toLowerCase();
      if (k === 'portal' || k === 'connector') continue;

      const openPct = clamp(Number(o && o.openPct != null ? o.openPct : 0), 0, 1);
      const isOpenForSight = (k === 'threshold') || (k === 'window') || (isDoorKind(k) && openPct >= 0.5);
      if (!isOpenForSight) continue;

      const ids = openingRoomIds(o, roomMeta);
      if (ids.length === 2) addEdge(ids[0], ids[1]);
    }

    const q = [];
    const dist = new Map();

    for (const rid of start) {
      q.push(rid);
      dist.set(rid, 0);
    }

    const vis = new Set();
    while (q.length) {
      const cur = q.shift();
      const d = dist.get(cur) || 0;
      vis.add(cur);
      if (d >= fog.maxDepth) continue;
      const ns = adj.get(cur);
      if (!ns) continue;
      for (const n of ns) {
        if (!dist.has(n)) {
          dist.set(n, d + 1);
          q.push(n);
        }
      }
    }

    if (fog.autoExplore) {
      for (const rid of vis) explored.add(rid);
      fog.setExploredRoomIds([...explored]);
    }

    fog.setVisibleRoomIds([...vis]);

    return { enabled: true, explored, visible: vis, maxDepth: fog.maxDepth, exploredAlpha: fog.exploredAlpha, unseenAlpha: fog.unseenAlpha };
  }

  function drawRememberedRoomOverlays(rooms) {
    if (!RENDER_FOG || !RENDER_FOG.enabled) return;

    ctx.save();
    ctx.globalAlpha = RENDER_FOG.exploredAlpha;
    ctx.fillStyle = COLORS.fogExplored;

    for (const r of (Array.isArray(rooms) ? rooms : [])) {
      if (!r || !r.id) continue;
      if (isFogFloorRoom(r)) continue;

      const id = String(r.id);
      if (!RENDER_FOG.explored.has(id)) continue;
      if (RENDER_FOG.visible.has(id)) continue;

      const box = roomToWallBox(r);
      const f = roomFloorRectWorld(r, box);
      const p1 = worldToScreen({ x: f.x1, y: f.y1 });
      const p2 = worldToScreen({ x: f.x2, y: f.y2 });
      const w = p2.x - p1.x;
      const h = p2.y - p1.y;
      if (w > 0 && h > 0) ctx.fillRect(p1.x, p1.y, w, h);
    }

    ctx.restore();
  }

  // ===== Objects / tokens orientation =====
  function degToRad(deg) { return (deg * Math.PI) / 180; }

  function objectRotationRad(o) {
    if (!o) return 0;
    const deg = Number(o.rotDeg);
    return Number.isFinite(deg) ? degToRad(deg) : 0;
  }

  function objectCenterWorld(o) {
    const p = parseObjectHex(o && o.hex);
    if (!p) return null;

    const base = hexCenterWorld(p.col, p.row);

    const ox = Number(o && o.ox);
    const oy = Number(o && o.oy);

    return {
      x: base.x + (Number.isFinite(ox) ? ox : 0) * GRID.size,
      y: base.y + (Number.isFinite(oy) ? oy : 0) * GRID.size,
    };
  }

  function objectCenterScreen(o) {
    const w = objectCenterWorld(o);
    if (!w) return null;
    return worldToScreen(w);
  }

  function objectSizePx(o) {
    const base = GRID.size * 1.15;
    return { w: base, h: base };
  }

  function objectVisible(o, roomMetaAll) {
    if (!RENDER_FOG || !RENDER_FOG.enabled) return true;

    const kind = String(o && o.kind ? o.kind : '').toLowerCase();

    const w = objectCenterWorld(o);
    if (!w) return true;

    const rid = pickRoomAtWorldPoint(roomMetaAll, w);
    if (!rid) return true;

    if (kind === 'hearth' || kind === 'cooking.hearth') return RENDER_FOG.explored.has(rid) || RENDER_FOG.visible.has(rid);

    return RENDER_FOG.visible.has(rid) || RENDER_FOG.explored.has(rid);
  }

  function roundRectPath(targetCtx, x, y, w, h, r) {
    const rr = Math.max(0, Math.min(r, Math.min(Math.abs(w), Math.abs(h)) / 2));
    targetCtx.beginPath();
    targetCtx.moveTo(x + rr, y);
    targetCtx.lineTo(x + w - rr, y);
    targetCtx.quadraticCurveTo(x + w, y, x + w, y + rr);
    targetCtx.lineTo(x + w, y + h - rr);
    targetCtx.quadraticCurveTo(x + w, y + h, x + w - rr, y + h);
    targetCtx.lineTo(x + rr, y + h);
    targetCtx.quadraticCurveTo(x, y + h, x, y + h - rr);
    targetCtx.lineTo(x, y + rr);
    targetCtx.quadraticCurveTo(x, y, x + rr, y);
    targetCtx.closePath();
  }

  function drawObject(o, roomMetaAll) {
    if (!o) return;
    if (!objectVisible(o, roomMetaAll)) return;

    const c = objectCenterScreen(o);
    if (!c) return;

    const { w, h } = objectSizePx(o);
    const rot = objectRotationRad(o);

    const kind = String(o.kind || 'object').toLowerCase();

    if (SPRITES_ENABLED) {
      const def = getSpriteDef(kind);
      if (def) {
        const img = loadSprite(def.file);

        let sx = 1, sy = 1;
        // Sprite-def defaults are always applied first.
        if (isFiniteNum(def.scale)) { sx *= Number(def.scale); sy *= Number(def.scale); }
        if (isFiniteNum(def.scaleX)) sx *= Number(def.scaleX);
        if (isFiniteNum(def.scaleY)) sy *= Number(def.scaleY);

        // Scaling rules:
        // - spriteScale => proportional (uniform) scaling
        // - spriteScaleX / spriteScaleY => absolute per-axis scaling (non-uniform), and ignores spriteScale
        const hasAxisScale = isFiniteNum(o.spriteScaleX) || isFiniteNum(o.spriteScaleY);

        if (!hasAxisScale && isFiniteNum(o.spriteScale)) {
          sx *= Number(o.spriteScale);
          sy *= Number(o.spriteScale);
        }

        if (hasAxisScale) {
          if (isFiniteNum(o.spriteScaleX)) sx *= Number(o.spriteScaleX);
          if (isFiniteNum(o.spriteScaleY)) sy *= Number(o.spriteScaleY);
          const ok = drawSpriteImage(img, {
            x: c.x,
            y: c.y,
            w: w * sx,
            h: h * sy,
            fit: 'stretch',
            rotRad: def.rotate === 'deg' ? rot : 0,
          });
          if (ok) return;
        } else {
          const ok = drawSpriteImage(img, {
            x: c.x,
            y: c.y,
            w: w * sx,
            h: h * sy,
            fit: 'contain',
            rotRad: def.rotate === 'deg' ? rot : 0,
          });
          if (ok) return;
        }
      }
    }

    ctx.save();
    ctx.translate(c.x, c.y);
    if (rot) ctx.rotate(rot);

    ctx.fillStyle = 'rgba(255,255,255,0.08)';
    ctx.strokeStyle = 'rgba(0,0,0,0.25)';
    ctx.lineWidth = 1;

    if (kind === 'stairs') {
      const rw = w * 2;
      const rh = h * 4;
      const topW = rw * 0.4;

      ctx.fillStyle = COLORS.stairsWood;
      ctx.beginPath();
      ctx.moveTo(-rw/2,  rh/2);
      ctx.lineTo( rw/2,  rh/2);
      ctx.lineTo( topW/2, -rh/2);
      ctx.lineTo(-topW/2, -rh/2);
      ctx.closePath();
      ctx.fill();

    } else if (kind === 'bath') {
      // Simple non-sprite fallback for bath.png (top-down oval tub)
      const rw = w * 2.05;
      const rh = h * 1.20;

      // Outer tub
      ctx.fillStyle = 'rgba(90, 58, 32, 0.85)';
      ctx.strokeStyle = 'rgba(0,0,0,0.28)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.ellipse(0, 0, rw / 2, rh / 2, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.stroke();

      // Inner basin (water)
      ctx.fillStyle = 'rgba(20, 28, 40, 0.55)';
      ctx.beginPath();
      ctx.ellipse(0, 0, (rw * 0.82) / 2, (rh * 0.70) / 2, 0, 0, Math.PI * 2);
      ctx.fill();

      // Water sheen
      ctx.fillStyle = 'rgba(210, 230, 255, 0.18)';
      ctx.beginPath();
      ctx.ellipse(0, -rh * 0.06, (rw * 0.30), (rh * 0.18), 0, 0, Math.PI * 2);
      ctx.fill();

    } else if (kind === 'chest') {
      const rw = w * 0.90, rh = h * 0.70;

      ctx.fillStyle = COLORS.chestWood;
      ctx.strokeStyle = 'rgba(0,0,0,0.22)';
      ctx.lineWidth = 1;

      roundRectPath(ctx, -rw/2, -rh/2, rw, rh, Math.min(10, rh/3));
      ctx.fill();
      ctx.stroke();

      ctx.strokeStyle = 'rgba(0,0,0,0.32)';
      ctx.lineWidth = 2;
      const slats = 4;
      for (let i = 1; i < slats; i++) {
        const x = -rw/2 + (rw * i)/slats;
        ctx.beginPath();
        ctx.moveTo(x, -rh/2);
        ctx.lineTo(x, rh/2);
        ctx.stroke();
      }

    } else if (kind === 'crate') {
      // 1-hex square crate
      const s = Math.min(w, h) * 0.82;
      ctx.fillStyle = COLORS.objectWood;
      ctx.strokeStyle = 'rgba(0,0,0,0.26)';
      ctx.lineWidth = 2;
      roundRectPath(ctx, -s/2, -s/2, s, s, Math.min(10, s/5));
      ctx.fill();
      ctx.stroke();

      // simple plank/X bracing
      ctx.strokeStyle = 'rgba(0,0,0,0.28)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(-s/2, -s/2);
      ctx.lineTo(s/2, s/2);
      ctx.moveTo(-s/2, s/2);
      ctx.lineTo(s/2, -s/2);
      ctx.stroke();

      ctx.globalAlpha = 0.75;
      ctx.beginPath();
      ctx.moveTo(-s/2, 0);
      ctx.lineTo(s/2, 0);
      ctx.moveTo(0, -s/2);
      ctx.lineTo(0, s/2);
      ctx.stroke();
      ctx.globalAlpha = 1;

    } else if (kind === 'keg' || kind === 'barrel') {
      // 1-hex circular prop; barrel gets a taller oval
      const isBarrel = (kind === 'barrel');
      const rx = Math.min(w, h) * 0.42;
      const ry = Math.min(w, h) * (isBarrel ? 0.52 : 0.42);

      // body
      ctx.fillStyle = COLORS.objectWood;
      ctx.strokeStyle = 'rgba(0,0,0,0.28)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.ellipse(0, 0, rx, ry, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.stroke();

      // hoops/bands
      ctx.strokeStyle = 'rgba(0,0,0,0.34)';
      ctx.lineWidth = 3;
      const bands = isBarrel ? [-0.55, 0, 0.55] : [-0.30, 0.30];
      for (const t of bands) {
        ctx.beginPath();
        ctx.ellipse(0, ry * t, rx * 0.98, ry * 0.18, 0, 0, Math.PI * 2);
        ctx.stroke();
      }

      // staves
      ctx.strokeStyle = 'rgba(0,0,0,0.18)';
      ctx.lineWidth = 1;
      const staves = isBarrel ? 7 : 6;
      for (let i = 0; i < staves; i++) {
        const x = -rx + (2 * rx) * (i / (staves - 1));
        ctx.beginPath();
        ctx.moveTo(x, -ry * 0.85);
        ctx.lineTo(x, ry * 0.85);
        ctx.stroke();
      }

    } else if (kind === 'hearth' || kind === 'cooking.hearth') {
      const rw = w * 1.15;
      const rh = h * 0.55;
      ctx.fillStyle = COLORS.hearth;
      ctx.fillRect(-rw/2, -rh/2, rw, rh);

    } else if (kind === 'bed' || kind === 'bed.double') {
      const isDouble = (kind === 'bed.double');
      const BOOST = 2.0;
      const widthMul = isDouble ? 1.3 : 0.75;

      const rw = w * 0.70 * BOOST * widthMul;
      const rh = h * 0.95 * BOOST;

      ctx.fillStyle = COLORS.bedFabric;
      roundRectPath(ctx, -rw/2, -rh/2, rw, rh, Math.min(18, rw/3));
      ctx.fill();
      ctx.stroke();

      ctx.fillStyle = COLORS.bedPillow;
      const pad = Math.max(6, Math.min(14, Math.min(rw, rh) * 0.08));
      const pillowH = Math.max(10, rh * 0.22);
      const innerW = Math.max(0, rw - pad * 2);

      const pillowRadius = Math.min(14, pillowH * 0.5);
      const drawPillow = (x, y, pw) => {
        roundRectPath(ctx, x, y, pw, pillowH, pillowRadius);
        ctx.fill();
      };

      if (!isDouble) {
        drawPillow(-rw/2 + pad, -rh/2 + pad, innerW);
      } else {
        const gap = Math.max(6, Math.min(14, innerW * 0.06));
        const pw = Math.max(0, (innerW - gap) / 2);
        const x0 = -rw/2 + pad;
        const y0 = -rh/2 + pad;
        drawPillow(x0, y0, pw);
        drawPillow(x0 + pw + gap, y0, pw);
      }

    } else if (kind === 'table.round') {
      const r = Math.min(w, h) * 0.64;
      ctx.fillStyle = COLORS.objectWood;
      ctx.beginPath();
      ctx.arc(0, 0, r, 0, Math.PI * 2);
      ctx.fill();
      ctx.stroke();

    } else if (kind === 'table.sqr' || kind === 'table.square') {
      // Square side-table (used as a non-sprite fallback)
      const s = Math.min(w, h) * 0.75;
      ctx.fillStyle = COLORS.objectWood;
      roundRectPath(ctx, -s/2, -s/2, s, s, Math.min(10, s/5));
      ctx.fill();
      ctx.stroke();

    } else if (kind.startsWith('table')) {
      const rw = w * 0.90, rh = h * 0.55;
      ctx.fillStyle = COLORS.objectWood;
      roundRectPath(ctx, -rw/2, -rh/2, rw, rh, Math.min(10, rh/3));
      ctx.fill();
      ctx.stroke();

    } else if (kind === 'chair') {
      const rw = Math.min(w, h) * 0.65;
      const r = rw / 2;
      const rectH = rw * 0.55;
      const yShift = -(rectH - r) / 2;

      ctx.fillStyle = COLORS.objectWood;
      ctx.beginPath();
      ctx.moveTo(-rw / 2, yShift);
      ctx.arc(0, yShift, r, Math.PI, 0, false);
      ctx.lineTo(rw / 2, yShift + rectH);
      ctx.lineTo(-rw / 2, yShift + rectH);
      ctx.closePath();
      ctx.fill();

    } else {
      const rw = w * 0.80, rh = h * 0.55;
      roundRectPath(ctx, -rw/2, -rh/2, rw, rh, 10);
      ctx.fill();
      ctx.stroke();
    }



    ctx.restore();
  }

  // ===== Tokens =====
  function tokenVisible(t, roomMetaAll) {
    if (!RENDER_FOG || !RENDER_FOG.enabled) return true;
    if (isPlayerToken(t)) return true;

    const p = parseHex(t && t.hex);
    if (!p) return true;
    const w = hexCenterWorld(p.col, p.row);
    const rid = pickRoomAtWorldPoint(roomMetaAll, w);
    if (!rid) return true;

    return RENDER_FOG.visible.has(rid);
  }

  function drawTokenLabel(t, x, y, isPC) {
    const label = (t && t.label) ? String(t.label) : (t && t.name ? String(t.name).slice(0, 2) : '?');

    ctx.fillStyle = isPC ? COLORS.tokenTextDark : COLORS.tokenTextLight;
    ctx.font = 'bold 14px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(label, x, y);
  }

  function getTokenSpriteRequest(t, isPC) {
    if (!t || typeof t !== 'object') {
      return { kind: isPC ? 'token.pc' : 'token.npc', file: '', scale: 1 };
    }

    const kind = String(
      t.sprite ??
      t.spriteKind ??
      t.sprite_key ??
      t.spriteId ??
      t.sprite_id ??
      ''
    ).trim();

    const file = String(t.spriteFile ?? t.sprite_file ?? '').trim();

    let scale = 1;
    const s = Number(t.spriteScale ?? t.sprite_scale);
    if (Number.isFinite(s) && s > 0) scale *= s;

    return {
      kind: kind || (isPC ? 'token.pc' : 'token.npc'),
      file,
      scale,
    };
  }

  function drawToken(t, roomMetaAll) {
    if (!t || !t.hex) return;
    if (!tokenVisible(t, roomMetaAll)) return;

    const p = parseHexId(t.hex);
    const c = worldToScreen(hexCenterWorld(p.col, p.row));

    const r = GRID.size * 0.40;
    const isPC = isPlayerToken(t);

    if (SPRITES_ENABLED) {
      const req = getTokenSpriteRequest(t, isPC);

      // Prefer explicit spriteFile, else sprite kind, else the default pc/npc tokens.
      let file = String(req.file || '').trim();
      if (!file) {
        const defK = getSpriteDef(req.kind);
        const defD = getSpriteDef(isPC ? 'token.pc' : 'token.npc');
        file = defK ? defK.file : (defD ? defD.file : '');
      }

      if (file) {
        const img = loadSprite(file);
        const s = (Number.isFinite(Number(req.scale)) && Number(req.scale) > 0) ? Number(req.scale) : 1;
        const ok = drawSpriteImage(img, {
          x: c.x,
          y: c.y,
          w: r * 2.2 * s,
          h: r * 2.2 * s,
          fit: 'contain',
          rotRad: 0,
        });
        if (ok) {
          drawTokenLabel(t, c.x, c.y, isPC);
          return;
        }
      }
    }

    ctx.save();
    ctx.fillStyle = isPC ? COLORS.tokenHero : COLORS.tokenEnemy;
    ctx.beginPath();
    ctx.arc(c.x, c.y, r, 0, Math.PI * 2);
    ctx.fill();

    ctx.strokeStyle = 'rgba(255,255,255,0.15)';
    ctx.lineWidth = 2;
    ctx.stroke();

    drawTokenLabel(t, c.x, c.y, isPC);

    ctx.restore();
  }

  // ===== Grid =====
  function drawHexOutline(center, size) {
    const pts = [];
    for (let i = 0; i < 6; i++) {
      const a = (Math.PI / 180) * (60 * i);
      pts.push({ x: center.x + size * Math.cos(a), y: center.y + size * Math.sin(a) });
    }

    ctx.beginPath();
    ctx.moveTo(pts[0].x, pts[0].y);
    for (let i = 1; i < pts.length; i++) ctx.lineTo(pts[i].x, pts[i].y);
    ctx.closePath();
    ctx.stroke();
  }

  function drawGrid() {
    const rect = canvas.getBoundingClientRect();
    const w = Math.max(1, rect.width);
    const h = Math.max(1, rect.height);

    const colsR = Math.ceil((w / 2) / colStep()) + 4;
    const rowsR = Math.ceil((h / 2) / rowStep()) + 4;

    const c0 = VIEW.camera.col;
    const r0 = VIEW.camera.row;

    ctx.save();
    ctx.strokeStyle = `rgba(255,255,255,${GRID.lineAlpha})`;
    ctx.lineWidth = GRID.lineWidth;

    for (let dc = -colsR; dc <= colsR; dc++) {
      for (let dr = -rowsR; dr <= rowsR; dr++) {
        const col = c0 + dc;
        const row = r0 + dr;
        const p = worldToScreen(hexCenterWorld(col, row));

        if (p.x < -100 || p.x > w + 100 || p.y < -100 || p.y > h + 100) continue;
        drawHexOutline(p, GRID.size);
      }
    }

    const bright = !!(elLabelBoldToggle && elLabelBoldToggle.checked);
    ctx.globalAlpha = bright ? 1 : GRID.labelAlpha;
    ctx.fillStyle = bright ? 'rgba(233,238,247,0.96)' : 'rgba(233,238,247,0.65)';
    ctx.font = bright
      ? '900 14px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial'
      : GRID.labelFont;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';

    if (bright) {
      ctx.lineWidth = 4;
      ctx.strokeStyle = 'rgba(0,0,0,0.70)';
      ctx.lineJoin = 'round';
    }

    for (let dc = -colsR; dc <= colsR; dc++) {
      for (let dr = -rowsR; dr <= rowsR; dr++) {
        const col = c0 + dc;
        const row = r0 + dr;
        const p = worldToScreen(hexCenterWorld(col, row));
        if (p.x < -100 || p.x > w + 100 || p.y < -100 || p.y > h + 100) continue;

        const label = hexId(col, row);
        const lx = p.x;
        const ly = p.y + 2;

        if (bright) ctx.strokeText(label, lx, ly);
        ctx.fillText(label, lx, ly);
      }
    }

    ctx.restore();
  }

  // ===== UI rendering =====
  function escapeHtml(s) {
    return String(s)
      .replaceAll('&', '&amp;')
      .replaceAll('<', '&lt;')
      .replaceAll('>', '&gt;')
      .replaceAll('"', '&quot;')
      .replaceAll("'", '&#39;');
  }

  function updateSidebar(state, floor, rooms, openings, objects, tokens) {
    const kvs = els.kvs;
    const turns = els.turns;
    if (!kvs || !turns) return;

    const meta = state && state.meta ? state.meta : {};
    const round = Number(meta.round != null ? meta.round : 1);

    const camHex = (state && state.view && state.view.camera_hex)
      ? String(state.view.camera_hex)
      : hexId(VIEW.camera.col, VIEW.camera.row);

    const fog = normalizeFog(state, VIEW.floorId);
    const fogLabel = fog.enabled
      ? ('ON (' + fog.visibleRoomIds.length + ' vis / ' + fog.exploredRoomIds.length + ' exp)')
      : 'off';

    const lines = [
      ['Version', VERSION],
      ['Battle', meta.battleId != null ? String(meta.battleId) : ''],
      ['Source', STATE_SOURCE],
      ['Floor', floor && floor.name ? String(floor.name) : String(VIEW.floorId || '')],
      ['Round', String(round)],
      ['Camera', camHex],
      ['Zoom', Math.round(ZOOM * 100) + '%'],
      ['Rooms', String(rooms.length)],
      ['Openings', String(openings.length)],
      ['Objects', String(objects.length)],
      ['Tokens', String(tokens.length)],
      ['Fog', fogLabel],
      ['Fog maxDepth', String(fog.maxDepth)],
    ];

    kvs.innerHTML = lines
      .map(([k, v]) => '<div>' + escapeHtml(k) + '</div><div style="color:var(--text); text-align:right;">' + escapeHtml(v) + '</div>')
      .join('');

    const sorted = [...tokens]
      .filter(t => t && t.id)
      .sort((a, b) => (Number(b.init) || 0) - (Number(a.init) || 0));

    const activeId = (state && state.turn && state.turn.activeTokenId) ? String(state.turn.activeTokenId) : '';

    turns.innerHTML = sorted.map(t => {
      const isActive = activeId && String(t.id) === activeId;
      const name = t.name ? String(t.name) : String(t.id);
      const right = (t.hp != null) ? ('HP ' + t.hp) : '';
      return '<div class="turnRow' + (isActive ? ' active' : '') + '">' + '<div>' + escapeHtml(name) + ' <span style="opacity:0.65">(' + escapeHtml(String(t.init ?? '')) + ')</span></div>'
        + '<div style="opacity:0.85">' + escapeHtml(right) + '</div>'
        + '</div>';
    }).join('');
  }

 function populateSceneSelect(state) {
  if (!elSceneSelect) return;

  const w = (WORLD_STATE && WORLD_STATE.records && WORLD_STATE.active) ? WORLD_STATE : null;

  // Legacy mode (no world wrapper): show a single disabled option.
  if (!w) {
    const title = (state && state.meta && state.meta.title) ? String(state.meta.title) : 'Scene';
    elSceneSelect.innerHTML = '<option value="Scene">' + escapeHtml(title) + '</option>';
    elSceneSelect.value = 'Scene';
    elSceneSelect.disabled = true;
    return;
  }

  const recordIds = Object.keys(w.records || {}).sort();
  const activeRid = String((w.active && w.active.recordId) ? w.active.recordId : '');

  // Build options once per render (cheap) — but avoid stomping the dropdown while it's focused.
  if (document.activeElement !== elSceneSelect) {
    elSceneSelect.innerHTML = recordIds.map(rid => {
      const rec = w.records[rid];
      const label = (rec && rec.meta && rec.meta.title) ? String(rec.meta.title) : rid;
      return '<option value="' + escapeHtml(rid) + '">' + escapeHtml(label) + '</option>';
    }).join('');

    if (recordIds.includes(activeRid)) elSceneSelect.value = activeRid;
    else if (recordIds.length) elSceneSelect.value = recordIds[0];
  }

  elSceneSelect.disabled = recordIds.length <= 1;
}

function populateFloorSelect(floors) {
  if (!elFloorSelect) return;

  const list = Array.isArray(floors) ? floors : [];
  const current = String(VIEW.floorId || '');

  // Build options
  elFloorSelect.innerHTML = list.map(f => {
    const id = String((f && f.id) != null ? f.id : '');
    const name = (f && f.name) ? String(f.name) : id;
    return '<option value="' + escapeHtml(id) + '">' + escapeHtml(name) + '</option>';
  }).join('');

  // Pick selected value: current (if present in list) else first item's id else ''
  const hasCurrent = current && list.some(f => String((f && f.id) != null ? f.id : '') === current);
  const fallback = list.length ? String((list[0] && list[0].id) != null ? list[0].id : '') : '';

  elFloorSelect.value = hasCurrent ? current : fallback;
}

  

  function populateCenterOn(state, tokensOnThisFloor) {
    if (!elCenterOn) return;

    const tokens = Array.isArray(tokensOnThisFloor) ? tokensOnThisFloor : tokensOnFloor(state, VIEW.floorId);
    const pcs = tokens.filter(isPlayerToken);
    const wanted = VIEW.followTokenId || '';

    const opts = ['<option value="">None</option>'];
    for (const t of pcs) {
      const label = t.name ? t.name : t.id;
      opts.push('<option value="' + escapeHtml(t.id) + '">' + escapeHtml(label) + '</option>');
    }

    elCenterOn.innerHTML = opts.join('');
    elCenterOn.value = pcs.some(t => t.id === wanted) ? wanted : '';
    if (elCenterOn.value === '') VIEW.followTokenId = null;
  }

  function buildRenderState(state) {
    const floors = getFloorsFromState(state);
    const activeFloorId = VIEW.floorId || pickActiveFloorId(state, floors);
    const floor = floorById(floors, activeFloorId) || floors[0];
    const floorId = floor ? String(floor.id) : String(activeFloorId || '');

    const tokensAll = getTokensArray(state);
    const rooms = Array.isArray(floor && floor.rooms) ? floor.rooms : [];
    const openings = Array.isArray(floor && floor.openings) ? floor.openings : [];
    const objects = Array.isArray(floor && floor.objects) ? floor.objects : [];
    const tokens = tokensAll.filter(t => {
      const fid = entityFloorId(t);
      return fid ? fid === floorId : true;
    });

    return { floors, floor, floorId, rooms, openings, objects, tokensAll, tokens };
  }

  // ===== Main render =====
  function clear() {
    // Use backing-store derived CSS size so we always cover the full drawable area.
    // This prevents 1px edge seams that can appear on the right/bottom when the
    // layout produces fractional CSS pixels.
    const d = Number(VIEW && VIEW.dpr) || 1;
    const w = Math.max(1, canvas.width / d);
    const h = Math.max(1, canvas.height / d);
    ctx.fillStyle = COLORS.bg;
    ctx.fillRect(0, 0, w, h);
  }

  function renderScene(roomsAll, roomsToDraw, openingsToDraw, objects, tokens, roomMetaAll, fogEnabled) {
    clear();

    drawFloorsLayered(roomsToDraw);

    const roomsForWalls = (RENDER_FOG && RENDER_FOG.enabled)
      ? roomsToDraw.filter(r => (isFogFloorRoom(r) ? roomHasWalls(r) : true))
      : roomsToDraw;

    const wallSegsRaw = buildWallSegments(roomsForWalls);
    const wallSegs = dedupeWallSegments(wallSegsRaw);

    // Floor-aware knockout fills for doors/thresholds (so wall openings match the underlying texture)
    drawOpeningSeamFills(openingsToDraw, roomsAll, roomMetaAll, wallSegs, fogEnabled);

    wallCtx.save();
    wallCtx.setTransform(1, 0, 0, 1, 0, 0);
    wallCtx.clearRect(0, 0, wallCanvas.width, wallCanvas.height);
    wallCtx.restore();

    wallCtx.setTransform(VIEW.dpr, 0, 0, VIEW.dpr, 0, 0);

    drawWallSegments(wallCtx, wallSegs);

    wallCtx.save();
    wallCtx.globalCompositeOperation = 'destination-out';
    wallCtx.fillStyle = '#000';

    for (const o of openingsToDraw) {
      const k = String(o && o.kind ? o.kind : 'door').toLowerCase();
      wallCtx.globalAlpha = (k === 'window') ? 0.25 : 1;
      cutOpeningHole(wallCtx, o, wallSegs, roomsAll);
    }

    wallCtx.restore();

    ctx.save();
    ctx.setTransform(1, 0, 0, 1, 0, 0);
    ctx.drawImage(wallCanvas, 0, 0);
    ctx.restore();

    ctx.setTransform(VIEW.dpr, 0, 0, VIEW.dpr, 0, 0);

    for (const o of openingsToDraw) drawOpeningMarker(o, wallSegs);
    drawEditorOverlays(wallSegs);

    for (const o of objects) drawObject(o, roomMetaAll);

    drawRememberedRoomOverlays(roomsAll);

    for (const t of tokens) drawToken(t, roomMetaAll);

    drawGrid();
  }

  function updateUI(state, render, rooms, openings, objects, tokens) {
    populateFloorSelect(render.floors);
    populateCenterOn(state, tokens);
    updateSidebar(state, render.floor, rooms, openings, objects, tokens);
    syncSourceSelect();
    syncBattleIdInput();
  }

  function redraw() {
    const state = getState();

    if (!canvas.width || !canvas.height || !wallCanvas.width || !wallCanvas.height) return;

    const render = buildRenderState(state);
    VIEW.floorId = render.floorId;

    populateSceneSelect(state);

    if (VIEW.followTokenId) {
      const t = render.tokensAll.find(x => x && x.id === VIEW.followTokenId);
      if (t && t.hex) {
        const fid = entityFloorId(t) || VIEW.floorId;
        if (fid && fid !== VIEW.floorId) {
          setActiveFloor(fid, { fromFollow: true });
          return;
        }

        const p = parseHexId(t.hex);
        VIEW.camera.col = p.col;
        VIEW.camera.row = p.row;
      } else {
        VIEW.followTokenId = null;
        if (elCenterOn) elCenterOn.value = '';
      }
    }

    const rooms = render.rooms;
    const openings = render.openings;
    const objects = render.objects;
    const tokens = render.tokens;
    EDITOR.lastOpenings = openings;

    const roomMetaAll = buildRoomMeta(rooms);

    const fogEnabled = !!elFogToggle.checked;
    const spritesEnabled = !!(elSpriteToggle && elSpriteToggle.checked);
    SPRITES_ENABLED = spritesEnabled;
    const labelsEnabled = !!(elLabelBoldToggle && elLabelBoldToggle.checked);
    if (state.fog && typeof state.fog === 'object') state.fog.enabled = fogEnabled;

    const renderSig = renderSignatureFor(state, {
      fogEnabled,
      spritesEnabled,
      labelsEnabled,
    });
    const editorSig = editorSignatureFor();
    const shouldRender = (renderSig !== LAST_RENDER_SIGNATURE) || (editorSig !== LAST_EDITOR_SIGNATURE);

    let roomsToDraw = rooms;
    let openingsToDraw = openings;

    if (shouldRender) {
      RENDER_FOG = computeRenderFog(state, VIEW.floorId, rooms, openings, tokens);

      if (!fogEnabled) {
        roomsToDraw = rooms.filter(r => !isFogFloorRoom(r));
      }

      if (RENDER_FOG && RENDER_FOG.enabled) {
        const baseFogRoomIds = new Set();
        for (const r of rooms) {
          if (isFogFloorRoom(r) && r && r.id) baseFogRoomIds.add(String(r.id));
        }

        const renderableRoomIds = new Set([...RENDER_FOG.explored]);
        roomsToDraw = rooms.filter(r => {
          const id = r && r.id ? String(r.id) : '';
          if (!id) return true;
          if (baseFogRoomIds.has(id)) return true;
          return renderableRoomIds.has(id);
        });

        openingsToDraw = openings.filter(o => {
          const ids = openingRoomIds(o, roomMetaAll);
          if (!ids.length) return false;
          const isRenderable = (id) => renderableRoomIds.has(id) || baseFogRoomIds.has(id);
          if (ids.length === 1) return isRenderable(ids[0]);
          return (isRenderable(ids[0]) || isRenderable(ids[1]));
        });
      }

      renderScene(rooms, roomsToDraw, openingsToDraw, objects, tokens, roomMetaAll, fogEnabled);
      LAST_RENDER_SIGNATURE = renderSig;
      LAST_EDITOR_SIGNATURE = editorSig;
    }
    updateUI(state, render, rooms, openings, objects, tokens);

    if (state.view && typeof state.view === 'object') state.view.camera_hex = hexId(VIEW.camera.col, VIEW.camera.row);
  }

  function safeRedraw() {
    try {
      if (elError) { elError.hidden = true; elError.textContent = ''; }
      redraw();
    } catch (e) {
      console.error('[Battlemat] redraw failed:', e);
      if (elError) {
        elError.hidden = false;
        elError.textContent = String(e && e.stack ? e.stack : e);
      }
    }
  }

  // ===== Controls =====
  function pan(dc, dr) {
    if (VIEW.followTokenId) {
      VIEW.followTokenId = null;
      if (elCenterOn) elCenterOn.value = '';
    }
    VIEW.camera.col += dc;
    VIEW.camera.row += dr;
    safeRedraw();
  }

  function setCameraToHex(hex, opts = {}) {
    const manual = (opts.manual !== false);
    const p = parseHexId(hex);
    VIEW.camera.col = p.col;
    VIEW.camera.row = p.row;

    if (manual) {
      VIEW.followTokenId = null;
      if (elCenterOn) elCenterOn.value = '';
    }

    safeRedraw();
  }

  function setActiveRecord(recordId) {
  const rid = String(recordId || '').trim();
  if (!rid) return;

  const w = ensureWorldWrapper();
  if (!w || !w.records || !w.records[rid]) return;

  const rec = w.records[rid];
  const floors = Array.isArray(rec && rec.floors) ? rec.floors : [];
  const defaultFloorId = (rec && rec.view && rec.view.floorId) ? String(rec.view.floorId) : (floors[0] ? String(floors[0].id) : null);
  const defaultCameraHex = (rec && rec.view && rec.view.camera_hex) ? String(rec.view.camera_hex) : null;

  if (!w.active || typeof w.active !== 'object') w.active = { recordId: rid };
  w.active.recordId = rid;
  if (defaultFloorId) w.active.floorId = defaultFloorId;
  if (defaultCameraHex) w.active.camera_hex = defaultCameraHex;

  // Manual scene switch stops following a token.
  VIEW.followTokenId = null;
  if (elCenterOn) elCenterOn.value = '';

  refreshFromWorld();
  safeRedraw();
}

function setActiveFloor(floorId, opts = {}) {
    const state = getState();
    const floors = getFloorsFromState(state);

    const target = String(floorId || '');
    const f = floorById(floors, target);
    if (!f) return;

    // Preserve the current camera unless explicitly told to re-center.
    const prevCam = { col: VIEW.camera.col, row: VIEW.camera.row };

    // If the user manually switched floors, stop following a token.
    if (!opts.fromFollow) {
      VIEW.followTokenId = null;
      if (elCenterOn) elCenterOn.value = '';
    }

    VIEW.floorId = target;

    if (state.view && typeof state.view === 'object') state.view.floorId = target;

    const keepCamera = !!opts.keepCamera;

    // Old behavior: when not keeping camera (and not switching due to follow), snap to a PC on that floor.
    if (!opts.fromFollow && !keepCamera) {
      const pcs = tokensOnFloor(state, target).filter(isPlayerToken);
      if (pcs.length && pcs[0].hex) {
        try {
          const p = parseHexId(pcs[0].hex);
          VIEW.camera.col = p.col;
          VIEW.camera.row = p.row;
        } catch {}
      }
    } else {
      // Default requested behavior: keep the same map spot centered.
      VIEW.camera.col = prevCam.col;
      VIEW.camera.row = prevCam.row;
    }

    safeRedraw();
  }

  function wireUI() {
    const req = (id) => {
      const el = els[id];
      if (!el) console.warn('[Battlemat] missing control #' + id);
      return el;
    };

    const btnLeft = req('btnLeft');
    const btnRight = req('btnRight');
    const btnUp = req('btnUp');
    const btnDown = req('btnDown');
    const btnZoomOut = req('btnZoomOut');
    const btnZoomIn = req('btnZoomIn');
    const btnRedraw = req('btnRedraw');
    const btnJump = req('btnJump');
    const toolSelect = req('toolSelect');
    const toolRoom = req('toolRoom');
    const toolDoor = req('toolDoor');
    const toolWindow = req('toolWindow');
    const toolDelete = req('toolDelete');
    const btnSaveDb = req('btnSaveDb');
    const btnUndo = req('btnUndo');
    const btnScanIssues = req('btnScanIssues');
    const btnCleanOrphans = req('btnCleanOrphans');
    const sourceSelect = req('sourceSelect');
    const battleIdInput = req('battleIdInput');
    const battleIdApply = req('battleIdApply');

    if (btnLeft) btnLeft.onclick = () => pan(-PAN_STEP, 0);
    if (btnRight) btnRight.onclick = () => pan(PAN_STEP, 0);
    if (btnUp) btnUp.onclick = () => pan(0, PAN_STEP);
    if (btnDown) btnDown.onclick = () => pan(0, -PAN_STEP);

    const ZOOM_STEP = 0.10;
    if (btnZoomOut) btnZoomOut.onclick = () => setZoom(ZOOM - ZOOM_STEP);
    if (btnZoomIn) btnZoomIn.onclick = () => setZoom(ZOOM + ZOOM_STEP);

    if (btnRedraw) btnRedraw.onclick = () => safeRedraw();

    if (btnJump) btnJump.onclick = () => {
      const v = String(elJumpHex.value || '').trim();
      if (!v) return;
      try { setCameraToHex(v, { manual: true }); }
      catch (e) { console.warn('[Battlemat] Bad jump hex:', v, e); }
    };

    if (toolSelect) toolSelect.onclick = () => setEditorTool('select');
    if (toolRoom) toolRoom.onclick = () => setEditorTool('room');
    if (toolDoor) toolDoor.onclick = () => setEditorTool('door');
    if (toolWindow) toolWindow.onclick = () => setEditorTool('window');
    if (toolDelete) toolDelete.onclick = () => setEditorTool('delete');
    if (btnSaveDb) btnSaveDb.onclick = () => saveStateToDatabase();
    if (btnUndo) btnUndo.onclick = () => applyUndoSnapshot();
    if (btnScanIssues) btnScanIssues.onclick = () => window.BattlematScanIssues();
    if (btnCleanOrphans) btnCleanOrphans.onclick = () => window.BattlematCleanOrphanOpenings();

    if (canvas) {
      canvas.addEventListener('mousemove', (ev) => {
        const tool = EDITOR.tool;
        if (tool !== 'door' && tool !== 'window' && tool !== 'room') {
          let changed = false;
          if (EDITOR.preview) { EDITOR.preview = null; changed = true; }
          if (EDITOR.roomPreview) { EDITOR.roomPreview = null; changed = true; }
          if (changed) safeRedraw();
          return;
        }

        const ctx = getEditorContext();
        if (!ctx) return;
        const world = eventToWorld(ev);

        if (tool === 'door' || tool === 'window') {
          const placement = computeDoorPlacement(world, ctx);
          if (!placement) {
            if (EDITOR.preview) {
              EDITOR.preview = null;
              safeRedraw();
            }
            return;
          }
          const prev = EDITOR.preview && EDITOR.preview.opening
            ? EDITOR.preview.opening
            : null;
          if (prev && prev.hex === placement.hex && prev.orientation === placement.orientation && EDITOR.preview.floorId === ctx.floorId) {
            return;
          }
          EDITOR.preview = {
            floorId: ctx.floorId,
            opening: { kind: (tool === 'window' ? 'window' : 'door.wood'), hex: placement.hex, orientation: placement.orientation }
          };
          safeRedraw();
          return;
        }

        if (EDITOR.preview) {
          EDITOR.preview = null;
        }

        if (EDITOR.roomStart && EDITOR.roomStart.floorId && EDITOR.roomStart.floorId !== ctx.floorId) {
          EDITOR.roomStart = null;
          EDITOR.roomPreview = null;
        }

        if (!EDITOR.roomStart) {
          if (EDITOR.roomPreview) {
            EDITOR.roomPreview = null;
            safeRedraw();
          }
          return;
        }

        const endHex = roomHexFromWorld(world);
        const roomPreview = endHex ? buildRoomPreview(ctx, EDITOR.roomStart, endHex) : null;
        if (!roomPreview) {
          if (EDITOR.roomPreview) {
            EDITOR.roomPreview = null;
            safeRedraw();
          }
          return;
        }

        const nextKey = Array.isArray(roomPreview.corners) ? roomPreview.corners.join('|') : '';
        const prevKey = (EDITOR.roomPreview && EDITOR.roomPreview.room && Array.isArray(EDITOR.roomPreview.room.corners))
          ? EDITOR.roomPreview.room.corners.join('|')
          : '';
        if (nextKey && nextKey === prevKey && EDITOR.roomPreview.floorId === ctx.floorId) return;

        EDITOR.roomPreview = { floorId: ctx.floorId, room: roomPreview };
        safeRedraw();
      }, { passive: true });

      canvas.addEventListener('mouseleave', () => {
        let changed = false;
        if (EDITOR.preview) { EDITOR.preview = null; changed = true; }
        if (EDITOR.roomPreview) { EDITOR.roomPreview = null; changed = true; }
        if (changed) safeRedraw();
      }, { passive: true });

      canvas.addEventListener('mousedown', (ev) => {
        if (ev.button !== 0) return;
        const ctx = getEditorContext();
        if (!ctx) return;
        const world = eventToWorld(ev);

        if (EDITOR.tool === 'door') {
          const hit = findOpeningNear(world, ctx);
          if (hit) {
            setSelectedOpening(hit, ctx.floorId);
            safeRedraw();
            return;
          }
          const placement = computeDoorPlacement(world, ctx);
          if (!placement) return;
          captureUndoSnapshot('add door');
          const opening = addDoorAtPlacement(ctx, placement);
          if (!opening) return;
          setSelectedOpening(opening, ctx.floorId);
          scheduleDatabaseSave();
          safeRedraw();
          return;
        }

        if (EDITOR.tool === 'window') {
          const hit = findOpeningNear(world, ctx);
          if (hit) {
            setSelectedOpening(hit, ctx.floorId);
            safeRedraw();
            return;
          }
          const placement = computeDoorPlacement(world, ctx);
          if (!placement) return;
          captureUndoSnapshot('add window');
          const opening = addWindowAtPlacement(ctx, placement);
          if (!opening) return;
          setSelectedOpening(opening, ctx.floorId);
          scheduleDatabaseSave();
          safeRedraw();
          return;
        }

        if (EDITOR.tool === 'room') {
          if (EDITOR.roomStart && EDITOR.roomStart.floorId && EDITOR.roomStart.floorId !== ctx.floorId) {
            EDITOR.roomStart = null;
            EDITOR.roomPreview = null;
          }

          const hex = roomHexFromWorld(world);
          if (!hex) return;

          if (!EDITOR.roomStart) {
            const start = { col: hex.col, row: hex.row, floorId: ctx.floorId };
            EDITOR.roomStart = start;
            const preview = buildRoomPreview(ctx, start, start);
            EDITOR.roomPreview = preview ? { floorId: ctx.floorId, room: preview } : null;
            safeRedraw();
            return;
          }

          const corners = roomCornersFromHexes(EDITOR.roomStart, hex);
          if (!corners) {
            EDITOR.roomPreview = null;
            safeRedraw();
            return;
          }

          captureUndoSnapshot('add room');
          const room = addRoomAtCorners(ctx, corners);
          EDITOR.roomStart = null;
          EDITOR.roomPreview = null;
          if (room) scheduleDatabaseSave();
          safeRedraw();
          return;
        }

        if (EDITOR.tool === 'delete') {
          const hitOpening = findOpeningNear(world, ctx);
          if (hitOpening && removeOpening(ctx, hitOpening)) {
            scheduleDatabaseSave();
          } else {
            const hitObject = findObjectNear(world, ctx);
            if (hitObject && removeObject(ctx, hitObject)) {
              scheduleDatabaseSave();
            } else {
              const hitToken = findTokenNear(world, ctx);
              if (hitToken && removeToken(ctx, hitToken)) {
                scheduleDatabaseSave();
              } else {
                const hitRoom = findRoomAtWorld(world, ctx);
                if (hitRoom && removeRoom(ctx, hitRoom)) {
                  scheduleDatabaseSave();
                } else {
                  setSelectedOpening(null);
                }
              }
            }
          }
          safeRedraw();
          return;
        }

        const hit = findOpeningNear(world, ctx);
        if (hit) setSelectedOpening(hit, ctx.floorId);
        else setSelectedOpening(null);
        safeRedraw();
      });
    }

    const applyBattleId = () => {
      if (!battleIdInput) return;
      const v = String(battleIdInput.value || '').trim();
      if (!v) return;
      const id = encodeURIComponent(v);
      if (elError) { elError.hidden = true; elError.textContent = ''; }
      stopStatePolling();
      try { history.replaceState(null, '', '/play/' + id); } catch {}
      STATE_URL = '/api/battles/' + id;
      STATE_SOURCE = 'database';
      startStatePolling();
      syncSourceSelect();
      syncBattleIdInput();
    };

    if (battleIdInput) {
      battleIdInput.value = resolveBattleIdHintFromUrl() || '';
      battleIdInput.onchange = () => {
        const v = String(battleIdInput.value || '').trim();
        if (!v) syncBattleIdInput();
      };
      battleIdInput.onkeydown = (ev) => {
        if (ev.key === 'Enter') {
          ev.preventDefault();
          applyBattleId();
        }
      };
    }

    if (battleIdApply) battleIdApply.onclick = () => applyBattleId();

    if (elFogToggle) elFogToggle.onchange = () => safeRedraw();
    if (elSpriteToggle) {
      elSpriteToggle.onchange = () => {
        SPRITES_ENABLED = !!elSpriteToggle.checked;
        safeRedraw();
      };
    }
    if (elLabelBoldToggle) elLabelBoldToggle.onchange = () => safeRedraw();

    if (elSceneSelect) {
      elSceneSelect.onchange = () => setActiveRecord(elSceneSelect.value);
    }

    if (elFloorSelect) {
      elFloorSelect.onchange = () => setActiveFloor(elFloorSelect.value, { fromFollow: false, keepCamera: true });
    }

    if (elCenterOn) {
      elCenterOn.onchange = () => {
        const id = String(elCenterOn.value || '');
        VIEW.followTokenId = id || null;
        safeRedraw();
      };
    }

    if (elSsSelect) {
      elSsSelect.onchange = () => setSupersample(elSsSelect.value);
    }

    if (sourceSelect) {
      sourceSelect.onchange = () => applySourceSelection(sourceSelect.value);
    }

    window.onkeydown = (ev) => {
      if (ev.target && (ev.target.tagName === 'INPUT' || ev.target.tagName === 'SELECT' || ev.target.isContentEditable)) return;
      if ((ev.ctrlKey || ev.metaKey) && (ev.key === 'z' || ev.key === 'Z')) {
        applyUndoSnapshot();
        ev.preventDefault();
        return;
      }
      if (handleEditorKey(ev)) {
        ev.preventDefault();
        return;
      }
      const k = ev.key;
      if (k === 'ArrowLeft' || k === 'a' || k === 'A') pan(-PAN_STEP, 0);
      else if (k === 'ArrowRight' || k === 'd' || k === 'D') pan(PAN_STEP, 0);
      else if (k === 'ArrowUp' || k === 'w' || k === 'W') pan(0, PAN_STEP);
      else if (k === 'ArrowDown' || k === 's' || k === 'S') pan(0, -PAN_STEP);
      else if (k === 'r' || k === 'R') safeRedraw();
      else if (k === '+' || k === '=' ) setZoom(ZOOM + 0.10);
      else if (k === '-' || k === '_' ) setZoom(ZOOM - 0.10);
    };
  }

  // ===== Resize =====
  function resize() {
    SUPERSAMPLE = readSupersample();
    ZOOM = readZoom();
    applyZoom();
    syncZoomUI();

    const wrap = els.canvasWrap;

    // Prefer integer CSS sizes (clientWidth/Height) to avoid fractional px gaps that
    // can show up as a 1px line along the right/bottom edge.
    let cssW = Math.max(1, wrap ? wrap.clientWidth : 1);
    let cssH = Math.max(1, wrap ? wrap.clientHeight : 1);

    // Fallback: if layout is mid-transition and client sizes are 0, use a rounded rect.
    if (wrap && (cssW <= 1 || cssH <= 1)) {
      const rect = wrap.getBoundingClientRect();
      cssW = Math.max(1, Math.round(rect.width));
      cssH = Math.max(1, Math.round(rect.height));
    }

    const dpr = Math.max(1, window.devicePixelRatio || 1);
    const scale = dpr * SUPERSAMPLE;

    VIEW.dpr = scale;
    VIEW.anchor.x = cssW / 2;
    VIEW.anchor.y = cssH / 2;

    if (elDpr) elDpr.textContent = dpr.toFixed(2);
    if (elSs) elSs.textContent = String(SUPERSAMPLE);

    canvas.width = Math.max(1, Math.floor(cssW * scale));
    canvas.height = Math.max(1, Math.floor(cssH * scale));

    wallCanvas.width = canvas.width;
    wallCanvas.height = canvas.height;

    ctx.setTransform(scale, 0, 0, scale, 0, 0);
    wallCtx.setTransform(scale, 0, 0, scale, 0, 0);

    ctx.imageSmoothingEnabled = true;
    try { ctx.imageSmoothingQuality = 'high'; } catch {}

    // Force a full render after any resize since the backing store changed.
    LAST_RENDER_SIGNATURE = '';
    safeRedraw();
  }

  // ===== Self-tests (tiny sanity checks) =====
  function runSelfTests() {
    const assert = (name, cond) => {
      if (!cond) throw new Error('SelfTest failed: ' + name);
    };

    // quarter-step openings (still supports .5)
    const oh = parseOpeningHexId('M12.5');
    assert('parseOpeningHexId col', oh.col === lettersToCol('M'));
    assert('parseOpeningHexId row (.5)', Math.abs(oh.row - 11.5) < 1e-9);

    const oq = parseOpeningHexId('M12.25');
    assert('parseOpeningHexId row (.25)', Math.abs(oq.row - 11.25) < 1e-9);

    // integer hex
    const hh = parseHexId('U16');
    assert('parseHexId row', hh.row === 15);

    // corner decimals
    const ch = parseCornerHexId('M21.5');
    assert('parseCornerHexId half row', Math.abs(ch.row - 20.5) < 1e-9);

    // texture alias
    const td = resolveTextureDef('floor', 'wood');
    assert('resolveTextureDef alias', !!td && td.file === 'wood_oak.png');

    // threshold auto-span sizing
    const testRooms = [{
      id: 'TestRoom',
      corners: ['A6', 'D6', 'D3', 'A3'],
      thickness: 20,
      floor: { kind: 'wood' },
      wall: { kind: 'brick' },
    }];
    const testRoom = testRooms[0];
    const box = roomToWallBox(testRoom);
    const fr = roomFloorRectWorld(testRoom, box);

    const thH = { kind: 'threshold', hex: 'B5', orientation: 'h', parent: 'TestRoom' };
    const thV = { kind: 'threshold', hex: 'D4', orientation: 'v', parent: 'TestRoom' };
    assert('openingLengthWorld threshold-h uses parent span', Math.abs(openingLengthWorld(thH, testRooms) - Math.abs(fr.x2 - fr.x1)) < 1e-6);
    assert('openingLengthWorld threshold-v uses parent span', Math.abs(openingLengthWorld(thV, testRooms) - Math.abs(fr.y2 - fr.y1)) < 1e-6);

    const noParent = { kind: 'threshold', hex: 'B5', orientation: 'h', span: 2 };
    assert('openingLengthWorld threshold fallback to span', Math.abs(openingLengthWorld(noParent, testRooms) - (GRID.size * 1.2 * 2)) < 1e-6);

    // opening padding (axis-specific)
    const pV = openingPadAxes({ kind: 'threshold', orientation: 'v' });
    const pH = openingPadAxes({ kind: 'threshold', orientation: 'h' });
    assert('openingPadAxes threshold v pads X only', pV.x === 4 && pV.y === 0);
    assert('openingPadAxes threshold h pads Y only', pH.x === 0 && pH.y === 4);
    const pD = openingPadAxes({ kind: 'door', orientation: 'v' });
    assert('openingPadAxes door pads both axes', pD.x === 4 && pD.y === 4);

    // door kind detection
    assert('isDoorKind door', isDoorKind('door') === true);
    assert('isDoorKind door_wood', isDoorKind('door_wood') === true);
    assert('isDoorKind door.wood', isDoorKind('door.wood') === true);
    assert('isDoorKind door.steel (prefix)', isDoorKind('door.steel') === true);
    assert('isDoorKind window false', isDoorKind('window') === false);

    // door sprite swing direction should match the line-based door math for both hinge sides.
    // Non-sprite math uses: y2 = swingSign * sin(ang) (independent of hinge side), while x flips for hingeRight.
    // For sprite math, we rotate about hinge. Base leaf direction is +X for hinge-left, -X for hinge-right.
    // Using rotAng = (hingeRight ? -1 : 1) * swingSign * ang preserves y2 sign across hinge sides.
    {
      const ang = 0.75; // arbitrary radians
      for (const hingeRight of [false, true]) {
        for (const swingSign of [-1, 1]) {
          const baseX = hingeRight ? -1 : 1;
          const rotAng = (hingeRight ? -1 : 1) * swingSign * ang;
          const ySprite = baseX * Math.sin(rotAng);
          const yLine = swingSign * Math.sin(ang);
          assert('door sprite swing matches line (hingeRight=' + hingeRight + ', swing=' + swingSign + ')', Math.abs(ySprite - yLine) < 1e-12);
        }
      }
    }

    // door sprite scaling (openings)
    const doorDef = getSpriteDef('door.wood');
    const sOpen = { kind: 'door.wood', spriteScale: 1.5, spriteScaleX: 2, spriteScaleY: 0.5 };
    let sx = 1, sy = 1;
    if (doorDef) {
      if (isFiniteNum(doorDef.scale)) { sx *= Number(doorDef.scale); sy *= Number(doorDef.scale); }
      if (isFiniteNum(doorDef.scaleX)) sx *= Number(doorDef.scaleX);
      if (isFiniteNum(doorDef.scaleY)) sy *= Number(doorDef.scaleY);
    }
    if (isFiniteNum(sOpen.spriteScale)) { sx *= Number(sOpen.spriteScale); sy *= Number(sOpen.spriteScale); }
    if (isFiniteNum(sOpen.spriteScaleX)) sx *= Number(sOpen.spriteScaleX);
    if (isFiniteNum(sOpen.spriteScaleY)) sy *= Number(sOpen.spriteScaleY);
    assert('door opening spriteScale combines', Math.abs(sx - (1.5 * 2)) < 1e-12 && Math.abs(sy - (1.5 * 0.5)) < 1e-12);

    // query parsing
    const qp = getQueryParams('?stateUrl=%2Fdata%2Fbattle.json&pollMs=1500');
    assert('getQueryParams stateUrl', qp.get('stateUrl') === '/data/battle.json');
    assert('getQueryParams pollMs', qp.get('pollMs') === '1500');

    // clamp zoom
    assert('clamp zoom low', clamp(0.1, 0.6, 2.25) === 0.6);
    assert('clamp zoom high', clamp(9, 0.6, 2.25) === 2.25);

    // zoom math
    const base = GRID.baseSize;
    const prev = ZOOM;
    ZOOM = 1.35;
    applyZoom();
    assert('applyZoom sets GRID.size', Math.abs(GRID.size - base * 1.35) < 1e-9);
    ZOOM = prev;
    applyZoom();

    // wall thickness scales with zoom
    const prevZ = ZOOM;
    ZOOM = 2;
    const wtRoom = { id: 'WallTest', corners: ['A6','D6','D3','A3'], thickness: 20, floor: { kind: 'wood' }, wall: { kind: 'brick' } };
    const wtBox = roomToWallBox(wtRoom);
    assert('roomToWallBox thickness scales with ZOOM', Math.abs(wtBox.thickness - 40) < 1e-9);
    ZOOM = prevZ;
    applyZoom();

    // snap to device pixels (prevents 1px seams at high zoom)
    const prevDpr = VIEW.dpr;
    VIEW.dpr = 2;
    assert('snapCss rounds to 1/dpr grid', Math.abs(snapCss(1.25) - 1.5) < 1e-12);
    const rr = snappedRectFromCenter({ x: 10.25, y: 9.75 }, 5.1, 3.1);
    // edges should land on 0.5 increments when dpr=2
    assert('snappedRectFromCenter x aligned', Math.abs((rr.x * 2) - Math.round(rr.x * 2)) < 1e-12);
    assert('snappedRectFromCenter y aligned', Math.abs((rr.y * 2) - Math.round(rr.y * 2)) < 1e-12);
    VIEW.dpr = prevDpr;

    // sqrt3 / rowStep math
    assert('sqrt3 constant', Math.abs(sqrt3 - Math.sqrt(3)) < 1e-12);
    const rs = rowStep();
    assert('rowStep uses sqrt3', Math.abs(rs - Math.sqrt(3) * GRID.size) < 1e-9);
  }

  // ===== Boot =====
  function init() {
    const state = getState();
    const floors = getFloorsFromState(state);
    VIEW.floorId = pickActiveFloorId(state, floors);

    // Persisted zoom + SS
    SUPERSAMPLE = readSupersample();
    ZOOM = readZoom();
    applyZoom();
    syncZoomUI();

    const camHex = state && state.view && state.view.camera_hex ? String(state.view.camera_hex) : null;
    if (camHex) {
      try {
        const p = parseHexId(camHex);
        VIEW.camera.col = p.col;
        VIEW.camera.row = p.row;
      } catch {}
    } else {
      const pc = (getTokensArray(state)).find(isPlayerToken);
      if (pc && pc.hex) {
        try {
          const p = parseHexId(pc.hex);
          VIEW.camera.col = p.col;
          VIEW.camera.row = p.row;
        } catch {}
      }
    }

    if (state.fog && typeof state.fog === 'object') elFogToggle.checked = !!state.fog.enabled;
    elSsSelect.value = String(readSupersample());

    // Run sanity checks only when explicitly requested.
    if (shouldRunSelfTests()) {
      try { runSelfTests(); }
      catch (e) {
        if (elError) {
          elError.hidden = false;
          elError.textContent = String(e && e.stack ? e.stack : e);
        }
        throw e;
      }
    }

    wireUI();
    syncEditorButtons();

    // Remote state (DB/API) hookup with DB default.
    const qp = getQueryParamsCached();
    const fromQuery = qp.get('stateUrl') || qp.get('state_url') || qp.get('state') || '';
    const fromWindow = (window && window.BATTLE_STATE_URL) ? String(window.BATTLE_STATE_URL) : '';
    const explicitUrl = (fromQuery || fromWindow || '').trim();

    if (explicitUrl) {
      const source = stateSourceFromUrl(explicitUrl);
      if (source === 'file') {
        applySourceSelection('file');
      } else {
        STATE_URL = explicitUrl;
        STATE_SOURCE = 'database';
        startStatePolling();
        syncSourceSelect();
        setToolStatus('DB: idle');
      }
    } else {
      const battleId = resolveBattleIdHintFromUrl();
      if (battleId) {
        STATE_URL = `/api/battles/${encodeURIComponent(battleId)}`;
        STATE_SOURCE = 'database';
        startStatePolling();
        syncSourceSelect();
        setToolStatus('DB: idle');
      } else {
        applySourceSelection('embedded');
      }
    }

    const ro = new ResizeObserver(() => resize());
    if (els.canvasWrap) ro.observe(els.canvasWrap);

    window.addEventListener('resize', resize, { passive: true });

    resize();
    requestAnimationFrame(() => {
      safeRedraw();
      requestAnimationFrame(safeRedraw);
    });
  }

  init();
  </script>
</body>
</html>

