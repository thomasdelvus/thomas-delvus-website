<!doctype html>
<!--
  Battlemat - V4
  Version 4.34

  Rewrite notes (v4.32):
  - Fixes a JS SyntaxError caused by an unescaped newline inside a string literal.
  - Adds a tiny console self-test for hex label parsing/roundtrips.

  Rewrite notes (v4.31):
  - Single, explicit geometry model for flat-top hexes (odd-q offset).
  - One authoritative wall pipeline: rooms -> wall centerlines -> wall rings (thickness-aware).
  - Horizontal walls use the "lower-half rule" by anchoring to a consistent parity phase,
    then shifting by 1/4 rowStep to land in the gap between alternating flat tops.
  - Doors/windows snap to the nearest precomputed wall segment (no parity hacks in openings).
  - Camera pan + jump-to-hex preserved.
-->
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Battlemat</title>
  <style>
    :root {
      --ui-bg: #f4f4f4;
      --panel-bg: #ffffff;
      --panel-border: #e5e5e5;
      --text: #111;
      --muted: #666;
      --btn: #ffffff;
      --btn-border: #d0d0d0;
    }

    html, body { height: 100%; }
    body {
      margin: 0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      background: var(--ui-bg);
      color: var(--text);
    }

    .app {
      height: 100%;
      display: grid;
      grid-template-columns: 1fr 500px;
      gap: 12px;
      padding: 12px;
      box-sizing: border-box;
    }

    .stage {
      background: var(--panel-bg);
      border: 1px solid var(--panel-border);
      border-radius: 12px;
      overflow: hidden;
      display: grid;
      grid-template-rows: 1fr auto;
      min-width: 0;
      min-height: 0;
    }

    .canvasWrap {
      position: relative;
      min-height: 0;
      min-width: 0;
    }

    canvas {
      display: block;
      width: 100%;
      height: 100%;
      background: #fff;
    }

    .controls {
      border-top: 1px solid var(--panel-border);
      padding: 10px;
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
    }

    .controls .spacer { flex: 1; }

    button {
      background: var(--btn);
      border: 1px solid var(--btn-border);
      border-radius: 10px;
      padding: 8px 10px;
      cursor: pointer;
      user-select: none;
    }
    button:active { transform: translateY(1px); }

    input, select {
      border: 1px solid var(--btn-border);
      border-radius: 10px;
      padding: 8px 10px;
      outline: none;
    }

    .sidebar {
      background: var(--panel-bg);
      border: 1px solid var(--panel-border);
      border-radius: 12px;
      overflow: hidden;
      display: grid;
      grid-template-rows: auto 1fr;
    }

    .sidebarHeader {
      padding: 12px;
      border-bottom: 1px solid var(--panel-border);
      display: flex;
      align-items: center;
      justify-content: space-between;
    }

    .pill {
      font-size: 12px;
      color: var(--muted);
      border: 1px solid var(--panel-border);
      background: #fafafa;
      padding: 4px 8px;
      border-radius: 999px;
    }

    .sidebarBody {
      padding: 12px;
      overflow: auto;
    }

    .kvs {
      display: grid;
      grid-template-columns: 1fr auto;
      gap: 6px 10px;
      font-size: 13px;
      color: var(--muted);
    }

    .legend {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      align-items: center;
      font-size: 12px;
      color: var(--muted);
    }
    .sw {
      width: 14px; height: 14px;
      border-radius: 4px;
      border: 1px solid rgba(0,0,0,0.15);
      display: inline-block;
      vertical-align: middle;
      margin-right: 6px;
    }
  </style>
</head>
<body>
  <div class="app">
    <div class="stage">
      <div class="canvasWrap">
        <canvas id="canvas"></canvas>
      </div>
      <div class="controls">
        <button id="btnLeft">←</button>
        <button id="btnUp">↑</button>
        <button id="btnDown">↓</button>
        <button id="btnRight">→</button>

        <span class="spacer"></span>

        <label class="legend" style="margin-right: 8px;">
          <span><span class="sw" style="background:#b67a2c"></span>Door</span>
          <span><span class="sw" style="background:#bfe2ff"></span>Window</span>
          <span><span class="sw" style="background:#666"></span>Wall</span>
        </label>

        <select id="floorKind">
          <option value="wood">Floor: Wood</option>
          <option value="stone">Floor: Stone</option>
          <option value="none">Floor: None</option>
        </select>

        <input id="jumpHex" placeholder="Jump to (e.g., H6)" style="width: 140px;" />
        <button id="btnJump">Jump</button>
        <button id="btnRedraw">Redraw</button>
      </div>
    </div>

    <div class="sidebar">
      <div class="sidebarHeader">
        <div style="font-weight: 600;">Status</div>
        <div class="pill" id="versionLine">v4.34</div>
      </div>
      <div class="sidebarBody">
        <div class="kvs" id="kvs"></div>
        <hr style="border: none; border-top: 1px solid var(--panel-border); margin: 12px 0;" />
        <div style="font-size: 12px; font-weight: 600; margin-bottom: 6px;">Debug: Room corner coords</div>
        <div id="debugRooms" style="font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace; font-size: 11px; color: var(--muted); white-space: pre; line-height: 1.35;"></div>
        <hr style="border: none; border-top: 1px solid var(--panel-border); margin: 12px 0;" />
        <div style="font-size: 12px; color: var(--muted); line-height: 1.35;">
          Geometry rewrite: rooms → wall centerlines → thickness-aware wall rings.
        </div>
      </div>
    </div>
  </div>

<script>
(() => {
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');

  // Flat-top hex geometry: size is center-to-vertex.
  const GRID = {
    size: 42,
    lineWidth: 2,
    lineAlpha: 0.18,
    labelAlpha: 0.65,
    labelFont: 'bold 12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial',
  };

  const COLORS = {
    wall: '#666',
    door: '#b67a2c',
    window: '#bfe2ff',
    floorStone: 'rgba(214, 195, 140, 0.78)',
    floorWood: 'rgba(193, 146, 86, 0.78)',
    tokenHero: '#4aa3ff',
    tokenEnemy: '#111',
    tokenTextDark: 'rgba(0,0,0,0.72)',
    tokenTextLight: 'rgba(255,255,255,0.88)',
  };

  const VIEW = {
    // Camera is in hex coords (col,row), row 0 is "row 1" at the bottom.
    camera: { col: 6, row: 6 },
    anchor: { x: 0, y: 0 },
    dx: 0,
    dy: 0,
  };

  const PAN_STEP = 2;

  const DEFAULT_STATE = {
    meta: { title: 'Cross Keys Inn — Upper Floor', battleId: 'local', round: 1 },
    view: { camera_hex: 'K6' },

    rooms: [
      {
        id: 'CrossKeysUpperFloor',
        corners: ['B11','Z11','Z2','B2'],
        thickness: 20,
        color: '#555',
        floor: { kind: 'wood' },
        wall: { kind: 'brick' },
      },
      {
        id: 'Bedroom2',
        corners: ['B8','F8','F5','B5'],
        thickness: 20,
        color: '#555',
        floor: { kind: 'wood' },
        wall: { kind: 'brick' },
      },
      {
        id: 'Bedroom3',
        corners: ['B5','F5','F2','B2'],
        thickness: 20,
        color: '#555',
        floor: { kind: 'wood' },
        wall: { kind: 'brick' },
      },
      {
        id: 'Bedroom4',
        corners: ['H5','N5','N2','H2'],
        thickness: 20,
        color: '#555',
        floor: { kind: 'wood' },
        wall: { kind: 'brick' },
      },
      {
        id: 'Bedroom5',
        corners: ['H11','N11','N7','H7'],
        thickness: 20,
        color: '#555',
        floor: { kind: 'wood' },
        wall: { kind: 'brick' },
      },
      {
        id: 'Bedroom6',
        corners: ['N9','T9','T7','N7'],
        thickness: 20,
        color: '#555',
        floor: { kind: 'wood' },
        wall: { kind: 'brick' },
      },
      {
        id: 'Bedroom7',
        corners: ['N5','T5','T2','N2'],
        thickness: 20,
        color: '#555',
        floor: { kind: 'wood' },
        wall: { kind: 'brick' },
      },
      {
        id: 'Bedroom8',
        corners: ['V5','Z5','Z2','V2'],
        thickness: 20,
        color: '#555',
        floor: { kind: 'wood' },
        wall: { kind: 'brick' },
      },
      {
        id: 'Bedroom9',
        corners: ['V8','Z8','Z5','V5'],
        thickness: 20,
        color: '#555',
        floor: { kind: 'wood' },
        wall: { kind: 'brick' },
      },
      {
        id: 'Bedroom10',
        corners: ['V11','Z11','Z8','V8'],
        thickness: 20,
        color: '#555',
        floor: { kind: 'wood' },
        wall: { kind: 'brick' },
      },
      {
        id: 'Bedroom1',
        corners: ['B11','F11','F8','B8'],
        thickness: 20,
        color: '#555',
        floor: { kind: 'wood' },
        wall: { kind: 'brick' },
      },
      
    ],

    // Converted: at -> hex, facing -> orientation (E/W => v, N/S/D => h)
    openings: [
      { id: 'door_room1', kind: 'door', hex: 'F9', orientation: 'v', widthPx: 70 },
      { id: 'door_room2', kind: 'door', hex: 'F6', orientation: 'v', widthPx: 70 },
      { id: 'door_room3', kind: 'door', hex: 'F3', orientation: 'v', widthPx: 70 },
      { id: 'door_room4', kind: 'door', hex: 'J5', orientation: 'h', widthPx: 70 },
      { id: 'door_room5', kind: 'door', hex: 'K6', orientation: 'h', widthPx: 70 },
      { id: 'door_room6', kind: 'door', hex: 'Q6', orientation: 'h', widthPx: 70 },
      { id: 'door_room7', kind: 'door', hex: 'S4', orientation: 'h', widthPx: 70 },
      { id: 'door_room8', kind: 'door', hex: 'V3', orientation: 'v', widthPx: 70 },
      { id: 'door_room9', kind: 'door', hex: 'V6', orientation: 'v', widthPx: 70 },
      { id: 'door_room10', kind: 'door', hex: 'V10', orientation: 'v', widthPx: 70 },

      { id: 'west_window1', kind: 'window', hex: 'B10', orientation: 'v', widthPx: 70 },
      { id: 'west_window2', kind: 'window', hex: 'B9', orientation: 'v', widthPx: 70 },
      { id: 'west_window3', kind: 'window', hex: 'B7', orientation: 'v', widthPx: 70 },
      { id: 'west_window4', kind: 'window', hex: 'B6', orientation: 'v', widthPx: 70 },
      { id: 'west_window5', kind: 'window', hex: 'B4', orientation: 'v', widthPx: 70 },
      { id: 'west_window6', kind: 'window', hex: 'B3', orientation: 'v', widthPx: 70 },

      { id: 'south_window1', kind: 'window', hex: 'C1', orientation: 'h', widthPx: 70 },
      { id: 'south_window2', kind: 'window', hex: 'D2', orientation: 'h', widthPx: 70 },
      { id: 'south_window3', kind: 'window', hex: 'G1', orientation: 'h', widthPx: 70 },
      { id: 'south_window4', kind: 'window', hex: 'J2', orientation: 'h', widthPx: 70 },
      { id: 'south_window5', kind: 'window', hex: 'K1', orientation: 'h', widthPx: 70 },
      { id: 'south_window6', kind: 'window', hex: 'Q1', orientation: 'h', widthPx: 70 },
      { id: 'south_window7', kind: 'window', hex: 'R2', orientation: 'h', widthPx: 70 },
      { id: 'south_window8', kind: 'window', hex: 'U1', orientation: 'h', widthPx: 70 },
      { id: 'south_window9', kind: 'window', hex: 'X2', orientation: 'h', widthPx: 70 },
    ],

    // Converted: actors[] -> tokens[] (at -> hex). Kept init/hp for later UI.
    tokens: [
      { id: 'lich', name: 'Lich', side: 'ENEMY', hex: 'K9', label: 'L', init: 15, hp: 135 },
      { id: 'w1', name: 'Wraith 1', side: 'ENEMY', hex: 'J6', label: 'W1', init: 12, hp: 67 },
      { id: 'w2', name: 'Wraith 2', side: 'ENEMY', hex: 'G8', label: 'W2', init: 11, hp: 67 },
      { id: 'w3', name: 'Wraith 3', side: 'ENEMY', hex: 'D7', label: 'W3', init: 10, hp: 67 },
      { id: 'a', name: 'Aelar', side: 'PC', hex: 'J3', label: 'A', init: 14, hp: 42 },
      { id: 'b', name: 'Brunna', side: 'PC', hex: 'K3', label: 'B', init: 13, hp: 55 },
      { id: 'c', name: 'Caelin', side: 'PC', hex: 'L4', label: 'C', init: 12, hp: 38 },
    ],
  };

  const getState = () => (window.BATTLE_STATE ?? DEFAULT_STATE);

  // ===== Hex helpers =====
  function colToLetters(col) {
    let n = col + 1;
    let s = '';
    while (n > 0) {
      const r = (n - 1) % 26;
      s = String.fromCharCode(65 + r) + s;
      n = Math.floor((n - 1) / 26);
    }
    return s;
  }

  function lettersToCol(letters) {
    const u = String(letters).toUpperCase();
    let n = 0;
    for (let i = 0; i < u.length; i++) {
      const c = u.charCodeAt(i);
      if (c < 65 || c > 90) throw new Error('Bad column letters');
      n = n * 26 + (c - 64);
    }
    return n - 1;
  }

  function parseHexId(hex) {
    const m = String(hex).trim().toUpperCase().match(/^([A-Z]+)([0-9]+)$/);
    if (!m) throw new Error('Bad hex: ' + hex);
    return { col: lettersToCol(m[1]), row: parseInt(m[2], 10) - 1 };
  }

  function hexId(col, row) {
    return colToLetters(col) + String(row + 1);
  }

  // ===== Geometry (world coords) =====
  const sqrt3 = Math.sqrt(3);
  function colStep() { return 1.5 * GRID.size; }
  function rowStep() { return sqrt3 * GRID.size; }

  // Row 0 is bottom row ("1"), row increases upward.
  function hexCenterWorld(col, row) {
    const x = col * colStep();
    const y = -(row * rowStep() + (col & 1) * (rowStep() / 2));
    return { x, y };
  }

  function snappedCenterY(row, phase) {
    const p = phase ? 1 : 0;
    return -(row * rowStep() + p * (rowStep() / 2));
  }

  // Horizontal walls baseline (test): use the *upper-phase* gap.
  // Anchor to even-column phase (phase 0) and shift DOWN by 1/4 rowStep to hit the mid-gap.
  function horizontalGapY_forTopOfRow(row) {
    const half = rowStep() / 2;
    const quarter = rowStep() / 4;
    return (snappedCenterY(row, 0) - half) + quarter;
  }

  function horizontalGapY_forBottomOfRow(row) {
    const half = rowStep() / 2;
    const quarter = rowStep() / 4;
    return (snappedCenterY(row, 0) + half) + quarter;
  }

  // ===== Camera transform =====
  function cameraWorld() {
    return hexCenterWorld(VIEW.camera.col, VIEW.camera.row);
  }

  function worldToScreen(p) {
    const cam = cameraWorld();
    return { x: VIEW.anchor.x + (p.x - cam.x) + VIEW.dx, y: VIEW.anchor.y + (p.y - cam.y) + VIEW.dy };
  }

  function screenToWorld(p) {
    const cam = cameraWorld();
    return { x: (p.x - VIEW.anchor.x) + cam.x - VIEW.dx, y: (p.y - VIEW.anchor.y) + cam.y - VIEW.dy };
  }

  // ===== Grid drawing =====
  function hexCornersWorld(center) {
    const s = GRID.size;
    return [
      { x: center.x + s,   y: center.y },
      { x: center.x + s/2, y: center.y + (sqrt3*s)/2 },
      { x: center.x - s/2, y: center.y + (sqrt3*s)/2 },
      { x: center.x - s,   y: center.y },
      { x: center.x - s/2, y: center.y - (sqrt3*s)/2 },
      { x: center.x + s/2, y: center.y - (sqrt3*s)/2 },
    ];
  }

  function drawHexOutline(col, row) {
    const pts = hexCornersWorld(hexCenterWorld(col, row)).map(worldToScreen);
    ctx.beginPath();
    ctx.moveTo(pts[0].x, pts[0].y);
    for (let i = 1; i < pts.length; i++) ctx.lineTo(pts[i].x, pts[i].y);
    ctx.closePath();
    ctx.stroke();
  }

  function drawHexLabel(col, row) {
    const c = worldToScreen(hexCenterWorld(col, row));
    const text = hexId(col, row);

    // Outline helps labels stay readable over floors/walls.
    ctx.save();
    ctx.lineWidth = 3;
    ctx.strokeStyle = 'rgba(255,255,255,0.75)';
    ctx.strokeText(text, c.x, c.y);
    ctx.fillText(text, c.x, c.y);
    ctx.restore();
  }

  // ===== Rooms =====
  function cornersToBounds(corners) {
    const pts = corners.map(parseHexId);
    const cols = pts.map(p => p.col);
    const rows = pts.map(p => p.row);
    return { minCol: Math.min.apply(null, cols), maxCol: Math.max.apply(null, cols), minRow: Math.min.apply(null, rows), maxRow: Math.max.apply(null, rows) };
  }

  function roomToWallBox(room) {
    const thickness = Math.max(1, Number(room.thickness ?? 30));

    if (!Array.isArray(room.corners) || room.corners.length < 4) {
      throw new Error('Room missing 4 corners');
    }

    // Corner order (by convention in our scenes):
    // [top-left, top-right, bottom-right, bottom-left]
    // IMPORTANT: We anchor horizontal/vertical wall *centerlines* to the declared corner hex CENTERS.
    // That means a room with corners [..., 'B8', ...] will have its south wall centerline at the
    // world-space Y of hex B8 (not "one row lower" via gap math).
    const p0 = parseHexId(room.corners[0]);
    const p1 = parseHexId(room.corners[1]);
    const p2 = parseHexId(room.corners[2]);
    const p3 = parseHexId(room.corners[3]);

    const c0 = hexCenterWorld(p0.col, p0.row);
    const c1 = hexCenterWorld(p1.col, p1.row);
    const c2 = hexCenterWorld(p2.col, p2.row);
    const c3 = hexCenterWorld(p3.col, p3.row);

    // Robust averaging keeps things stable even if a user accidentally mixes parities.
    const xL = (c0.x + c3.x) / 2;
    const xR = (c1.x + c2.x) / 2;
    const yTop = (c0.y + c1.y) / 2;
    const yBot = (c2.y + c3.y) / 2;

    // Keep bounds around for debug/inspection.
    const b = cornersToBounds(room.corners);

    const halfT = thickness / 2;
    const outer = { x1: xL - halfT, x2: xR + halfT, y1: yTop - halfT, y2: yBot + halfT, thickness: thickness };
    const inner = { x1: outer.x1 + thickness, x2: outer.x2 - thickness, y1: outer.y1 + thickness, y2: outer.y2 - thickness };

    return { bounds: b, thickness: thickness, outer: outer, inner: inner, xL: xL, xR: xR, yTop: yTop, yBot: yBot };
  }

  function buildWallSegments(rooms) {
    const segs = [];
    for (const r of rooms) {
      const box = roomToWallBox(r);
      const t = box.thickness;
      segs.push({ orientation: 'h', y: box.yTop, x1: box.xL, x2: box.xR, thickness: t });
      segs.push({ orientation: 'h', y: box.yBot, x1: box.xL, x2: box.xR, thickness: t });
      segs.push({ orientation: 'v', x: box.xL, y1: box.yTop, y2: box.yBot, thickness: t });
      segs.push({ orientation: 'v', x: box.xR, y1: box.yTop, y2: box.yBot, thickness: t });
    }
    return segs;
  }

  function fillBrickRectScreen(rect, color) {
    const brickW = 18;
    const brickH = 10;
    const mortar = 2;

    ctx.fillStyle = color;
    ctx.fillRect(rect.x, rect.y, rect.w, rect.h);

    ctx.fillStyle = 'rgba(0,0,0,0.08)';
    for (let y = rect.y; y < rect.y + rect.h; y += brickH) ctx.fillRect(rect.x, y, rect.w, mortar);

    for (let row = 0, y = rect.y; y < rect.y + rect.h; row++, y += brickH) {
      const offset = (row % 2) ? (brickW / 2) : 0;
      for (let x = rect.x - offset; x < rect.x + rect.w; x += brickW) ctx.fillRect(x, y, mortar, brickH);
    }
  }

  function drawRoom(room) {
    const box = roomToWallBox(room);
    const wallColor = room.color ?? COLORS.wall;

    const o1 = worldToScreen({ x: box.outer.x1, y: box.outer.y1 });
    const o2 = worldToScreen({ x: box.outer.x2, y: box.outer.y2 });
    const i1 = worldToScreen({ x: box.inner.x1, y: box.inner.y1 });
    const i2 = worldToScreen({ x: box.inner.x2, y: box.inner.y2 });

    const t = box.thickness;

    // Wall ring
    fillBrickRectScreen({ x: o1.x, y: o1.y, w: o2.x - o1.x, h: t }, wallColor);
    fillBrickRectScreen({ x: o1.x, y: o2.y - t, w: o2.x - o1.x, h: t }, wallColor);
    fillBrickRectScreen({ x: o1.x, y: o1.y + t, w: t, h: (o2.y - o1.y) - 2*t }, wallColor);
    fillBrickRectScreen({ x: o2.x - t, y: o1.y + t, w: t, h: (o2.y - o1.y) - 2*t }, wallColor);

    // Floor
    const floorKind = room.floor?.kind ?? 'stone';
    if (floorKind !== 'none') {
      ctx.fillStyle = (floorKind === 'stone') ? COLORS.floorStone
        : (floorKind === 'wood') ? COLORS.floorWood
        : 'rgba(255,255,255,0)';
      ctx.fillRect(i1.x, i1.y, i2.x - i1.x, i2.y - i1.y);
    }
  }

  // ===== Openings =====
  function openingOrientation(o) {
    if (o.orientation === 'h' || o.orientation === 'v') return o.orientation;
    const rot = Number(o.rot ?? 0) % 180;
    return (rot === 90) ? 'h' : 'v';
  }

  function findNearestWallSegment(segs, orient, worldPoint) {
    let best = null;
    let bestD = Infinity;

    for (const s of segs) {
      if (s.orientation !== orient) continue;
      if (orient === 'h') {
        if (worldPoint.x < Math.min(s.x1, s.x2) - 1 || worldPoint.x > Math.max(s.x1, s.x2) + 1) continue;
        const d = Math.abs(worldPoint.y - s.y);
        if (d < bestD) { bestD = d; best = s; }
      } else {
        if (worldPoint.y < Math.min(s.y1, s.y2) - 1 || worldPoint.y > Math.max(s.y1, s.y2) + 1) continue;
        const d = Math.abs(worldPoint.x - s.x);
        if (d < bestD) { bestD = d; best = s; }
      }
    }

    return best;
  }

  function drawOpening(opening, wallSegs) {
    const kind = String(opening.kind ?? 'door').toLowerCase();
    const orient = openingOrientation(opening);
    const p = parseHexId(opening.hex);

    const hexWorld = hexCenterWorld(p.col, p.row);
    const seg = findNearestWallSegment(wallSegs, orient, hexWorld);

    const w = GRID.size * 1.2;
    const fallbackH = GRID.size * 0.55;

    let cx = hexWorld.x;
    let cy = hexWorld.y;
    let thickness = 28;

    if (seg) {
      thickness = seg.thickness;
      if (orient === 'h') cy = seg.y;
      else cx = seg.x;
    }

    const centerS = worldToScreen({ x: cx, y: cy });

    ctx.save();
    ctx.translate(centerS.x, centerS.y);
    if (orient === 'v') ctx.rotate(Math.PI / 2);

    const fill = (kind === 'window') ? COLORS.window : COLORS.door;
    const stroke = 'rgba(0,0,0,0.35)';
    const openingH = Math.min(thickness * 0.72, fallbackH);

    ctx.fillStyle = fill;
    ctx.strokeStyle = stroke;
    ctx.lineWidth = 2;

    ctx.beginPath();
    ctx.roundRect(-w/2, -openingH/2, w, openingH, 6);
    ctx.fill();
    ctx.stroke();

    if (kind === 'window') {
      ctx.strokeStyle = 'rgba(0,0,0,0.25)';
      ctx.beginPath();
      ctx.moveTo(0, -openingH/2 + 2);
      ctx.lineTo(0, openingH/2 - 2);
      ctx.stroke();
    }

    ctx.restore();
  }

  // ===== Tokens =====
  function drawToken(t) {
    const p = parseHexId(t.hex);
    const cS = worldToScreen(hexCenterWorld(p.col, p.row));

    const isEnemy = String(t.side || '').toUpperCase().indexOf('EN') >= 0;
    const r = GRID.size * 0.42;

    ctx.beginPath();
    ctx.arc(cS.x, cS.y, r, 0, Math.PI * 2);
    ctx.fillStyle = isEnemy ? COLORS.tokenEnemy : COLORS.tokenHero;
    ctx.fill();

    ctx.lineWidth = 2;
    ctx.strokeStyle = 'rgba(0,0,0,0.2)';
    ctx.stroke();

    const label = t.label ?? (t.name ? t.name[0] : '?');
    ctx.font = 'bold 14px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillStyle = isEnemy ? COLORS.tokenTextLight : 'rgba(255,255,255,0.95)';
    ctx.fillText(label, cS.x, cS.y);

    if (t.name) {
      ctx.font = '12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
      ctx.fillStyle = COLORS.tokenTextDark;
      ctx.fillText(t.name, cS.x, cS.y + r + 14);
    }
  }

  // ===== Grid range =====
  function estimateVisibleRange() {
    const pad = GRID.size * 4;
    const topLeftW = screenToWorld({ x: -pad, y: -pad });
    const botRightW = screenToWorld({ x: canvas.width + pad, y: canvas.height + pad });

    const minCol = Math.floor(Math.min(topLeftW.x, botRightW.x) / colStep()) - 2;
    const maxCol = Math.ceil(Math.max(topLeftW.x, botRightW.x) / colStep()) + 2;

    const minRow = Math.floor(-Math.max(topLeftW.y, botRightW.y) / rowStep()) - 4;
    const maxRow = Math.ceil(-Math.min(topLeftW.y, botRightW.y) / rowStep()) + 4;

    return { minCol: Math.max(-10, minCol), maxCol: Math.min(400, maxCol), minRow: Math.max(-10, minRow), maxRow: Math.min(400, maxRow) };
  }

  function drawGrid() {
    const range = estimateVisibleRange();

    ctx.save();
    ctx.lineWidth = GRID.lineWidth;
    ctx.strokeStyle = 'rgba(0,0,0,' + GRID.lineAlpha + ')';

    for (let col = range.minCol; col <= range.maxCol; col++) {
      for (let row = range.minRow; row <= range.maxRow; row++) {
        drawHexOutline(col, row);
      }
    }

    ctx.font = GRID.labelFont;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillStyle = 'rgba(0,0,0,' + GRID.labelAlpha + ')';

    for (let col = range.minCol; col <= range.maxCol; col++) {
      for (let row = range.minRow; row <= range.maxRow; row++) {
        drawHexLabel(col, row);
      }
    }

    ctx.restore();
  }

  // ===== Render =====
  function clear() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = '#fff';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
  }

  function updateSidebar(state) {
    const kvs = document.getElementById('kvs');
    const dbg = document.getElementById('debugRooms');

    const rows = [];
    const meta = state.meta || {};
    rows.push(['Round', meta.round ?? '-']);
    rows.push(['Camera', hexId(VIEW.camera.col, VIEW.camera.row)]);
    rows.push(['Rooms', (state.rooms || []).length]);
    rows.push(['Openings', (state.openings || []).length]);
    rows.push(['Tokens', (state.tokens || []).length]);
    kvs.innerHTML = rows
      .map(pair => '<div>' + pair[0] + '</div><div style="color:#111; font-variant-numeric: tabular-nums;">' + pair[1] + '</div>')
      .join('');

    // Debug block: for each room, print the world-space X/Y of each declared corner hex center,
    // plus the derived wall centerlines (xL/xR/yTop/yBot) that drive the wall ring.
    const fmt = (n) => (Number.isFinite(n) ? n.toFixed(1) : String(n));

    const rooms = Array.isArray(state.rooms) ? state.rooms : [];
    const lines = [];
    for (const r of rooms) {
      lines.push(`${r.id ?? '(unnamed)'}  (t=${r.thickness ?? ''})`);
      if (Array.isArray(r.corners) && r.corners.length) {
        for (const h of r.corners) {
          try {
            const p = parseHexId(h);
            const c = hexCenterWorld(p.col, p.row);
            lines.push(`  ${h.padEnd(5)} -> center world: x=${fmt(c.x)}  y=${fmt(c.y)}  (col=${p.col}, row=${p.row})`);
          } catch (e) {
            lines.push(`  ${String(h)} -> ERROR: ${e.message}`);
          }
        }
      } else {
        lines.push('  (no corners)');
      }

      // Derived rectangle numbers that actually place the walls/floor.
      try {
        const box = roomToWallBox(r);
        lines.push(`  derived: xL=${fmt(box.xL)}  xR=${fmt(box.xR)}  yTop=${fmt(box.yTop)}  yBot=${fmt(box.yBot)}`);
        lines.push(`  outer:   x1=${fmt(box.outer.x1)}  y1=${fmt(box.outer.y1)}  x2=${fmt(box.outer.x2)}  y2=${fmt(box.outer.y2)}`);
        lines.push(`  inner:   x1=${fmt(box.inner.x1)}  y1=${fmt(box.inner.y1)}  x2=${fmt(box.inner.x2)}  y2=${fmt(box.inner.y2)}`);
      } catch (e) {
        lines.push(`  derived: ERROR: ${e.message}`);
      }

      lines.push('');
    }

    // IMPORTANT: use an escaped newline so we don't create a syntax error.
    dbg.textContent = lines.join('\n');
  }

  function redraw() {
    const state = getState();

    clear();

    const rooms = Array.isArray(state.rooms) ? state.rooms : [];
    for (const r of rooms) drawRoom(r);

    const wallSegs = buildWallSegments(rooms);

    const openings = Array.isArray(state.openings) ? state.openings : [];
    for (const o of openings) drawOpening(o, wallSegs);

    const tokens = Array.isArray(state.tokens) ? state.tokens : [];
    for (const t of tokens) drawToken(t);

    drawGrid();
    updateSidebar(state);
  }

  // ===== Tiny self-tests (console only) =====
  function runSelfTests() {
    try {
      const a = 'A';
      const z = 'Z';
      const aa = 'AA';
      const dz = 'DZ';

      const checkRoundTrip = (letters) => {
        const col = lettersToCol(letters);
        const back = colToLetters(col);
        if (back !== letters) throw new Error(`Roundtrip failed: ${letters} -> ${col} -> ${back}`);
      };

      checkRoundTrip(a);
      checkRoundTrip(z);
      checkRoundTrip(aa);
      checkRoundTrip(dz);

      const p = parseHexId('AA27');
      if (hexId(p.col, p.row) !== 'AA27') throw new Error('parseHexId/hexId mismatch for AA27');

      // Geometry sanity: Bedroom1 south wall should land on the declared south-corner hex centers.
      const testRoom = { id: 'Bedroom1', corners: ['B11','F11','F8','B8'], thickness: 20 };
      const b8 = hexCenterWorld(parseHexId('B8').col, parseHexId('B8').row);
      const box = roomToWallBox(testRoom);
      const eps = 0.001;
      if (Math.abs(box.yBot - b8.y) > eps) {
        throw new Error(`roomToWallBox yBot mismatch: expected ${b8.y} got ${box.yBot}`);
      }

      console.log('[Battlemat] self-tests: OK');
    } catch (e) {
      console.warn('[Battlemat] self-tests: FAIL', e);
    }
  }

  // ===== UI =====
  function pan(dc, dr) {
    VIEW.camera.col += dc;
    VIEW.camera.row += dr;
    redraw();
  }

  function setCameraToHex(hex) {
    const p = parseHexId(hex);
    VIEW.camera.col = p.col;
    VIEW.camera.row = p.row;
    redraw();
  }

  function wireUI() {
    document.getElementById('btnLeft').addEventListener('click', () => pan(-PAN_STEP, 0));
    document.getElementById('btnRight').addEventListener('click', () => pan(PAN_STEP, 0));
    document.getElementById('btnUp').addEventListener('click', () => pan(0, PAN_STEP));
    document.getElementById('btnDown').addEventListener('click', () => pan(0, -PAN_STEP));

    document.getElementById('btnRedraw').addEventListener('click', redraw);

    document.getElementById('btnJump').addEventListener('click', () => {
      const v = document.getElementById('jumpHex').value.trim();
      if (!v) return;
      try { setCameraToHex(v); } catch (e) { console.warn(e); }
    });

    document.getElementById('jumpHex').addEventListener('keydown', (e) => {
      if (e.key === 'Enter') document.getElementById('btnJump').click();
    });

    document.getElementById('floorKind').addEventListener('change', (e) => {
      const state = getState();
      const kind = e.target.value;
      if (!Array.isArray(state.rooms)) return redraw();
      for (const r of state.rooms) {
        if (!r.floor) r.floor = {};
        r.floor.kind = kind;
      }
      redraw();
    });

    window.addEventListener('keydown', (e) => {
      if (e.key === 'ArrowLeft') { e.preventDefault(); pan(-PAN_STEP, 0); }
      if (e.key === 'ArrowRight') { e.preventDefault(); pan(PAN_STEP, 0); }
      if (e.key === 'ArrowUp') { e.preventDefault(); pan(0, PAN_STEP); }
      if (e.key === 'ArrowDown') { e.preventDefault(); pan(0, -PAN_STEP); }
    });
  }

  function resize() {
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    const rect = canvas.getBoundingClientRect();
    canvas.width = Math.floor(rect.width * dpr);
    canvas.height = Math.floor(rect.height * dpr);
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

    VIEW.anchor.x = rect.width / 2;
    VIEW.anchor.y = rect.height / 2;

    redraw();
  }

  function init() {
    wireUI();
    runSelfTests();

    const state = getState();
    const hex = state.view?.camera_hex;
    if (hex) {
      try { setCameraToHex(hex); } catch (e) { /* ignore */ }
    }

    window.addEventListener('resize', resize);
    resize();
  }

  init();
})();
</script>
</body>
</html>
