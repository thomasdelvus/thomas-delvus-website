<!doctype html>
<!--
  Battlemat - V4
  Version 4.03

  Notes:
  - Restores full room/wall rendering pipeline (walls/floors/doors/windows) while keeping the grid + labels drawn on top.
  - Textures are always ON (no toggle).
  - Brick texture uses small, consistent medium-gray bricks.
-->
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Battlemat - V4</title>
  <style>
    :root{
      --bg:#f5f6f7;
      --panel:#ffffff;
      --line:#e6e8eb;
      --text:#111827;
      --muted:#6b7280;
      --pill:#f3f4f6;
      --shadow:0 10px 30px rgba(0,0,0,.06);
      --radius:12px;
    }
    html,body{height:100%; margin:0; font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,Arial,sans-serif; color:var(--text); background:var(--bg);}
    .app{display:grid; grid-template-columns: 1fr 340px; gap:16px; padding:16px; height:100%; box-sizing:border-box;}
    .left{display:flex; flex-direction:column; gap:10px; min-width:0;}
    .title{font-weight:700; font-size:14px; margin:0 0 2px 4px; color:#111;}

    .stage{flex:1; background:var(--panel); border:1px solid var(--line); border-radius:var(--radius); box-shadow:var(--shadow); padding:10px; display:flex; align-items:center; justify-content:center; min-height:540px;}
    canvas{background:#fff; border-radius:10px;}

    .bottom{background:var(--panel); border:1px solid var(--line); border-radius:var(--radius); box-shadow:var(--shadow); padding:10px; display:flex; align-items:center; justify-content:space-between; gap:10px; flex-wrap:wrap;}

    .legend{display:flex; gap:10px; flex-wrap:wrap; align-items:center;}
    .legend .item{display:flex; align-items:center; gap:6px; font-size:12px; color:var(--muted);}
    .swatch{width:14px; height:14px; border-radius:4px; border:1px solid rgba(0,0,0,.12);}

    .right{display:flex; flex-direction:column; gap:12px;}
    .panel{background:var(--panel); border:1px solid var(--line); border-radius:var(--radius); box-shadow:var(--shadow); padding:12px;}
    .panel-title{font-weight:700; font-size:13px; margin:0 0 8px 0;}

    .row{display:flex; align-items:center; justify-content:space-between; gap:10px;}
    .subtle{color:var(--muted); font-size:12px;}
    .pill{background:var(--pill); border:1px solid var(--line); border-radius:999px; padding:6px 10px; font-size:12px; color:#111; cursor:pointer; user-select:none;}
    .pill:active{transform:translateY(1px);}

    table{width:100%; border-collapse:collapse; font-size:12px;}
    th,td{padding:6px 6px; border-bottom:1px solid var(--line); text-align:left;}
    th{color:var(--muted); font-weight:600;}

    textarea{width:100%; height:520px; resize:none; border:1px solid var(--line); border-radius:10px; padding:10px; font-size:12px; line-height:1.35; box-sizing:border-box; outline:none;}

    select{border:1px solid var(--line); border-radius:999px; padding:6px 10px; font-size:12px; background:#fff;}
    .btn{border:1px solid var(--line); border-radius:999px; padding:8px 12px; background:#fff; cursor:pointer; font-size:12px;}
    .btn:hover{background:#fafafa;}

    @media (max-width: 1060px){
      .app{grid-template-columns: 1fr;}
      .right{order:2;}
    }
  </style>
</head>
<body>
  <div class="app">
    <div class="left">
      <div class="title">Battlemat - V4</div>
      <div class="stage">
        <canvas id="mat" width="1000" height="820"></canvas>
      </div>

      <div class="bottom">
        <div class="legend" aria-label="Legend">
          <div class="item"><span class="swatch" style="background:#b07a2f"></span>Door</div>
          <div class="item"><span class="swatch" style="background:#cfe9ff"></span>Window</div>
          <div class="item"><span class="swatch" style="background:#4aa3ff"></span>Player</div>
          <div class="item"><span class="swatch" style="background:#111"></span>Enemy</div>
          <div class="item"><span class="swatch" style="background:#d1d5db"></span>Difficult</div>
        </div>

        <div class="row" style="gap:8px;">
          <span class="subtle">Floor</span>
          <select id="floorSelect">
            <option value="stone" selected>Stone</option>
            <option value="wood">Wood</option>
          </select>
          <button class="btn" id="redrawBtn">Redraw</button>
        </div>
      </div>
    </div>

    <div class="right">
      <div class="panel">
        <div class="row">
          <div class="panel-title" style="margin:0;">Status</div>
          <div class="pill" style="border:none; background:transparent; cursor:default;" id="versionLine">v4.02</div>
        </div>
        <div class="row subtle" style="margin-top:6px;">
          <div id="roundLine">Round 1</div>
          <span class="pill" id="refreshBtn">Refresh: 60s</span>
        </div>
        <div style="margin-top:10px;">
          <table>
            <thead>
              <tr><th>Actor</th><th>Init</th><th>HP</th></tr>
            </thead>
            <tbody id="statusBody"></tbody>
          </table>
        </div>
      </div>

      <div class="panel" style="flex:1; display:flex; flex-direction:column;">
        <div class="panel-title">Narration</div>
        <textarea id="narration" placeholder="Scene beats, GM notes, what just happened..."></textarea>
      </div>
    </div>
  </div>

  <script>
    'use strict';

    /**
     * Core idea:
     * - Keep a simple, deterministic flat-top hex coordinate system.
     * - Draw rooms/walls/floors first.
     * - Then doors/windows/props/tokens.
     * - Finally draw hex grid + hex labels on top.
     */

    // ---------------------------
    // Canvas + sizing
    // ---------------------------
    const canvas = document.getElementById('mat');
    const ctx = canvas.getContext('2d');

    // Grid: flat-top hexes
    const GRID = {
      cols: 16,      // A..P
      rows: 11,      // 1..11 (A1 is bottom-left)
      size: 42,      // hex radius
      originX: 70,
      originY: 70,
    };

    // Visual tuning
    const COLORS = {
      grid: 'rgba(0,0,0,0.15)',
      gridBold: 'rgba(0,0,0,0.18)',
      label: 'rgba(0,0,0,0.16)',
      labelBold: 'rgba(0,0,0,0.18)',
      fog: 'rgba(0,0,0,0.55)',
      door: '#b07a2f',
      window: '#cfe9ff',
      enemy: '#111111',
      player: '#4aa3ff',
    };

    // ---------------------------
    // Scene data (default)
    // ---------------------------
    // NOTE: This provides walls/floors by default so you can verify rendering.
    // If you later load scene JSON from an API, merge it over this.
    const DEFAULT_SCENE = {
      battleId: 'local',
      round: 1,
      rooms: [
        {
          id: 'building1',
          corners: ['D11','N11','N2','D2'],
          thickness: 30,
          color: '#555',
          floor: { kind: 'wood' },
          wall: { kind: 'brick' },
        },
        {
          id: 'room_left',
          corners: ['D11','H11','H2','D2'],
          thickness: 30,
          color: '#555',
          floor: { kind: 'wood' },
          wall: { kind: 'brick' },
        },
        {
          id: 'room_right',
          corners: ['H11','N11','N2','H2'],
          thickness: 30,
          color: '#555',
          floor: { kind: 'wood' },
          wall: { kind: 'brick' },
        },
      ],
      openings: [
        { id: 'door_mid', kind: 'door', at: 'H6', facing: 'E', widthPx: 70 },
        { id: 'door_east1', kind: 'door', at: 'N6', facing: 'E', widthPx: 70 },
        { id: 'door_east2', kind: 'door', at: 'N5', facing: 'E', widthPx: 70 },
        { id: 'win_s1', kind: 'window', at: 'F1', facing: 'S', widthPx: 70 },
        { id: 'win_s2', kind: 'window', at: 'H1', facing: 'S', widthPx: 70 },
        { id: 'win_s3', kind: 'window', at: 'J1', facing: 'S', widthPx: 70 },
      ],
      actors: [
        { id: 'lich', name: 'Lich', side: 'ENEMY', at: 'K9', init: 15, hp: 135 },
        { id: 'w1', name: 'Wraith 1', side: 'ENEMY', at: 'H6', init: 12, hp: 67 },
        { id: 'w2', name: 'Wraith 2', side: 'ENEMY', at: 'G8', init: 11, hp: 67 },
        { id: 'w3', name: 'Wraith 3', side: 'ENEMY', at: 'F6', init: 10, hp: 67 },
        { id: 'a', name: 'Aelar', side: 'PLAYER', at: 'J3', init: 14, hp: 42 },
        { id: 'b', name: 'Brunna', side: 'PLAYER', at: 'K3', init: 13, hp: 55 },
        { id: 'c', name: 'Caelin', side: 'PLAYER', at: 'L4', init: 12, hp: 38 },
      ],
      fog: {
        enabled: false,
        visibleRooms: ['room_left'],
      },
      narration: "The crypt is silent but for the soft scrape of bone on stone.\n\nAelar steps forward, blade raised â€” and the air suddenly turns cold.\n\nCaelin: \"I don't like this...\"\n\nA shadow shifts near the sarcophagus."
    };

    // Active scene
    let SCENE = structuredClone(DEFAULT_SCENE);

    // ---------------------------
    // Utilities: hex math
    // ---------------------------
    const LETTERS = 'ABCDEFGHIJKLMNOP'.split('');

    function clamp(n, a, b){ return Math.max(a, Math.min(b, n)); }

    function parseHexId(id){
      // e.g. "H6" => {col:7,row:6}
      const m = String(id).trim().toUpperCase().match(/^([A-P])(\d{1,2})$/);
      if(!m) return null;
      const col = LETTERS.indexOf(m[1]);
      const row = parseInt(m[2], 10);
      if(col < 0 || row < 1 || row > GRID.rows) return null;
      return { col, row };
    }

    function hexCenter(col, row){
      // Flat-top layout (odd-q vertical offset).
      // IMPORTANT: Coordinate system is "A1 in the lower-left".
      // That means row 1 should be at the bottom of the canvas and row numbers increase upward.
      // We implement that by flipping the row index when mapping to pixels.
      //
      // x = originX + size*3/2*col
      // y = originY + size*sqrt(3)*(rowFromTop + 0.5*(col%2))
      const s = GRID.size;
      const x = GRID.originX + (s * 1.5) * col;
      const rowFromTop = (GRID.rows - row); // 0-based; row=GRID.rows at top, row=1 at bottom
      const y = GRID.originY + (s * Math.sqrt(3)) * (rowFromTop + 0.5 * (col % 2));
      return { x, y };
    }

    function hexPolygon(cx, cy, s){
      // flat-top
      const pts = [];
      for(let i=0;i<6;i++){
        const a = Math.PI/180 * (60*i);
        pts.push({ x: cx + s*Math.cos(a), y: cy + s*Math.sin(a) });
      }
      return pts;
    }

    function drawPoly(p, fill=null, stroke=null, lw=1){
      ctx.beginPath();
      ctx.moveTo(p[0].x, p[0].y);
      for(let i=1;i<p.length;i++) ctx.lineTo(p[i].x, p[i].y);
      ctx.closePath();
      if(fill){ ctx.fillStyle = fill; ctx.fill(); }
      if(stroke){ ctx.strokeStyle = stroke; ctx.lineWidth = lw; ctx.stroke(); }
    }

    // Convert a corners array into a pixel-space bounding box rectangle.
    // NOTE: This is the simple rectangle mode you've been using for now.
    function cornersToRect(corners){
      const pts = corners
        .map(parseHexId)
        .filter(Boolean)
        .map(h => hexCenter(h.col, h.row));
      if(pts.length < 2) return null;
      let minX=Infinity, minY=Infinity, maxX=-Infinity, maxY=-Infinity;
      for(const p of pts){
        minX = Math.min(minX, p.x);
        minY = Math.min(minY, p.y);
        maxX = Math.max(maxX, p.x);
        maxY = Math.max(maxY, p.y);
      }
      // Expand by our agreed rules:
      // - X expands by quarter column-step (vertical walls centered on boundary hex column)
      // - Y expands by half row-step (horizontal walls use the bottom-half convention)
      const s = GRID.size;
      const expandX = s * 0.375;               // quarter of (1.5*s)  (align vertical walls to mid-hex column)
      const expandY = s * Math.sqrt(3) * 0.5;  // half of (sqrt3*s)   (align horizontal walls to bottom-half rule)
      return { x: minX - expandX, y: minY - expandY, w: (maxX-minX) + 2*expandX, h: (maxY-minY) + 2*expandY };
    }

    // ---------------------------
    // Procedural textures
    // ---------------------------
    const patternCache = new Map();

    function makePattern(key, build){
      if(patternCache.has(key)) return patternCache.get(key);
      const p = build();
      patternCache.set(key, p);
      return p;
    }

    function patternBrickSmall(){
      // Small, consistent medium-gray bricks.
      return makePattern('brickSmall', () => {
        const c = document.createElement('canvas');
        // 1/4 size feel: keep tile small
        c.width = 64;
        c.height = 48;
        const g = c.getContext('2d');

        // background mortar
        g.fillStyle = '#7d7f82';
        g.fillRect(0,0,c.width,c.height);

        // brick fill
        const brick = '#8a8c8f';
        const edge = 'rgba(0,0,0,0.10)';
        const mortar = '#7d7f82';

        const bw = 16; // brick width
        const bh = 10; // brick height
        const gap = 2; // mortar thickness

        for(let y=0; y<c.height; y += (bh+gap)){
          const row = Math.floor(y/(bh+gap));
          const offset = (row % 2) ? Math.floor((bw+gap)/2) : 0;
          for(let x=-offset; x<c.width; x += (bw+gap)){
            g.fillStyle = brick;
            g.fillRect(x, y, bw, bh);
            g.strokeStyle = edge;
            g.lineWidth = 1;
            g.strokeRect(x+0.5, y+0.5, bw-1, bh-1);

            // speckles (subtle)
            g.fillStyle = 'rgba(0,0,0,0.05)';
            for(let i=0;i<2;i++){
              const sx = x + 2 + Math.random()*(bw-4);
              const sy = y + 2 + Math.random()*(bh-4);
              g.fillRect(sx, sy, 1, 1);
            }
          }
        }

        // thin mortar lines
        g.fillStyle = mortar;
        for(let y=bh; y<c.height; y += (bh+gap)){
          g.fillRect(0, y, c.width, gap);
        }
        return ctx.createPattern(c, 'repeat');
      });
    }

    function patternStone(){
      return makePattern('stone', () => {
        const c = document.createElement('canvas');
        c.width = 120;
        c.height = 120;
        const g = c.getContext('2d');
        g.fillStyle = '#b7b9bc';
        g.fillRect(0,0,c.width,c.height);
        g.strokeStyle = 'rgba(0,0,0,0.10)';
        g.lineWidth = 2;
        for(let y=0;y<120;y+=24){
          for(let x=0;x<120;x+=40){
            g.strokeRect(x+1, y+1, 38, 22);
          }
        }
        g.fillStyle = 'rgba(0,0,0,0.05)';
        for(let i=0;i<150;i++){
          g.fillRect(Math.random()*120, Math.random()*120, 1, 1);
        }
        return ctx.createPattern(c, 'repeat');
      });
    }

    function patternWood(){
      return makePattern('wood', () => {
        const c = document.createElement('canvas');
        c.width = 120;
        c.height = 120;
        const g = c.getContext('2d');
        g.fillStyle = '#d2c19a';
        g.fillRect(0,0,c.width,c.height);
        g.strokeStyle = 'rgba(0,0,0,0.10)';
        g.lineWidth = 2;
        for(let x=0;x<120;x+=20){
          g.beginPath();
          g.moveTo(x,0);
          g.lineTo(x,120);
          g.stroke();
        }
        g.strokeStyle = 'rgba(0,0,0,0.06)';
        for(let i=0;i<12;i++){
          g.beginPath();
          g.moveTo(0, Math.random()*120);
          g.bezierCurveTo(40, Math.random()*120, 80, Math.random()*120, 120, Math.random()*120);
          g.stroke();
        }
        g.fillStyle = 'rgba(0,0,0,0.07)';
        for(let i=0;i<60;i++){
          g.beginPath();
          g.arc(Math.random()*120, Math.random()*120, Math.random()*3, 0, Math.PI*2);
          g.stroke();
        }
        return ctx.createPattern(c, 'repeat');
      });
    }

    function floorPattern(kind){
      if(kind === 'wood') return patternWood();
      return patternStone();
    }

    // ---------------------------
    // Drawing: grid + labels
    // ---------------------------
    function drawHexGrid(){
      const s = GRID.size;
      for(let col=0; col<GRID.cols; col++){
        for(let row=1; row<=GRID.rows; row++){
          const c = hexCenter(col,row);
          const poly = hexPolygon(c.x,c.y,s);
          ctx.lineWidth = 1;
          ctx.strokeStyle = COLORS.grid;
          drawPoly(poly, null, COLORS.grid, 1);

          // labels
          const label = `${LETTERS[col]}${row}`;
          ctx.fillStyle = (row === GRID.rows || row === 1 || col === 0 || col === GRID.cols-1) ? COLORS.labelBold : COLORS.label;
          ctx.font = '600 12px system-ui, sans-serif';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText(label, c.x, c.y);
        }
      }
    }

    // ---------------------------
    // Drawing: rooms (walls + floors)
    // ---------------------------
    function drawRoom(room){
      const rect = cornersToRect(room.corners);
      if(!rect) return;

      const t = Number(room.thickness || 0);
      // Wall: brick pattern inside the wall band
      if(t > 0){
        ctx.save();
        ctx.fillStyle = patternBrickSmall();
        ctx.fillRect(rect.x, rect.y, rect.w, rect.h);

        // Cut out interior (to leave a wall ring)
        ctx.globalCompositeOperation = 'destination-out';
        ctx.fillRect(rect.x + t, rect.y + t, rect.w - 2*t, rect.h - 2*t);
        ctx.restore();

        // subtle outline (very light, to avoid the thin black line you flagged)
        ctx.save();
        ctx.strokeStyle = 'rgba(0,0,0,0.08)';
        ctx.lineWidth = 1;
        ctx.strokeRect(rect.x + 0.5, rect.y + 0.5, rect.w - 1, rect.h - 1);
        ctx.restore();
      }

      // Floor fill
      const floorKind = (room.floor && room.floor.kind) ? room.floor.kind : document.getElementById('floorSelect').value;
      ctx.save();
      ctx.fillStyle = floorPattern(floorKind);
      ctx.fillRect(rect.x + t, rect.y + t, rect.w - 2*t, rect.h - 2*t);
      ctx.restore();
    }

    function drawRooms(){
      if(!Array.isArray(SCENE.rooms)) return;
      for(const r of SCENE.rooms){
        drawRoom(r);
      }
    }

    // ---------------------------
    // Openings: doors/windows
    // ---------------------------
    function drawOpening(o){
      const h = parseHexId(o.at);
      if(!h) return;
      const c = hexCenter(h.col, h.row);
      const w = Number(o.widthPx || 70);
      const thick = 18;

      ctx.save();
      if(o.kind === 'window'){
        ctx.fillStyle = COLORS.window;
        ctx.strokeStyle = 'rgba(0,0,0,0.15)';
      } else {
        ctx.fillStyle = COLORS.door;
        ctx.strokeStyle = 'rgba(0,0,0,0.20)';
      }
      ctx.lineWidth = 2;

      const facing = String(o.facing || 'E').toUpperCase();
      // Draw as a small rectangle straddling the wall line.
      let x=c.x, y=c.y, rw=w, rh=thick;
      if(facing === 'E' || facing === 'W'){
        rw = thick; rh = w;
      }
      ctx.beginPath();
      ctx.rect(x - rw/2, y - rh/2, rw, rh);
      ctx.fill();
      ctx.stroke();
      ctx.restore();
    }

    function drawOpenings(){
      if(!Array.isArray(SCENE.openings)) return;
      for(const o of SCENE.openings) drawOpening(o);
    }

    // ---------------------------
    // Actors (tokens)
    // ---------------------------
    function tokenColor(side){
      return (String(side).toUpperCase() === 'PLAYER') ? COLORS.player : COLORS.enemy;
    }

    function drawActor(a){
      const h = parseHexId(a.at);
      if(!h) return;
      const c = hexCenter(h.col, h.row);

      const fill = tokenColor(a.side);
      ctx.save();
      ctx.beginPath();
      ctx.arc(c.x, c.y, 18, 0, Math.PI*2);
      ctx.fillStyle = fill;
      ctx.fill();
      ctx.strokeStyle = 'rgba(0,0,0,0.25)';
      ctx.lineWidth = 2;
      ctx.stroke();

      // label inside
      ctx.fillStyle = '#fff';
      ctx.font = '700 12px system-ui, sans-serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      const inside = (a.name || '').trim().split(/\s+/)[0].slice(0,1).toUpperCase();
      ctx.fillText(inside || '?', c.x, c.y);

      // name under token
      ctx.fillStyle = 'rgba(0,0,0,0.55)';
      ctx.font = '600 12px system-ui, sans-serif';
      ctx.fillText(a.name || a.id, c.x, c.y + 28);
      ctx.restore();
    }

    function drawActors(){
      if(!Array.isArray(SCENE.actors)) return;
      for(const a of SCENE.actors) drawActor(a);
    }

    // ---------------------------
    // Fog of war
    // ---------------------------
    function drawFog(){
      if(!SCENE.fog || !SCENE.fog.enabled) return;

      const visible = new Set(SCENE.fog.visibleRooms || []);

      // Simple room-based fog for now:
      // - Darken everything
      // - Then punch holes for visible rooms
      ctx.save();
      ctx.fillStyle = COLORS.fog;
      ctx.fillRect(0,0,canvas.width,canvas.height);

      ctx.globalCompositeOperation = 'destination-out';
      for(const r of (SCENE.rooms || [])){
        if(!visible.has(r.id)) continue;
        const rect = cornersToRect(r.corners);
        if(!rect) continue;
        const t = Number(r.thickness || 0);
        ctx.fillRect(rect.x + t, rect.y + t, rect.w - 2*t, rect.h - 2*t);
      }
      ctx.restore();
    }

    // ---------------------------
    // Render pipeline
    // ---------------------------
    function clear(){
      ctx.clearRect(0,0,canvas.width,canvas.height);
    }

    function render(){
      clear();
      drawRooms();
      drawOpenings();
      drawActors();
      drawFog();
      // Grid + labels LAST (on top)
      drawHexGrid();
    }

    // ---------------------------
    // UI wiring
    // ---------------------------
    const statusBody = document.getElementById('statusBody');
    const narrationBox = document.getElementById('narration');

    function refreshStatus(){
      const list = [...(SCENE.actors || [])].slice().sort((a,b) => (b.init||0)-(a.init||0));
      statusBody.innerHTML = '';
      for(const a of list){
        const tr = document.createElement('tr');
        tr.innerHTML = `<td>${escapeHtml(a.name || a.id)}</td><td>${escapeHtml(String(a.init ?? ''))}</td><td>${escapeHtml(String(a.hp ?? ''))}</td>`;
        statusBody.appendChild(tr);
      }
      document.getElementById('roundLine').textContent = `Round ${SCENE.round || 1}`;
      narrationBox.value = SCENE.narration || '';
    }

    function escapeHtml(s){
      return String(s)
        .replaceAll('&','&amp;')
        .replaceAll('<','&lt;')
        .replaceAll('>','&gt;')
        .replaceAll('"','&quot;')
        .replaceAll("'",'&#039;');
    }

    document.getElementById('redrawBtn').addEventListener('click', () => {
      render();
    });

    document.getElementById('floorSelect').addEventListener('change', () => {
      render();
    });

    // ---------------------------
    // Self-checks (lightweight "tests")
    function runSelfTests(){
      // Basic parsing
      console.assert(parseHexId('A1')?.col === 0 && parseHexId('A1')?.row === 1, '[Test] parseHexId A1');
      console.assert(parseHexId('P11')?.col === 15 && parseHexId('P11')?.row === 11, '[Test] parseHexId P11');
      console.assert(parseHexId('Z9') === null, '[Test] parseHexId invalid letter');

      // Coordinate orientation: A1 should be BELOW A11 on the canvas
      const a1 = hexCenter(0, 1);
      const a11 = hexCenter(0, 11);
      console.assert(a1.y > a11.y, '[Test] A1 is below A11 (A1 bottom-left)');

      // Expansion math: quarter column-step & half row-step
      const s = GRID.size;
      const expectedExpandX = 0.25 * (1.5 * s);
      const expectedExpandY = 0.5 * (Math.sqrt(3) * s);

      const c1 = hexCenter(LETTERS.indexOf('D'), 1);
      const c2 = hexCenter(LETTERS.indexOf('D'), 11);
      const r = cornersToRect(['D1','D11']);
      console.assert(r && Math.abs(r.x - (Math.min(c1.x,c2.x) - expectedExpandX)) < 1e-6, '[Test] cornersToRect expandX');
      console.assert(r && Math.abs(r.y - (Math.min(c1.y,c2.y) - expectedExpandY)) < 1e-6, '[Test] cornersToRect expandY');
    }

    // Self-checks (lightweight "tests")
    // ---------------------------
    function validateScene(scene){
      const errs = [];
      if(!scene) errs.push('scene is null');
      if(!Array.isArray(scene.rooms) || scene.rooms.length === 0) errs.push('scene.rooms missing/empty (walls will not draw)');
      if(scene.rooms){
        for(const r of scene.rooms){
          if(!r.id) errs.push('room missing id');
          if(!Array.isArray(r.corners) || r.corners.length < 4) errs.push(`room ${r.id||'?'} missing corners`);
        }
      }
      if(errs.length){
        console.warn('[Battlemat] Scene validation warnings:', errs);
      }
      return errs;
    }

    // Boot
    (function boot(){
      // Ensure default floor matches dropdown.
      try{
        const sel = document.getElementById('floorSelect');
        if(sel && sel.value){
          for(const r of SCENE.rooms){
            if(r.floor && r.floor.kind) continue;
            r.floor = { kind: sel.value };
          }
        }
      } catch(_){ }

      runSelfTests();
      validateScene(SCENE);
      refreshStatus();
      render();
    })();

  </script>
</body>
</html>
