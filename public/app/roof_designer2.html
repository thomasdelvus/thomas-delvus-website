<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Roof Designer 2</title>
  <style>
    :root { color-scheme: dark; --bg:#0b0f14; --panel:rgba(18,22,30,.96); --panel-border:rgba(255,255,255,.08); --text:#e6e9ef; --muted:#9aa5b1; --accent:#6aa9ff; }
    * { box-sizing: border-box; }
    body { margin:0; background:var(--bg); color:var(--text); font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,sans-serif; }
    #toolbar { position:sticky; top:0; z-index:10; display:flex; align-items:center; gap:10px; padding:10px 12px; background:var(--panel); border-bottom:1px solid var(--panel-border); flex-wrap:wrap; }
    #toolbar label { font-size:12px; color:var(--muted); }
    #toolbar input[type="text"], #toolbar input[type="number"], #toolbar select { padding:6px 8px; border-radius:6px; border:1px solid var(--panel-border); background:#0f141c; color:var(--text); }
    #pointsInput { min-width:420px; max-width:70vw; }
    #toolbar button { padding:6px 10px; border-radius:6px; border:1px solid var(--panel-border); background:#0f141c; color:var(--text); cursor:pointer; }
    #toolbar button.active { border-color:var(--accent); box-shadow:0 0 0 1px rgba(106,169,255,.35); }
    .group { display:inline-flex; align-items:center; gap:6px; padding-right:8px; border-right:1px solid rgba(255,255,255,.06); }
    .info { margin-left:auto; font-size:12px; color:var(--muted); }
    #canvasWrap { padding:16px; }
    canvas { display:block; background:#0b0f14; border:1px solid rgba(255,255,255,.08); border-radius:8px; }
  </style>
</head>
<body>
  <div id="toolbar">
    <div class="group">
      <label for="pointsInput">Points</label>
      <input id="pointsInput" type="text" />
      <button id="btnApply">Apply</button>
    </div>
    <div class="group">
      <label>Mode</label>
      <button id="btnModeDraw" class="active">Draw</button>
      <button id="btnModeSelect">Select</button>
      <button id="btnDelete">Delete</button>
    </div>
    <div class="group">
      <label>Tool</label>
      <button id="btnToolRect" class="active">Rect</button>
      <button id="btnToolPoly">Poly</button>
    </div>
    <div class="group">
      <label>Start°</label><input id="startAngle" type="number" step="1" value="0" min="-85" max="85" />
      <label>End°</label><input id="endAngle" type="number" step="1" value="0" min="-85" max="85" />
      <label>Rot</label><select id="rectRot"><option value="0" selected>0</option><option value="90">90</option><option value="180">180</option><option value="270">270</option></select>
      <label>Z</label><input id="rectZ" type="number" step="1" value="0" />
      <button id="btnFront">Front</button><button id="btnBack">Back</button>
    </div>
    <div class="group">
      <label>Tile</label><select id="tileKind"><option value="slate" selected>slate</option><option value="thatch">thatch</option><option value="terracotta">terracotta</option><option value="grass">grass</option></select>
      <label>Scale</label><input id="tileScale" type="number" step="0.01" value="0.20" />
    </div>
    <div class="group">
      <label>Line</label><input id="lineColor" type="color" value="#70777e" />
      <label>W</label><input id="lineWidth" type="number" step="0.5" value="2" />
    </div>
    <div class="group">
      <button id="btnUndo">Undo</button><button id="btnRedo">Redo</button><button id="btnExportPng">Export PNG</button><button id="btnCopyJson">Copy JSON</button>
    </div>
    <label><input type="checkbox" id="gridToggle" checked /> Hexgrid</label>
    <span id="info" class="info"></span>
  </div>
  <div id="canvasWrap"><canvas id="canvas"></canvas></div>
  <script>
    (() => {
      const DEFAULT_POINTS = 'HA96.5, HA87.5, HK87.5, HK85, HX84.5, HX96';
      const GRID = { size: 32, lineAlpha: 0.22, lineWidth: 1.1 };
      const VIEW = { cameraWorld: { x: 0, y: 0 }, zoom: 1 };
      const HISTORY_MAX = 20;
      const STATE = { points: [], boundary: [], rects: [], polys: [], mode: 'draw', tool: 'rect', selection: null, preview: null, polyDraft: null, lineColor: '#70777e', lineWidth: 2, historyPast: [], historyFuture: [] };
      const TILE_TEXTURES = { slate:{url:'/assets/sprites/slate.png',color:'#3a434a'}, terracotta:{url:'/assets/sprites/terracotta.png',color:'#6a3a2a'}, thatch:{url:'/assets/sprites/thatch.png',color:'#6a5a3a'}, grass:{url:'/assets/sprites/grass.png',color:'#2f5a2f'} };
      const spriteCache = new Map();
      function loadSprite(url){ if(spriteCache.has(url)) return spriteCache.get(url); const img=new Image(); img.src=url; spriteCache.set(url,img); img.onload=render; return img; }
      const canvas=document.getElementById('canvas'); const ctx=canvas.getContext('2d');
      const pointsInput=document.getElementById('pointsInput'); const btnApply=document.getElementById('btnApply');
      const btnModeDraw=document.getElementById('btnModeDraw'); const btnModeSelect=document.getElementById('btnModeSelect'); const btnDelete=document.getElementById('btnDelete');
      const btnToolRect=document.getElementById('btnToolRect'); const btnToolPoly=document.getElementById('btnToolPoly');
      const startAngleEl=document.getElementById('startAngle'); const endAngleEl=document.getElementById('endAngle'); const rectRotEl=document.getElementById('rectRot'); const rectZEl=document.getElementById('rectZ');
      const btnFront=document.getElementById('btnFront'); const btnBack=document.getElementById('btnBack');
      const tileKindEl=document.getElementById('tileKind'); const tileScaleEl=document.getElementById('tileScale');
      const lineColorEl=document.getElementById('lineColor'); const lineWidthEl=document.getElementById('lineWidth');
      const btnUndo=document.getElementById('btnUndo'); const btnRedo=document.getElementById('btnRedo'); const btnExportPng=document.getElementById('btnExportPng'); const btnCopyJson=document.getElementById('btnCopyJson');
      const gridToggle=document.getElementById('gridToggle'); const info=document.getElementById('info');
      let drag=null;
      const clamp=(v,a,b)=>Math.max(a,Math.min(b,v)); const colStep=()=>1.5*GRID.size; const rowStep=()=>Math.sqrt(3)*GRID.size;
      function indexToLetters(idx){ let n=idx,out=''; while(n>=0){ out=String.fromCharCode(65+(n%26))+out; n=Math.floor(n/26)-1; } return out; }
      function lettersToIndex(letters){ let n=0; for(let i=0;i<letters.length;i++) n=n*26+(letters.charCodeAt(i)-64); return n-1; }
      function parseHexLabel(label){ const m=/^([A-Za-z]+)(\d+(?:\.5)?)$/.exec(String(label||'').trim()); if(!m) return null; const col=lettersToIndex(m[1].toUpperCase()); const row=Number(m[2])-1; if(!Number.isFinite(col)||!Number.isFinite(row)) return null; return {col,row}; }
      function formatRowOneBased(v){ const n=Math.round(v*2)/2; return Number.isInteger(n)?String(n):n.toFixed(1); }
      function toHexLabel(col,row){ return `${indexToLetters(Math.round(col))}${formatRowOneBased(row+1)}`; }
      function hexToWorld(col,row){ const x=col*colStep(); const y=-(row*rowStep() + (col & 1)*(rowStep()/2)); return { x, y }; }
      function worldToHexHalf(world){ const size=GRID.size||1; const qf=(2/3)*(world.x/size); const rf=(((-world.y)/size)/Math.sqrt(3))-(qf/2); const col=Math.round(qf); const rowf=rf + (col - (col & 1))/2; return { col, row:Math.round(rowf*2)/2 }; }
      function snapWorldToHex(world){ const h=worldToHexHalf(world); return hexToWorld(h.col,h.row); }
      function worldToScreen(p){ const w=canvas.clientWidth,h=canvas.clientHeight; return { x:w/2+(p.x-VIEW.cameraWorld.x)*VIEW.zoom, y:h/2+(p.y-VIEW.cameraWorld.y)*VIEW.zoom }; }
      function screenToWorld(x,y){ const w=canvas.clientWidth,h=canvas.clientHeight; return { x:(x-w/2)/VIEW.zoom+VIEW.cameraWorld.x, y:(y-h/2)/VIEW.zoom+VIEW.cameraWorld.y }; }
      function computeBounds(points){ let minX=Infinity,minY=Infinity,maxX=-Infinity,maxY=-Infinity; for(const p of points){ if(p.x<minX)minX=p.x; if(p.x>maxX)maxX=p.x; if(p.y<minY)minY=p.y; if(p.y>maxY)maxY=p.y; } return {minX,minY,maxX,maxY}; }
      function setCanvasForBounds(bounds){ const pad=GRID.size*5; const ww=Math.max(1,bounds.maxX-bounds.minX+pad*2), wh=Math.max(1,bounds.maxY-bounds.minY+pad*2); const maxW=window.innerWidth-40, maxH=Math.max(240,window.innerHeight-120); VIEW.zoom=clamp(Math.min(maxW/ww,maxH/wh),0.2,2); const cssW=Math.max(320,Math.round(ww*VIEW.zoom)), cssH=Math.max(220,Math.round(wh*VIEW.zoom)); const dpr=window.devicePixelRatio||1; canvas.style.width=`${cssW}px`; canvas.style.height=`${cssH}px`; canvas.width=Math.round(cssW*dpr); canvas.height=Math.round(cssH*dpr); ctx.setTransform(dpr,0,0,dpr,0,0); }
      function parsePointList(raw){ return String(raw||'').split(',').map(s=>s.trim()).filter(Boolean).map(s=>s.replace(/\s+/g,'')); }
      function pointInPolygon(point, polygon){
        let inside=false;
        for(let i=0,j=polygon.length-1;i<polygon.length;j=i++){
          const xi=polygon[i].x, yi=polygon[i].y, xj=polygon[j].x, yj=polygon[j].y;
          const intersect=((yi>point.y)!==(yj>point.y)) && (point.x<((xj-xi)*(point.y-yi))/((yj-yi)||1e-9)+xi);
          if(intersect) inside=!inside;
        }
        return inside;
      }
      function pointOnPolygonEdge(point, polygon, eps){
        const eps2=eps*eps;
        for(let i=0;i<polygon.length;i++){
          const a=polygon[i];
          const b=polygon[(i+1)%polygon.length];
          const abx=b.x-a.x, aby=b.y-a.y;
          const apx=point.x-a.x, apy=point.y-a.y;
          const ab2=abx*abx+aby*aby || 1e-9;
          let t=(apx*abx+apy*aby)/ab2;
          t=clamp(t,0,1);
          const cx=a.x+abx*t, cy=a.y+aby*t;
          const dx=point.x-cx, dy=point.y-cy;
          if(dx*dx+dy*dy<=eps2) return true;
        }
        return false;
      }
      const pointInBoundary=(p)=>{
        if(STATE.boundary.length<3) return false;
        if(pointInPolygon(p,STATE.boundary)) return true;
        return pointOnPolygonEdge(p,STATE.boundary,GRID.size*0.01);
      };
      function rotatePointLocal(p,deg){ const r=(deg||0)*Math.PI/180; if(!r) return {x:p.x,y:p.y}; const c=Math.cos(r),s=Math.sin(r); return { x:p.x*c-p.y*s, y:p.x*s+p.y*c }; }
      const worldToLocal=(w,c,rot)=>rotatePointLocal({x:w.x-c.x,y:w.y-c.y},-rot); const localToWorld=(l,c,rot)=>{ const r=rotatePointLocal(l,rot); return {x:c.x+r.x,y:c.y+r.y}; };
      function depthFromAngle(a,hw,hh){
        if(a<=0) return 0;
        const t=clamp(a,0,85)*Math.PI/180;
        return clamp(Math.tan(t)*hw,0,hh-0.001);
      }
      const rectCenterWorld=(r)=>hexToWorld(r.col,r.row); const rectDimsWorld=(r)=>({w:Math.max(1,r.wCols)*colStep(),h:Math.max(0.5,r.hRows)*rowStep()});
      function buildRectShapeLocal(rect){
        const dims=rectDimsWorld(rect), hw=dims.w/2, hh=dims.h/2;
        const sa=clamp(Number(rect.startAngle)||0,-85,85), ea=clamp(Number(rect.endAngle)||0,-85,85);
        const ds=depthFromAngle(Math.abs(sa),hw,hh), de=depthFromAngle(Math.abs(ea),hw,hh);
        const pts=[];
        if(sa>0){
          pts.push({x:-hw,y:-hh+ds},{x:0,y:-hh},{x:hw,y:-hh+ds});
        } else {
          pts.push({x:-hw,y:-hh},{x:hw,y:-hh});
        }
        if(ea>0){
          pts.push({x:hw,y:hh-de},{x:0,y:hh},{x:-hw,y:hh-de});
        } else {
          pts.push({x:hw,y:hh},{x:-hw,y:hh});
        }
        const spine=[{x:0,y:-hh+(sa<0?ds:0)},{x:0,y:hh-(ea<0?de:0)}];
        const cuts=[];
        if(sa<0){ const tip={x:0,y:-hh+ds}; cuts.push([{x:-hw,y:-hh},tip],[{x:hw,y:-hh},tip]); }
        if(ea<0){ const tip={x:0,y:hh-de}; cuts.push([{x:-hw,y:hh},tip],[{x:hw,y:hh},tip]); }
        return { poly:pts, spine, cutLines:cuts, hw, hh, ds, de, sa, ea };
      }
      function rectPolygonWorld(rect){ const c=rectCenterWorld(rect), s=buildRectShapeLocal(rect), rot=Number(rect.rot)||0; return s.poly.map(p=>localToWorld(p,c,rot)); }
      function rectInsideBoundary(rect){ if(STATE.boundary.length<3) return false; for(const p of rectPolygonWorld(rect)){ if(!pointInBoundary(p)) return false; } return true; }
      function getTexturePattern(kind){ const def=TILE_TEXTURES[kind]||TILE_TEXTURES.slate; const img=loadSprite(def.url); if(!img||!img.complete||!img.naturalWidth||!img.naturalHeight) return {pattern:null,color:def.color}; return { pattern:ctx.createPattern(img,'repeat'), color:def.color }; }
      function applyPatternTransform(pattern, scale, rotDeg){ if(!pattern||typeof pattern.setTransform!=='function') return; const s=Math.max(.01,(Number(scale)||0.2)*VIEW.zoom); const m=new DOMMatrix(); m.rotateSelf(rotDeg||0); m.scaleSelf(s,s); pattern.setTransform(m); }
      function polygonPathLocal(g,pts){ if(!pts.length) return; g.beginPath(); g.moveTo(pts[0].x,pts[0].y); for(let i=1;i<pts.length;i++) g.lineTo(pts[i].x,pts[i].y); g.closePath(); }
      function clipLeftHalf(g){ g.beginPath(); g.rect(-100000,-100000,100000,200000); g.clip(); }
      function clipRightHalf(g){ g.beginPath(); g.rect(0,-100000,100000,200000); g.clip(); }
      function drawHexGrid(g){
        if(!gridToggle.checked) return;
        g.save(); g.strokeStyle=`rgba(210,220,240,${GRID.lineAlpha})`; g.lineWidth=GRID.lineWidth;
        const w=canvas.clientWidth,h=canvas.clientHeight, tl=screenToWorld(0,0), br=screenToWorld(w,h);
        const minCol=Math.floor((Math.min(tl.x,br.x)/colStep())-3), maxCol=Math.ceil((Math.max(tl.x,br.x)/colStep())+3);
        const minRow=Math.floor((Math.min(-tl.y,-br.y)/rowStep())-3), maxRow=Math.ceil((Math.max(-tl.y,-br.y)/rowStep())+3);
        const r=GRID.size*VIEW.zoom;
        const baseAngle=0; // flat-top to match battlemat
        for(let c=minCol;c<=maxCol;c++) for(let rr=minRow;rr<=maxRow;rr++){
          const p=worldToScreen(hexToWorld(c,rr)); const pts=[];
          for(let i=0;i<6;i++){ const a=baseAngle+i*Math.PI/3; pts.push({x:p.x+r*Math.cos(a),y:p.y+r*Math.sin(a)}); }
          g.beginPath(); g.moveTo(pts[0].x,pts[0].y); for(let i=1;i<6;i++) g.lineTo(pts[i].x,pts[i].y); g.closePath(); g.stroke();
        }
        g.restore();
      }
      function drawBoundary(g){
        if(STATE.boundary.length<3) return;
        g.save(); g.strokeStyle='#5fa8ff'; g.lineWidth=2; g.setLineDash([8,6]); g.beginPath();
        const p0=worldToScreen(STATE.boundary[0]); g.moveTo(p0.x,p0.y);
        for(let i=1;i<STATE.boundary.length;i++){ const p=worldToScreen(STATE.boundary[i]); g.lineTo(p.x,p.y); }
        g.closePath(); g.stroke(); g.restore();
      }
      function drawRect(g, rect, selected){
        const c=worldToScreen(rectCenterWorld(rect)), rot=Number(rect.rot)||0, shape=buildRectShapeLocal(rect), sc=VIEW.zoom;
        g.save(); g.translate(c.x,c.y); g.rotate((rot*Math.PI)/180);
        const poly=shape.poly.map(p=>({x:p.x*sc,y:p.y*sc}));
        const spine=shape.spine.map(p=>({x:p.x*sc,y:p.y*sc}));
        const cuts=shape.cutLines.map(l=>[{x:l[0].x*sc,y:l[0].y*sc},{x:l[1].x*sc,y:l[1].y*sc}]);
        const tex=getTexturePattern(rect.tileKind||'slate');
        const shadeAlpha=0.10;
        const shadeIf=(dirLocal, clipFn)=>{
          const r=(rot*Math.PI)/180;
          const dx=dirLocal.x*Math.cos(r)-dirLocal.y*Math.sin(r);
          const dy=dirLocal.x*Math.sin(r)+dirLocal.y*Math.cos(r);
          if(dx>0 || dy<0){
            g.save();
            clipFn();
            g.fillStyle=`rgba(0,0,0,${shadeAlpha})`;
            g.fillRect(-100000,-100000,200000,200000);
            g.restore();
          }
        };
        const fillHalf=(left)=>{ g.save(); polygonPathLocal(g,poly); g.clip(); if(left) clipLeftHalf(g); else clipRightHalf(g); if(tex.pattern){ applyPatternTransform(tex.pattern, rect.tileScale||0.2, left?90:270); g.fillStyle=tex.pattern; } else g.fillStyle=tex.color; g.fillRect(-100000,-100000,200000,200000); g.restore(); };
        fillHalf(true); shadeIf({x:-1,y:0},()=>{ polygonPathLocal(g,poly); g.clip(); clipLeftHalf(g); });
        fillHalf(false); shadeIf({x:1,y:0},()=>{ polygonPathLocal(g,poly); g.clip(); clipRightHalf(g); });
        const fillTriangle=(a,b,c,rotDeg)=>{
          g.save();
          g.beginPath(); g.moveTo(a.x,a.y); g.lineTo(b.x,b.y); g.lineTo(c.x,c.y); g.closePath();
          g.clip();
          if(tex.pattern){ applyPatternTransform(tex.pattern, rect.tileScale||0.2, rotDeg); g.fillStyle=tex.pattern; }
          else g.fillStyle=tex.color;
          g.fillRect(-100000,-100000,200000,200000);
          g.restore();
        };
        if(shape.sa<0){
          const tip={x:0,y:(-shape.hh+shape.ds)*sc};
          const a1={x:-shape.hw*sc,y:-shape.hh*sc};
          const b1={x:0,y:-shape.hh*sc};
          const a2={x:0,y:-shape.hh*sc};
          const b2={x:shape.hw*sc,y:-shape.hh*sc};
          fillTriangle(a1,b1,tip,180);
          fillTriangle(a2,b2,tip,180);
          shadeIf({x:0,y:-1},()=>{
            g.beginPath(); g.moveTo(a1.x,a1.y); g.lineTo(b2.x,b2.y); g.lineTo(tip.x,tip.y); g.closePath(); g.clip();
          });
        }
        if(shape.ea<0){
          const tip={x:0,y:(shape.hh-shape.de)*sc};
          const a1={x:-shape.hw*sc,y:shape.hh*sc};
          const b1={x:0,y:shape.hh*sc};
          const a2={x:0,y:shape.hh*sc};
          const b2={x:shape.hw*sc,y:shape.hh*sc};
          fillTriangle(a1,b1,tip,0);
          fillTriangle(a2,b2,tip,0);
          shadeIf({x:0,y:1},()=>{
            g.beginPath(); g.moveTo(a1.x,a1.y); g.lineTo(b2.x,b2.y); g.lineTo(tip.x,tip.y); g.closePath(); g.clip();
          });
        }
        g.strokeStyle=STATE.lineColor; g.lineWidth=Math.max(.5,Number(STATE.lineWidth)||2); g.lineJoin='round'; g.lineCap='round';
        polygonPathLocal(g,poly); g.stroke(); g.beginPath(); g.moveTo(spine[0].x,spine[0].y); g.lineTo(spine[1].x,spine[1].y); g.stroke();
        for(const l of cuts){ g.beginPath(); g.moveTo(l[0].x,l[0].y); g.lineTo(l[1].x,l[1].y); g.stroke(); }
        if(selected){ g.strokeStyle='#6aa9ff'; g.lineWidth=2; polygonPathLocal(g,poly); g.stroke(); }
        g.restore();
      }
      function rectHandles(rect){
        const c=rectCenterWorld(rect), s=buildRectShapeLocal(rect), hw=s.hw, hh=s.hh, rot=Number(rect.rot)||0;
        return [{id:'n',local:{x:0,y:-hh}},{id:'s',local:{x:0,y:hh}},{id:'e',local:{x:hw,y:0}},{id:'w',local:{x:-hw,y:0}},{id:'c',local:{x:0,y:0}}].map(h=>({id:h.id,world:localToWorld(h.local,c,rot)}));
      }
      function drawHandles(g,rect){ g.save(); g.strokeStyle='rgba(255,200,100,.95)'; g.fillStyle='rgba(255,200,100,.22)'; g.lineWidth=2; for(const h of rectHandles(rect)){ const p=worldToScreen(h.world); g.beginPath(); g.arc(p.x,p.y,9,0,Math.PI*2); g.fill(); g.stroke(); } g.restore(); }
      function handleAtScreen(rect,x,y){ for(const h of rectHandles(rect)){ const p=worldToScreen(h.world), dx=x-p.x, dy=y-p.y; if(dx*dx+dy*dy<=18*18) return h.id; } return null; }
      function rectAtScreen(x,y){
        const w=screenToWorld(x,y); const sorted=[...STATE.rects].sort((a,b)=>(Number(a.z)||0)-(Number(b.z)||0));
        for(let i=sorted.length-1;i>=0;i--){ const r=sorted[i], c=rectCenterWorld(r), local=worldToLocal(w,c,Number(r.rot)||0), shape=buildRectShapeLocal(r); if(pointInPolygon(local,shape.poly)) return r; }
        return null;
      }
      function polyWorldPoints(poly){
        return poly.points.map(p=>hexToWorld(p.col,p.row));
      }
      function polySpine(polyPts){
        let minX=Infinity,maxX=-Infinity,minY=Infinity,maxY=-Infinity;
        for(const p of polyPts){ if(p.x<minX)minX=p.x; if(p.x>maxX)maxX=p.x; if(p.y<minY)minY=p.y; if(p.y>maxY)maxY=p.y; }
        const x=(minX+maxX)/2;
        return { a:{x, y:minY}, b:{x, y:maxY} };
      }
      function rotateWorldPoints(points, center, deg){
        if(!deg) return points;
        const r=(deg*Math.PI)/180, c=Math.cos(r), s=Math.sin(r);
        return points.map(p=>{
          const dx=p.x-center.x, dy=p.y-center.y;
          return { x:center.x + dx*c - dy*s, y:center.y + dx*s + dy*c };
        });
      }
      function clipPolyHalfPlane(points, a, b, keepLeft){
        const out=[];
        const side=(p)=> (b.x-a.x)*(p.y-a.y) - (b.y-a.y)*(p.x-a.x);
        for(let i=0;i<points.length;i++){
          const p1=points[i];
          const p2=points[(i+1)%points.length];
          const s1=side(p1);
          const s2=side(p2);
          const in1=keepLeft ? s1>=0 : s1<=0;
          const in2=keepLeft ? s2>=0 : s2<=0;
          if(in1 && in2){
            out.push(p2);
          } else if(in1 && !in2){
            const t=s1/(s1-s2);
            out.push({ x:p1.x + (p2.x-p1.x)*t, y:p1.y + (p2.y-p1.y)*t });
          } else if(!in1 && in2){
            const t=s1/(s1-s2);
            out.push({ x:p1.x + (p2.x-p1.x)*t, y:p1.y + (p2.y-p1.y)*t });
            out.push(p2);
          }
        }
        return out;
      }
      function drawPoly(g, poly, selected){
        const pts0=polyWorldPoints(poly);
        if(pts0.length<3) return;
        const bounds=computeBounds(pts0);
        const center={ x:(bounds.minX+bounds.maxX)/2, y:(bounds.minY+bounds.maxY)/2 };
        const rot=Number(poly.rot)||0;
        let pts=pts0;
        let spine=polySpine(pts0);
        if(rot){
          pts=rotateWorldPoints(pts0, center, rot);
          const sp=rotateWorldPoints([spine.a, spine.b], center, rot);
          spine={ a:sp[0], b:sp[1] };
        }
        const tex=getTexturePattern(poly.tileKind||'slate');
        const shadeAlpha=0.10;
        const spineMid={ x:(spine.a.x+spine.b.x)/2, y:(spine.a.y+spine.b.y)/2 };
        const centroid=(polyPts)=>{
          let x=0,y=0; for(const p of polyPts){ x+=p.x; y+=p.y; }
          const n=Math.max(1,polyPts.length); return { x:x/n, y:y/n };
        };
        const left=clipPolyHalfPlane(pts, spine.a, spine.b, true);
        const right=clipPolyHalfPlane(pts, spine.a, spine.b, false);
        const fillHalf=(halfPts, rotDeg)=>{
          if(halfPts.length<3) return;
          g.save();
          g.beginPath();
          const p0=worldToScreen(halfPts[0]); g.moveTo(p0.x,p0.y);
          for(let i=1;i<halfPts.length;i++){ const p=worldToScreen(halfPts[i]); g.lineTo(p.x,p.y); }
          g.closePath();
          g.clip();
          if(tex.pattern){
            applyPatternTransform(tex.pattern, poly.tileScale||0.2, rotDeg);
            g.fillStyle=tex.pattern;
          } else g.fillStyle=tex.color;
          g.fillRect(0,0,canvas.clientWidth,canvas.clientHeight);
          const cpt=centroid(halfPts);
          const dir={ x:cpt.x-spineMid.x, y:cpt.y-spineMid.y };
          if(dir.x>0 || dir.y<0){
            g.fillStyle=`rgba(0,0,0,${shadeAlpha})`;
            g.fillRect(0,0,canvas.clientWidth,canvas.clientHeight);
          }
          g.restore();
        };
        fillHalf(left, 90);
        fillHalf(right, 270);
        g.save();
        g.strokeStyle=STATE.lineColor; g.lineWidth=Math.max(.5,Number(STATE.lineWidth)||2); g.lineJoin='round'; g.lineCap='round';
        g.beginPath();
        const s0=worldToScreen(pts[0]); g.moveTo(s0.x,s0.y);
        for(let i=1;i<pts.length;i++){ const p=worldToScreen(pts[i]); g.lineTo(p.x,p.y); }
        g.closePath(); g.stroke();
        const sa=worldToScreen(spine.a), sb=worldToScreen(spine.b);
        g.beginPath(); g.moveTo(sa.x,sa.y); g.lineTo(sb.x,sb.y); g.stroke();
        if(selected){
          g.strokeStyle='#6aa9ff'; g.lineWidth=2; g.stroke();
        }
        g.restore();
      }
      function polyHandles(poly){
        const pts0=polyWorldPoints(poly);
        const bounds=computeBounds(pts0);
        const center={ x:(bounds.minX+bounds.maxX)/2, y:(bounds.minY+bounds.maxY)/2 };
        const rot=Number(poly.rot)||0;
        let pts=pts0;
        if(rot) pts=rotateWorldPoints(pts0, center, rot);
        return pts.map((p,idx)=>({ idx, world: p }));
      }
      function drawPolyHandles(g, poly){
        g.save(); g.strokeStyle='rgba(255,200,100,.95)'; g.fillStyle='rgba(255,200,100,.22)'; g.lineWidth=2;
        for(const h of polyHandles(poly)){ const p=worldToScreen(h.world); g.beginPath(); g.arc(p.x,p.y,8,0,Math.PI*2); g.fill(); g.stroke(); }
        g.restore();
      }
      function polyHandleAtScreen(poly, x, y){
        for(const h of polyHandles(poly)){
          const p=worldToScreen(h.world);
          const dx=x-p.x, dy=y-p.y;
          if(dx*dx+dy*dy<=16*16) return h;
        }
        return null;
      }
      function polyAtScreen(x,y){
        const world=screenToWorld(x,y);
        const sorted=[...STATE.polys].sort((a,b)=>(Number(a.z)||0)-(Number(b.z)||0));
        for(let i=sorted.length-1;i>=0;i--){
          const poly=sorted[i];
          const pts0=polyWorldPoints(poly);
          const bounds=computeBounds(pts0);
          const center={ x:(bounds.minX+bounds.maxX)/2, y:(bounds.minY+bounds.maxY)/2 };
          const rot=Number(poly.rot)||0;
          let pts=pts0;
          if(rot) pts=rotateWorldPoints(pts0, center, rot);
          if(pointInPolygon(world,pts)) return poly;
        }
        return null;
      }
      function drawPreview(g){
        if(STATE.preview){
          const a=worldToScreen(STATE.preview.a), b=worldToScreen(STATE.preview.b);
          g.save(); g.strokeStyle='#6ee787'; g.lineWidth=2; g.setLineDash([6,4]);
          g.strokeRect(Math.min(a.x,b.x),Math.min(a.y,b.y),Math.abs(a.x-b.x),Math.abs(a.y-b.y));
          g.restore();
        }
        if(STATE.polyDraft && STATE.polyDraft.length){
          g.save(); g.strokeStyle='#6ee787'; g.lineWidth=2; g.setLineDash([6,4]);
          const p0=worldToScreen(hexToWorld(STATE.polyDraft[0].col, STATE.polyDraft[0].row));
          g.beginPath(); g.moveTo(p0.x,p0.y);
          for(let i=1;i<STATE.polyDraft.length;i++){
            const p=worldToScreen(hexToWorld(STATE.polyDraft[i].col, STATE.polyDraft[i].row));
            g.lineTo(p.x,p.y);
          }
          if(STATE.polyHover){
            const p=worldToScreen(STATE.polyHover);
            g.lineTo(p.x,p.y);
          }
          g.stroke();
          g.restore();
        }
      }
      function render(){
        const w=canvas.clientWidth,h=canvas.clientHeight;
        ctx.clearRect(0,0,w,h);
        drawHexGrid(ctx);
        drawBoundary(ctx);
        const items=[
          ...STATE.rects.map(r=>({type:'rect', z:Number(r.z)||0, item:r})),
          ...STATE.polys.map(p=>({type:'poly', z:Number(p.z)||0, item:p}))
        ].sort((a,b)=>a.z-b.z);
        for(const it of items){
          if(it.type==='rect') drawRect(ctx, it.item, STATE.selection && STATE.selection.type==='rect' && STATE.selection.id===it.item.id);
          else drawPoly(ctx, it.item, STATE.selection && STATE.selection.type==='poly' && STATE.selection.id===it.item.id);
        }
        if(STATE.selection){
          if(STATE.selection.type==='rect'){
            const sel=STATE.rects.find(r=>r.id===STATE.selection.id);
            if(sel) drawHandles(ctx,sel);
          } else {
            const sel=STATE.polys.find(p=>p.id===STATE.selection.id);
            if(sel) drawPolyHandles(ctx,sel);
          }
        }
        drawPreview(ctx);
        if(info) info.textContent=`${STATE.points.length} points | ${STATE.rects.length} rects | ${STATE.polys.length} polys | mode: ${STATE.mode} | tool: ${STATE.tool}`;
      }
      const cloneState=()=>({ rects: JSON.parse(JSON.stringify(STATE.rects)), polys: JSON.parse(JSON.stringify(STATE.polys)) });
      function pushHistorySnapshot(snapshot){ STATE.historyPast.push(snapshot); if(STATE.historyPast.length>HISTORY_MAX) STATE.historyPast.shift(); STATE.historyFuture=[]; }
      function undo(){ if(!STATE.historyPast.length) return; STATE.historyFuture.push(cloneState()); const snap=STATE.historyPast.pop(); STATE.rects=snap.rects; STATE.polys=snap.polys; if(STATE.selection && !findSelection()) STATE.selection=null; render(); }
      function redo(){ if(!STATE.historyFuture.length) return; STATE.historyPast.push(cloneState()); if(STATE.historyPast.length>HISTORY_MAX) STATE.historyPast.shift(); const snap=STATE.historyFuture.pop(); STATE.rects=snap.rects; STATE.polys=snap.polys; if(STATE.selection && !findSelection()) STATE.selection=null; render(); }
      function findSelection(){
        if(!STATE.selection) return null;
        if(STATE.selection.type==='rect') return STATE.rects.find(r=>r.id===STATE.selection.id) || null;
        if(STATE.selection.type==='poly') return STATE.polys.find(p=>p.id===STATE.selection.id) || null;
        return null;
      }
      function syncSelectedControls(){
        const sel=findSelection();
        if(!sel) return;
        if(STATE.selection.type==='rect'){
          startAngleEl.value=String(sel.startAngle||0);
          endAngleEl.value=String(sel.endAngle||0);
          rectRotEl.value=String(sel.rot||0);
        } else {
          rectRotEl.value=String(sel.rot||0);
        }
        rectZEl.value=String(sel.z||0);
        tileKindEl.value=sel.tileKind||'slate';
        tileScaleEl.value=String(sel.tileScale||0.2);
      }
      function applyBoundary(raw){
        const labels=parsePointList(raw); const points=labels.map(parseHexLabel).filter(Boolean).map(h=>hexToWorld(h.col,h.row));
        if(points.length<3){ if(info) info.textContent='Enter at least 3 points'; return; }
        STATE.points=labels; STATE.boundary=points; const b=computeBounds(points); VIEW.cameraWorld={x:(b.minX+b.maxX)/2,y:(b.minY+b.maxY)/2}; setCanvasForBounds(b); render();
      }
      function previewToRect(pre){
        const minX=Math.min(pre.a.x,pre.b.x), maxX=Math.max(pre.a.x,pre.b.x), minY=Math.min(pre.a.y,pre.b.y), maxY=Math.max(pre.a.y,pre.b.y);
        const centerH=worldToHexHalf({x:(minX+maxX)/2,y:(minY+maxY)/2});
        const wCols=Math.max(1,Math.round((maxX-minX)/colStep()));
        const halfRS=rowStep()*0.5;
        const hRows=Math.max(0.5,Math.round(((maxY-minY)/halfRS))/2);
        return { id:`rect_${Date.now().toString(36)}_${Math.random().toString(36).slice(2,6)}`, col:centerH.col, row:centerH.row, wCols, hRows, rot:Number(rectRotEl.value)||0, startAngle:clamp(Number(startAngleEl.value)||0,-85,85), endAngle:clamp(Number(endAngleEl.value)||0,-85,85), tileKind:tileKindEl.value, tileScale:Number(tileScaleEl.value)||0.2, z:Number(rectZEl.value)||STATE.rects.length };
      }
      function setMode(mode){
        STATE.mode=mode;
        btnModeDraw.classList.toggle('active',mode==='draw');
        btnModeSelect.classList.toggle('active',mode==='select');
        if(mode!=='draw'){ STATE.preview=null; STATE.polyDraft=null; STATE.polyHover=null; }
      }
      function setTool(tool){
        STATE.tool=tool;
        btnToolRect.classList.toggle('active',tool==='rect');
        btnToolPoly.classList.toggle('active',tool==='poly');
        STATE.preview=null;
        STATE.polyDraft=null;
        STATE.polyHover=null;
      }

      canvas.addEventListener('mousedown',(ev)=>{
        const rc=canvas.getBoundingClientRect(); const sx=ev.clientX-rc.left, sy=ev.clientY-rc.top; const w=snapWorldToHex(screenToWorld(sx,sy));
        if(STATE.mode==='draw'){
          if(STATE.tool==='rect'){ STATE.preview={a:w,b:w}; drag={type:'draw-rect'}; render(); return; }
          if(STATE.tool==='poly'){
            if(!STATE.polyDraft) STATE.polyDraft=[];
            const h=worldToHexHalf(w);
            const next={ col:h.col, row:h.row };
            if(STATE.polyDraft.length>=3){
              const first=STATE.polyDraft[0];
              const fp=worldToScreen(hexToWorld(first.col, first.row));
              const dx=sx-fp.x, dy=sy-fp.y;
              if(dx*dx+dy*dy<16*16){
                const poly={ id:`poly_${Date.now().toString(36)}_${Math.random().toString(36).slice(2,6)}`, points:[...STATE.polyDraft], rot:Number(rectRotEl.value)||0, tileKind:tileKindEl.value, tileScale:Number(tileScaleEl.value)||0.2, z:Number(rectZEl.value)||STATE.polys.length };
                if(poly.points.length>=3){ pushHistorySnapshot(cloneState()); STATE.polys.push(poly); STATE.selection={type:'poly', id:poly.id}; syncSelectedControls(); }
                STATE.polyDraft=null; render(); return;
              }
            }
            STATE.polyDraft.push(next);
            render();
            return;
          }
        }

        if(STATE.selection){
          if(STATE.selection.type==='rect'){
            const sel=STATE.rects.find(r=>r.id===STATE.selection.id);
            if(sel){ const h=handleAtScreen(sel,sx,sy); if(h){ drag={type:'rect-handle',id:sel.id,handle:h,startSnapshot:cloneState()}; return; } }
          } else {
            const sel=STATE.polys.find(p=>p.id===STATE.selection.id);
            if(sel){
              const h=polyHandleAtScreen(sel,sx,sy);
              if(h){ drag={type:'poly-handle',id:sel.id,idx:h.idx,world:h.world,startSnapshot:cloneState()}; return; }
            }
          }
        }

        const hitPoly=polyAtScreen(sx,sy);
        if(hitPoly){ STATE.selection={type:'poly', id:hitPoly.id}; syncSelectedControls(); render(); return; }
        const hitRect=rectAtScreen(sx,sy);
        if(hitRect){ STATE.selection={type:'rect', id:hitRect.id}; syncSelectedControls(); const c=rectCenterWorld(hitRect); drag={type:'rect-move',id:hitRect.id,offset:{x:c.x-w.x,y:c.y-w.y},startSnapshot:cloneState()}; render(); return; }
        STATE.selection=null; render();
      });

      window.addEventListener('mousemove',(ev)=>{
        const rc=canvas.getBoundingClientRect(); const sx=ev.clientX-rc.left, sy=ev.clientY-rc.top; const w=snapWorldToHex(screenToWorld(sx,sy));
        if(!drag){
          if(STATE.mode==='draw' && STATE.tool==='poly' && STATE.polyDraft){
            STATE.polyHover=w; render();
          }
          return;
        }
        if(drag.type==='draw-rect'){ STATE.preview.b=w; render(); return; }
        if(drag.type==='rect-move'){
          const t=STATE.rects.find(r=>r.id===drag.id); if(!t) return;
          const h=worldToHexHalf({x:w.x+drag.offset.x,y:w.y+drag.offset.y}); const cand={...t,col:h.col,row:h.row};
          if(rectInsideBoundary(cand)){ t.col=cand.col; t.row=cand.row; render(); }
          return;
        }
        if(drag.type==='rect-handle'){
          const t=STATE.rects.find(r=>r.id===drag.id); if(!t) return;
          if(drag.handle==='c'){
            const h=worldToHexHalf(w);
            const cand={...t,col:h.col,row:h.row};
            if(rectInsideBoundary(cand)){ t.col=cand.col; t.row=cand.row; render(); }
            return;
          }
          const rot=Number(t.rot)||0;
          const c=rectCenterWorld(t);
          const local=worldToLocal(w,c,rot);
          const dims=rectDimsWorld(t);
          let hw=dims.w/2, hh=dims.h/2;
          const minHW=colStep()*0.5, minHH=rowStep()*0.25;
          let newCenterLocal={x:0,y:0};
          if(drag.handle==='n' || drag.handle==='s'){
            const top = (drag.handle==='n') ? Math.min(local.y, hh - minHH) : -hh;
            const bottom = (drag.handle==='s') ? Math.max(local.y, -hh + minHH) : hh;
            const newHH = Math.max(minHH, (bottom - top)/2);
            newCenterLocal.y = (top + bottom)/2;
            hh = newHH;
          }
          if(drag.handle==='e' || drag.handle==='w'){
            const left = (drag.handle==='w') ? Math.min(local.x, hw - minHW) : -hw;
            const right = (drag.handle==='e') ? Math.max(local.x, -hw + minHW) : hw;
            const newHW = Math.max(minHW, (right - left)/2);
            newCenterLocal.x = (left + right)/2;
            hw = newHW;
          }
          const newCenterWorld=localToWorld(newCenterLocal,c,rot);
          const centerHex=worldToHexHalf(newCenterWorld);
          const halfRS=rowStep()*0.5;
          const wCols=Math.max(1,Math.round((hw*2)/colStep()));
          const hRows=Math.max(0.5,Math.round(((hh*2)/halfRS))/2);
          const cand={...t,col:centerHex.col,row:centerHex.row,wCols,hRows};
          if(rectInsideBoundary(cand)){ t.col=cand.col; t.row=cand.row; t.wCols=wCols; t.hRows=hRows; render(); }
          return;
        }
        if(drag.type==='poly-handle'){
          const poly=STATE.polys.find(p=>p.id===drag.id); if(!poly) return;
          const bounds=computeBounds(polyWorldPoints(poly));
          const center={ x:(bounds.minX+bounds.maxX)/2, y:(bounds.minY+bounds.maxY)/2 };
          const rot=Number(poly.rot)||0;
          let worldRaw=screenToWorld(sx,sy);
          if(rot){
            const r=(-rot*Math.PI)/180;
            const dx=worldRaw.x-center.x, dy=worldRaw.y-center.y;
            worldRaw={ x:center.x + dx*Math.cos(r) - dy*Math.sin(r), y:center.y + dx*Math.sin(r) + dy*Math.cos(r) };
          }
          const snap=snapWorldToHex(worldRaw);
          const h=worldToHexHalf(snap);
          const next={ col:h.col, row:h.row };
          const candidateWorld=hexToWorld(next.col,next.row);
          if(pointInBoundary(candidateWorld)){ poly.points[drag.idx]=next; render(); }
        }
      });

      window.addEventListener('mouseup',()=>{
        if(!drag) return;
        if(drag.type==='draw-rect'&&STATE.preview){
          const r=previewToRect(STATE.preview);
          if(rectInsideBoundary(r)){ pushHistorySnapshot(cloneState()); STATE.rects.push(r); STATE.selection={type:'rect', id:r.id}; syncSelectedControls(); }
          STATE.preview=null; drag=null; render(); return;
        }
        if((drag.type==='rect-move'||drag.type==='rect-handle'||drag.type==='poly-handle')&&drag.startSnapshot){
          if(JSON.stringify(drag.startSnapshot)!==JSON.stringify(cloneState())) pushHistorySnapshot(drag.startSnapshot);
        }
        drag=null; render();
      });
      btnApply.addEventListener('click',()=>applyBoundary(pointsInput.value));
      btnModeDraw.addEventListener('click',()=>setMode('draw'));
      btnModeSelect.addEventListener('click',()=>setMode('select'));
      btnToolRect.addEventListener('click',()=>setTool('rect'));
      btnToolPoly.addEventListener('click',()=>setTool('poly'));

      btnDelete.addEventListener('click',()=>{
        if(!STATE.selection) return;
        const before=cloneState();
        if(STATE.selection.type==='rect'){
          const idx=STATE.rects.findIndex(r=>r.id===STATE.selection.id);
          if(idx>=0) STATE.rects.splice(idx,1);
        } else if(STATE.selection.type==='poly'){
          const idx=STATE.polys.findIndex(p=>p.id===STATE.selection.id);
          if(idx>=0) STATE.polys.splice(idx,1);
        }
        STATE.selection=null;
        pushHistorySnapshot(before);
        render();
      });

      function applyToSelectedAny(mutator){
        const sel=findSelection(); if(!sel) return;
        const before=cloneState(); mutator(sel);
        if(STATE.selection.type==='rect' && !rectInsideBoundary(sel)){ STATE.rects=before.rects; STATE.polys=before.polys; return; }
        pushHistorySnapshot(before); render();
      }
      function applyToSelectedRect(mutator){
        const sel=findSelection(); if(!sel || STATE.selection.type!=='rect') return;
        const before=cloneState(); mutator(sel);
        if(!rectInsideBoundary(sel)){ STATE.rects=before.rects; STATE.polys=before.polys; return; }
        pushHistorySnapshot(before); render();
      }

      startAngleEl.addEventListener('input',()=>applyToSelectedRect(r=>{ r.startAngle=clamp(Number(startAngleEl.value)||0,-85,85); }));
      endAngleEl.addEventListener('input',()=>applyToSelectedRect(r=>{ r.endAngle=clamp(Number(endAngleEl.value)||0,-85,85); }));
      rectRotEl.addEventListener('change',()=>applyToSelectedAny(r=>{ r.rot=Number(rectRotEl.value)||0; }));
      rectZEl.addEventListener('input',()=>applyToSelectedAny(r=>{ r.z=Number(rectZEl.value)||0; }));
      tileKindEl.addEventListener('change',()=>applyToSelectedAny(r=>{ r.tileKind=tileKindEl.value; }));
      tileScaleEl.addEventListener('input',()=>applyToSelectedAny(r=>{ r.tileScale=Number(tileScaleEl.value)||0.2; }));

      btnFront.addEventListener('click',()=>{
        const sel=findSelection(); if(!sel) return;
        const maxZ=Math.max(0,...STATE.rects.map(r=>Number(r.z)||0),...STATE.polys.map(p=>Number(p.z)||0));
        const before=cloneState(); sel.z=maxZ+1; rectZEl.value=String(sel.z); pushHistorySnapshot(before); render();
      });
      btnBack.addEventListener('click',()=>{
        const sel=findSelection(); if(!sel) return;
        const minZ=Math.min(0,...STATE.rects.map(r=>Number(r.z)||0),...STATE.polys.map(p=>Number(p.z)||0));
        const before=cloneState(); sel.z=minZ-1; rectZEl.value=String(sel.z); pushHistorySnapshot(before); render();
      });

      lineColorEl.addEventListener('input',()=>{ STATE.lineColor=lineColorEl.value; render(); });
      lineWidthEl.addEventListener('input',()=>{ STATE.lineWidth=Math.max(0.5,Number(lineWidthEl.value)||2); render(); });

      btnUndo.addEventListener('click',undo);
      btnRedo.addEventListener('click',redo);
      window.addEventListener('keydown',(ev)=>{
        if((ev.ctrlKey||ev.metaKey)&&ev.key.toLowerCase()==='z'){ ev.preventDefault(); undo(); }
        if((ev.ctrlKey||ev.metaKey)&&ev.key.toLowerCase()==='y'){ ev.preventDefault(); redo(); }
      });

      btnExportPng.addEventListener('click',()=>{ const a=document.createElement('a'); a.download='roof_design2.png'; a.href=canvas.toDataURL('image/png'); a.click(); });
      btnCopyJson.addEventListener('click',async()=>{
        const payload={
          points:STATE.points,
          rects:STATE.rects.map(r=>({ id:r.id, center_hex:toHexLabel(r.col,r.row), width_cols:r.wCols, height_rows:r.hRows, rot:r.rot, start_angle:r.startAngle, end_angle:r.endAngle, tile:r.tileKind, tile_scale:r.tileScale, z:r.z })),
          style:{ line_color:STATE.lineColor, line_width:STATE.lineWidth }
        };
        try{ await navigator.clipboard.writeText(JSON.stringify(payload,null,2)); if(info) info.textContent='Copied JSON'; } catch { if(info) info.textContent='Copy failed'; }
      });

      window.addEventListener('resize',()=>{ if(STATE.boundary.length<3) return; const b=computeBounds(STATE.boundary); setCanvasForBounds(b); render(); });

      pointsInput.value=DEFAULT_POINTS;
      applyBoundary(DEFAULT_POINTS);
    })();
  </script>
</body>
</html>

