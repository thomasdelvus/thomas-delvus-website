<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Roof Designer 2</title>
  <style>
    :root { color-scheme: dark; --bg:#0b0f14; --panel:rgba(18,22,30,.96); --panel-border:rgba(255,255,255,.08); --text:#e6e9ef; --muted:#9aa5b1; --accent:#6aa9ff; }
    * { box-sizing: border-box; }
    body { margin:0; background:var(--bg); color:var(--text); font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,sans-serif; }
    #toolbar { position:sticky; top:0; z-index:10; display:flex; align-items:center; gap:10px; padding:10px 12px; background:var(--panel); border-bottom:1px solid var(--panel-border); flex-wrap:wrap; }
    #toolbar label { font-size:12px; color:var(--muted); }
    #toolbar input[type="text"], #toolbar input[type="number"], #toolbar select { padding:6px 8px; border-radius:6px; border:1px solid var(--panel-border); background:#0f141c; color:var(--text); }
    #pointsInput { min-width:420px; max-width:70vw; }
    #toolbar button { padding:6px 10px; border-radius:6px; border:1px solid var(--panel-border); background:#0f141c; color:var(--text); cursor:pointer; }
    #toolbar button.active { border-color:var(--accent); box-shadow:0 0 0 1px rgba(106,169,255,.35); }
    .group { display:inline-flex; align-items:center; gap:6px; padding-right:8px; border-right:1px solid rgba(255,255,255,.06); }
    .info { margin-left:auto; font-size:12px; color:var(--muted); }
    #canvasWrap { padding:16px; }
    canvas { display:block; background:#0b0f14; border:1px solid rgba(255,255,255,.08); border-radius:8px; }
  </style>
</head>
<body>
  <div id="toolbar">
    <div class="group">
      <label for="pointsInput">Points</label>
      <input id="pointsInput" type="text" />
      <button id="btnApply">Apply</button>
    </div>
    <div class="group">
      <label>Mode</label>
      <button id="btnModeDraw" class="active">Draw</button>
      <button id="btnModeSelect">Select</button>
      <button id="btnDelete">Delete</button>
    </div>
    <div class="group">
      <label>Start°</label><input id="startAngle" type="number" step="1" value="0" min="-85" max="85" />
      <label>End°</label><input id="endAngle" type="number" step="1" value="0" min="-85" max="85" />
      <label>Rot</label><select id="rectRot"><option value="0" selected>0</option><option value="90">90</option><option value="180">180</option><option value="270">270</option></select>
      <label>Z</label><input id="rectZ" type="number" step="1" value="0" />
      <button id="btnFront">Front</button><button id="btnBack">Back</button>
    </div>
    <div class="group">
      <label>Tile</label><select id="tileKind"><option value="slate" selected>slate</option><option value="thatch">thatch</option><option value="terracotta">terracotta</option><option value="grass">grass</option></select>
      <label>Scale</label><input id="tileScale" type="number" step="0.01" value="0.20" />
    </div>
    <div class="group">
      <label>Line</label><input id="lineColor" type="color" value="#4b4f54" />
      <label>W</label><input id="lineWidth" type="number" step="0.5" value="2" />
    </div>
    <div class="group">
      <button id="btnUndo">Undo</button><button id="btnRedo">Redo</button><button id="btnExportPng">Export PNG</button><button id="btnCopyJson">Copy JSON</button>
    </div>
    <label><input type="checkbox" id="gridToggle" checked /> Hexgrid</label>
    <span id="info" class="info"></span>
  </div>
  <div id="canvasWrap"><canvas id="canvas"></canvas></div>
  <script>
    (() => {
      const DEFAULT_POINTS = 'HA96.5, HA87.5, HK87.5, HK85, HX84.5, HX96';
      const GRID = { size: 32, lineAlpha: 0.22, lineWidth: 1.1 };
      const VIEW = { cameraWorld: { x: 0, y: 0 }, zoom: 1 };
      const HISTORY_MAX = 20;
      const STATE = { points: [], boundary: [], rects: [], mode: 'draw', selectionId: null, preview: null, lineColor: '#4b4f54', lineWidth: 2, historyPast: [], historyFuture: [] };
      const TILE_TEXTURES = { slate:{url:'/assets/sprites/slate.png',color:'#3a434a'}, terracotta:{url:'/assets/sprites/terracotta.png',color:'#6a3a2a'}, thatch:{url:'/assets/sprites/thatch.png',color:'#6a5a3a'}, grass:{url:'/assets/sprites/grass.png',color:'#2f5a2f'} };
      const spriteCache = new Map();
      function loadSprite(url){ if(spriteCache.has(url)) return spriteCache.get(url); const img=new Image(); img.src=url; spriteCache.set(url,img); img.onload=render; return img; }
      const canvas=document.getElementById('canvas'); const ctx=canvas.getContext('2d');
      const pointsInput=document.getElementById('pointsInput'); const btnApply=document.getElementById('btnApply');
      const btnModeDraw=document.getElementById('btnModeDraw'); const btnModeSelect=document.getElementById('btnModeSelect'); const btnDelete=document.getElementById('btnDelete');
      const startAngleEl=document.getElementById('startAngle'); const endAngleEl=document.getElementById('endAngle'); const rectRotEl=document.getElementById('rectRot'); const rectZEl=document.getElementById('rectZ');
      const btnFront=document.getElementById('btnFront'); const btnBack=document.getElementById('btnBack');
      const tileKindEl=document.getElementById('tileKind'); const tileScaleEl=document.getElementById('tileScale');
      const lineColorEl=document.getElementById('lineColor'); const lineWidthEl=document.getElementById('lineWidth');
      const btnUndo=document.getElementById('btnUndo'); const btnRedo=document.getElementById('btnRedo'); const btnExportPng=document.getElementById('btnExportPng'); const btnCopyJson=document.getElementById('btnCopyJson');
      const gridToggle=document.getElementById('gridToggle'); const info=document.getElementById('info');
      let drag=null;
      const clamp=(v,a,b)=>Math.max(a,Math.min(b,v)); const colStep=()=>1.5*GRID.size; const rowStep=()=>Math.sqrt(3)*GRID.size;
      function indexToLetters(idx){ let n=idx,out=''; while(n>=0){ out=String.fromCharCode(65+(n%26))+out; n=Math.floor(n/26)-1; } return out; }
      function lettersToIndex(letters){ let n=0; for(let i=0;i<letters.length;i++) n=n*26+(letters.charCodeAt(i)-64); return n-1; }
      function parseHexLabel(label){ const m=/^([A-Za-z]+)(\d+(?:\.5)?)$/.exec(String(label||'').trim()); if(!m) return null; const col=lettersToIndex(m[1].toUpperCase()); const row=Number(m[2])-1; if(!Number.isFinite(col)||!Number.isFinite(row)) return null; return {col,row}; }
      function formatRowOneBased(v){ const n=Math.round(v*2)/2; return Number.isInteger(n)?String(n):n.toFixed(1); }
      function toHexLabel(col,row){ return `${indexToLetters(Math.round(col))}${formatRowOneBased(row+1)}`; }
      function hexToWorld(col,row){ const x=col*colStep(); const y=-(row*rowStep() + (col & 1)*(rowStep()/2)); return { x, y }; }
      function worldToHexHalf(world){ const size=GRID.size||1; const qf=(2/3)*(world.x/size); const rf=(((-world.y)/size)/Math.sqrt(3))-(qf/2); const col=Math.round(qf); const rowf=rf + (col - (col & 1))/2; return { col, row:Math.round(rowf*2)/2 }; }
      function snapWorldToHex(world){ const h=worldToHexHalf(world); return hexToWorld(h.col,h.row); }
      function worldToScreen(p){ const w=canvas.clientWidth,h=canvas.clientHeight; return { x:w/2+(p.x-VIEW.cameraWorld.x)*VIEW.zoom, y:h/2+(p.y-VIEW.cameraWorld.y)*VIEW.zoom }; }
      function screenToWorld(x,y){ const w=canvas.clientWidth,h=canvas.clientHeight; return { x:(x-w/2)/VIEW.zoom+VIEW.cameraWorld.x, y:(y-h/2)/VIEW.zoom+VIEW.cameraWorld.y }; }
      function computeBounds(points){ let minX=Infinity,minY=Infinity,maxX=-Infinity,maxY=-Infinity; for(const p of points){ if(p.x<minX)minX=p.x; if(p.x>maxX)maxX=p.x; if(p.y<minY)minY=p.y; if(p.y>maxY)maxY=p.y; } return {minX,minY,maxX,maxY}; }
      function setCanvasForBounds(bounds){ const pad=GRID.size*5; const ww=Math.max(1,bounds.maxX-bounds.minX+pad*2), wh=Math.max(1,bounds.maxY-bounds.minY+pad*2); const maxW=window.innerWidth-40, maxH=Math.max(240,window.innerHeight-120); VIEW.zoom=clamp(Math.min(maxW/ww,maxH/wh),0.2,2); const cssW=Math.max(320,Math.round(ww*VIEW.zoom)), cssH=Math.max(220,Math.round(wh*VIEW.zoom)); const dpr=window.devicePixelRatio||1; canvas.style.width=`${cssW}px`; canvas.style.height=`${cssH}px`; canvas.width=Math.round(cssW*dpr); canvas.height=Math.round(cssH*dpr); ctx.setTransform(dpr,0,0,dpr,0,0); }
      function parsePointList(raw){ return String(raw||'').split(',').map(s=>s.trim()).filter(Boolean).map(s=>s.replace(/\s+/g,'')); }
      function pointInPolygon(point, polygon){ let inside=false; for(let i=0,j=polygon.length-1;i<polygon.length;j=i++){ const xi=polygon[i].x, yi=polygon[i].y, xj=polygon[j].x, yj=polygon[j].y; const intersect=((yi>point.y)!==(yj>point.y)) && (point.x<((xj-xi)*(point.y-yi))/((yj-yi)||1e-9)+xi); if(intersect) inside=!inside; } return inside; }
      const pointInBoundary=(p)=> STATE.boundary.length>=3 && pointInPolygon(p,STATE.boundary);
      function rotatePointLocal(p,deg){ const r=(deg||0)*Math.PI/180; if(!r) return {x:p.x,y:p.y}; const c=Math.cos(r),s=Math.sin(r); return { x:p.x*c-p.y*s, y:p.x*s+p.y*c }; }
      const worldToLocal=(w,c,rot)=>rotatePointLocal({x:w.x-c.x,y:w.y-c.y},-rot); const localToWorld=(l,c,rot)=>{ const r=rotatePointLocal(l,rot); return {x:c.x+r.x,y:c.y+r.y}; };
      function depthFromAngle(a,hw,hh){ if(a<1) return 0; const t=clamp(a,1,85)*Math.PI/180; return clamp(hw/Math.tan(t),0,hh-0.001); }
      const rectCenterWorld=(r)=>hexToWorld(r.col,r.row); const rectDimsWorld=(r)=>({w:Math.max(1,r.wCols)*colStep(),h:Math.max(0.5,r.hRows)*rowStep()});
      function buildRectShapeLocal(rect){
        const dims=rectDimsWorld(rect), hw=dims.w/2, hh=dims.h/2;
        const sa=clamp(Number(rect.startAngle)||0,-85,85), ea=clamp(Number(rect.endAngle)||0,-85,85);
        const ds=depthFromAngle(Math.abs(sa),hw,hh), de=depthFromAngle(Math.abs(ea),hw,hh);
        const pts=[];
        if(sa>0){ pts.push({x:-hw,y:-hh+ds},{x:0,y:-hh},{x:hw,y:-hh+ds}); }
        else if(sa<0){ pts.push({x:-hw,y:-hh},{x:0,y:-hh+ds},{x:hw,y:-hh}); }
        else { pts.push({x:-hw,y:-hh},{x:hw,y:-hh}); }
        if(ea>0){ pts.push({x:hw,y:hh-de},{x:0,y:hh},{x:-hw,y:hh-de}); }
        else if(ea<0){ pts.push({x:hw,y:hh},{x:0,y:hh-de},{x:-hw,y:hh}); }
        else { pts.push({x:hw,y:hh},{x:-hw,y:hh}); }
        const spine=[{x:0,y:-hh+(sa<0?ds:0)},{x:0,y:hh-(ea<0?de:0)}];
        const cuts=[];
        if(sa!==0){ const tip=sa>0?{x:0,y:-hh}:{x:0,y:-hh+ds}; cuts.push([{x:-hw,y:-hh},tip],[{x:hw,y:-hh},tip]); }
        if(ea!==0){ const tip=ea>0?{x:0,y:hh}:{x:0,y:hh-de}; cuts.push([{x:-hw,y:hh},tip],[{x:hw,y:hh},tip]); }
        return { poly:pts, spine, cutLines:cuts, hw, hh };
      }
      function rectPolygonWorld(rect){ const c=rectCenterWorld(rect), s=buildRectShapeLocal(rect), rot=Number(rect.rot)||0; return s.poly.map(p=>localToWorld(p,c,rot)); }
      function rectInsideBoundary(rect){ if(STATE.boundary.length<3) return false; for(const p of rectPolygonWorld(rect)){ if(!pointInBoundary(p)) return false; } return true; }
      function getTexturePattern(kind){ const def=TILE_TEXTURES[kind]||TILE_TEXTURES.slate; const img=loadSprite(def.url); if(!img||!img.complete||!img.naturalWidth||!img.naturalHeight) return {pattern:null,color:def.color}; return { pattern:ctx.createPattern(img,'repeat'), color:def.color }; }
      function applyPatternTransform(pattern, scale, rotDeg){ if(!pattern||typeof pattern.setTransform!=='function') return; const s=Math.max(.01,(Number(scale)||0.2)*VIEW.zoom); const m=new DOMMatrix(); m.rotateSelf(rotDeg||0); m.scaleSelf(s,s); pattern.setTransform(m); }
      function polygonPathLocal(g,pts){ if(!pts.length) return; g.beginPath(); g.moveTo(pts[0].x,pts[0].y); for(let i=1;i<pts.length;i++) g.lineTo(pts[i].x,pts[i].y); g.closePath(); }
      function clipLeftHalf(g){ g.beginPath(); g.rect(-100000,-100000,100000,200000); g.clip(); }
      function clipRightHalf(g){ g.beginPath(); g.rect(0,-100000,100000,200000); g.clip(); }
      function drawHexGrid(g){
        if(!gridToggle.checked) return;
        g.save(); g.strokeStyle=`rgba(210,220,240,${GRID.lineAlpha})`; g.lineWidth=GRID.lineWidth;
        const w=canvas.clientWidth,h=canvas.clientHeight, tl=screenToWorld(0,0), br=screenToWorld(w,h);
        const minCol=Math.floor((Math.min(tl.x,br.x)/colStep())-3), maxCol=Math.ceil((Math.max(tl.x,br.x)/colStep())+3);
        const minRow=Math.floor((Math.min(-tl.y,-br.y)/rowStep())-3), maxRow=Math.ceil((Math.max(-tl.y,-br.y)/rowStep())+3);
        const r=GRID.size*VIEW.zoom;
        const baseAngle=Math.PI/2; // flat-top
        for(let c=minCol;c<=maxCol;c++) for(let rr=minRow;rr<=maxRow;rr++){
          const p=worldToScreen(hexToWorld(c,rr)); const pts=[];
          for(let i=0;i<6;i++){ const a=baseAngle+i*Math.PI/3; pts.push({x:p.x+r*Math.cos(a),y:p.y+r*Math.sin(a)}); }
          g.beginPath(); g.moveTo(pts[0].x,pts[0].y); for(let i=1;i<6;i++) g.lineTo(pts[i].x,pts[i].y); g.closePath(); g.stroke();
        }
        g.restore();
      }
      function drawBoundary(g){
        if(STATE.boundary.length<3) return;
        g.save(); g.strokeStyle='#5fa8ff'; g.lineWidth=2; g.setLineDash([8,6]); g.beginPath();
        const p0=worldToScreen(STATE.boundary[0]); g.moveTo(p0.x,p0.y);
        for(let i=1;i<STATE.boundary.length;i++){ const p=worldToScreen(STATE.boundary[i]); g.lineTo(p.x,p.y); }
        g.closePath(); g.stroke(); g.restore();
      }
      function drawRect(g, rect, selected){
        const c=worldToScreen(rectCenterWorld(rect)), rot=Number(rect.rot)||0, shape=buildRectShapeLocal(rect), sc=VIEW.zoom;
        g.save(); g.translate(c.x,c.y); g.rotate((rot*Math.PI)/180);
        const poly=shape.poly.map(p=>({x:p.x*sc,y:p.y*sc}));
        const spine=shape.spine.map(p=>({x:p.x*sc,y:p.y*sc}));
        const cuts=shape.cutLines.map(l=>[{x:l[0].x*sc,y:l[0].y*sc},{x:l[1].x*sc,y:l[1].y*sc}]);
        const tex=getTexturePattern(rect.tileKind||'slate');
        const fillHalf=(left)=>{ g.save(); polygonPathLocal(g,poly); g.clip(); if(left) clipLeftHalf(g); else clipRightHalf(g); if(tex.pattern){ applyPatternTransform(tex.pattern, rect.tileScale||0.2, left?90:270); g.fillStyle=tex.pattern; } else g.fillStyle=tex.color; g.fillRect(-100000,-100000,200000,200000); g.restore(); };
        fillHalf(true); fillHalf(false);
        g.strokeStyle=STATE.lineColor; g.lineWidth=Math.max(.5,Number(STATE.lineWidth)||2); g.lineJoin='round'; g.lineCap='round';
        polygonPathLocal(g,poly); g.stroke(); g.beginPath(); g.moveTo(spine[0].x,spine[0].y); g.lineTo(spine[1].x,spine[1].y); g.stroke();
        for(const l of cuts){ g.beginPath(); g.moveTo(l[0].x,l[0].y); g.lineTo(l[1].x,l[1].y); g.stroke(); }
        if(selected){ g.strokeStyle='#6aa9ff'; g.lineWidth=2; polygonPathLocal(g,poly); g.stroke(); }
        g.restore();
      }
      function rectHandles(rect){
        const c=rectCenterWorld(rect), s=buildRectShapeLocal(rect), hw=s.hw, hh=s.hh, rot=Number(rect.rot)||0;
        return [{id:'n',local:{x:0,y:-hh}},{id:'s',local:{x:0,y:hh}},{id:'e',local:{x:hw,y:0}},{id:'w',local:{x:-hw,y:0}},{id:'c',local:{x:0,y:0}}].map(h=>({id:h.id,world:localToWorld(h.local,c,rot)}));
      }
      function drawHandles(g,rect){ g.save(); g.strokeStyle='rgba(255,200,100,.95)'; g.fillStyle='rgba(255,200,100,.22)'; g.lineWidth=2; for(const h of rectHandles(rect)){ const p=worldToScreen(h.world); g.beginPath(); g.arc(p.x,p.y,9,0,Math.PI*2); g.fill(); g.stroke(); } g.restore(); }
      function handleAtScreen(rect,x,y){ for(const h of rectHandles(rect)){ const p=worldToScreen(h.world), dx=x-p.x, dy=y-p.y; if(dx*dx+dy*dy<=18*18) return h.id; } return null; }
      function rectAtScreen(x,y){
        const w=screenToWorld(x,y); const sorted=[...STATE.rects].sort((a,b)=>(Number(a.z)||0)-(Number(b.z)||0));
        for(let i=sorted.length-1;i>=0;i--){ const r=sorted[i], c=rectCenterWorld(r), local=worldToLocal(w,c,Number(r.rot)||0), shape=buildRectShapeLocal(r); if(pointInPolygon(local,shape.poly)) return r; }
        return null;
      }
      function drawPreview(g){ if(!STATE.preview) return; const a=worldToScreen(STATE.preview.a), b=worldToScreen(STATE.preview.b); g.save(); g.strokeStyle='#6ee787'; g.lineWidth=2; g.setLineDash([6,4]); g.strokeRect(Math.min(a.x,b.x),Math.min(a.y,b.y),Math.abs(a.x-b.x),Math.abs(a.y-b.y)); g.restore(); }
      function render(){ const w=canvas.clientWidth,h=canvas.clientHeight; ctx.clearRect(0,0,w,h); drawHexGrid(ctx); drawBoundary(ctx); const sorted=[...STATE.rects].sort((a,b)=>(Number(a.z)||0)-(Number(b.z)||0)); for(const r of sorted) drawRect(ctx,r,r.id===STATE.selectionId); const sel=STATE.rects.find(r=>r.id===STATE.selectionId); if(sel) drawHandles(ctx,sel); drawPreview(ctx); if(info) info.textContent=`${STATE.points.length} points | ${STATE.rects.length} rects | mode: ${STATE.mode}`; }
      const cloneRects=()=>JSON.parse(JSON.stringify(STATE.rects));
      function pushHistorySnapshot(snapshot){ STATE.historyPast.push(snapshot); if(STATE.historyPast.length>HISTORY_MAX) STATE.historyPast.shift(); STATE.historyFuture=[]; }
      function undo(){ if(!STATE.historyPast.length) return; STATE.historyFuture.push(cloneRects()); STATE.rects=STATE.historyPast.pop(); if(STATE.selectionId&&!STATE.rects.some(r=>r.id===STATE.selectionId)) STATE.selectionId=null; render(); }
      function redo(){ if(!STATE.historyFuture.length) return; STATE.historyPast.push(cloneRects()); if(STATE.historyPast.length>HISTORY_MAX) STATE.historyPast.shift(); STATE.rects=STATE.historyFuture.pop(); render(); }
      function syncSelectedControls(){ const sel=STATE.rects.find(r=>r.id===STATE.selectionId); if(!sel) return; startAngleEl.value=String(sel.startAngle||0); endAngleEl.value=String(sel.endAngle||0); rectRotEl.value=String(sel.rot||0); rectZEl.value=String(sel.z||0); tileKindEl.value=sel.tileKind||'slate'; tileScaleEl.value=String(sel.tileScale||0.2); }
      function applyBoundary(raw){
        const labels=parsePointList(raw); const points=labels.map(parseHexLabel).filter(Boolean).map(h=>hexToWorld(h.col,h.row));
        if(points.length<3){ if(info) info.textContent='Enter at least 3 points'; return; }
        STATE.points=labels; STATE.boundary=points; const b=computeBounds(points); VIEW.cameraWorld={x:(b.minX+b.maxX)/2,y:(b.minY+b.maxY)/2}; setCanvasForBounds(b); render();
      }
      function previewToRect(pre){
        const minX=Math.min(pre.a.x,pre.b.x), maxX=Math.max(pre.a.x,pre.b.x), minY=Math.min(pre.a.y,pre.b.y), maxY=Math.max(pre.a.y,pre.b.y);
        const centerH=worldToHexHalf({x:(minX+maxX)/2,y:(minY+maxY)/2});
        const wCols=Math.max(1,Math.round((maxX-minX)/colStep()));
        const halfRS=rowStep()*0.5;
        const hRows=Math.max(0.5,Math.round(((maxY-minY)/halfRS))/2);
        return { id:`rect_${Date.now().toString(36)}_${Math.random().toString(36).slice(2,6)}`, col:centerH.col, row:centerH.row, wCols, hRows, rot:Number(rectRotEl.value)||0, startAngle:clamp(Number(startAngleEl.value)||0,-85,85), endAngle:clamp(Number(endAngleEl.value)||0,-85,85), tileKind:tileKindEl.value, tileScale:Number(tileScaleEl.value)||0.2, z:Number(rectZEl.value)||STATE.rects.length };
      }
      function setMode(mode){ STATE.mode=mode; btnModeDraw.classList.toggle('active',mode==='draw'); btnModeSelect.classList.toggle('active',mode==='select'); }

      canvas.addEventListener('mousedown',(ev)=>{
        const rc=canvas.getBoundingClientRect(); const sx=ev.clientX-rc.left, sy=ev.clientY-rc.top; const w=snapWorldToHex(screenToWorld(sx,sy));
        if(STATE.mode==='draw'){ STATE.preview={a:w,b:w}; drag={type:'draw'}; render(); return; }
        const sel=STATE.rects.find(r=>r.id===STATE.selectionId);
        if(sel){ const h=handleAtScreen(sel,sx,sy); if(h){ drag={type:'handle',id:sel.id,handle:h,startSnapshot:cloneRects()}; return; } }
        const hit=rectAtScreen(sx,sy);
        if(hit){ STATE.selectionId=hit.id; syncSelectedControls(); const c=rectCenterWorld(hit); drag={type:'move',id:hit.id,offset:{x:c.x-w.x,y:c.y-w.y},startSnapshot:cloneRects()}; render(); return; }
        STATE.selectionId=null; render();
      });

      window.addEventListener('mousemove',(ev)=>{
        if(!drag) return; const rc=canvas.getBoundingClientRect(); const sx=ev.clientX-rc.left, sy=ev.clientY-rc.top; const w=snapWorldToHex(screenToWorld(sx,sy));
        if(drag.type==='draw'){ STATE.preview.b=w; render(); return; }
        const t=STATE.rects.find(r=>r.id===drag.id); if(!t) return;
        if(drag.type==='move'){
          const h=worldToHexHalf({x:w.x+drag.offset.x,y:w.y+drag.offset.y}); const cand={...t,col:h.col,row:h.row};
          if(rectInsideBoundary(cand)){ t.col=cand.col; t.row=cand.row; render(); }
          return;
        }
        if(drag.type==='handle'){
          if(drag.handle==='c'){ const h=worldToHexHalf(w); const cand={...t,col:h.col,row:h.row}; if(rectInsideBoundary(cand)){ t.col=cand.col; t.row=cand.row; render(); } return; }
          const c=rectCenterWorld(t), local=worldToLocal(w,c,Number(t.rot)||0), dims=rectDimsWorld(t);
          let hw=dims.w/2, hh=dims.h/2; const minHW=colStep()*0.5, minHH=rowStep()*0.25;
          if(drag.handle==='n') hh=Math.max(minHH,-local.y); if(drag.handle==='s') hh=Math.max(minHH,local.y); if(drag.handle==='e') hw=Math.max(minHW,local.x); if(drag.handle==='w') hw=Math.max(minHW,-local.x);
          const halfRS=rowStep()*0.5; const wCols=Math.max(1,Math.round((hw*2)/colStep())); const hRows=Math.max(0.5,Math.round(((hh*2)/halfRS))/2);
          const cand={...t,wCols,hRows}; if(rectInsideBoundary(cand)){ t.wCols=wCols; t.hRows=hRows; render(); }
        }
      });

      window.addEventListener('mouseup',()=>{
        if(!drag) return;
        if(drag.type==='draw'&&STATE.preview){ const r=previewToRect(STATE.preview); if(rectInsideBoundary(r)){ pushHistorySnapshot(cloneRects()); STATE.rects.push(r); STATE.selectionId=r.id; syncSelectedControls(); } STATE.preview=null; drag=null; render(); return; }
        if((drag.type==='move'||drag.type==='handle')&&drag.startSnapshot){ if(JSON.stringify(drag.startSnapshot)!==JSON.stringify(STATE.rects)) pushHistorySnapshot(drag.startSnapshot); }
        drag=null; render();
      });
      btnApply.addEventListener('click',()=>applyBoundary(pointsInput.value));
      btnModeDraw.addEventListener('click',()=>setMode('draw'));
      btnModeSelect.addEventListener('click',()=>setMode('select'));

      btnDelete.addEventListener('click',()=>{
        if(!STATE.selectionId) return;
        const idx=STATE.rects.findIndex(r=>r.id===STATE.selectionId); if(idx<0) return;
        pushHistorySnapshot(cloneRects()); STATE.rects.splice(idx,1); STATE.selectionId=null; render();
      });

      function applyToSelected(mutator){
        if(!STATE.selectionId) return;
        const r=STATE.rects.find(x=>x.id===STATE.selectionId); if(!r) return;
        const before=cloneRects(); mutator(r);
        if(!rectInsideBoundary(r)){ STATE.rects=before; return; }
        pushHistorySnapshot(before); render();
      }

      startAngleEl.addEventListener('input',()=>applyToSelected(r=>{ r.startAngle=clamp(Number(startAngleEl.value)||0,-85,85); }));
      endAngleEl.addEventListener('input',()=>applyToSelected(r=>{ r.endAngle=clamp(Number(endAngleEl.value)||0,-85,85); }));
      rectRotEl.addEventListener('change',()=>applyToSelected(r=>{ r.rot=Number(rectRotEl.value)||0; }));
      rectZEl.addEventListener('input',()=>applyToSelected(r=>{ r.z=Number(rectZEl.value)||0; }));
      tileKindEl.addEventListener('change',()=>applyToSelected(r=>{ r.tileKind=tileKindEl.value; }));
      tileScaleEl.addEventListener('input',()=>applyToSelected(r=>{ r.tileScale=Number(tileScaleEl.value)||0.2; }));

      btnFront.addEventListener('click',()=>{
        if(!STATE.selectionId) return; const r=STATE.rects.find(x=>x.id===STATE.selectionId); if(!r) return;
        pushHistorySnapshot(cloneRects()); r.z=STATE.rects.reduce((m,x)=>Math.max(m,Number(x.z)||0),0)+1; rectZEl.value=String(r.z); render();
      });
      btnBack.addEventListener('click',()=>{
        if(!STATE.selectionId) return; const r=STATE.rects.find(x=>x.id===STATE.selectionId); if(!r) return;
        pushHistorySnapshot(cloneRects()); r.z=STATE.rects.reduce((m,x)=>Math.min(m,Number(x.z)||0),0)-1; rectZEl.value=String(r.z); render();
      });

      lineColorEl.addEventListener('input',()=>{ STATE.lineColor=lineColorEl.value; render(); });
      lineWidthEl.addEventListener('input',()=>{ STATE.lineWidth=Math.max(0.5,Number(lineWidthEl.value)||2); render(); });

      btnUndo.addEventListener('click',undo);
      btnRedo.addEventListener('click',redo);
      window.addEventListener('keydown',(ev)=>{
        if((ev.ctrlKey||ev.metaKey)&&ev.key.toLowerCase()==='z'){ ev.preventDefault(); undo(); }
        if((ev.ctrlKey||ev.metaKey)&&ev.key.toLowerCase()==='y'){ ev.preventDefault(); redo(); }
      });

      btnExportPng.addEventListener('click',()=>{ const a=document.createElement('a'); a.download='roof_design2.png'; a.href=canvas.toDataURL('image/png'); a.click(); });
      btnCopyJson.addEventListener('click',async()=>{
        const payload={
          points:STATE.points,
          rects:STATE.rects.map(r=>({ id:r.id, center_hex:toHexLabel(r.col,r.row), width_cols:r.wCols, height_rows:r.hRows, rot:r.rot, start_angle:r.startAngle, end_angle:r.endAngle, tile:r.tileKind, tile_scale:r.tileScale, z:r.z })),
          style:{ line_color:STATE.lineColor, line_width:STATE.lineWidth }
        };
        try{ await navigator.clipboard.writeText(JSON.stringify(payload,null,2)); if(info) info.textContent='Copied JSON'; } catch { if(info) info.textContent='Copy failed'; }
      });

      window.addEventListener('resize',()=>{ if(STATE.boundary.length<3) return; const b=computeBounds(STATE.boundary); setCanvasForBounds(b); render(); });

      pointsInput.value=DEFAULT_POINTS;
      applyBoundary(DEFAULT_POINTS);
    })();
  </script>
</body>
</html>

