<!--
HEX BATTLEMAT v2 (optimized)

Goals
- SCENE is JSON (cannot crash JS parser)
- Last-known-good SCENE fallback (never blank on bad edits)
- Single obvious edit region (SCENE JSON only)
- Clear separation: SCENE / CONFIG / ENGINE

During play: edit ONLY the SCENE JSON block.
-->

<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Hex Battlemat</title>
  <style>
    :root{
      --bg:#f3f3f3;
      --panel:#fff;
      --ink:#111;
      --line:rgba(0,0,0,0.12);
      --mat:#d7d7d7;
      --hexFill:#fff;
      --wood:#b07a3f;
      --win:#cfe6f6;
      --pc:rgba(80,160,220,0.95);
      --en:rgba(220,120,80,0.95);
    }
    body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;background:var(--bg);color:var(--ink)}
    header{padding:10px 14px;border-bottom:1px solid var(--line);background:var(--panel);font-weight:650}
    main{padding:12px;overflow:hidden}
    .layout{width:max-content;display:grid;grid-template-columns:940px 340px;gap:12px;align-items:stretch;margin:0 auto}
    canvas{width:940px;height:750px;background:var(--mat);border:1px solid var(--line)}
    aside{background:var(--panel);border:1px solid var(--line);padding:10px;overflow:hidden;display:grid;grid-template-rows:auto 1fr;gap:10px}
    .panel-title{display:flex;justify-content:space-between;align-items:baseline;gap:10px}
    .panel-title h3{margin:0;font-size:1rem;font-weight:650}
    .subtle{opacity:.7;font-size:.9rem;white-space:nowrap}

    .status-wrap{overflow:auto;border:1px solid rgba(0,0,0,0.10)}
    table{width:100%;border-collapse:collapse;font-size:.92rem}
    thead th{position:sticky;top:0;background:#f6f6f6;text-align:left;font-weight:650;padding:8px 10px;border-bottom:1px solid rgba(0,0,0,0.10)}
    tbody td{padding:8px 10px;border-bottom:1px solid rgba(0,0,0,0.08);vertical-align:top}
    .chip{display:inline-block;padding:2px 8px;border-radius:999px;margin:2px 6px 0 0;border:1px solid rgba(0,0,0,0.12);background:#f2f2f2;font-size:.82rem;white-space:nowrap}
    .side-pc{border-left:4px solid rgba(80,160,220,0.85)}
    .side-en{border-left:4px solid rgba(220,120,80,0.85)}
    .side-npc{border-left:4px solid rgba(160,160,160,0.85)}
    tr.dead{background:rgba(0,0,0,0.04);color:rgba(0,0,0,0.55)}
    tr.dead .subtle{opacity:.5}
    tr.dead.side-pc,tr.dead.side-en,tr.dead.side-npc{border-left-color:rgba(120,120,120,0.85)}
    .hp{font-variant-numeric:tabular-nums;white-space:nowrap}

    .legend{margin-top:10px;padding-top:8px;border-top:1px solid rgba(0,0,0,0.12);font-size:.9rem}
    .legend-title{font-weight:650;margin-bottom:6px}
    .legend-list{list-style:none;padding:0;margin:0;display:grid;grid-template-columns:1fr 1fr;gap:6px 10px}
    .legend-swatch{display:inline-flex;align-items:center;justify-content:center;width:20px;height:20px;margin-right:6px;border-radius:3px;vertical-align:middle;border:1px solid rgba(0,0,0,0.6);font-size:11px;font-weight:700;color:rgba(0,0,0,0.85);line-height:1}
    .legend-swatch.door{background:var(--wood)}
    .legend-swatch.window{background:var(--win)}
    .legend-swatch.table{background:var(--wood);border-radius:50%}
    .legend-swatch.difficult{background:rgba(120,120,120,0.08)}
    .legend-swatch.pc{background:var(--pc);border-radius:50%}
    .legend-swatch.en{background:var(--en);border-radius:50%}

    .legend-swatch.hex{position:relative;z-index:0;border-radius:0;clip-path:polygon(25% 6%,75% 6%,100% 50%,75% 94%,25% 94%,0% 50%);border:none}
    .legend-swatch.hex::before{content:"";position:absolute;inset:0;background:rgba(0,0,0,0.45);clip-path:inherit;transform:scale(1.12);z-index:-1}
  </style>
</head>
<body>
  <header>Hex Battlemat</header>

  <main>
    <div class="layout">
      <canvas id="mat" width="940" height="750" aria-label="Hex battlemat"></canvas>

      <aside aria-label="Combat status panel">
        <div class="panel-title">
          <h3>Initiative &amp; Status</h3>
          <div class="subtle" id="roundLine">Round —</div>
        </div>

        <div class="status-wrap">
          <table aria-label="Combatants">
            <thead>
              <tr>
                <th style="width: 52%">Actor</th>
                <th style="width: 18%">Init</th>
                <th style="width: 30%">HP</th>
              </tr>
            </thead>
            <tbody id="statusBody"></tbody>
          </table>
        </div>

        <div class="legend" aria-label="Map legend">
          <div class="legend-title">Key</div>
          <ul class="legend-list">
            <li><span class="legend-swatch door">D</span> Door</li>
            <li><span class="legend-swatch window">W</span> Window</li>
            <li><span class="legend-swatch table">T</span> Table <span class="subtle">(blocks)</span></li>
            <li><span class="legend-swatch difficult hex">~</span> Difficult terrain</li>
            <li><span class="legend-swatch pc">A</span> Player</li>
            <li><span class="legend-swatch en">W</span> Enemy</li>
          </ul>
        </div>
      </aside>
    </div>
  </main>

  <!-- ===================== EDIT ONLY THIS BLOCK: SCENE JSON =====================
       - Edit ONLY the JSON inside this tag.
       - Keep VALID JSON (double quotes, no trailing commas, no comments).
       - If JSON is invalid, the engine keeps the last valid scene.
       ===================== END SCENE JSON =================================== -->
  <script type="application/json" id="scene-json">
{
  "round": 1,
  "rooms": [
    {"id":"room1","corners":["D11","N11","N1","D1"],"thickness":30,"color":"#555"}
  ],
  "openings": [
    {"id":"win_s_1","kind":"window","room":"room1","wall":"S","at":"F1","state":"closed"},
    {"id":"win_s_2","kind":"window","room":"room1","wall":"S","at":"H1","state":"closed"},
    {"id":"win_s_3","kind":"window","room":"room1","wall":"S","at":"J1","state":"closed"},
    {"id":"win_s_4","kind":"window","room":"room1","wall":"S","at":"L1","state":"closed"},

    {"id":"door_e_1","kind":"door","room":"room1","wall":"E","at":"N6","state":"closed"},
    {"id":"door_e_2","kind":"door","room":"room1","wall":"E","at":"N5","state":"closed"}
  ],
  "objects": [
    {"id":"table1","kind":"table","cells":["I4","I5","J5"],"blocks":true,"label":"T"},
    {"id":"sarc1","kind":"sarcophagus","cells":["J8","K8","L8"],"blocks":true,"label":"S"},
    {"id":"difficult_1","kind":"difficult","cells":["G2","H3","I3"],"blocks":false,"label":"~","color":"rgba(120,120,120,0.18)"}
  ],
  "actors": [
    {"id":"lich","name":"Lich","side":"EN","init":15,"hp":135,"maxHp":135,"effects":[],"at":"F9","label":"L"},
    {"id":"wraith1","name":"Wraith","side":"EN","init":12,"hp":67,"maxHp":67,"effects":[],"at":"H7","label":"W1"},
    {"id":"wraith2","name":"Wraith","side":"EN","init":11,"hp":0,"maxHp":67,"effects":[],"at":"K9","label":"W2"},
    {"id":"wraith3","name":"Wraith","side":"EN","init":10,"hp":67,"maxHp":67,"effects":[],"at":"E6","label":"W3"},

    {"id":"pc1","name":"Aelar","side":"PC","init":14,"hp":42,"maxHp":42,"effects":[],"at":"K2","label":"A"},
    {"id":"pc2","name":"Brunna","side":"PC","init":13,"hp":55,"maxHp":55,"effects":[],"at":"L3","label":"B"},
    {"id":"pc3","name":"Caelin","side":"PC","init":12,"hp":38,"maxHp":38,"effects":[],"at":"M3","label":"C"}
  ]
}
  </script>

  <script>
  // ===================== CONFIG =====================
  const GRID = { cols: 17, rows: 11, size: 34.5, margin: 55, canvasW: 940, canvasH: 750 };
  const CONFIG = {
    room: { yInsetFrac: 0.25 },
    labels: { dyFrac: 0.70, fillAlpha: 0.35 },
    grid: { baseW: 1.2, baseA: 0.07, overW: 1.1, overA: 0.04 },
    opening: { minAcross: 18, acrossMul: 1.05, spanNSMul: 1.5, spanEWMul: 1.0 },
    token: { rMul: 0.40, outlineW: 0.75 },
    table: { rMul: 1.25 },
    rect: { padXMul: 0.85, padYMul: 0.55, cornerMul: 0.35 }
  };

  // ===================== ENGINE STATE =====================
  const canvas = document.getElementById('mat');
  const ctx = canvas.getContext('2d');
  const SQRT3 = Math.sqrt(3);
  const letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';

  let LAST_GOOD_SCENE = null;
  let SCENE_PARSE_ERROR = null;

  // Cached geometry
  let HEX_PATHS = null;     // Map<label, Path2D>
  let HEX_CENTERS = null;   // Map<label, {x,y}>

  // Per-draw state
  let SCENE = {};
  let SCENE_NORM = null;
  let ROOM_GEOMS = null;

  // ===================== SCENE LOADER =====================
  function loadSceneFromJsonTag(){
    const el = document.getElementById('scene-json');
    const raw = el ? String(el.textContent||'').trim() : '';
    if(!raw){ SCENE_PARSE_ERROR = 'SCENE JSON is empty.'; return (LAST_GOOD_SCENE||{}); }
    try{
      const obj = JSON.parse(raw);
      LAST_GOOD_SCENE = obj;
      SCENE_PARSE_ERROR = null;
      return obj;
    }catch(e){
      SCENE_PARSE_ERROR = `SCENE JSON parse error: ${e && e.message ? e.message : String(e)}`;
      try{ console.error('[Battlemat] '+SCENE_PARSE_ERROR);}catch(_){ }
      return (LAST_GOOD_SCENE||{});
    }
  }

  // ===================== GRID MATH =====================
  function labelFor(q,r){ return `${letters[q]}${r+1}`; }

  function parseLabel(label){
    const m = String(label).trim().toUpperCase().match(/^([A-Z])([0-9]{1,2})$/);
    if(!m) return null;
    const q = letters.indexOf(m[1]);
    const r = Number(m[2]) - 1;
    if(q<0 || q>=GRID.cols) return null;
    if(r<0 || r>=GRID.rows) return null;
    return {q,r};
  }

  // r=0 is bottom; odd columns offset
  function qrToPixel(q,r){
    const drawR = (GRID.rows - 1 - r);
    const colOff = (q%2===0)?0:0.5;
    const x = GRID.size*(3/2)*q + GRID.margin;
    const y = GRID.size*SQRT3*(drawR + colOff) + GRID.margin;
    return {x,y};
  }

  function labelToPixel(label){
    const pos = parseLabel(label);
    if(!pos) return null;
    return qrToPixel(pos.q,pos.r);
  }

  function buildHexCaches(){
    HEX_PATHS = new Map();
    HEX_CENTERS = new Map();
    for(let q=0;q<GRID.cols;q++){
      for(let r=0;r<GRID.rows;r++){
        const lab = labelFor(q,r);
        const c = qrToPixel(q,r);
        HEX_CENTERS.set(lab,c);
        const path = new Path2D();
        for(let i=0;i<6;i++){
          const a = (Math.PI/180)*(60*i);
          const px = c.x + GRID.size*Math.cos(a);
          const py = c.y + GRID.size*Math.sin(a);
          if(i===0) path.moveTo(px,py); else path.lineTo(px,py);
        }
        path.closePath();
        HEX_PATHS.set(lab,path);
      }
    }
  }

  // ===================== NORMALIZATION =====================
  function normalizeScene(){
    const src = (typeof SCENE==='object' && SCENE) ? SCENE : {};

    const warn = (msg,obj)=>{ try{console.warn('[Battlemat] '+msg, obj??'');}catch(_){ } };

    // Rooms
    const roomsIn = Array.isArray(src.rooms) ? src.rooms : [];
    const rooms = [];
    const roomIds = new Set();
    for(let i=0;i<roomsIn.length;i++){
      const r = roomsIn[i]||{};
      const corners = Array.isArray(r.corners)?r.corners:null;
      if(!corners || corners.length!==4 || corners.map(parseLabel).some(p=>!p)){
        warn('Room skipped: corners must be 4 valid labels', r);
        continue;
      }
      let id = String(r.id||'').trim() || `room_${i+1}`;
      if(roomIds.has(id)){
        let k=2; while(roomIds.has(`${id}_${k}`)) k++; id = `${id}_${k}`;
      }
      roomIds.add(id);
      rooms.push({ id, corners: corners.map(c=>String(c).trim().toUpperCase()), thickness:Number(r.thickness??18), color:String(r.color||'#555') });
    }

    // Openings
    const openingsIn = Array.isArray(src.openings)?src.openings:[];
    const openings=[];
    for(const o0 of openingsIn){
      const o = o0||{};
      const kind = String(o.kind||'door').toLowerCase();
      if(kind!=='door' && kind!=='window') { warn('Opening skipped: kind must be door/window', o); continue; }
      const room = String(o.room||'').trim();
      if(!room || !roomIds.has(room)) { warn(`Opening skipped: unknown room '${room}'`, o); continue; }
      const wall = String(o.wall||'').trim().toUpperCase();
      if(!['N','S','E','W'].includes(wall)) { warn('Opening skipped: wall must be N/S/E/W', o); continue; }
      const at = String(o.at||'').trim().toUpperCase();
      if(!parseLabel(at)) { warn('Opening skipped: invalid at label', o); continue; }
      const state = String(o.state??'closed').toLowerCase();
      openings.push({...o, kind, room, wall, at, state});
    }

    // Objects
    const objectsIn = Array.isArray(src.objects)?src.objects:[];
    const objects=[];
    for(const o0 of objectsIn){
      const o=o0||{};
      const kind = String(o.kind||'object').toLowerCase();
      const blocks = Boolean(o.blocks??false);
      let cells = Array.isArray(o.cells)&&o.cells.length ? o.cells : (o.at?[o.at]:[]);
      cells = cells.map(c=>String(c).trim().toUpperCase()).filter(lab=>!!parseLabel(lab));
      if(!cells.length){ warn('Object skipped: missing/invalid cells', o); continue; }
      objects.push({...o, kind, blocks, cells, label:(o.label!=null?String(o.label):null), color:(o.color!=null?String(o.color):null)});
    }

    // Actors
    const actorsIn = Array.isArray(src.actors)?src.actors:[];
    const actors=[];
    for(const a0 of actorsIn){
      const a=a0||{};
      const at = String(a.at||'').trim().toUpperCase();
      if(!parseLabel(at)) { warn('Actor skipped: invalid at label', a); continue; }
      const side = String(a.side||'NPC').toUpperCase();
      actors.push({...a, at, side:(side==='PC'||side==='EN')?side:'NPC'});
    }

    return { round:Number(src.round??1), rooms, openings, objects, actors };
  }

  // ===================== ROOM GEOMETRY =====================
  function getRoomGeom(room){
    const c = Array.isArray(room.corners)?room.corners:null;
    if(!c || c.length!==4) return null;
    const pTL = labelToPixel(c[0]);
    const pTR = labelToPixel(c[1]);
    const pBL = labelToPixel(c[3]);
    if(!pTL||!pTR||!pBL) return null;
    const hexH = SQRT3*GRID.size;
    const yInset = hexH*CONFIG.room.yInsetFrac;
    return { id:String(room.id||''), leftX:pTL.x, rightX:pTR.x, topY:pTL.y+yInset, botY:pBL.y-yInset, thickness:Number(room.thickness??18), color:String(room.color||'#555') };
  }

  function drawRooms(){
    const rooms = SCENE_NORM?.rooms || [];
    if(!rooms.length || !ROOM_GEOMS) return;
    for(const room of rooms){
      const g = ROOM_GEOMS.get(String(room.id||''));
      if(!g) continue;
      ctx.save();
      ctx.strokeStyle = g.color;
      ctx.lineWidth = g.thickness;
      ctx.lineJoin='miter';
      ctx.lineCap='butt';
      ctx.beginPath();
      ctx.moveTo(g.leftX,g.topY);
      ctx.lineTo(g.rightX,g.topY);
      ctx.lineTo(g.rightX,g.botY);
      ctx.lineTo(g.leftX,g.botY);
      ctx.closePath();
      ctx.stroke();
      ctx.restore();
    }
  }

  // ===================== OPENINGS =====================
  function drawOpenings(){
    const openings = SCENE_NORM?.openings || [];
    if(!openings.length || !ROOM_GEOMS) return;

    for(const o of openings){
      const kind = String(o.kind||'door').toLowerCase();
      if(kind!=='door' && kind!=='window') continue;
      const g = ROOM_GEOMS.get(String(o.room||''));
      if(!g) continue;
      const wall = String(o.wall||'').toUpperCase();
      const atPx = labelToPixel(o.at);
      if(!atPx) continue;

      let x=atPx.x, y=atPx.y;
      if(wall==='N') y=g.topY; else if(wall==='S') y=g.botY; else if(wall==='E') x=g.rightX; else if(wall==='W') x=g.leftX; else continue;

      const thicknessAcross = Number(o.thicknessAcross ?? Math.max(CONFIG.opening.minAcross, g.thickness*CONFIG.opening.acrossMul));
      const spanAlong = (wall==='N'||wall==='S')
        ? Number(o.spanAlong ?? (CONFIG.opening.spanNSMul*GRID.size))
        : Number(o.spanAlong ?? (CONFIG.opening.spanEWMul*SQRT3*GRID.size));

      const rectW = (wall==='N'||wall==='S') ? spanAlong : thicknessAcross;
      const rectH = (wall==='N'||wall==='S') ? thicknessAcross : spanAlong;

      const state = String(o.state??'closed').toLowerCase();
      const isOpen = state==='open';
      const isDoor = kind==='door';
      const isWindow = kind==='window';

      ctx.save();
      ctx.translate(x,y);

      if(isOpen){
        if(isWindow){ ctx.fillStyle='#eeeeee'; ctx.strokeStyle='#eeeeee'; ctx.lineWidth=1; }
        else { ctx.fillStyle='#ffffff'; ctx.strokeStyle='#ffffff'; ctx.lineWidth=0; }
      }else{
        ctx.fillStyle = isDoor ? getComputedStyle(document.documentElement).getPropertyValue('--wood').trim() : getComputedStyle(document.documentElement).getPropertyValue('--win').trim();
        ctx.strokeStyle='rgba(0,0,0,0.6)';
        ctx.lineWidth=2;
      }

      ctx.beginPath();
      ctx.rect(-rectW/2,-rectH/2,rectW,rectH);
      ctx.fill();
      if(ctx.lineWidth>0) ctx.stroke();

      if(!isOpen){
        ctx.font = (Math.max(rectW,rectH)>=55) ? 'bold 13px ui-monospace, system-ui, sans-serif' : 'bold 12px ui-monospace, system-ui, sans-serif';
        ctx.fillStyle='rgba(0,0,0,0.55)';
        ctx.textAlign='center';
        ctx.textBaseline='middle';
        ctx.fillText(isWindow?'W':'D',0,0);
      }

      ctx.restore();
    }
  }

  // ===================== OBJECT HELPERS =====================
  function objectCentroidPx(cells){
    let sx=0, sy=0, n=0;
    for(const lab of (cells||[])){
      const p = HEX_CENTERS.get(String(lab).trim().toUpperCase()) || labelToPixel(lab);
      if(!p) continue;
      sx+=p.x; sy+=p.y; n++;
    }
    return n?{x:sx/n,y:sy/n}:null;
  }
  function objectBoundsPx(cells){
    let minX=Infinity,minY=Infinity,maxX=-Infinity,maxY=-Infinity,n=0;
    for(const lab of (cells||[])){
      const p = HEX_CENTERS.get(String(lab).trim().toUpperCase()) || labelToPixel(lab);
      if(!p) continue;
      minX=Math.min(minX,p.x); minY=Math.min(minY,p.y);
      maxX=Math.max(maxX,p.x); maxY=Math.max(maxY,p.y);
      n++;
    }
    return n?{minX,minY,maxX,maxY}:null;
  }
  function roundRectPath(x,y,w,h,r){
    const rr = Math.max(0, Math.min(r, Math.min(w,h)/2));
    const p = new Path2D();
    p.moveTo(x+rr,y);
    p.arcTo(x+w,y,x+w,y+h,rr);
    p.arcTo(x+w,y+h,x,y+h,rr);
    p.arcTo(x,y+h,x,y,rr);
    p.arcTo(x,y,x+w,y,rr);
    p.closePath();
    return p;
  }

  function drawObjects(){
    const objs = SCENE_NORM?.objects || [];
    if(!objs.length) return;

    for(const obj of objs){
      const kind = String(obj.kind||'object').toLowerCase();
      const cells = Array.isArray(obj.cells)?obj.cells:[];
      if(!cells.length) continue;

      const blocks = Boolean(obj.blocks);
      const glyph = (obj.label!=null && String(obj.label).trim()) ? String(obj.label).trim().slice(0,3) : kind.slice(0,1).toUpperCase();
      const fill = obj.color ? String(obj.color) : (blocks ? 'rgba(0,0,0,0.20)' : 'rgba(0,0,0,0.10)');

      // Footprint shading: everything except shaped blockers (table/rect/sarcophagus)
      if(kind!=='table' && kind!=='rect' && kind!=='sarcophagus'){
        for(let i=0;i<cells.length;i++){
          const lab = String(cells[i]).trim().toUpperCase();
          const path = HEX_PATHS.get(lab);
          const c = HEX_CENTERS.get(lab);
          if(!path||!c) continue;

          ctx.save();
          ctx.fillStyle = fill;
          ctx.fill(path);
          ctx.lineWidth = 1;
          ctx.strokeStyle = 'rgba(0,0,0,0.18)';
          ctx.stroke(path);

          if(kind==='difficult' || i===0){
            ctx.font='bold 12px ui-monospace, system-ui, sans-serif';
            ctx.fillStyle='rgba(0,0,0,0.55)';
            ctx.textAlign='center';
            ctx.textBaseline='middle';
            ctx.fillText(glyph, c.x, c.y);
          }
          ctx.restore();
        }
      }

      // Table (circle)
      if(kind==='table'){
        const c = objectCentroidPx(cells);
        if(!c) continue;
        const radius = GRID.size * CONFIG.table.rMul;
        ctx.save();
        ctx.beginPath();
        ctx.arc(c.x,c.y,radius,0,Math.PI*2);
        ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--wood').trim();
        ctx.fill();
        ctx.lineWidth = 2;
        ctx.strokeStyle = 'rgba(0,0,0,0.85)';
        ctx.stroke();
        ctx.font='bold 14px ui-monospace, system-ui, sans-serif';
        ctx.fillStyle='rgba(0,0,0,0.85)';
        ctx.textAlign='center';
        ctx.textBaseline='middle';
        ctx.fillText(glyph||'T', c.x, c.y);
        ctx.restore();
      }

      // Rect / Sarcophagus (rounded rectangle)
      if(kind==='rect' || kind==='sarcophagus'){
        const c = objectCentroidPx(cells);
        const b = objectBoundsPx(cells);
        if(!c||!b) continue;

        const padX = GRID.size * CONFIG.rect.padXMul;
        const padY = GRID.size * CONFIG.rect.padYMul;
        const w = (b.maxX-b.minX) + padX*2;
        const h = (b.maxY-b.minY) + padY*2;
        const rot = Number(obj.rot ?? 0);
        const r = Math.max(6, Math.min(GRID.size*CONFIG.rect.cornerMul, Math.min(w,h)*0.25));

        const path = roundRectPath(-w/2, -h/2, w, h, r);
        ctx.save();
        ctx.translate(c.x,c.y);
        if(rot) ctx.rotate((Math.PI/180)*rot);
        ctx.fillStyle = obj.color ? String(obj.color) : getComputedStyle(document.documentElement).getPropertyValue('--wood').trim();
        ctx.fill(path);
        ctx.lineWidth = 2;
        ctx.strokeStyle='rgba(0,0,0,0.85)';
        ctx.stroke(path);
        ctx.font='bold 14px ui-monospace, system-ui, sans-serif';
        ctx.fillStyle='rgba(0,0,0,0.85)';
        ctx.textAlign='center';
        ctx.textBaseline='middle';
        ctx.fillText(glyph || (kind==='sarcophagus'?'S':'R'), 0, 0);
        ctx.restore();
      }
    }
  }

  // ===================== TOKENS =====================
  function isDeadActor(a){
    const hp = Number(a.hp ?? 0);
    const effects = Array.isArray(a.effects) ? a.effects : [];
    return hp<=0 || effects.includes('dead') || effects.includes('down');
  }

  function drawToken(atLabel, label, side, dead){
    const pos = parseLabel(atLabel);
    if(!pos) return;
    const c = qrToPixel(pos.q,pos.r);

    let fill = 'rgba(160,160,160,0.95)';
    if(dead) fill = 'rgba(140,140,140,0.85)';
    else if(side==='PC') fill = getComputedStyle(document.documentElement).getPropertyValue('--pc').trim();
    else if(side==='EN') fill = getComputedStyle(document.documentElement).getPropertyValue('--en').trim();

    ctx.save();
    ctx.beginPath();
    ctx.arc(c.x,c.y, GRID.size*CONFIG.token.rMul, 0, Math.PI*2);
    ctx.fillStyle = fill;
    ctx.fill();
    ctx.lineWidth = CONFIG.token.outlineW;
    ctx.strokeStyle = 'rgba(0,0,0,0.85)';
    ctx.stroke();

    ctx.font='bold 14px ui-monospace, system-ui, sans-serif';
    ctx.fillStyle = dead ? 'rgba(0,0,0,0.35)' : 'rgba(0,0,0,0.72)';
    ctx.textAlign='center';
    ctx.textBaseline='middle';
    ctx.fillText(String(label||'?'), c.x, c.y);
    ctx.restore();
  }

  // ===================== GRID DRAW =====================
  function drawBaseGrid(){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--mat').trim();
    ctx.fillRect(0,0,canvas.width,canvas.height);

    ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--hexFill').trim();
    ctx.lineWidth = CONFIG.grid.baseW;
    ctx.strokeStyle = `rgba(0,0,0,${CONFIG.grid.baseA})`;

    for(const [lab,path] of HEX_PATHS.entries()){
      ctx.fill(path);
      ctx.stroke(path);
    }
  }

  function drawHexOverlay(){
    ctx.lineWidth = CONFIG.grid.overW;
    ctx.strokeStyle = `rgba(0,0,0,${CONFIG.grid.overA})`;
    for(const path of HEX_PATHS.values()) ctx.stroke(path);
  }

  function drawLabels(){
    const dy = GRID.size * CONFIG.labels.dyFrac;
    ctx.font = '13px "Times New Roman", Georgia, "Century Schoolbook", "Book Antiqua", serif';
    ctx.fillStyle = `rgba(180,150,90,${CONFIG.labels.fillAlpha})`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    for(const [lab,c] of HEX_CENTERS.entries()){
      ctx.fillText(lab, c.x, c.y + dy);
    }
  }

  // ===================== STATUS PANEL =====================
  function escapeHtml(s){
    return String(s)
      .replaceAll('&','&amp;')
      .replaceAll('<','&lt;')
      .replaceAll('>','&gt;')
      .replaceAll('"','&quot;')
      .replaceAll("'",'&#39;');
  }

  function renderStatus(){
    const tbody = document.getElementById('statusBody');
    const roundLine = document.getElementById('roundLine');
    if(!tbody || !roundLine) return;

    roundLine.textContent = SCENE_PARSE_ERROR ? 'SCENE JSON ERROR' : `Round ${SCENE_NORM?.round ?? '—'}`;

    const actors = Array.isArray(SCENE_NORM?.actors) ? SCENE_NORM.actors.slice() : [];
    actors.sort((a,b)=>{
      const ai = Number(a.init??0), bi = Number(b.init??0);
      if(bi!==ai) return bi-ai;
      return String(a.name??a.id).localeCompare(String(b.name??b.id));
    });

    tbody.innerHTML='';
    for(const a of actors){
      const tr = document.createElement('tr');
      const side = String(a.side||'NPC').toUpperCase();
      const dead = isDeadActor(a);
      tr.className = (side==='PC'?'side-pc':(side==='EN'?'side-en':'side-npc')) + (dead?' dead':'');

      const effects = Array.isArray(a.effects) ? a.effects : [];
      const effectsHtml = effects.length ? effects.map(e=>`<span class="chip">${escapeHtml(e)}</span>`).join('') : '';

      tr.innerHTML = `
        <td>
          <div style="display:flex; align-items:baseline; gap:8px; flex-wrap:wrap;">
            <span style="font-weight:650;">${escapeHtml(a.name ?? a.id ?? 'Actor')}</span>
            <span class="subtle">${escapeHtml(a.at ?? '')}</span>
          </div>
          ${effectsHtml ? `<div style="margin-top:4px;">${effectsHtml}</div>` : ''}
        </td>
        <td class="hp">${escapeHtml(String(a.init ?? 0))}</td>
        <td class="hp">${escapeHtml(String(a.hp ?? '—'))} / ${escapeHtml(String(a.maxHp ?? '—'))}</td>
      `;

      tbody.appendChild(tr);
    }
  }

  // ===================== DRAW PIPELINE =====================
  function rebuildPerDraw(){
    SCENE = loadSceneFromJsonTag();
    SCENE_NORM = normalizeScene();

    ROOM_GEOMS = new Map();
    for(const room of (SCENE_NORM.rooms||[])){
      const g = getRoomGeom(room);
      if(g && g.id) ROOM_GEOMS.set(g.id, g);
    }
  }

  function safeDraw(){
    try{
      if(!HEX_PATHS || !HEX_CENTERS) buildHexCaches();
      rebuildPerDraw();

      drawBaseGrid();
      drawRooms();
      drawOpenings();
      drawObjects();
      drawHexOverlay();
      drawLabels();

      // Tokens
      for(const a of (SCENE_NORM.actors||[])){
        drawToken(a.at, a.label || (a.name?String(a.name).slice(0,1):'?'), a.side, isDeadActor(a));
      }

      renderStatus();
    }catch(e){
      console.error('[Battlemat] render failed:', e);
      ctx.clearRect(0,0,canvas.width,canvas.height);
      ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--mat').trim();
      ctx.fillRect(0,0,canvas.width,canvas.height);
      ctx.fillStyle = 'rgba(0,0,0,0.65)';
      ctx.font = '14px ui-monospace, system-ui, sans-serif';
      ctx.textAlign='left';
      ctx.textBaseline='top';
      ctx.fillText('Battlemat render error (see console).', 14, 14);
    }
  }

  safeDraw();
  </script>
</body>
</html>
