// game-api worker v3.15 (minimal merge, no auth, no hex APIs)
// Purpose: GET/PUT battles with safe id-based merges for the current JSON schema.

const CORS_HEADERS = {
  "Access-Control-Allow-Origin": "*",
  "Access-Control-Allow-Methods": "GET,PUT,OPTIONS",
  "Access-Control-Allow-Headers": "Content-Type, Authorization",
};

function withCors(res) {
  const headers = new Headers(res.headers);
  for (const [k, v] of Object.entries(CORS_HEADERS)) headers.set(k, v);
  return new Response(res.body, { status: res.status, statusText: res.statusText, headers });
}

function json(data, status = 200, extraHeaders = {}) {
  return withCors(new Response(JSON.stringify(data), {
    status,
    headers: {
      "content-type": "application/json",
      "cache-control": "no-store",
      ...extraHeaders,
    },
  }));
}

function text(data, status = 200) {
  return withCors(new Response(data, { status, headers: { "content-type": "text/plain" } }));
}

function isObject(v) {
  return !!v && typeof v === "object" && !Array.isArray(v);
}

function clone(value) {
  if (typeof structuredClone === "function") return structuredClone(value);
  return JSON.parse(JSON.stringify(value));
}

function slug(s) {
  return String(s ?? "").toLowerCase().replace(/[^a-z0-9]+/g, "_").replace(/^_+|_+$/g, "");
}

function genId(prefix) {
  const p = slug(prefix || "id") || "id";
  if (globalThis.crypto && typeof globalThis.crypto.randomUUID === "function") {
    return `${p}_${globalThis.crypto.randomUUID()}`;
  }
  return `${p}_${Date.now().toString(36)}_${Math.random().toString(36).slice(2, 10)}`;
}

function mergeArrayById(currentArr, incomingArr, prefix) {
  const out = Array.isArray(currentArr) ? currentArr : [];
  const byId = new Map(out.filter(v => isObject(v) && v.id).map(v => [v.id, v]));

  if (!Array.isArray(incomingArr)) return out;

  for (const patch0 of incomingArr) {
    if (!isObject(patch0)) continue;
    const patch = { ...patch0 };
    if (!patch.id) patch.id = genId(prefix);

    const existing = byId.get(patch.id);
    if (patch.deleted === true) {
      if (existing) {
        const idx = out.findIndex(x => x && x.id === patch.id);
        if (idx !== -1) out.splice(idx, 1);
        byId.delete(patch.id);
      }
      continue;
    }

    if (existing) {
      const { id, deleted, ...rest } = patch;
      Object.assign(existing, rest);
    } else {
      out.push(patch);
      byId.set(patch.id, patch);
    }
  }

  return out;
}

function mergeFloor(existing, patch) {
  if (!isObject(existing)) existing = {};
  if (!isObject(patch)) return existing;

  const { id, deleted, rooms, openings, objects, ...rest } = patch;
  Object.assign(existing, rest);
  existing.rooms = mergeArrayById(existing.rooms, rooms, "room");
  existing.openings = mergeArrayById(existing.openings, openings, "opening");
  existing.objects = mergeArrayById(existing.objects, objects, "object");
  return existing;
}

function mergeFloors(currentFloors, incomingFloors) {
  const out = Array.isArray(currentFloors) ? currentFloors : [];
  const byId = new Map(out.filter(v => isObject(v) && v.id).map(v => [v.id, v]));

  if (!Array.isArray(incomingFloors)) return out;

  for (const patch0 of incomingFloors) {
    if (!isObject(patch0)) continue;
    const patch = { ...patch0 };
    if (!patch.id) patch.id = genId("floor");

    const existing = byId.get(patch.id);
    if (patch.deleted === true) {
      if (existing) {
        const idx = out.findIndex(x => x && x.id === patch.id);
        if (idx !== -1) out.splice(idx, 1);
        byId.delete(patch.id);
      }
      continue;
    }

    if (existing) {
      mergeFloor(existing, patch);
    } else {
      const created = mergeFloor({ id: patch.id }, patch);
      out.push(created);
      byId.set(patch.id, created);
    }
  }

  return out;
}

function mergeRecord(current, incoming) {
  const out = clone(current ?? {});

  if (isObject(incoming.meta)) out.meta = { ...(out.meta || {}), ...incoming.meta };
  if (isObject(incoming.view)) out.view = { ...(out.view || {}), ...incoming.view };
  if (isObject(incoming.fog)) out.fog = { ...(out.fog || {}), ...incoming.fog };
  if (isObject(incoming.turn)) out.turn = { ...(out.turn || {}), ...incoming.turn };

  if (incoming.narration != null) out.narration = String(incoming.narration);
  if (incoming.narrationText != null) out.narrationText = String(incoming.narrationText);

  if (incoming.last_action != null) {
    out.last_action = String(incoming.last_action);
    out.lastAction = out.last_action;
  } else if (incoming.lastAction != null) {
    out.lastAction = String(incoming.lastAction);
    out.last_action = out.lastAction;
  }

  if (Array.isArray(incoming.log)) {
    const cur = Array.isArray(out.log) ? out.log : [];
    out.log = cur.concat(incoming.log).slice(-200);
  }

  const tokensPatch = Array.isArray(incoming.tokens)
    ? incoming.tokens
    : (Array.isArray(incoming.actors) ? incoming.actors : null);
  out.tokens = mergeArrayById(out.tokens, tokensPatch, "token");

  out.floors = mergeFloors(out.floors, incoming.floors);

  // Legacy top-level collections: apply to active floor if present.
  const legacyRooms = Array.isArray(incoming.rooms) ? incoming.rooms : null;
  const legacyOpenings = Array.isArray(incoming.openings) ? incoming.openings : null;
  const legacyObjects = Array.isArray(incoming.objects) ? incoming.objects : null;
  if (legacyRooms || legacyOpenings || legacyObjects) {
    const floorId =
      (incoming.view && incoming.view.floorId) ||
      (out.view && out.view.floorId) ||
      (Array.isArray(out.floors) && out.floors[0] ? out.floors[0].id : null);
    if (floorId) {
      if (!Array.isArray(out.floors)) out.floors = [];
      let floor = out.floors.find(f => f && f.id === floorId);
      if (!floor) {
        floor = { id: floorId, name: floorId };
        out.floors.push(floor);
      }
      floor.rooms = mergeArrayById(floor.rooms, legacyRooms, "room");
      floor.openings = mergeArrayById(floor.openings, legacyOpenings, "opening");
      floor.objects = mergeArrayById(floor.objects, legacyObjects, "object");
    }
  }

  return out;
}

function isWorldState(state) {
  return isObject(state) && isObject(state.records);
}

function isWorldPatch(patch) {
  return isObject(patch) && (
    isObject(patch.records) ||
    isObject(patch.active) ||
    isObject(patch.otherWorlds) ||
    patch.world != null ||
    Array.isArray(patch.links)
  );
}

function mergeWorld(current, incoming) {
  const out = clone(current ?? {});

  if (incoming.world != null) out.world = incoming.world;
  if (incoming.version != null) out.version = incoming.version;
  if (isObject(incoming.meta)) out.meta = { ...(out.meta || {}), ...incoming.meta };
  if (isObject(incoming.active)) out.active = { ...(out.active || {}), ...incoming.active };
  if (Array.isArray(incoming.links)) out.links = incoming.links.slice();

  if (isObject(incoming.otherWorlds)) {
    out.otherWorlds = isObject(out.otherWorlds) ? out.otherWorlds : {};
    for (const [key, patch] of Object.entries(incoming.otherWorlds)) {
      if (!isObject(patch)) continue;
      out.otherWorlds[key] = mergeState(out.otherWorlds[key] ?? {}, patch);
    }
  }

  out.records = isObject(out.records) ? out.records : {};
  if (isObject(incoming.records)) {
    for (const [rid, patch] of Object.entries(incoming.records)) {
      if (!isObject(patch)) continue;
      if (patch.deleted === true) {
        delete out.records[rid];
        continue;
      }
      out.records[rid] = mergeRecord(out.records[rid], patch);
    }
  }

  return out;
}

function getActiveRecordId(state) {
  if (isObject(state) && isObject(state.active) && state.active.recordId) {
    return String(state.active.recordId);
  }
  const keys = isObject(state?.records) ? Object.keys(state.records) : [];
  return keys.length ? keys[0] : "Scene";
}

function mergeState(current, incoming) {
  if (isWorldState(current) || isWorldPatch(incoming)) {
    return mergeWorld(current, incoming);
  }
  return mergeRecord(current, incoming);
}

function stripInternalKeys(obj) {
  if (!isObject(obj)) return obj;
  const out = { ...obj };
  for (const key of Object.keys(out)) {
    if (key.startsWith("__")) delete out[key];
  }
  return out;
}

export default {
  async fetch(request, env) {
    const url = new URL(request.url);
    const path = url.pathname;
    const method = request.method.toUpperCase();

    if (method === "OPTIONS") {
      return withCors(new Response(null, { status: 204 }));
    }

    if (path === "/" || path === "/health") {
      return json({ ok: true });
    }

    const battleMatch = path.match(/^\/battles\/([^\/?#]+)$/);
    if (!battleMatch) {
      return json({ error: "Not found" }, 404);
    }

    const battleId = decodeURIComponent(battleMatch[1]);

    if (method === "GET") {
      const row = await env.DB.prepare(
        `SELECT battle_id, campaign_id, name, state_json, version, updated_at
         FROM battles
         WHERE battle_id = ?`
      ).bind(battleId).first();

      if (!row) return json({ error: "Battle not found", battle_id: battleId }, 404);
      return json(row);
    }

    if (method !== "PUT") {
      return json({ error: "Method not allowed" }, 405);
    }

    let incoming = await request.json().catch(() => null);
    if (!incoming || typeof incoming !== "object") {
      return json({ error: "Invalid JSON body" }, 400);
    }

    if ("state_json" in incoming) {
      const sj = incoming.state_json;
      if (typeof sj === "string") {
        try {
          incoming = JSON.parse(sj);
        } catch (e) {
          return json({ error: "state_json must be valid JSON string" }, 400);
        }
      } else if (sj && typeof sj === "object") {
        incoming = sj;
      } else {
        return json({ error: "state_json must be an object or JSON string" }, 400);
      }
    }

    if (!incoming || typeof incoming !== "object") {
      return json({ error: "state_json must be an object or JSON string" }, 400);
    }

    incoming = stripInternalKeys(incoming);

    const row = await env.DB.prepare(
      `SELECT battle_id, state_json, version FROM battles WHERE battle_id = ?`
    ).bind(battleId).first();

    if (!row) return json({ error: "Battle not found", battle_id: battleId }, 404);

    let currentState = {};
    if (row.state_json) {
      try { currentState = JSON.parse(row.state_json); } catch { currentState = {}; }
    }

    let merged = mergeState(currentState, incoming);

    // Record-level patch against a world wrapper: apply to active record.
    if (isWorldState(currentState) && !isWorldPatch(incoming)) {
      const rid = getActiveRecordId(merged);
      merged.records = isObject(merged.records) ? merged.records : {};
      merged.records[rid] = mergeRecord(merged.records[rid], incoming);
      merged.active = isObject(merged.active) ? merged.active : {};
      merged.active.recordId = rid;
    }

    const nextVersion = (row.version ?? 0) + 1;
    const updatedAt = Math.floor(Date.now() / 1000);
    const stateJson = JSON.stringify(merged, null, 2);

    await env.DB.prepare(
      `UPDATE battles SET state_json = ?, version = ?, updated_at = ? WHERE battle_id = ?`
    ).bind(stateJson, nextVersion, updatedAt, battleId).run();

    return json({
      battle_id: battleId,
      state_json: stateJson,
      version: nextVersion,
      updated_at: updatedAt
    });
  }
};
